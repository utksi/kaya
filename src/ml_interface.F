#include "symbol.inc"

!**********************************************************************
!
! this module is interfacing VASP to a machine learning code
! it is part of VASP and coverged by the general VASP 
! copy right
!
!**********************************************************************
MODULE ml_interface
  USE mpimy
  USE prec
  USE tutor, ONLY: vtutor, isError, RandomSeed, argument
#ifdef ML_AVAILABLE
  USE ml_main_subroutines
#endif
  IMPLICIT NONE
! this variable specifies whether the MLFF calculation is executed or not.
     LOGICAL :: ML_LMLFF
! this variable determines whether ab initio calculation is executed.
     LOGICAL :: LDO_AB_INITIO=.TRUE.
     LOGICAL :: LRUN_VASP_TO_ML=.FALSE.
! this variable specifies the results of the judgement of the necessity of ab initio calculations on new configurations.
! if ML_LMLFF=.FALSE., LDO_AB_INITIO_NEW=LDO_AB_INITIO=.TRUE.
     LOGICAL :: LDO_AB_INITIO_NEW=.TRUE.
! this variable determines whether the calculations are executed using only the
! force field or not.
     LOGICAL :: ML_FF_LMLONLY

  CONTAINS

!=======================================================================
!
! This subroutine reads variables necessary for the machine-learning force field
! generations from INCAR file.
!
!=======================================================================

   SUBROUTINE MACHINE_LEARNING_GENERAL_AND_INSTANCE_READER(INCAR)

      USE incar_reader, only: INCAR_FILE, PROCESS_INCAR, COUNT_ELEMENTS
#ifdef ML_AVAILABLE
      ! Warning: "tag" states are not set in this routine because the
      ! corresponding instance "ML_SUPER_TYPE%TAG_LIST" is not available here.
      USE ML_FF_TAGLIST, ONLY: TAGLIST_GET_ALT_TAGS
      USE ML_FF_STRUCT, ONLY: ML_FILESTREAM_GLOBAL, ML_TOTNUM_INSTANCES
#endif
      IMPLICIT NONE
      TYPE(INCAR_FILE), INTENT(INOUT) :: INCAR
      ! Local variables
      CHARACTER(len=:), ALLOCATABLE :: ALT_TAGS(:)
      INTEGER                       :: I
      ! Set ML_LMLFF as .FALSE.
      ML_LMLFF=.FALSE.
      ! Read ML_LMLFF.
      !   ML_LMLFF = .FALSE.: No machine-learning force field generations
      !   ML_LMLFF = .TRUE. : Execute machine-learning force field
      !   generations
      ! Need to set alternatives manually because the taglist module is
      ! not available here.
      ALT_TAGS = ['ML_LMLFF   ', 'ML_FF_LMLFF']
      DO I = 1, SIZE(ALT_TAGS)
         IF (COUNT_ELEMENTS(INCAR, TRIM(ALT_TAGS(I))) > 0) THEN
            CALL PROCESS_INCAR(INCAR, TRIM(ALT_TAGS(I)), ML_LMLFF)
            ! Skip alternative tags if one is already found.
            EXIT
         END IF
      END DO
#ifdef ML_AVAILABLE
      ! By default the number of instances is 1
      ML_TOTNUM_INSTANCES = 1
      ! At this point there is no need for multiple instances so we disable
      ! reading of this tag.
      !ALT_TAGS = TAGLIST_GET_ALT_TAGS('ML_TOTNUM_INSTANCES')
      !DO I = 1, SIZE(ALT_TAGS)
      !   IF (COUNT_ELEMENTS(INCAR, TRIM(ALT_TAGS(I))) > 0) THEN
      !      CALL PROCESS_INCAR(INCAR, TRIM(ALT_TAGS(I)), ML_TOTNUM_INSTANCES)
      !      ! Skip alternative tags if one is already found.
      !      EXIT
      !   END IF
      !END DO

      ! Global filestream variable
      ML_FILESTREAM_GLOBAL=500
      ALT_TAGS = TAGLIST_GET_ALT_TAGS('ML_FILESTREAM_START')
      DO I = 1, SIZE(ALT_TAGS)
         IF (COUNT_ELEMENTS(INCAR, TRIM(ALT_TAGS(I))) > 0) THEN
            CALL PROCESS_INCAR(INCAR, TRIM(ALT_TAGS(I)), ML_FILESTREAM_GLOBAL)
            ! Skip alternative tags if one is already found.
            EXIT
         END IF
      END DO
#else
      IF (ML_LMLFF) THEN
         CALL vtutor%error("This VASP executable does not support machine &
                           &learning (ML_LMLFF=.TRUE.)! Try recompiling with &
                           &-DML_AVAILABLE")
      ENDIF
#endif
   END SUBROUTINE MACHINE_LEARNING_GENERAL_AND_INSTANCE_READER

#ifdef ML_AVAILABLE
#if defined(MPI) || defined(MPI_CHAIN)
!=======================================================================
!
! Routines important for the handling of global machine learning handles.
!
!=======================================================================

     SUBROUTINE MACHINE_LEARNING_HANDLE_ALLOCATE(NUM_INSTANCES)
       USE ML_FF_STRUCT, ONLY: ML_SUPER_HANDLE_MAIN
       IMPLICIT NONE
       INTEGER, INTENT(IN) :: NUM_INSTANCES
       IF (ALLOCATED(ML_SUPER_HANDLE_MAIN)) THEN
          DEALLOCATE(ML_SUPER_HANDLE_MAIN)
       ENDIF
       ALLOCATE(ML_SUPER_HANDLE_MAIN(NUM_INSTANCES))
     END SUBROUTINE MACHINE_LEARNING_HANDLE_ALLOCATE

     SUBROUTINE MACHINE_LEARNING_HANDLE_DEALLOCATE
       USE ML_FF_STRUCT, ONLY: ML_SUPER_HANDLE_MAIN
       IMPLICIT NONE
       IF (ALLOCATED(ML_SUPER_HANDLE_MAIN)) THEN
          DEALLOCATE(ML_SUPER_HANDLE_MAIN)
       ENDIF
     END SUBROUTINE MACHINE_LEARNING_HANDLE_DEALLOCATE

!=======================================================================
!
! the following routine is called once, before initialization is called
! to set a global COMM_WORLD communicator. This communicator should be
! only used very sparsely for emergency aborts and etc.
!
!=======================================================================
    SUBROUTINE MACHINE_LEARNING_SET_COMM_WORLD_GLOBAL(VASP_COMMUNICATOR)
      USE mpimy, ONLY : communic
      USE ML_FF_STRUCT, ONLY : ML_MPI_PAR, ML_COMM_WORLD_GLOBAL, ML_IO_WRITE
      IMPLICIT NONE
      TYPE (communic)   :: VASP_COMMUNICATOR
      ML_COMM_WORLD_GLOBAL%MPI_COMM = VASP_COMMUNICATOR%MPI_COMM
      ML_COMM_WORLD_GLOBAL%NCPU     = VASP_COMMUNICATOR%NCPU
      ML_COMM_WORLD_GLOBAL%NODE_ME     = VASP_COMMUNICATOR%NODE_ME
      ! set here which rank is allowed to write (currently only the first rank)
      IF (ML_COMM_WORLD_GLOBAL%NODE_ME.EQ.1) THEN
         ML_IO_WRITE = .TRUE.
      ELSE
         ML_IO_WRITE = .FALSE.
      ENDIF
    END SUBROUTINE MACHINE_LEARNING_SET_COMM_WORLD_GLOBAL

#ifndef ML_LEARNING_NOT_ACTIVE
    SUBROUTINE INQUIRE_ML_AB_FILE(ML_SUPER_HANDLE)
      USE ML_FF_STRUCT, ONLY: ML_SUPER_TYPE
      USE IOHANDLE
      IMPLICIT NONE
      TYPE (ML_SUPER_TYPE) :: ML_SUPER_HANDLE
      CHARACTER(LEN=4)     :: FILE_POSTFIX
      ML_SUPER_HANDLE%FF%LMLABEXIST=.FALSE.
      CALL ML_SET_POSTFIX(ML_SUPER_HANDLE%INSTANCE,FILE_POSTFIX) 
      IF (ML_SUPER_HANDLE%INSTANCE.EQ.1) THEN
         INQUIRE( FILE='./ML_AB', EXIST=ML_SUPER_HANDLE%FF%LMLABEXIST )
      ELSE
         INQUIRE( FILE='./ML_AB'//FILE_POSTFIX, EXIST=ML_SUPER_HANDLE%FF%LMLABEXIST )
      ENDIF
    END SUBROUTINE INQUIRE_ML_AB_FILE
#endif

    SUBROUTINE INQUIRE_ML_FF_FILE(ML_SUPER_HANDLE)
      USE ML_FF_STRUCT, ONLY: ML_SUPER_TYPE
      USE IOHANDLE
      IMPLICIT NONE
      TYPE (ML_SUPER_TYPE) :: ML_SUPER_HANDLE
      CHARACTER(LEN=4)     :: FILE_POSTFIX
      ML_SUPER_HANDLE%FF%LMLFFEXIST=.FALSE.
      CALL ML_SET_POSTFIX(ML_SUPER_HANDLE%INSTANCE,FILE_POSTFIX) 
      IF (ML_SUPER_HANDLE%INSTANCE.EQ.1) THEN
         INQUIRE( FILE='./ML_FF', EXIST=ML_SUPER_HANDLE%FF%LMLFFEXIST )
      ELSE
         INQUIRE( FILE='./ML_FF'//FILE_POSTFIX, EXIST=ML_SUPER_HANDLE%FF%LMLFFEXIST )
      ENDIF
    END SUBROUTINE INQUIRE_ML_FF_FILE

!=======================================================================
!
! the following routine is called once, after VASP has read
! the ionic positions + the Bravais lattice
! at this point the machine learning code is supposed to perform
! the basic setup
!
!=======================================================================

    SUBROUTINE MACHINE_LEARNING_INIT(ML_SUPER_HANDLE, &
                                     DIR_APP,         &
                                     DIR_LEN,         &
                                     DYN,             &
                                     INFO,            &
                                     LATT_CUR,        &
                                     T_INFO,          &
                                     IO,              &
                                     VASP_COMM)
      USE base
      USE lattice
      USE poscar
      USE ML_FF_STRUCT, ONLY: ML_SUPER_TYPE, ML_IO_WRITE
      USE ML_FF_CONSTANT, ONLY: AUTOA, PI, MUNIT, TUNIT
      USE ml_ff_tutor, only: ml_tutor
      IMPLICIT NONE
      TYPE (ML_SUPER_TYPE) :: ML_SUPER_HANDLE
      TYPE (dynamics)    DYN
      TYPE (info_struct) INFO
      TYPE (latt)        LATT_CUR             ! Bravais lattice information
      TYPE (in_struct)   IO                   ! File units
      TYPE (type_info)   T_INFO               ! type and position information
      CHARACTER(LEN=10), INTENT(IN) ::  DIR_APP
      INTEGER, INTENT(IN)           ::  DIR_LEN
      INTEGER, INTENT(IN)           ::  VASP_COMM
      INTEGER                       ::  INIONS

! FOr ISIF.LE.1 the stress tensor is not calculated, which is not allowed
      IF (ML_SUPER_HANDLE%FF%ISTART.LE.1 .AND. DYN%ISIF.LE.1) THEN
         CALL vtutor%error("ML_INTERFACE: ERROR: ML_ISTART=0,1 is not allowed with ISIF=0,1, exiting ...")
      ENDIF

! One has to provide proper structure name in the POSCAR file otherwise the structure cannot be identified
! when reading the ML_AB file
      IF (T_INFO%SZNAM2.EQ."") THEN
         CALL vtutor%error("ML_INTERFACE: ERROR: No structure name was provided in the POSCAR file, exiting...")
      ENDIF
! Stop code if NSW>1 and ML_ISTART=3
! Give some variables from VASP to MLFF and allocate some necessary arrays
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%A = LATT_CUR%A/AUTOA
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%B = LATT_CUR%B*AUTOA*2.0_q*PI
!      ML_SUPER_HANDLE%ML_INPUT_HANDLE%A = LATT_CUR%A
!      ML_SUPER_HANDLE%ML_INPUT_HANDLE%B = LATT_CUR%B
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%DIR_APP = DIR_APP
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%DIR_LEN = DIR_LEN
      ML_SUPER_HANDLE%FF%DIR_APP = DIR_APP
      ML_SUPER_HANDLE%FF%DIR_LEN = DIR_LEN
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%LABORT = INFO%LABORT
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%COMM_VASP = VASP_COMM
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NIONS = T_INFO%NIONS
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%SZNAM2 = TRIM(ADJUSTL(T_INFO%SZNAM2))
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA = LATT_CUR%OMEGA/AUTOA**3
!      ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA = LATT_CUR%OMEGA
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%POTIM = DYN%POTIM/TUNIT
!      ML_SUPER_HANDLE%ML_INPUT_HANDLE%POTIM = DYN%POTIM
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NTYP = T_INFO%NTYP
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%NITYP(1:ML_SUPER_HANDLE%ML_INPUT_HANDLE%NTYP))
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POMASS(1:ML_SUPER_HANDLE%ML_INPUT_HANDLE%NTYP))
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TYPE(1:ML_SUPER_HANDLE%ML_INPUT_HANDLE%NTYP))
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NITYP = T_INFO%NITYP
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%POMASS = T_INFO%POMASS/MUNIT
!      ML_SUPER_HANDLE%ML_INPUT_HANDLE%POMASS = T_INFO%POMASS
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TYPE = T_INFO%TYPE
! Set TIFOR_ML,TSIF_ML.
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML)
      ENDIF
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML(1:3,1:ML_SUPER_HANDLE%ML_INPUT_HANDLE%NIONS))
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML)
      ENDIF
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML(1:3,1:3))
! Set VEL_ML.
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML)
      ENDIF
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML(1:3,1:ML_SUPER_HANDLE%ML_INPUT_HANDLE%NIONS))
! Set ionic positions
      IF (ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POSION)) DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POSION)
      ALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POSION(1:3,ML_SUPER_HANDLE%ML_INPUT_HANDLE%NIONS))
      DO INIONS=1, ML_SUPER_HANDLE%ML_INPUT_HANDLE%NIONS
         ML_SUPER_HANDLE%ML_INPUT_HANDLE%POSION(1:3,INIONS)= &
                  T_INFO%POSION(1,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,1) + &
                  T_INFO%POSION(2,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,2) + &
                  T_INFO%POSION(3,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,3)
      ENDDO
      ! Initialize tutor (only one processor writes messages to screen).
      ml_tutor%discardOutputToNegativeUnit = .TRUE.
      IF (ML_IO_WRITE) THEN
         ml_tutor%unitOut = IO%IU6
         ml_tutor%unitErr = IO%IU0
      ELSE
         ml_tutor%unitOut = -1
         ml_tutor%unitErr = -1
      END IF
! Send variables to machine-learning library
      CALL MACHINE_LEARNING_INIT_LIB (ML_SUPER_HANDLE)
! We need to set this if ISTART=3
      IF (ML_SUPER_HANDLE%FF%ISTART.EQ.3) THEN
         LDO_AB_INITIO=.FALSE.
         LDO_AB_INITIO_NEW=.FALSE.
      ENDIF
      IF (ML_SUPER_HANDLE%FF%ISTART.EQ.4) THEN
         LDO_AB_INITIO=.FALSE.
         LDO_AB_INITIO_NEW=.FALSE.
      ENDIF
    END SUBROUTINE MACHINE_LEARNING_INIT

!=======================================================================
!
! the following routine whenever a new set of positions
! is available to VASP the ML code, might be already able
! to calculate forces etc. and in that case returns the energy
! forces and the stress tensor, as well as an error estimate
! if LDO_AB_INITIO_NEW is set to be true, VASP will do the 
! calculations for the present positions, otherwise
! we will use the predicted data
!
!=======================================================================

    SUBROUTINE ML_TO_VASP_MACHINE_LEARNING(ML_SUPER_HANDLE, DYN, GRIDC, IO, LATT_CUR, LREMOVE_DRIFT, LWRITE_FORCE, &
               NIOND, NSTEP, SYMM, T_INFO, TOTEN, TIFOR, TSIF, VASP_COMM)
      USE base
      USE classicfields
      USE constant
      USE ini
      USE lattice
      USE poscar
      USE mgrid
      USE mpimy
      USE msymmetry
      USE poscar
      USE ML_FF_STRUCT, ONLY: ML_SUPER_TYPE, ML_IO_WRITE
      USE ML_FF_CONSTANT, ONLY: MUNIT, TUNIT
      IMPLICIT NONE
!Input and output variables
      TYPE (ML_SUPER_TYPE)          :: ML_SUPER_HANDLE
      TYPE (dynamics)               :: DYN
      TYPE (grid_3d)                :: GRIDC             ! grid for potentials/charge
      TYPE (in_struct)              :: IO
      TYPE (latt), INTENT(IN)       :: LATT_CUR          ! Bravais lattice information
      TYPE(symmetry)                :: SYMM
      TYPE (type_info), INTENT(IN)  :: T_INFO            ! type and position information
      LOGICAL, INTENT(IN)           :: LWRITE_FORCE      ! If LWRITE_FORCE=.TRUE., write forces in OUTCAR file.
      INTEGER, INTENT(IN)           :: NIOND             ! The number of ions.
      INTEGER, INTENT(IN)           :: NSTEP             ! MD step
      REAL (q), INTENT(OUT)         :: TOTEN             ! total energy
      REAL (q), INTENT(OUT)         :: TIFOR(:,:)        !(1:3,1:NIOND) ! forces on all atoms
      REAL (q), INTENT(OUT)         :: TSIF(:,:)         !(1:3,1:3)      ! stress tensor
      INTEGER, INTENT(IN)           :: VASP_COMM
! Local variables related to symmetry.
      INTEGER  ISYMOP,NROTK
      LOGICAL LREMOVE_DRIFT
      COMMON /SYMM/   ISYMOP(3,3,48),NROTK
      REAL (q)         :: TOTEN_TMP             ! total energy
      REAL (q)         :: TIFOR_TMP(1:3,1:NIOND)        !(1:3,1:NIOND) ! forces on all atoms
      REAL (q)         :: TSIF_TMP(1:3,1:3)         !(1:3,1:3)      ! stress tensor
      LOGICAL :: LDO_AB_INITIO_NEW_TMP
! Local variables related to bias forces.
      REAL(q)   :: EV2KB
      REAL(q)   :: FAC
      INTEGER   :: I
      INTEGER   :: INIONS
      INTEGER   :: IXYZ
      INTEGER   :: JXYZ
      INTEGER   :: NOFFS
      INTEGER   :: NI
      INTEGER   :: NT
      REAL(q)   :: OFIELD_E                        ! energy contribution from order field
      REAL(q)   :: OFIELD_FOR(1:3,T_INFO%NIONS)    ! forces from order field
      REAL(q)   :: POSION_LOC(1:3,T_INFO%NIONS)
      REAL(q)   :: PRESS
      REAL(q)   :: pressure
      REAL(q)   :: TMP(1:6)
      REAL(q)   :: VEL(1:3)
      REAL(q)   :: VTMP(1:3)

! Do nothing and return if this flag is set to true (for instance ML_ISTART=3)
      IF (ML_SUPER_HANDLE%SKIP_ML_TO_VASP) THEN
         TOTEN=0.0_q
         TIFOR=0.0_q
         TSIF=0.0_q
         RETURN
      ENDIF

! Constants.
      EV2KB = EVTOJ*1E+22_q/LATT_CUR%OMEGA
      FAC  = AMTOKG* &
             1E5_q* &
             1E5_q* &
             1E30_q* &
             1E-8_q
! Give some variables from VASP to MLFF
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%A = LATT_CUR%A/AUTOA
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%B = LATT_CUR%B*AUTOA*2.0_q*PI
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%COMM_VASP = VASP_COMM
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NIONS = T_INFO%NIONS
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NITYP = T_INFO%NITYP
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NSTEP = NSTEP
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%NTYP = T_INFO%NTYP
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%POMASS = T_INFO%POMASS/MUNIT
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%POTIM = DYN%POTIM/TUNIT
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%SZNAM2 = TRIM(ADJUSTL(T_INFO%SZNAM2))
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TYPE = T_INFO%TYPE
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA = LATT_CUR%OMEGA/AUTOA**3
! Calculate positions in cartesian coordinates
! Set velocity. At NSTEP>1, velocity at the next step is estimated by adding 
! current accerelation to current velocity.
      DO INIONS=1, T_INFO%NIONS
         POSION_LOC(1:3,INIONS)=T_INFO%POSION(1,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,1) + &
                                T_INFO%POSION(2,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,2) + &
                                T_INFO%POSION(3,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,3)
         ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML(1:3,INIONS)=DYN%VEL(1,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,1) + &
                                                            DYN%VEL(2,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,2) + &
                                                            DYN%VEL(3,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,3)
         ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML(1:3,INIONS)=ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML(1:3,INIONS) / &
                                                           ML_SUPER_HANDLE%ML_INPUT_HANDLE%POTIM
      ENDDO
! Predict energy, force and stress tensor by using machine-learning force field.
      IF (ML_SUPER_HANDLE%FF%LSECOND_TIME_ML_TO_VASP) THEN
         CALL ML_TO_VASP_MACHINE_LEARNING_LIB (ML_SUPER_HANDLE,ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:,1:),ML_SUPER_HANDLE%ML_INPUT_HANDLE%B(1:,1:), &
              ML_SUPER_HANDLE%ML_INPUT_HANDLE%POTIM,ML_SUPER_HANDLE%ML_INPUT_HANDLE%NSTEP, &
              ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA,POSION_LOC,ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML, &
              ML_SUPER_HANDLE%ML_INPUT_HANDLE%SZNAM2,TOTEN_TMP,TIFOR_TMP,TSIF_TMP,LDO_AB_INITIO_NEW_TMP)
      ELSE
         CALL ML_TO_VASP_MACHINE_LEARNING_LIB (ML_SUPER_HANDLE,ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:,1:),ML_SUPER_HANDLE%ML_INPUT_HANDLE%B(1:,1:), &
              ML_SUPER_HANDLE%ML_INPUT_HANDLE%POTIM,ML_SUPER_HANDLE%ML_INPUT_HANDLE%NSTEP, &
              ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA,POSION_LOC,ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML, &
              ML_SUPER_HANDLE%ML_INPUT_HANDLE%SZNAM2,TOTEN,TIFOR,TSIF,LDO_AB_INITIO_NEW)
! Add the external order field, if necessary
         CALL OFIELD(GRIDC%COMM, IO, LATT_CUR, DYN, T_INFO, OFIELD_FOR, OFIELD_E)
         TIFOR=TIFOR+OFIELD_FOR
         TOTEN=TOTEN+OFIELD_E
! Remove drift.
         IF (DYN%IBRION/=0) THEN
! remove drift from the forces
            IF (LREMOVE_DRIFT) CALL SYMVEC(T_INFO%NIONS,TIFOR)
         ENDIF
! Only write at every DYN%NBLOCK steps
         IF (MOD(NSTEP,DYN%NBLOCK)==0) THEN
! Output to OUTCAR file.
            IF (IO%IU6>=0) THEN
               PRESS=(TSIF(1,1)+TSIF(2,2)+TSIF(3,3))/3._q- &
                     DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA
               WRITE(IO%IU6,1)       (TSIF(IXYZ,IXYZ),IXYZ=1,3),      TSIF (1,2),     TSIF(2,3),     TSIF (3,1), &
                               (EV2KB*TSIF(IXYZ,IXYZ),IXYZ=1,3),EV2KB*TSIF(1,2),EV2KB*TSIF(2,3),EV2KB*TSIF(3,1), &
                               PRESS*EV2KB,DYN%PSTRESS
               TMP = 0._q
               NOFFS = 0
               DO NT=1,T_INFO%NTYP
                  DO NI=1+NOFFS,T_INFO%NITYP(NT)+NOFFS
                     VEL(1) = DYN%VEL(1,NI)/DYN%POTIM
                     VEL(2) = DYN%VEL(2,NI)/DYN%POTIM
                     VEL(3) = DYN%VEL(3,NI)/DYN%POTIM
                     CALL  DIRKAR( 1, VEL, LATT_CUR%A )
                     TMP(1) = TMP(1) + VEL(1)*VEL(2) * T_INFO%POMASS(NT)
                     TMP(2) = TMP(2) + VEL(2)*VEL(3) * T_INFO%POMASS(NT)
                     TMP(3) = TMP(3) + VEL(3)*VEL(1) * T_INFO%POMASS(NT)
                     TMP(4) = TMP(4) + VEL(1)*VEL(1) * T_INFO%POMASS(NT)
                     TMP(5) = TMP(5) + VEL(2)*VEL(2) * T_INFO%POMASS(NT)
                     TMP(6) = TMP(6) + VEL(3)*VEL(3) * T_INFO%POMASS(NT)
                  ENDDO
                  NOFFS = NOFFS + T_INFO%NITYP(NT)
               ENDDO
               TMP = TMP/LATT_CUR%OMEGA*FAC         ! NOW TMP IS IN KB
               WRITE(IO%IU6,'(''  kinetic pressure (ideal gas correction) = '',F9.2,'' kB'')') (TMP(4)+TMP(5)+TMP(6))/3
               pressure=(TSIF(1,1)+TSIF(2,2)+TSIF(3,3))*EV2KB
               pressure=pressure + (TMP(4)+TMP(5)+TMP(6))
               pressure=pressure/3.
               WRITE(IO%IU6,'(''  total pressure  = '',F9.2,'' kB'')') pressure
               WRITE(IO%IU6,'(''  Total+kin. '',F9.3,5F12.3)') TSIF(1,1)*EV2KB + TMP(4),  &
                                                               TSIF(2,2)*EV2KB + TMP(5),  &
                                                               TSIF(3,3)*EV2KB + TMP(6),  &
                                                               TSIF(1,2)*EV2KB + TMP(1),  &
                                                               TSIF(2,3)*EV2KB + TMP(2),  &
                                                               TSIF(3,1)*EV2KB + TMP(3)
               WRITE(IO%IU6,2) LATT_CUR%OMEGA, &
                  ((LATT_CUR%A(IXYZ,JXYZ),IXYZ=1,3),(LATT_CUR%B(IXYZ,JXYZ),IXYZ=1,3),JXYZ=1,3), &
                  (LATT_CUR%ANORM(IXYZ),IXYZ=1,3),(LATT_CUR%BNORM(IXYZ),IXYZ=1,3)
               IF(LWRITE_FORCE) THEN
                  WRITE(IO%IU6,3)
                  DO INIONS=1, T_INFO%NIONS
                     VTMP(1)=T_INFO%POSION(1,INIONS)
                     VTMP(2)=T_INFO%POSION(2,INIONS)
                     VTMP(3)=T_INFO%POSION(3,INIONS)
                     CALL  DIRKAR(1,VTMP(1),LATT_CUR%A(1,1))
                     WRITE(IO%IU6,4) (VTMP(I),I=1,3),(TIFOR(I,INIONS),I=1,3)
                  ENDDO
                  VTMP(1:3)=0.0_q
                  DO INIONS=1, T_INFO%NIONS
                     DO IXYZ=1, 3
                        VTMP(IXYZ)=VTMP(IXYZ)+TIFOR(IXYZ,INIONS)
                     ENDDO
                  ENDDO
                  WRITE(IO%IU6,5) VTMP
               ENDIF
               WRITE(IO%IU6,6)
               WRITE(IO%IU6,7) '  ML FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)',TOTEN,TOTEN,TOTEN
            ENDIF
         ENDIF
! Convert to enthalpy
         IF (DYN%PSTRESS/=0) THEN
            TOTEN=TOTEN+DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA
            ! Again printing only at every NBLOCK step
            IF (MOD(NSTEP,DYN%NBLOCK)==0) THEN
               IF (IO%IU6>=0) WRITE(IO%IU6,8) TOTEN,DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA
            ENDIF
         ENDIF
! Format
1        FORMAT(/'  ML FORCE on cell =-STRESS in cart. coord. units (eV/cell)'/ &
                 '  Direction',4X,'XX', 10X,'YY', 10X,'ZZ', 10X,'XY', 10X,'YZ', 10X,'ZX'/ &
                 '  --------------------------------------------------------------------------------------'/ &
                 '  Total: ',6F12.5/ &
                 '  in kB  ',6F12.5/, &
                 '  external pressure = ',F11.2,' kB', &
                 '  Pullay stress = ',F11.2,' kB'/)
2        FORMAT( '  volume of cell :  ',F10.2/ &
                 '      direct lattice vectors',17X,'reciprocal lattice vectors'/ &
                 3(2(3X,3F13.9)/)/ &
                 '  length of vectors'/ &
                  (2(3X,3F13.9)/) /)
3        FORMAT( '  POSITION    ',35X,'TOTAL-FORCE (eV/Angst) (ML)'/ &
                 ' -----------------------------------------------------------------------------------')
4        FORMAT((3F13.5,3X,3F14.6))
5        FORMAT( ' ----------------------------------------------', &
                 '-------------------------------------',/ &
                 '    total drift:      ',20X,3F14.6)
6        FORMAT (5X, //, &
                '----------------------------------------------------', &
                '----------------------------------------------------'//)
7        FORMAT(/ &
                A/ &
                '  ---------------------------------------------------'/ &
                '  free  energy ML TOTEN  = ',F18.8,' eV'// &
                '  ML energy  without entropy=',F18.8, &
                '  ML energy(sigma->0) =',F18.8/)
8        FORMAT ('  enthalpy is ML TOTEN    = ',F18.8,' eV   P V=',F18.8/)
      ENDIF
    END SUBROUTINE ML_TO_VASP_MACHINE_LEARNING

#ifndef ML_LEARNING_NOT_ACTIVE
!=======================================================================
!
! the following routine passes the energies and forces
! calculated by VASP to the ML code
! note that if LDO_AB_INITIO is false, these are just the
! very same forces and energies as calculated by the ML code
! Not TOTEN, TIFOR, TSIF but TOTEN_ML, TIFOR_ML, TSIF_ML must be
! provided to machine-learning library.
!
!=======================================================================

    SUBROUTINE VASP_TO_ML_MACHINE_LEARNING( ML_SUPER_HANDLE, DIR_APP,DIR_LEN,INFO, LATT_CUR, NSTEP, T_INFO, DYN, IO, GRIDC, IONS, TOTEN, TIFOR, TSIF )
      USE constant
      USE base
      USE mgrid
      USE ini
      USE lattice
      USE poscar
      USE mpimy
      USE classicfields
      USE ML_FF_STRUCT, ONLY: ML_SUPER_TYPE
      USE ML_FF_CONSTANT, ONLY: MUNIT, TUNIT, EUNIT, FUNIT, SUNIT
      IMPLICIT NONE
! Input and output variables
      TYPE (ML_SUPER_TYPE)          :: ML_SUPER_HANDLE
      CHARACTER(LEN=10), INTENT(IN) :: DIR_APP
      INTEGER          , INTENT(IN) :: DIR_LEN
      TYPE (info_struct)            :: INFO                      ! Information
      TYPE (latt)      , INTENT(IN) :: LATT_CUR    ! Bravais lattice information
      INTEGER          , INTENT(IN) :: NSTEP       ! MD step
      TYPE (type_info) , INTENT(IN) :: T_INFO      ! type and position information
      TYPE (dynamics)  , INTENT(IN) :: DYN
      TYPE (in_struct) , INTENT(IN) :: IO
      TYPE (grid_3d)   , INTENT(IN) :: GRIDC
      INTEGER                       :: IONS
      REAL(q)                       :: TOTEN
      REAL(q)                       :: TIFOR(:,:) !(1:3,1:IONS)
      REAL(q)                       :: TSIF(:,:) !(1:3,1:3)
! LOCAL variables
      REAL(q)                       :: OFIELD_E                        ! energy contribution from orderfield
      REAL(q)                       :: OFIELD_FOR (1:3,T_INFO%NIONS)    ! forces from order field
      REAL(q)                       :: FAKT
      INTEGER                       :: INIONS
      LOGICAL                       :: LDO_AB_INITIO_HELP
      REAL(q)                       :: POSION_LOC(1:3,T_INFO%NIONS)
      REAL(q)                       :: TOTEN_TMP
      REAL(q)                       :: TIFOR_TMP(1:3,1:T_INFO%NIONS)
      REAL(q)                       :: TSIF_TMP(1:3,1:3)
      REAL(q)                       :: VEL_TMP(1:3,1:T_INFO%NIONS)

! Do nothing and return if this flag is set to true (for instance ML_ISTART=3)
      IF (ML_SUPER_HANDLE%SKIP_VASP_TO_ML) RETURN

! Initialize helping arrays
      VEL_TMP=0.0_q

      ! Conversions needed for input to INIT_LIB
      FAKT=EVTOJ*1.0E+22_q/LATT_CUR%OMEGA !/AUTOA**3

      ! subtract contribution of OFIELD that was added in force.F
      CALL OFIELD(GRIDC%COMM, IO, LATT_CUR, DYN, T_INFO, OFIELD_FOR, OFIELD_E) 
      IF (DYN%PSTRESS/=0) THEN
         ! subtract stress contribution of energy that was added in main.F
         ML_SUPER_HANDLE%ML_INPUT_HANDLE%TOTEN_ML=TOTEN - DYN%PSTRESS/(EVTOJ*1E22_q)*LATT_CUR%OMEGA - OFIELD_E
      ELSE
         ML_SUPER_HANDLE%ML_INPUT_HANDLE%TOTEN_ML=TOTEN - OFIELD_E
      ENDIF
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML(1:3,1:IONS)=TIFOR(1:3,1:IONS)-OFIELD_FOR(1:3,1:IONS)
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML(1:3,1:3)=TSIF(1:3,1:3)

! We need to do unit conversions here
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TOTEN_ML=ML_SUPER_HANDLE%ML_INPUT_HANDLE%TOTEN_ML/EUNIT
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML(1:3,1:IONS)=ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML(1:3,1:IONS)/FUNIT
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML(1:3,1:3)=ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML(1:3,1:3)*FAKT/SUNIT
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,1:3) = LATT_CUR%A(1:3,1:3)/AUTOA
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%B(1:3,1:3) = LATT_CUR%B(1:3,1:3)*AUTOA*2.0_q*PI
      ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA = LATT_CUR%OMEGA/AUTOA**3
      DO INIONS=1, T_INFO%NIONS
         POSION_LOC(1:3,INIONS)=T_INFO%POSION(1,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,1) + &
                                T_INFO%POSION(2,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,2) + &
                                T_INFO%POSION(3,INIONS)*ML_SUPER_HANDLE%ML_INPUT_HANDLE%A(1:3,3)
      ENDDO
! Do the actual calculations here
      CALL VASP_TO_ML_MACHINE_LEARNING_LIB (ML_SUPER_HANDLE, ML_SUPER_HANDLE%ML_INPUT_HANDLE%A, ML_SUPER_HANDLE%ML_INPUT_HANDLE%B, &
           DIR_APP,DIR_LEN,INFO%LABORT, NSTEP, ML_SUPER_HANDLE%ML_INPUT_HANDLE%OMEGA, POSION_LOC, &
           TRIM(ADJUSTL(T_INFO%SZNAM2)), ML_SUPER_HANDLE%ML_INPUT_HANDLE%TOTEN_ML, ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML, ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML )
    END SUBROUTINE VASP_TO_ML_MACHINE_LEARNING
#endif
! defined(ML_LEARNING_NOT_ACTIVE)

!=======================================================================
!
! the following routine allows the ML code to terminate and
! write all data
!
!=======================================================================

    SUBROUTINE MACHINE_LEARNING_FINISH (ML_SUPER_HANDLE,DIR_APP,DIR_LEN,NSTEP)
      USE mpimy
      USE ML_FF_STRUCT, ONLY: ML_SUPER_TYPE
      IMPLICIT NONE
      TYPE (ML_SUPER_TYPE) :: ML_SUPER_HANDLE
      CHARACTER(LEN=10), INTENT(IN) :: DIR_APP
      INTEGER          , INTENT(IN) :: DIR_LEN
      INTEGER          , INTENT(IN) :: NSTEP ! Final MD step
      CALL MACHINE_LEARNING_FINISH_LIB (ML_SUPER_HANDLE,DIR_APP,DIR_LEN,NSTEP)
! Deallocate NITYP, POMASS and TYPE
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%NITYP)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%NITYP)
      ENDIF
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POMASS)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POMASS)
      ENDIF
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TYPE)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TYPE)
      ENDIF
! Deallocate POSEIDON
      IF (ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POSION)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%POSION)
      ENDIF
! Deallocate TIFOR_ML and TSIF_ML.
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TIFOR_ML)
      ENDIF
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%TSIF_ML)
      ENDIF
! Deallocate VEL_ML.
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%VEL_ML)
      ENDIF
! Deallocate arrays storing the energies of isolated atoms.
      IF(ALLOCATED(ML_SUPER_HANDLE%ML_INPUT_HANDLE%EATOM_VASP)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%ML_INPUT_HANDLE%EATOM_VASP)
      ENDIF
! Deallocate ML_ICOUPLE that stores the list of atoms, where the coupling parameter is introduced for the calculation of the chemical potential.
      IF(ALLOCATED(ML_SUPER_HANDLE%FFM%ICOUPLE)) THEN
         DEALLOCATE(ML_SUPER_HANDLE%FFM%ICOUPLE)
      ENDIF
    END SUBROUTINE MACHINE_LEARNING_FINISH

#endif
! defined(MPI) || defined(MPI_CHAIN)
#endif
! ML_AVAILABLE
END MODULE ml_interface
