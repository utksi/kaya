#if defined(MPI) || defined(MPI_CHAIN)
#include "symbol.inc"
!****************************************************************************************************
! Module to handle force field variables
!    parts of the force field generations.
!****************************************************************************************************

      MODULE FORCE_FIELD
        USE ML_FF_CONSTANT
        USE IOHANDLE
        USE LOGFILE
        USE LAPACK_DATA
        USE MEMORY_USAGE
        USE MPI_DATA
        USE ML_FF_PREC
        USE TIME_CHECK
#ifdef use_shmem
        USE ML_FF_MPI_SHMEM
#endif

        IMPLICIT NONE

        CONTAINS

!****************************************************************************************************
! Define element order and logical variables specifying the presence of data and executions 
! of operations.
! 1) When no previous ab initio database is available, the order of the element is defined
!    to be same as that in current VASP calculation.
! 2) When an ab inito database generated by previous machine-leraning calculations is available,
!    the order of the element is defined both from the previous ab initio data and the current 
!    VASP data.
! 3) In this subroutine, logical variables that specify the presence of the force field, 
!    executions of force field generation, sparsification, descriptor calculations
!    will be initialized, too.
!****************************************************************************************************

       SUBROUTINE DEF_ELEMENT_ORDER_FF (AB_HELP,TIM,FF,FFM,EATOM_NEW,NITYP_NEW,NIONS_NEW,NTYP_NEW,POMASS_NEW,TYPE_NEW,LALLOCATE_ARRAYS,ISTART_FF)
         USE TIME_CHECK
         USE ML_FF_STRUCT, ONLY: ABINITIO, TIME, FF_PAR, FFM_PAR
         IMPLICIT NONE
! Input variables
         TYPE (ABINITIO)               :: AB_HELP
         TYPE (TIME)                   :: TIM
         TYPE (FF_PAR)                 :: FF
         TYPE (FFM_PAR)                :: FFM
         REAL(q)          , INTENT(IN) :: EATOM_NEW(:) !(1:NTYP_NEW) ! Reference energy for each element provided by INCAR file.
         INTEGER          , INTENT(IN) :: NITYP_NEW(:) !(1:NTYP_NEW) ! The number of atoms per element in the current VASP execution.
         INTEGER          , INTENT(IN) :: NIONS_NEW ! The number of ions in the current VASP execution.
         INTEGER          , INTENT(IN) :: NTYP_NEW  ! The number of element in the current VASP execution.
         REAL(q)          , INTENT(IN) :: POMASS_NEW(:) !(1:NTYP_NEW) ! Mass of atoms.
         CHARACTER (LEN=2), INTENT(IN) :: TYPE_NEW(:) !(1:NTYP_NEW) ! The element symbol in the current VASP data.
         LOGICAL          , INTENT(IN) :: LALLOCATE_ARRAYS
         INTEGER          , INTENT(IN) :: ISTART_FF
! Local variables
         REAL(q), ALLOCATABLE :: EATOM_OLD(:),EATOM_TMP(:) ! Temprary arrays to store reference atomic energies provided INCAR and ABCAR files.
         INTEGER :: I
         INTEGER :: ICOL,IROW
         INTEGER :: IFLAG_LOC ! A flag to specify the presence of elements in the previous ab initio data.
         INTEGER INTYP ! A variable specifying the element number.
         INTEGER JNTYP ! A variable specifying the element number.
         REAL(q) CPUTIM0,CPUTIM1 ! Temporary variables used to measure the times.
         INTEGER MITYP_NEW
         INTEGER MITYP_OLD,MIONS_OLD,MTYP_OLD ! The maximum numbers of atoms and elements in the previous ab initio data.
         INTEGER MITYP_TMP,MIONS_TMP,MTYP_TMP ! The temporary variables that store temporary numbers of the atoms and elements.
         INTEGER NCOL,NMOD
         INTEGER NWRITE
         REAL(q), ALLOCATABLE :: POMASS_OLD(:), POMASS_TMP(:) ! Temporary arrays to store the atomic masses.
         CHARACTER (LEN=2), ALLOCATABLE :: TYPE_OLD(:), TYPE_TMP(:) ! Element types in previous ab initio data and temporary data.
         REAL(q) VPUTIM0,VPUTIM1 ! Temporary variables used to measure the times.
! Start profiling
         PROFILING_START('def_element_order')
! Measure the initial time
         CALL VTIME (VPUTIM0,CPUTIM0)
! Set constants.
         NWRITE=3
! If FF%ISTART=0, just copy the variables given from current VASP calculations since there is no previous database.
         IF(ISTART_FF .EQ. 0) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
            FF%MTYP=NTYP_NEW
            FF%MIONS=NIONS_NEW
            FF%MITYP=NITYP_NEW(1)
! Set arrays for allocation
            FF%MTYP_ALLOCATE=FF%MTYP
            FF%MIONS_ALLOCATE=FF%MIONS
! allocate arrays storing the element order.
! ALlocate arrays that are only allocated once
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY1(FF,FFM)
            ENDIF
! Set variables.
!unit            FF%EATOM_REF(1)=EATOM_NEW(1)/EUNIT
            FF%EATOM_REF(1)=EATOM_NEW(1)
            FF%LADD(1)=1
!unit            FF%POMASS(1)=POMASS_NEW(1)/MUNIT
            FF%POMASS(1)=POMASS_NEW(1)
            FF%TYPE(1)=TYPE_NEW(1)
            DO INTYP=2, FF%MTYP, 1
!unit               FF%EATOM_REF(INTYP)=EATOM_NEW(INTYP)/EUNIT
               FF%EATOM_REF(INTYP)=EATOM_NEW(INTYP)
               FF%LADD(INTYP)=INTYP
               FF%MITYP=MAX(FF%MITYP,NITYP_NEW(INTYP))
!unit               FF%POMASS(INTYP)=POMASS_NEW(INTYP)/MUNIT
               FF%POMASS(INTYP)=POMASS_NEW(INTYP)
               FF%TYPE(INTYP)=TYPE_NEW(INTYP)
            ENDDO
! Set arrays for allocation
            FF%MITYP_ALLOCATE=FF%MITYP
#endif
         ELSE IF (ISTART_FF.EQ.1 .OR. ISTART_FF.EQ.4) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
! If FF%ISTART=1, the element order is determined on the basis of both the current VASP data and previous database.
! Determine the maximum number of atoms per element
            MITYP_NEW=NITYP_NEW(1)
            DO INTYP=2, NTYP_NEW, 1
               MITYP_NEW=MAX(MITYP_NEW,NITYP_NEW(INTYP))
            ENDDO
! Read header of ab initio data file "ABCAR" to detecting the maximum number of atoms and elements in the previous ab initio data
! Read the number of element in the ABCAR file.
            CALL READ_ABCAR_ELEMENT_ORDER1 (AB_HELP,MTYP_OLD)
! Allocate temporary arrays.
            CALL ALLOCATE_TMP_ARRAY
! Read the element data in the ABCAR file.
            CALL READ_ABCAR_ELEMENT_ORDER2 (AB_HELP,FFM%MB,FF%MCONF,EATOM_OLD,MIONS_OLD,MITYP_OLD,MTYP_OLD,POMASS_OLD,TYPE_OLD)
! Merge the information on the maximum number of atoms and elements in previous ab initio data and current VASP calculations
            MIONS_TMP=MAX(MIONS_OLD,NIONS_NEW)
            MITYP_TMP=MAX(MITYP_OLD,MITYP_NEW)
            DO INTYP=1, MTYP_OLD
               EATOM_TMP(INTYP)=EATOM_OLD(INTYP)
!unit               POMASS_TMP(INTYP)=POMASS_OLD(INTYP)/MUNIT
               POMASS_TMP(INTYP)=POMASS_OLD(INTYP)
               TYPE_TMP(INTYP)=TYPE_OLD(INTYP)
            ENDDO
            MTYP_TMP=MTYP_OLD
            DO INTYP=1, NTYP_NEW
               IFLAG_LOC=1
               DO JNTYP=1, MTYP_OLD
                  IF(TYPE_NEW(INTYP) .EQ. TYPE_OLD(JNTYP)) THEN
                     IFLAG_LOC=0
                     EXIT
                  ENDIF
               ENDDO
! IFLAG_LOC=1 indicates that there is elements that do not exist in the previous ab initio data.
! In this case, the element is added in the list made from the previous ab initio data.
! Furthermore, in this case, since no ab initio data exist on the new element, force field generation
! will be skipped.
               IF(IFLAG_LOC .EQ. 1) THEN
                  MTYP_TMP=MTYP_TMP+1
                  EATOM_TMP(MTYP_TMP)=EATOM_NEW(INTYP)
!unit                  POMASS_TMP(MTYP_TMP)=POMASS_NEW(INTYP)/MUNIT
                  POMASS_TMP(MTYP_TMP)=POMASS_NEW(INTYP)
                  TYPE_TMP(MTYP_TMP)=TYPE_NEW(INTYP)
               ENDIF
            ENDDO
! Memorize the merged data
            FF%MITYP=MITYP_TMP
            FF%MIONS=MIONS_TMP
            FF%MTYP=MTYP_TMP
! Set arrays for allocation
            FF%MITYP_ALLOCATE=FF%MITYP
            FF%MIONS_ALLOCATE=FF%MIONS
            FF%MTYP_ALLOCATE=FF%MTYP
! ALlocate arrays that are only allocated once
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY1(FF,FFM)
            ENDIF
            DO INTYP=1, FF%MTYP
!unit               FF%EATOM_REF(INTYP)=EATOM_TMP(INTYP)/EUNIT
               FF%EATOM_REF(INTYP)=EATOM_TMP(INTYP)
               FF%LADD(INTYP)=INTYP
               FF%POMASS(INTYP)=POMASS_TMP(INTYP)
               FF%TYPE(INTYP)=TYPE_TMP(INTYP)
            ENDDO
! Deallocate temporary arrays
            CALL DEALLOCATE_TMP_ARRAY
#endif
         ELSE IF (ISTART_FF .EQ. 2) THEN
            MITYP_NEW=NITYP_NEW(1)
            DO INTYP=2, NTYP_NEW, 1
               MITYP_NEW=MAX(MITYP_NEW,NITYP_NEW(INTYP))
            ENDDO
! Read the number of elements in the FFCAR file.
            IF (FF%ML_FF_BINARY) THEN
               CALL READ_FF_CAR_DEF_ELEMENT_ORDER_FF_1(FF,MTYP_OLD)
            ELSE
               CALL READ_FF_CAR_DEF_ELEMENT_ORDER_FF_1_NON_BINARY(FF,MTYP_OLD)
            ENDIF
! Allocate temporary arrays.
            CALL ALLOCATE_TMP_ARRAY
! Read the element data in the FFCAR file.
            IF (FF%ML_FF_BINARY) THEN
               CALL READ_FF_CAR_DEF_ELEMENT_ORDER_FF_2(FF,EATOM_OLD,MTYP_OLD,POMASS_OLD,TYPE_OLD)
            ELSE
               CALL READ_FF_CAR_DEF_ELEMENT_ORDER_FF_2_NON_BINARY(FF,EATOM_OLD,MTYP_OLD,POMASS_OLD,TYPE_OLD)
            ENDIF
! Determine the maximum number of atoms per element
            FF%MITYP=MITYP_NEW
            FF%MIONS=NIONS_NEW
            FF%MTYP=MAX(MTYP_OLD,NTYP_NEW)
! Set arrays for allocation
            FF%MITYP_ALLOCATE=FF%MITYP
            FF%MIONS_ALLOCATE=FF%MIONS
            FF%MTYP_ALLOCATE=FF%MTYP
! ALlocate arrays that are only allocated once
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY1(FF,FFM)
            ENDIF
            DO INTYP=1, FF%MTYP
!unit               FF%EATOM_REF(INTYP)=EATOM_OLD(INTYP)/EUNIT
               FF%EATOM_REF(INTYP)=EATOM_OLD(INTYP)
               FF%LADD(INTYP)=INTYP
!unit               FF%POMASS(INTYP)=POMASS_OLD(INTYP)/MUNIT
               FF%POMASS(INTYP)=POMASS_OLD(INTYP)
               FF%TYPE(INTYP)=TYPE_OLD(INTYP)
            ENDDO
! Deallocate temporary arrays
            CALL DEALLOCATE_TMP_ARRAY
         ELSE IF (ISTART_FF .EQ. 3) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
! Read header of ab initio data file "ABCAR" to detecting the maximum number of atoms and elements in the previous ab initio data
! Read the number of element in the ABCAR file.
            CALL READ_ABCAR_ELEMENT_ORDER1 (AB_HELP,MTYP_OLD)
! Allocate temporary arrays.
            CALL ALLOCATE_TMP_ARRAY
! Read the element data in the ABCAR file.
            CALL READ_ABCAR_ELEMENT_ORDER2 (AB_HELP,FFM%MB,FF%MCONF,EATOM_OLD,MIONS_OLD,MITYP_OLD,MTYP_OLD,POMASS_OLD,TYPE_OLD)
! Memorize the merged data
            FF%MITYP=MITYP_OLD
            FF%MIONS=MIONS_OLD
            FF%MTYP=MTYP_OLD
! Set arrays for allocation
            FF%MITYP_ALLOCATE=FF%MITYP
            FF%MIONS_ALLOCATE=FF%MIONS
            FF%MTYP_ALLOCATE=FF%MTYP
! ALlocate arrays that are only allocated once
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY1(FF,FFM)
            ENDIF
            DO INTYP=1, FF%MTYP
!unit               FF%EATOM_REF(INTYP)=EATOM_TMP(INTYP)/EUNIT
               FF%EATOM_REF(INTYP)=EATOM_OLD(INTYP)
               FF%LADD(INTYP)=INTYP
               FF%POMASS(INTYP)=POMASS_OLD(INTYP)
               FF%TYPE(INTYP)=TYPE_OLD(INTYP)
            ENDDO
! Deallocate temporary arrays
            CALL DEALLOCATE_TMP_ARRAY
#endif
         ENDIF
! Measure the final time and add them
         CALL VTIME(VPUTIM1,CPUTIM1)
         TIM%CPUTIM(1)=TIM%CPUTIM(1)+CPUTIM1-CPUTIM0
         TIM%VPUTIM(1)=TIM%VPUTIM(1)+VPUTIM1-VPUTIM0
! Stop profiling
         PROFILING_STOP('def_element_order')

           CONTAINS

! Allocate temporary arrays used in this subroutine
           SUBROUTINE ALLOCATE_TMP_ARRAY 
             IMPLICIT NONE
             ALLOCATE (EATOM_OLD(1:MTYP_OLD),EATOM_TMP(1:MTYP_OLD+NTYP_NEW), &
             POMASS_OLD(1:MTYP_OLD),POMASS_TMP(1:MTYP_OLD+NTYP_NEW), &
             TYPE_OLD(1:MTYP_OLD),TYPE_TMP(1:MTYP_OLD+NTYP_NEW))
           END SUBROUTINE ALLOCATE_TMP_ARRAY

! Deallocate temporary arrays used in this subroutine
           SUBROUTINE DEALLOCATE_TMP_ARRAY
             IMPLICIT NONE
             DEALLOCATE (EATOM_OLD,EATOM_TMP,POMASS_OLD,POMASS_TMP,TYPE_OLD,TYPE_TMP)
           END SUBROUTINE DEALLOCATE_TMP_ARRAY

        END SUBROUTINE DEF_ELEMENT_ORDER_FF

!****************************************************************************************************
! This subroutine define the order of the model systems in the training data set.
!****************************************************************************************************

        SUBROUTINE DEF_SYSTEM_ORDER_FF (AB_HELP,FF,FFM,SZNAM2,SZNAM2_INPUT,LALLOCATE_ARRAYS,ISTART_FF)
          USE ML_FF_STRUCT, ONLY: ABINITIO, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)    :: AB_HELP
          TYPE (FF_PAR)      :: FF
          TYPE (FFM_PAR)     :: FFM
          CHARACTER(LEN=40), INTENT(IN)              :: SZNAM2
          CHARACTER(LEN=40), INTENT(IN)              :: SZNAM2_INPUT
          LOGICAL          , INTENT(IN)              :: LALLOCATE_ARRAYS
          INTEGER          , INTENT(IN)              :: ISTART_FF
! Local variables.
          INTEGER                                    :: I
          INTEGER                                    :: ICOL
          INTEGER                                    :: ICONF
          INTEGER                                    :: INTYP
          INTEGER                                    :: IROW
          INTEGER                                    :: ISYS
          INTEGER                                    :: IFLAG
          INTEGER                                    :: NB(1:FF%MTYP)
          INTEGER                                    :: NCOL
          INTEGER                                    :: NCONF
          INTEGER                                    :: NIONS
          INTEGER                                    :: NITYP
          INTEGER                                    :: NMOD
          INTEGER                                    :: NTYP
          INTEGER                                    :: NWRITE
          INTEGER                                    :: MTYP
          CHARACTER(LEN=40)                          :: SZNAM2_HELP1
          CHARACTER(LEN=40)            , ALLOCATABLE :: SZNAM2_HELP2(:)
          CHARACTER(LEN=40)            , ALLOCATABLE :: SZNAM2_HELP2_INPUT(:)
! Start profiling.
          PROFILING_START('def_system_order')
! Set constant.
          NWRITE=3
! If FF%ISTART=0, just copy the system name given from current VASP calculations.
          IF(ISTART_FF .EQ. 0) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
             FF%NSYS=1
             FF%NSYS_AB_ONLY=FF%NSYS
             FF%NSYS_ALLOCATE=FF%NSYS
             IF (LALLOCATE_ARRAYS) THEN
                CALL ALLOCATE_FFARRAY2(FF,FFM)
             ENDIF
             FF%SZNAM2(1)=SZNAM2
             FF%SZNAM2_INPUT(1)=SZNAM2_INPUT
#endif
          ELSE IF (ISTART_FF.EQ.1 .OR. ISTART_FF.EQ.4) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
! If FF%ISTART=1, the system order is determined on the basis of both the current VASP data and previous database.
! Read the number of configurations written in the ABCAR file.
             CALL READ_ABCAR_SYSTEM_ORDER1 (NCONF,AB_HELP)
! Allocate the temporary array.
             ALLOCATE(SZNAM2_HELP2(1:NCONF+1))
             ALLOCATE(SZNAM2_HELP2_INPUT(1:NCONF+1))
             CALL READ_ABCAR_SYSTEM_ORDER2 (NCONF,FF%NSYS,SZNAM2_HELP2,SZNAM2_HELP2_INPUT,AB_HELP)
! AB%NSYS only from AB file
             FF%NSYS_AB_ONLY=FF%NSYS
! Merge old system name and new system name.
             IFLAG=1
             DO ISYS=1, FF%NSYS
                IF(SZNAM2.EQ.SZNAM2_HELP2(ISYS)) THEN
                   IFLAG=0
                   EXIT
                ENDIF 
             ENDDO
             IF(IFLAG.EQ.1) THEN
                FF%NSYS=FF%NSYS+1
                SZNAM2_HELP2(FF%NSYS)=SZNAM2
                SZNAM2_HELP2_INPUT(FF%NSYS)=SZNAM2_INPUT
             ENDIF
             FF%NSYS_ALLOCATE=FF%NSYS
             IF (LALLOCATE_ARRAYS) THEN
                CALL ALLOCATE_FFARRAY2(FF,FFM)
             ENDIF
             DO ISYS=1, FF%NSYS
                FF%SZNAM2(ISYS)=SZNAM2_HELP2(ISYS)
                FF%SZNAM2_INPUT(ISYS)=SZNAM2_HELP2_INPUT(ISYS)
             ENDDO
             DEALLOCATE(SZNAM2_HELP2)
             DEALLOCATE(SZNAM2_HELP2_INPUT)
#endif
          ELSE IF (ISTART_FF .EQ. 2) THEN
             FF%NSYS=1
             FF%NSYS_AB_ONLY=FF%NSYS
             FF%NSYS_ALLOCATE=FF%NSYS
             IF (LALLOCATE_ARRAYS) THEN
                CALL ALLOCATE_FFARRAY2(FF,FFM)
             ENDIF
             DO ISYS=1, FF%NSYS
                FF%SZNAM2(ISYS)="SZNAM2"
                FF%SZNAM2_INPUT(ISYS)="SZNAM2"
             ENDDO
          ELSE IF (ISTART_FF .EQ. 3) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
! If FF%ISTART=3, the system order is determined on the basis of previous database only.
! Read the number of configurations written in the ABCAR file.
             CALL READ_ABCAR_SYSTEM_ORDER1 (NCONF,AB_HELP)
! Allocate the temporary array.
             ALLOCATE(SZNAM2_HELP2(1:NCONF))
             ALLOCATE(SZNAM2_HELP2_INPUT(1:NCONF+1))
             CALL READ_ABCAR_SYSTEM_ORDER2 (NCONF,FF%NSYS,SZNAM2_HELP2,SZNAM2_HELP2_INPUT,AB_HELP)
             FF%NSYS_AB_ONLY=FF%NSYS
! For ISTART=3 don't merge old system name and new system name.
             FF%NSYS_ALLOCATE=FF%NSYS
             IF (LALLOCATE_ARRAYS) THEN
                CALL ALLOCATE_FFARRAY2(FF,FFM)
             ENDIF
             DO ISYS=1, FF%NSYS
                FF%SZNAM2(ISYS)=SZNAM2_HELP2(ISYS)
                FF%SZNAM2_INPUT(ISYS)=SZNAM2_HELP2_INPUT(ISYS)
             ENDDO
             DEALLOCATE(SZNAM2_HELP2)
             DEALLOCATE(SZNAM2_HELP2_INPUT)
#endif
          ENDIF
! Stop profiling.
          PROFILING_STOP('def_system_order')
        END SUBROUTINE DEF_SYSTEM_ORDER_FF

!****************************************************************************************************
! Read force field parameters from INCAR file and set the related
! variables necessary for force field generations.
!****************************************************************************************************

        SUBROUTINE SET_FF_PAR (AB_HELP,          &
                               TAG_LIST,         &
                               TIM,              &
                               PAR_SUP_HANDLE,   &
                               MLSHM,            &
                               MEM1,             &
                               LOGF,             &
                               FF,               &
                               FFM,              &
                               IU1,              &
                               NIONS_NEW,        &
                               NITYP_NEW,        &
                               NTYP_NEW,         &
                               LALLOCATE_ARRAYS, &
                               ISTART_FF)
          USE ATOM_DATA
          USE BASIS_SOAP
          USE RANDOM_NUMBER_GENERATOR
          USE ML_FF_TAGLIST
          USE ML_FF_STRUCT, ONLY: ABINITIO,       &
                                  TIME,           &
                                  PARALLEL_SUPER, &
                                  ML_SHMEM,       &
                                  MEMORY,         &
                                  LOG_PAR,        &
                                  FF_PAR,         &
                                  FFM_PAR,        &
                                  ML_IO_WRITE,    &
                                  ML_MB_DEFAULT,  &
                                  ML_MCONF_DEFAULT
          USE ml_ff_tutor, ONLY: ml_tutor
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)               :: AB_HELP
          TYPE (TAGLIST), INTENT(INOUT) :: TAG_LIST
          TYPE (TIME)                   :: TIM
          TYPE (PARALLEL_SUPER)         :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)               :: MLSHM
          TYPE (MEMORY)                 :: MEM1
          TYPE (LOG_PAR)                :: LOGF
          TYPE (FF_PAR)                 :: FF
          TYPE (FFM_PAR)                :: FFM
          INTEGER, INTENT(IN)           :: IU1
          INTEGER, INTENT(IN)           :: NIONS_NEW
          INTEGER, INTENT(IN)           :: NITYP_NEW(:) !(1:NTYP_NEW)
          INTEGER, INTENT(IN)           :: NTYP_NEW
          LOGICAL, INTENT(IN)           :: LALLOCATE_ARRAYS
          INTEGER, INTENT(IN)           :: ISTART_FF
! Local variables
          REAL(q) :: CPUTIM0,CPUTIM1 ! Variables necessary for measuring the times.
          REAL(q) :: ERR1 ! Error caused by radial expansions
          REAL(q) :: ERR2 ! Error caused by radial expansions
          INTEGER :: I 
          INTEGER :: NCONF
          REAL(q) :: RDUM
          REAL(q) :: VPUTIM0,VPUTIM1 ! Variables necessary for measuring the times.
! Start profiling
          PROFILING_START('set_ff_par')
! Measure the initial time
          CALL VTIME (VPUTIM0,CPUTIM0)
! ISTART_FF=0: Start the training from scracth.
          IF(ISTART_FF.EQ.0) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
             CALL SET_FF_PAR_ISTART0
#endif
! ISTART_FF=1: Read ABCAR file, and restart the training.
          ELSE IF(ISTART_FF.EQ.1) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
             CALL SET_FF_PAR_ISTART1
#endif
! ISTART_FF=2: Read both ABCAR and FFCAR files, and start simulations using the existing force field. Training is not executed.
          ELSE IF(ISTART_FF.EQ.2) THEN
             CALL SET_FF_PAR_ISTART2
! ISTART_FF=1: Read ABCAR file, and use it as a database.
          ELSE IF(ISTART_FF.EQ.3) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
             CALL SET_FF_PAR_ISTART3
#endif
! ISTART_FF=4: Basically the same as 1
          ELSE IF(ISTART_FF.EQ.4) THEN
#ifndef ML_LEARNING_NOT_ACTIVE
             CALL SET_FF_PAR_ISTART1
#endif
          ENDIF
! Output.
          ! Main parameters
          CALL LOGSECTION_PARAMETERS(TAG_LIST, LOGF, FF, FFM)
          ! Output parameters read from ML_FF file
          IF (ISTART_FF.EQ.2) THEN
             CALL LOGSECTION_ML_FF_PARAMETERS(LOGF, FF, FFM)
          ENDIF
! Measure the final time and add them
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(1)=TIM%CPUTIM(1)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(1)=TIM%VPUTIM(1)+VPUTIM1-VPUTIM0
! Start profiling
          PROFILING_STOP('set_ff_par')

          CONTAINS

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set up the force field parameters for FF%ISTART=0

          SUBROUTINE SET_FF_PAR_ISTART0
            IMPLICIT NONE
! Set size parameters for the design matrices
            CALL SET_SIZE_OF_DESIGN_MATRIX_ISTART0
! Set force field parameters that do not change during the iterations.
            CALL SET_FF_PAR_NON_ARRAY_ISTART0
! Set variable sizes for arrays
            CALL ALLOCATE_FFARRAY3_SET_VARIABLES(PAR_SUP_HANDLE,MLSHM,FF,FFM)
! Allocate arrays.
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY3_DO_ALLOCATIONS(PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM)
            ENDIF
! Set arrays storing the force field parameters.
            CALL SET_FF_PAR_ARRAY_ISTART0
          END SUBROUTINE SET_FF_PAR_ISTART0
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set size of the design matrices.

          SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART0
            IMPLICIT NONE
! Start profiling.
            PROFILING_START('set_size_design_matrix_istart0')
! Set sizes.
            IF (TAG_LIST%GET_STATE("ML_MCONF") == TL_DEFAULT .OR. &
                TAG_LIST%GET_STATE("ML_MCONF") == TL_OVERRIDE) THEN
               FF%MCONF=MIN(MAX(1,FF%NSW),ML_MCONF_DEFAULT)
            ENDIF
            FFM%MDATA=0
            FFM%MDATA_ALLOCATE=0
            IF(.NOT.FF%LMLONLY) THEN
               IF(FF%LMLMB) THEN
                  FFM%MDATA=FFM%MDATA+(3*NIONS_NEW+7)*FF%MCONF
                  IF (ISTART_FF.EQ.3) THEN
                     FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*FF%MIONS_ALLOCATE+7)*FF%MCONF
                  ELSE
                     FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*NIONS_NEW+7)*FF%MCONF
                  ENDIF
               ENDIF
            ENDIF
            FFM%MDATA_NEW=(3*NIONS_NEW+7)*FF%MCONF_NEW
            IF (ISTART_FF.EQ.3) THEN
               FFM%MDATA_NEW_ALLOCATE=(3*FF%MIONS_ALLOCATE+7)*FF%MCONF_NEW
            ELSE
               FFM%MDATA_NEW_ALLOCATE=FFM%MDATA_NEW
            ENDIF
! Stop profiling.
            PROFILING_STOP('set_size_design_matrix_istart0')
          END SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART0
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set FF parameters.

          SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART0
            IMPLICIT NONE
! Start profiling.
            PROFILING_START('set_ff_par_istart0')
! Set logical variables that control the necessity of operations.
            FF%IFF        =.FALSE.
            FF%LTHRESHOLD =.FALSE.
            FF%LDOUB      =.FALSE.
            FF%LFMAT      =.FALSE.
            FF%LGENFF     =.FALSE.
            FF%LLIST      =.TRUE.
            FF%LLIST_NEW  =.TRUE.
            FF%LOVER      =.FALSE.
            FF%LPS        =.FALSE.
            FF%LSAMPLE    =.TRUE.
            FF%LSIG       =.FALSE.
            FF%LSOAP      =.FALSE.
! Set size variables.
! Set sizes of arrays related to descriptors. For the radial descriptors.
            IF(FFM%W1.GT.0.0_q) THEN
               FFM%MMVAR1=FFM%MRB1*FF%MTYP
               FFM%MMVAR1_ALLOCATE=FFM%MRB1*FF%MTYP_ALLOCATE
            ENDIF
! Set sizes of arrays related to descriptors. For the angular descriptors.
            IF(FFM%W2.GT.0.0_q) THEN
               IF (FFM%DESC_TYPE.EQ.0) THEN
                  FFM%MMVAR2=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP**2
                  FFM%MMVAR2_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE**2
                  IF(FFM%LSIC) THEN
                     FFM%MMVAR2_SIC=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP
                     FFM%MMVAR2_SIC_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE
                  ENDIF
               ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
                  FFM%MMVAR2=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP
                  FFM%MMVAR2_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE
               ENDIF
            ENDIF
! Set FF parameters that are the same in all situations.
            CALL SET_FF_PAR_NON_ARRAY_COMMON(TAG_LIST,FF,FFM,NIONS_NEW,ISTART_FF,LALLOCATE_ARRAYS,NITYP_NEW,NTYP_NEW)
! Stop profiling.
            PROFILING_STOP('set_ff_par_istart0')
          END SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART0
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set FF array parameters.

          SUBROUTINE SET_FF_PAR_ARRAY_ISTART0
            IMPLICIT NONE
! Local variables
            INTEGER :: INTYP0
            INTEGER :: IRB
            INTEGER :: JJNTYP0
            INTEGER :: JNTYP0
            INTEGER :: JRB
            INTEGER :: L
! Start profiling.
            PROFILING_START('set_ff_par_array_istart0')
! Set FF array parameters that are the same in all situations.
            CALL SET_FF_PAR_ARRAY_COMMON(FF,FFM,MEM1,ERR1,ERR2)
! Set FF array parameters specific for FF%ISTART=0
! Initialization of the numbers and lists of basis sets.
            IF(FF%LMLMB) THEN
               FFM%NBTOT=0
               FFM%NBTOT_NEW=0
               FFM%LBHEAD=0
               FFM%NB=0
            ENDIF
! Initialization of variance parameters for regressions.
            IF(FF%LMLMB) THEN
               FFM%SIG(1:10)=0.0_q
               IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
                  FFM%SIG_SYS=0.0_q
               ENDIF
               FFM%SIGV=0.0_q
               FFM%SIGW=0.0_q
            ENDIF
! Determination of the numbers of variables related to the radial descriptor.
            IF(FFM%W1.GT.0.0_q) THEN
               FFM%NNVAR1=FFM%MRB1*FF%MTYP
               FFM%NNVAR1_ALLOCATE=FFM%MRB1*FF%MTYP_ALLOCATE
            ENDIF
! Determination of the numbers of variables related to the angular descriptor.
            IF(FFM%W2.GT.0.0_q) THEN
               FFM%NNVAR2=0
               FFM%LVAR=0
               FFM%LFLAG_VAR=.FALSE.
               FFM%WVAR=0.0_q
               IF(FFM%LSIC) THEN
                  FFM%NNVAR2_SIC=0
                  FFM%LVAR_SIC=0
                  FFM%LFLAG_VAR_SIC=.FALSE.
               ENDIF
               IF (FFM%DESC_TYPE.EQ.0) THEN
                  DO INTYP0=1, FF%MTYP
                     DO JNTYP0=1, FF%MTYP
                        DO JJNTYP0=1, FF%MTYP
                           DO L=0, FFM%LMAX2
                              DO IRB=1, FFM%NRB2(L)
                                 DO JRB=IRB, FFM%NRB2(L)
                                    FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                    FFM%LVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                    FFM%LFLAG_VAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=.TRUE.
                                    IF(JRB.EQ.IRB) THEN
                                       FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=1.0_q
                                    ELSE
                                       FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=SQRT(2.0_q)
                                    ENDIF
                                    IF(FFM%LSIC) THEN
                                       IF(JJNTYP0.EQ.JNTYP0) THEN
                                          FFM%NNVAR2_SIC(INTYP0)=FFM%NNVAR2_SIC(INTYP0)+1
                                          FFM%LVAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=FFM%NNVAR2_SIC(INTYP0)
                                          FFM%LFLAG_VAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=.TRUE.
                                       ENDIF
                                    ENDIF
                                 ENDDO
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
                  DO INTYP0=1, FF%MTYP
                     DO JNTYP0=1, FF%MTYP
                        DO L=0, FFM%LMAX2
                           DO IRB=1, FFM%NRB2(L)
                              DO JRB=IRB, FFM%NRB2(L)
                                 FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                 FFM%LVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                 FFM%LFLAG_VAR(JRB,IRB,L,1,JNTYP0,INTYP0)=.TRUE.
                                 IF(JRB.EQ.IRB) THEN
                                    FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=1.0_q
                                 ELSE
                                    FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=SQRT(2.0_q)
                                 ENDIF
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDIF
            ENDIF
! Stop profiling.
            PROFILING_STOP('set_ff_par_array_istart0')
          END SUBROUTINE SET_FF_PAR_ARRAY_ISTART0


#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set the force field parameters for the case of FF%ISTART=1.

          SUBROUTINE SET_FF_PAR_ISTART1
            IMPLICIT NONE
! Set size parameters for the design matrices
            CALL SET_SIZE_OF_DESIGN_MATRIX_ISTART1
! Set force field parameters that do not change during the iterations.
            CALL SET_FF_PAR_NON_ARRAY_ISTART1
! Set variable sizes for arrays
            CALL ALLOCATE_FFARRAY3_SET_VARIABLES(PAR_SUP_HANDLE,MLSHM,FF,FFM)
! Allocate arrays.
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY3_DO_ALLOCATIONS(PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM)
            ENDIF
! Set arrays storing the force field parameters.
            CALL SET_FF_PAR_ARRAY_ISTART1
          END SUBROUTINE SET_FF_PAR_ISTART1
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set size of training data

          SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART1
            IMPLICIT NONE
! Start profiling
            PROFILING_START('set_size_design_matrix_istart1')
! Set the maximum numbers of the candidates of the structure datasets.
            IF (TAG_LIST%GET_STATE("ML_MCONF") == TL_DEFAULT .OR. &
                TAG_LIST%GET_STATE("ML_MCONF") == TL_OVERRIDE) THEN
               FF%MCONF=FF%MCONF+MIN(MAX(FF%NSW,1),ML_MCONF_DEFAULT)
            ENDIF
            IF(FF%LMLMB) THEN
               FFM%MDATA_NEW=(3*NIONS_NEW+7)*FF%MCONF_NEW
               FFM%MDATA_NEW_ALLOCATE=FFM%MDATA_NEW 
            ENDIF
! Read the size parameters in ABCAR file.
            CALL READ_ABCAR_SIZE1 (AB_HELP,FF%LMLMB,FFM%MDATA,FF%MTYP,NCONF)
! Set size of FFM%MDATA_ALLOCATE
            FFM%MDATA_ALLOCATE=0
            FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*FF%MIONS_ALLOCATE+7)*NCONF
! Calculate the number of upcoming training data.
! If FF%LMLONLY=.FALSE., training will be executed.
! Therefore, the number of data needs to have mergin to accept the
! candidates of new training data.
            IF(.NOT.FF%LMLONLY) THEN
               IF(FF%LMLMB) THEN
                  FFM%MDATA=FFM%MDATA+(3*NIONS_NEW+7)*(FF%MCONF+FF%MCONF_NEW-NCONF)
                  IF (ISTART_FF.EQ.3) THEN
                     FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*FF%MIONS_ALLOCATE+7)*(FF%MCONF+FF%MCONF_NEW-NCONF)
                  ELSE
                     FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*NIONS_NEW+7)*(FF%MCONF+FF%MCONF_NEW-NCONF)
                  ENDIF
               ENDIF
            ENDIF
! Stop profiling
            PROFILING_STOP('set_size_design_matrix_istart1')
          END SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART1
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set non-arrayed FF parameters.

          SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART1
            IMPLICIT NONE
! Start profiling.
            PROFILING_START('set_ff_par_non_array_istart1')
! Set logical variables that control the necessity of operations.
            FF%IFF        =.FALSE.
            FF%LTHRESHOLD =.FALSE.
            FF%LDOUB      =.FALSE.
            FF%LFMAT      =.TRUE.
            FF%LGENFF     =.TRUE.
            FF%LLIST      =.TRUE.
            FF%LLIST_NEW  =.TRUE.
            FF%LOVER      =.TRUE.
            FF%LPS        =.TRUE.
            FF%LSAMPLE    =.TRUE.
            FF%LSIG       =.TRUE.
            FF%LSOAP      =.TRUE.
! Set size variables.
! Set sizes of arrays related to descriptors. For the radial descriptors.
            IF(FFM%W1.GT.0.0_q) THEN
               FFM%MMVAR1=FFM%MRB1*FF%MTYP
               FFM%MMVAR1_ALLOCATE=FFM%MRB1*FF%MTYP_ALLOCATE
            ENDIF
! Set sizes of arrays related to descriptors. For the angular descriptors.
            IF(FFM%W2.GT.0.0_q) THEN
               IF (FFM%DESC_TYPE.EQ.0) THEN
                  FFM%MMVAR2=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP**2
                  FFM%MMVAR2_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE**2
                  IF(FFM%LSIC) THEN
                     FFM%MMVAR2_SIC=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP
                     FFM%MMVAR2_SIC_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE
                  ENDIF
               ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
                  FFM%MMVAR2=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP
                  FFM%MMVAR2_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE
               ENDIF
            ENDIF
! Initialization of variance parameters for regressions.
            FFM%SIG(1:10)=0.0_q
            IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
               IF(FF%LMLMB) THEN
                  FFM%SIG_SYS=0.0_q
               ENDIF
            ENDIF
            FFM%SIGV=0.0_q
            FFM%SIGW=0.0_q
! Set FF parameters that are the same in all situations.
            CALL SET_FF_PAR_NON_ARRAY_COMMON(TAG_LIST,FF,FFM,NIONS_NEW,ISTART_FF,LALLOCATE_ARRAYS,NITYP_NEW,NTYP_NEW)
! Stop profiling.
            PROFILING_STOP('set_ff_par_non_array_istart1')
          END SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART1
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set arrayed force field parameters for the case of FF%ISTART=1.

          SUBROUTINE SET_FF_PAR_ARRAY_ISTART1
            IMPLICIT NONE
! Local variables
            INTEGER :: INTYP0
            INTEGER :: IRB
            INTEGER :: JJNTYP0
            INTEGER :: JNTYP0
            INTEGER :: JRB
            INTEGER :: L
! Set FF array parameters that are the same in all situations.
            CALL SET_FF_PAR_ARRAY_COMMON(FF,FFM,MEM1,ERR1,ERR2)
! Set FF array parameters specific for FF%ISTART=1
             FFM%NBTOT=0
             DO INTYP0=1, FF%MTYP
                FFM%NBTOT=FFM%NBTOT+FFM%NB(INTYP0)
             ENDDO
             FFM%LBHEAD(1)=0
             DO INTYP0=2, FF%MTYP
                FFM%LBHEAD(INTYP0)=FFM%LBHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
             ENDDO
! Determination of the numbers of variables related to the radial descriptor.
            IF(FFM%W1.GT.0.0_q) THEN
               FFM%NNVAR1=FFM%MRB1*FF%MTYP
            ENDIF
! Determination of the numbers of variables related to the angular descriptor.
            IF(FFM%W2.GT.0.0_q) THEN
               FFM%NNVAR2=0
               FFM%LVAR=0
               FFM%LFLAG_VAR=.FALSE.
               FFM%WVAR=0.0_q
               IF(FFM%LSIC) THEN
                  FFM%NNVAR2_SIC=0
                  FFM%LVAR_SIC=0
                  FFM%LFLAG_VAR_SIC=.FALSE.
               ENDIF
               IF (FFM%DESC_TYPE.EQ.0) THEN
                  DO INTYP0=1, FF%MTYP
                     DO JNTYP0=1, FF%MTYP
                        DO JJNTYP0=1, FF%MTYP
                           DO L=0, FFM%LMAX2
                              DO IRB=1, FFM%NRB2(L)
                                 DO JRB=IRB, FFM%NRB2(L)
                                    FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                    FFM%LVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                    FFM%LFLAG_VAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=.TRUE.
                                    IF(JRB.EQ.IRB) THEN
                                       FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=1.0_q
                                    ELSE
                                       FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=SQRT(2.0_q)
                                    ENDIF
                                    IF(FFM%LSIC) THEN
                                       IF(JJNTYP0.EQ.JNTYP0) THEN
                                          FFM%NNVAR2_SIC(INTYP0)=FFM%NNVAR2_SIC(INTYP0)+1
                                          FFM%LVAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=FFM%NNVAR2_SIC(INTYP0)
                                          FFM%LFLAG_VAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=.TRUE.
                                       ENDIF
                                    ENDIF
                                 ENDDO
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
                  DO INTYP0=1, FF%MTYP
                     DO JNTYP0=1, FF%MTYP
                        DO L=0, FFM%LMAX2
                           DO IRB=1, FFM%NRB2(L)
                              DO JRB=IRB, FFM%NRB2(L)
                                 FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                 FFM%LVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                 FFM%LFLAG_VAR(JRB,IRB,L,1,JNTYP0,INTYP0)=.TRUE.
                                 IF(JRB.EQ.IRB) THEN
                                    FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=1.0_q
                                 ELSE
                                    FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=SQRT(2.0_q)
                                 ENDIF
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDIF
            ENDIF
          END SUBROUTINE SET_FF_PAR_ARRAY_ISTART1
#endif

! Subroutine to set the force field parameters for the case of FF%ISTART=2.

          SUBROUTINE SET_FF_PAR_ISTART2
            IMPLICIT NONE
! Local variables
            INTEGER :: ISYS_NEW
! Read FFCAR file and overwrite the FF parameter read from the INCAR file.
            IF (FF%ML_FF_BINARY) THEN
               CALL OVERWRITE_FF_PAR_BY_PAR_IN_FFCAR (TAG_LIST,FF,FFM)
            ELSE
               CALL OVERWRITE_FF_PAR_BY_PAR_IN_FFCAR_NON_BINARY (TAG_LIST,FF,FFM)
            ENDIF
            IF (FFM%LSIC) THEN
               FF%LFAST=.FALSE.
            ELSE
               IF (FF%LFORCESLOW) THEN
                  FF%LFAST=.FALSE.
               ELSE
                  FF%LFAST=.TRUE.
               ENDIF
            ENDIF
            IF (FFM%LSIC .AND. FFM%DESC_TYPE>0) THEN
               CALL ml_tutor%error("ML_DESC_TYPE only available &
                    &for fast descriptor (ML_LFAST=.TRUE.).")
            ENDIF
            IF (.NOT.FFM%LSIC .AND. FF%IERR.GT.0) THEN
               CALL ml_tutor%error("Bayesian error estimation not available for &
                  &force field trained with ML_LFAST=.TRUE.")
            ENDIF
! Set size parameters for the design matrices
            CALL SET_SIZE_OF_DESIGN_MATRIX_ISTART2
! Set force field parameters that do not change during the iterations.
            CALL SET_FF_PAR_NON_ARRAY_ISTART2
! We need to set here the variables for allocation
            FFM%MMVAR1_ALLOCATE=FFM%MMVAR1
            FFM%MMVAR2_ALLOCATE=FFM%MMVAR2
            FFM%MMVAR2_SIC_ALLOCATE=FFM%MMVAR2_SIC
! We need to set MCONF here to 1 to have the right output
            FF%MCONF=1
! Set variable sizes for arrays
            CALL ALLOCATE_FFARRAY3_SET_VARIABLES(PAR_SUP_HANDLE,MLSHM,FF,FFM)
! Allocate arrays.
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY3_DO_ALLOCATIONS(PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM)
            ENDIF
! Set arrays storing the force field parameters.
            CALL SET_FF_PAR_ARRAY_ISTART2
! Read FFCAR file.
            ISYS_NEW = 1
            IF (FF%ML_FF_BINARY) THEN
               CALL READ_FFCAR (FF,FFM,PAR_SUP_HANDLE,ISYS_NEW)
            ELSE
               CALL READ_FFCAR_NON_BINARY (FF,FFM,PAR_SUP_HANDLE,ISYS_NEW)
            ENDIF
          END SUBROUTINE SET_FF_PAR_ISTART2

! Subroutine to set size of training data

          SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART2
            IMPLICIT NONE
! Start profiling
            PROFILING_START('set_size_design_matrix_istart1or2')
! Set the maximum numbers of the candidates of the structure datasets.
            FF%MCONF=FF%MCONF+1 !FF%MCONF_NEW 
            IF(FF%LMLMB) THEN
               FFM%MDATA_NEW=(3*NIONS_NEW+7)*FF%MCONF_NEW
               FFM%MDATA_NEW_ALLOCATE=FFM%MDATA_NEW 
            ENDIF
! FFM%MDATA is not used in if FF%ISTART=2 (hence no learning is executed)
            FFM%MDATA = 3*NIONS_NEW+7
            IF (ISTART_FF.EQ.3) THEN
               FFM%MDATA_ALLOCATE = 3*FF%MIONS_ALLOCATE+7
            ELSE
               FFM%MDATA_ALLOCATE = 3*NIONS_NEW+7
            ENDIF
! Stop profiling
            PROFILING_STOP('set_size_design_matrix_istart1or2')
          END SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART2

! Subroutine to set non-arrayed force field parameters for the case of FF%ISTART=2.

          SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART2
            IMPLICIT NONE
! Set logical parameters.
            FF%IFF        =.TRUE.
            FF%LTHRESHOLD =.FALSE.
            FF%LDOUB      =.FALSE.
            FF%LFMAT      =.FALSE.
            FF%LGENFF     =.FALSE.
            FF%LLIST      =.FALSE.
            FF%LLIST_NEW  =.TRUE.
            FF%LOVER      =.FALSE.
            FF%LPS        =.FALSE.
            FF%LSAMPLE    =.FALSE.
            FF%LSIG       =.FALSE.
            FF%LSOAP      =.FALSE.
! Set FF parameters that are the same in all situations.
            CALL SET_FF_PAR_NON_ARRAY_COMMON(TAG_LIST,FF,FFM,NIONS_NEW,ISTART_FF,LALLOCATE_ARRAYS,NITYP_NEW,NTYP_NEW)
          END SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART2

! Subroutine to set arrayed force field parameters for the case of FF%ISTART=2.

          SUBROUTINE SET_FF_PAR_ARRAY_ISTART2
            IMPLICIT NONE
! Local variables
            INTEGER :: INTYP0
! Set FF array parameters that are the same in all situations.
            CALL SET_FF_PAR_ARRAY_COMMON(FF,FFM,MEM1,ERR1,ERR2)
! Set FF array parameters specific for FF%ISTART=1
            FFM%NBTOT=0
            DO INTYP0=1, FF%MTYP
               FFM%NBTOT=FFM%NBTOT+FFM%NB(INTYP0)
            ENDDO
            FFM%LBHEAD(1)=0
            DO INTYP0=2, FF%MTYP
               FFM%LBHEAD(INTYP0)=FFM%LBHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
            ENDDO
          END SUBROUTINE SET_FF_PAR_ARRAY_ISTART2

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set the force field parameters for the case of FF%ISTART=1.

          SUBROUTINE SET_FF_PAR_ISTART3
            IMPLICIT NONE
! Set size parameters for the design matrices
            CALL SET_SIZE_OF_DESIGN_MATRIX_ISTART3
! Set force field parameters that do not change during the iterations.
            CALL SET_FF_PAR_NON_ARRAY_ISTART3
! Set variable sizes for arrays
            CALL ALLOCATE_FFARRAY3_SET_VARIABLES(PAR_SUP_HANDLE,MLSHM,FF,FFM)
! Allocate arrays.
            IF (LALLOCATE_ARRAYS) THEN
               CALL ALLOCATE_FFARRAY3_DO_ALLOCATIONS(PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM)
            ENDIF
! Set arrays storing the force field parameters.
            CALL SET_FF_PAR_ARRAY_ISTART3
          END SUBROUTINE SET_FF_PAR_ISTART3
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set size of training data

          SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART3
            IMPLICIT NONE
! Start profiling
            PROFILING_START('set_size_design_matrix_istart3')
! Set the maximum numbers of the candidates of the structure datasets.
            IF (TAG_LIST%GET_STATE("ML_MCONF") == TL_DEFAULT .OR. &
                TAG_LIST%GET_STATE("ML_MCONF") == TL_OVERRIDE) THEN
               FF%MCONF=FF%MCONF+1 !FF%MCONF_NEW
            ENDIF
            IF(FF%LMLMB) THEN
               ! FFM%MDATA_NEW needs to be set at every step of the database sweep
               FFM%MDATA_NEW=(3*FF%MIONS+7)*FF%MCONF_NEW
               FFM%MDATA_NEW_ALLOCATE=(3*FF%MIONS_ALLOCATE+7)*FF%MCONF_NEW
            ENDIF
! Read the size parameters in ABCAR file.
            CALL READ_ABCAR_SIZE1 (AB_HELP,FF%LMLMB,FFM%MDATA,FF%MTYP,NCONF)
! Set size of FFM%MDATA_ALLOCATE
!            FFM%MDATA_ALLOCATE=0
!            FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*FF%MIONS_ALLOCATE+7)*NCONF
            FFM%MDATA_ALLOCATE=FFM%MDATA
! Calculate the number of upcoming training data.
! If FF%LMLONLY=.FALSE., training will be executed.
! Therefore, the number of data needs to have mergin to accept the
! candidates of new training data.
            IF(.NOT.FF%LMLONLY) THEN
               IF(FF%LMLMB) THEN
                  FFM%MDATA=FFM%MDATA+(3*FF%MIONS+7) !*(FF%MCONF+FF%MCONF_NEW-NCONF)
!                  FFM%MDATA_ALLOCATE=FFM%MDATA_ALLOCATE+(3*FF%MIONS_ALLOCATE+7)*(FF%MCONF+FF%MCONF_NEW-NCONF)
                  FFM%MDATA_ALLOCATE=FFM%MDATA
               ENDIF
            ENDIF
! Stop profiling
            PROFILING_STOP('set_size_design_matrix_istart3')
          END SUBROUTINE SET_SIZE_OF_DESIGN_MATRIX_ISTART3
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set non-arrayed FF parameters.

          SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART3
            IMPLICIT NONE
! Start profiling.
            PROFILING_START('set_ff_par_non_array_istart3')
! Set logical variables that control the necessity of operations.
            FF%IFF        =.FALSE.
            FF%LTHRESHOLD =.FALSE.
            FF%LDOUB      =.FALSE.
            FF%LFMAT      =.TRUE.
            FF%LGENFF     =.TRUE.
            FF%LLIST      =.TRUE.
            FF%LLIST_NEW  =.TRUE.
            FF%LOVER      =.TRUE.
            FF%LPS        =.TRUE.
            FF%LSAMPLE    =.TRUE.
            FF%LSIG       =.TRUE.
            FF%LSOAP      =.TRUE.
! Set size variables.
! Set sizes of arrays related to descriptors. For the radial descriptors.
            IF(FFM%W1.GT.0.0_q) THEN
               FFM%MMVAR1=FFM%MRB1*FF%MTYP
               FFM%MMVAR1_ALLOCATE=FFM%MRB1*FF%MTYP_ALLOCATE
            ENDIF
! Set sizes of arrays related to descriptors. For the angular descriptors.
            IF(FFM%W2.GT.0.0_q) THEN
               IF (FFM%DESC_TYPE.EQ.0) THEN
                  FFM%MMVAR2=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP**2
                  FFM%MMVAR2_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE**2
                  IF(FFM%LSIC) THEN
                     FFM%MMVAR2_SIC=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP
                     FFM%MMVAR2_SIC_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE
                  ENDIF
               ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
                  FFM%MMVAR2=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP
                  FFM%MMVAR2_ALLOCATE=FFM%MRB2*(FFM%MRB2+1)/2*(FFM%LMAX2+1)*FF%MTYP_ALLOCATE
               ENDIF
            ENDIF
! Initialization of variance parameters for regressions.
            FFM%SIG(1:10)=0.0_q
            IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
               IF(FF%LMLMB) THEN
                  FFM%SIG_SYS=0.0_q
               ENDIF
            ENDIF
            FFM%SIGV=0.0_q
            FFM%SIGW=0.0_q
! Set FF parameters that are the same in all situations.
            CALL SET_FF_PAR_NON_ARRAY_COMMON(TAG_LIST,FF,FFM,NIONS_NEW,ISTART_FF,LALLOCATE_ARRAYS,NITYP_NEW,NTYP_NEW)
! Stop profiling.
            PROFILING_STOP('set_ff_par_non_array_istart3')
          END SUBROUTINE SET_FF_PAR_NON_ARRAY_ISTART3
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to set arrayed force field parameters for the case of FF%ISTART=1.

          SUBROUTINE SET_FF_PAR_ARRAY_ISTART3
            IMPLICIT NONE
! Local variables
            INTEGER :: INTYP0
            INTEGER :: IRB
            INTEGER :: JJNTYP0
            INTEGER :: JNTYP0
            INTEGER :: JRB
            INTEGER :: L
! Set FF array parameters that are the same in all situations.
            CALL SET_FF_PAR_ARRAY_COMMON(FF,FFM,MEM1,ERR1,ERR2)
! Set FF array parameters specific for FF%ISTART=1
             FFM%NBTOT=0
             DO INTYP0=1, FF%MTYP
                FFM%NBTOT=FFM%NBTOT+FFM%NB(INTYP0)
             ENDDO
             FFM%LBHEAD(1)=0
             DO INTYP0=2, FF%MTYP
                FFM%LBHEAD(INTYP0)=FFM%LBHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
             ENDDO
! Determination of the numbers of variables related to the radial descriptor.
            IF(FFM%W1.GT.0.0_q) THEN
               FFM%NNVAR1=FFM%MRB1*FF%MTYP
            ENDIF
! Determination of the numbers of variables related to the angular descriptor.
            IF(FFM%W2.GT.0.0_q) THEN
               FFM%NNVAR2=0
               FFM%LVAR=0
               FFM%LFLAG_VAR=.FALSE.
               FFM%WVAR=0.0_q
               IF(FFM%LSIC) THEN
                  FFM%NNVAR2_SIC=0
                  FFM%LVAR_SIC=0
                  FFM%LFLAG_VAR_SIC=.FALSE.
               ENDIF
               IF (FFM%DESC_TYPE.EQ.0) THEN
                  DO INTYP0=1, FF%MTYP
                     DO JNTYP0=1, FF%MTYP
                        DO JJNTYP0=1, FF%MTYP
                           DO L=0, FFM%LMAX2
                              DO IRB=1, FFM%NRB2(L)
                                 DO JRB=IRB, FFM%NRB2(L)
                                    FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                    FFM%LVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                    FFM%LFLAG_VAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=.TRUE.
                                    IF(JRB.EQ.IRB) THEN
                                       FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=1.0_q
                                    ELSE
                                       FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=SQRT(2.0_q)
                                    ENDIF
                                    IF(FFM%LSIC) THEN
                                       IF(JJNTYP0.EQ.JNTYP0) THEN
                                          FFM%NNVAR2_SIC(INTYP0)=FFM%NNVAR2_SIC(INTYP0)+1
                                          FFM%LVAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=FFM%NNVAR2_SIC(INTYP0)
                                          FFM%LFLAG_VAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=.TRUE.
                                       ENDIF
                                    ENDIF
                                 ENDDO
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
                  DO INTYP0=1, FF%MTYP
                     DO JNTYP0=1, FF%MTYP
                        DO L=0, FFM%LMAX2
                           DO IRB=1, FFM%NRB2(L)
                              DO JRB=IRB, FFM%NRB2(L)
                                 FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                 FFM%LVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                 FFM%LFLAG_VAR(JRB,IRB,L,1,JNTYP0,INTYP0)=.TRUE.
                                 IF(JRB.EQ.IRB) THEN
                                    FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=1.0_q
                                 ELSE
                                    FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=SQRT(2.0_q)
                                 ENDIF
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDIF
            ENDIF
          END SUBROUTINE SET_FF_PAR_ARRAY_ISTART3
#endif


        END SUBROUTINE SET_FF_PAR

! Subroutine to set FF parameters that are the same in all situations.

        SUBROUTINE SET_FF_PAR_NON_ARRAY_COMMON(TAG_LIST,FF,FFM,NIONS_NEW,ISTART_FF,LALLOCATE_ARRAYS,NITYP_NEW,NTYP_NEW)
          USE ATOM_DATA
          USE ML_FF_CONSTANT
          USE ML_FF_TAGLIST
          USE ML_FF_STRUCT, ONLY: TIME, PARALLEL_SUPER, ML_SHMEM, MEMORY, LOG_PAR, FF_PAR, FFM_PAR, ML_MB_DEFAULT
          IMPLICIT NONE
! Input variables
          TYPE (TAGLIST), INTENT(INOUT) :: TAG_LIST
          TYPE (FF_PAR)        :: FF
          TYPE (FFM_PAR)       :: FFM
          INTEGER,  INTENT(IN) :: NIONS_NEW
          INTEGER,  INTENT(IN) :: ISTART_FF
          LOGICAL,  INTENT(IN) :: LALLOCATE_ARRAYS
          INTEGER,  INTENT(IN) :: NITYP_NEW(:)
          INTEGER,  INTENT(IN) :: NTYP_NEW
! Local variables
          INTEGER              :: INTYP
          INTEGER              :: MITYP_NEW
          INTEGER              :: NSW_HELP
! Initialize logging control variables to .FALSE.
          FF%LLOG_THRESHOLD_HISTORY = .FALSE.
          FF%LLOG_THRESHOLD_UPDATE = .FALSE.
! Set many-body variables.
          IF(FF%LMLMB) THEN
! Set maximum number of atoms per each element type.
             IF (ISTART_FF.EQ.3) THEN
                MITYP_NEW=FF%MITYP_ALLOCATE
             ELSE
                MITYP_NEW=NITYP_NEW(1)
                DO INTYP=2, NTYP_NEW
                   MITYP_NEW=MAX(MITYP_NEW,NITYP_NEW(INTYP))
                ENDDO
             ENDIF
! If FF%LMLONLY=.FALSE., add the number of basis set candidates to the original FFM%MB to allow the machine to store the candidates temporally.
             IF (TAG_LIST%GET_STATE("ML_MB") == TL_DEFAULT .OR. &
                 TAG_LIST%GET_STATE("ML_MB") == TL_OVERRIDE) THEN
                IF (FF%NSW<2*FF%MCONF_NEW) THEN
                   NSW_HELP=2*FF%MCONF_NEW
                ELSE
                   NSW_HELP=FF%NSW
                ENDIF
                IF (ISTART_FF.EQ.0) THEN
                   FFM%MB=MIN(NSW_HELP*MITYP_NEW,ML_MB_DEFAULT)
                ELSE IF (ISTART_FF.EQ.1) THEN
                   FFM%MB=FFM%MB + MIN(NSW_HELP*MITYP_NEW,ML_MB_DEFAULT)
                ELSE IF (ISTART_FF.EQ.2) THEN
                   FFM%MB=FFM%MB
                ELSE IF (ISTART_FF.EQ.3) THEN
                   FFM%MB=FFM%MB + MITYP_NEW*FF%MCONF_NEW
                ELSE IF (ISTART_FF.EQ.4) THEN
                   FFM%MB=FFM%MB + MITYP_NEW
                ENDIF
                FFM%MB_TARGET=FFM%MB
             ENDIF
! Set size of ML_MB further
             IF (ISTART_FF.EQ.0 .OR. ISTART_FF.EQ.1) THEN
                FFM%MB=FFM%MB+MIN(FF%NSW,FF%MCONF_NEW)*MITYP_NEW
             ELSE IF (ISTART_FF.EQ.2) THEN
                FFM%MB=FFM%MB
             ELSE IF (ISTART_FF.EQ.3) THEN
                FFM%MB=FFM%MB+FF%MCONF_NEW*MITYP_NEW
             ELSE IF (ISTART_FF.EQ.4) THEN
                FFM%MB=FFM%MB+MITYP_NEW
             ENDIF
             FFM%MB_ALLOCATE=FFM%MB
!! We need to set the maximum size for FFM%MB by FFM%MB_ALLOCATE (relevant for FF%ISTART=3)
!             IF (ISTART_FF.EQ.3) THEN
!                FFM%MB_ALLOCATE=FFM%MB_INPUT+FF%MITYP_ALLOCATE*FF%MCONF_NEW
!             ELSE
!                FFM%MB_ALLOCATE=FFM%MB_INPUT+MITYP_NEW*FF%MCONF_NEW
!             ENDIF
! Set the number of basis set candidates as MITYP_NEW*FF%MCONF_NEW.
             FFM%MB_NEW=MITYP_NEW*FF%MCONF_NEW
! Set the maximum total number of basis sets.
             FFM%MBTOT=FF%MTYP*FFM%MB
             FFM%MBTOT_ALLOCATE=FF%MTYP_ALLOCATE*FFM%MB_ALLOCATE
! Set the maximum total number of basis set candidates.
             FFM%MBTOT_NEW=NIONS_NEW*FF%MCONF_NEW
! Set sizes of arrays related to descriptors. For the radial descriptors.
             IF(FFM%W1.GT.0.0_q) THEN
                FFM%MLNRB1=FFM%MRB1*(FFM%LMAX1+1)
                FFM%MLNR1 =FFM%NR1 *(FFM%LMAX1+1)
             ENDIF
! Set sizes of arrays related to descriptors. For the angular descriptors.
             IF(FFM%W2.GT.0.0_q) THEN
                FFM%MLNRB2=FFM%MRB2*(FFM%LMAX2+1)
                FFM%MLNR2 =FFM%NR2 *(FFM%LMAX2+1)
             ENDIF
! Set the increment for radial mesh for the radial descriptor.
             IF(FFM%W1.GT.0.0_q) THEN
! If the variable transform is introduced, the equispaced numerical radial grid is set over R^NMETRIC.
                IF(FFM%LVARTRAN1) THEN
                   FFM%DR1=1.0_q/REAL(FFM%NR1,q)
! Otherwise, the equispaced numerical radial grid is set over R.
                ELSE
                   FFM%DR1=FFM%RCUT1/REAL(FFM%NR1,q)
                ENDIF
             ENDIF
! Set the increment for radial mesh for the radial descriptor.
             IF(FFM%W2.GT.0.0_q) THEN
! If metric is introduced, the equispaced numerical radial grid is set over R^NMETRIC.
                IF(FFM%LVARTRAN2) THEN
                   FFM%DR2=1.0_q/REAL(FFM%NR2,q)
! Otherwise, the equispaced numerical radial grid is set over R.
                ELSE
                   FFM%DR2=FFM%RCUT2/REAL(FFM%NR2,q)
                ENDIF
             ENDIF
!TO_BE_DELETED
!! Set the increment for radial mesh.
!             IF(FFM%W1.GT.0.0_q) THEN
!! If metric is introduced, the equispaced numerical radial grid is set over R^NMETRIC.
!                IF(FFM%LVARTRAN1) THEN
!                   FFM%DR1=1.0_q/REAL(FFM%NR1,q)
! Otherwise, the equispaced numerical radial grid is set over R.
!                ELSE
!                   FFM%DR1=FFM%RCUT1/REAL(FFM%NR1,q)
!                ENDIF
!             ENDIF
!             IF(FFM%W2.GT.0.0_q) THEN
! If metric is introduced, the equispaced numerical radial grid is set over R^NMETRIC.
!                IF(FFM%LVARTRAN2) THEN
!                   FFM%DR2=1.0_q/REAL(FFM%NR2,q)
! Otherwise, the equispaced numerical radial grid is set over R.
!                ELSE
!                   FFM%DR2=FFM%RCUT2/REAL(FFM%NR2,q)
!                ENDIF
!             ENDIF
!TO_BE_DELETED
! Set the broadening widths.
! Regardless the metric, the Gaussian widths for atom distributions are defined in R-space.
! Set the Gaussian width for the radial descriptor.
             IF((FFM%W1.GT.0.0_q).AND.(FFM%IBROAD1.EQ.2)) THEN
                DO INTYP=1, FF%MTYP
                   FFM%WION1(INTYP)=FFM%SION1
                   FFM%WION1(INTYP)=5E-01_q/FFM%WION1(INTYP)**2
                ENDDO
             ELSE IF((FFM%W1.GT.0.0_q).AND.(FFM%IBROAD1.EQ.3)) THEN
                DO INTYP=1, FF%MTYP
                   CALL VDW_RADII (FF%TYPE(INTYP),FFM%WION1(INTYP))
                   FFM%WION1(INTYP)=FFM%SION1*FFM%WION1(INTYP)
                   FFM%WION1(INTYP)=5E-01_q/FFM%WION1(INTYP)**2
                ENDDO
             ENDIF
! Set the Gaussian width for the angular descriptor.
! If FFM%IBROAD2=2, set the constant width for all element types.
             IF((FFM%W2.GT.0.0_q).AND.(FFM%IBROAD2.EQ.2)) THEN
                DO INTYP=1, FF%MTYP
                   FFM%WION2(INTYP)=FFM%SION2
                   FFM%WION2(INTYP)=5E-01_q/FFM%WION2(INTYP)**2
                ENDDO
! If FFM%IBROAD=3, set the element-dependent widths.
             ELSE IF((FFM%W2.GT.0.0_q).AND.(FFM%IBROAD2.EQ.3)) THEN
                DO INTYP=1, FF%MTYP
                   CALL VDW_RADII (FF%TYPE(INTYP),FFM%WION2(INTYP))
                   FFM%WION2(INTYP)=FFM%SION2*FFM%WION2(INTYP)
                   FFM%WION2(INTYP)=5E-01_q/FFM%WION2(INTYP)**2
                ENDDO
             ENDIF
          ENDIF
        END SUBROUTINE SET_FF_PAR_NON_ARRAY_COMMON

! Subroutine to set FF array parameters that are the same in all situations.\

        SUBROUTINE SET_FF_PAR_ARRAY_COMMON(FF,FFM,MEM1,ERR1,ERR2)
          USE BASIS_SOAP
          USE RANDOM_NUMBER_GENERATOR
          USE ML_FF_CONSTANT
          USE ML_FF_STRUCT, ONLY: TIME, PARALLEL_SUPER, ML_SHMEM, MEMORY, LOG_PAR, FF_PAR, FFM_PAR
          USE ml_ff_tutor, ONLY: ml_tutor
          IMPLICIT NONE
! Input variables
          TYPE (FF_PAR)        :: FF
          TYPE (FFM_PAR)       :: FFM
          TYPE (MEMORY)        :: MEM1
! Output variables
          REAL(q), INTENT(OUT) :: ERR1 ! Error caused by radial expansions
          REAL(q), INTENT(OUT) :: ERR2 ! Error caused by radial expansions
! Local variables
          INTEGER :: INIONS
          INTEGER :: INIONS_COUPLED
          INTEGER :: INTYP 
          INTEGER :: IRB
          INTEGER :: L
          REAL(q) :: RMEM
! Set many-body parameters.
          IF(FF%LMLMB) THEN
! Set radial basis sets.
! Construct radial basis set for the radial descriptor.
             IF(FFM%W1.GT.0.0_q) THEN
                CALL RJ_RSBESSEL (FFM%DR1,FFM%FWIN1,FFM%IWINDOW1,FFM%LMAX1,FFM%LVARTRAN1,&
                     FFM%LWINDOW1,FFM%MRB1,FFM%NR1,FFM%NRB1,FFM%NVARTRAN1, &
                     FFM%QGRID1,FFM%QMAX1,FFM%RB1,FFM%RCUT1,FFM%RG1,RMEM,FFM%RNORM1,FFM%WR1)
                MEM1%RMEM(7)=RMEM
             ENDIF
! Construct radial basis set for the angular descriptor.
             IF(FFM%W2.GT.0.0_q) THEN
                CALL RJ_RSBESSEL (FFM%DR2,FFM%FWIN2,FFM%IWINDOW2,FFM%LMAX2,FFM%LVARTRAN2, &
                     FFM%LWINDOW2,FFM%MRB2,FFM%NR2,FFM%NRB2,FFM%NVARTRAN2, &
                     FFM%QGRID2,FFM%QMAX2,FFM%RB2,FFM%RCUT2,FFM%RG2,RMEM,FFM%RNORM2,FFM%WR2)
                MEM1%RMEM(7)=RMEM
             ENDIF
! Calculate the possible errors caused by the expansion of atom distributions by the radial basis sets.
! For the radial descriptor.
             IF((FFM%W1.GT.0.0_q).AND.(FFM%IBROAD1.NE.1)) THEN
                ERR1=0.0_q
                DO INTYP=1, FF%MTYP
                   CALL RAD_ERROR (FFM%DR1,ERR1,FFM%ICUT1,FFM%LMAX1,FFM%LMETRIC1,FFM%LVARTRAN1,FFM%MRB1, &
                        FFM%NMETRIC1,FFM%NR1,FFM%NRB1,FFM%NVARTRAN1,FFM%RB1,FFM%RCUT1,FFM%RMETRIC1,FFM%WION1(INTYP))
                ENDDO
             ENDIF
! For the angular descriptor.
             IF((FFM%W2.GT.0.0_q).AND.(FFM%IBROAD2.NE.1)) THEN
                ERR2=0.0_q
                DO INTYP=1, FF%MTYP
                   CALL RAD_ERROR (FFM%DR2,ERR2,FFM%ICUT2,FFM%LMAX2,FFM%LMETRIC2,FFM%LVARTRAN2,FFM%MRB2, &
                        FFM%NMETRIC2,FFM%NR2,FFM%NRB2,FFM%NVARTRAN2,FFM%RB2,FFM%RCUT2,FFM%RMETRIC2,FFM%WION2(INTYP))
                ENDDO
             ENDIF
! Spline interpolation.
             DO INTYP=1, FF%MTYP
! For the radial descriptor.
                IF(FFM%W1.GT.0.0_q) THEN
                   CALL RAD_FUNC (FFM%DR1,FFM%DRSPL1,FFM%FNL1(1:,1:,0:,1:,INTYP),FFM%IBROAD1, &
                        FFM%ICUT1,FFM%LMAX1,FFM%LMETRIC1,FFM%LVARTRAN1, &
                        FFM%MRB1,FFM%MSPL1,FFM%NMETRIC1,FFM%NR1,FFM%NRB1,FFM%NSPL1,FFM%NVARTRAN1,FFM%QGRID1,FFM%RB1,FFM%RC1, &
                        FFM%RCUT1,FFM%RG1,RMEM,FFM%RMETRIC1,FFM%RNORM1,FFM%USQ1,FFM%WION1(INTYP),FFM%WR1)
                   MEM1%RMEM(7)=MAX(MEM1%RMEM(7),RMEM)
                ENDIF
! For the angular descriptor.
                IF(FFM%W2.GT.0.0_q) THEN
                   CALL RAD_FUNC (FFM%DR2,FFM%DRSPL2,FFM%FNL2(1:,1:,0:,1:,INTYP),FFM%IBROAD2, &
                        FFM%ICUT2,FFM%LMAX2,FFM%LMETRIC2,FFM%LVARTRAN2, &
                        FFM%MRB2,FFM%MSPL2,FFM%NMETRIC2,FFM%NR2,FFM%NRB2,FFM%NSPL2,FFM%NVARTRAN2,FFM%QGRID2,FFM%RB2,FFM%RC2, &
                        FFM%RCUT2,FFM%RG2,RMEM,FFM%RMETRIC2,FFM%RNORM2,FFM%USQ2,FFM%WION2(INTYP),FFM%WR2)
                   MEM1%RMEM(7)=MAX(MEM1%RMEM(7),RMEM)
                ENDIF
             ENDDO
! Make lists necessary for calculating the descriptors.
! For the radial descriptor.
             IF(FFM%W1.GT.0.0_q) THEN
                FFM%NLNRB1=0
                DO IRB=1, FFM%MRB1
                   DO L=0, FFM%LMAX1
                      IF(IRB .LE. FFM%NRB1(L)) THEN
                         FFM%NLNRB1=FFM%NLNRB1+1
                         FFM%L_LNRB1(FFM%NLNRB1)=L
                         FFM%NRB_LNRB1(FFM%NLNRB1)=IRB
                      ENDIF
                   ENDDO
                ENDDO
             ENDIF
! For the angular descriptor.
             IF(FFM%W2.GT.0.0_q) THEN
                FFM%NLNRB2=0
                DO IRB=1, FFM%MRB2
                   DO L=0, FFM%LMAX2
                      IF(IRB .LE. FFM%NRB2(L)) THEN
                         FFM%NLNRB2=FFM%NLNRB2+1
                         FFM%L_LNRB2(FFM%NLNRB2)=L
                         FFM%NRB_LNRB2(FFM%NLNRB2)=IRB
                      ENDIF
                   ENDDO
                ENDDO
             ENDIF
! Set parameters related to the coupling used for the calculation of the chemical potential.
             FFM%RCOUPLE_IONS=1.0_q
             FFM%LIONS_COUPLE=.FALSE.
             IF(FFM%LCOUPLE) THEN
! Check here if atom index for coupled ions within thermodynamic
! integration is out of atom numbers for coupling
                DO INIONS=1, FFM%NATOM_COUPLED
                   IF (FFM%ICOUPLE(INIONS).GT.FF%MIONS) THEN
                      CALL ml_tutor%error("Atom index given via ML_ICOUPLE is &
                         &out of range.")
                   ENDIF
                ENDDO
                DO INIONS=1, FF%MIONS
                   DO INIONS_COUPLED=1, FFM%NATOM_COUPLED
                      IF(INIONS.EQ.FFM%ICOUPLE(INIONS_COUPLED)) THEN
                         FFM%RCOUPLE_IONS(INIONS)=FFM%RCOUPLE
                         FFM%LIONS_COUPLE(INIONS)=.TRUE.
                         EXIT
                      ENDIF
                   ENDDO
                ENDDO
             ENDIF
          ENDIF
        END SUBROUTINE SET_FF_PAR_ARRAY_COMMON


#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Initialize angular descriptor
!****************************************************************************************************

        SUBROUTINE INIT_PS (TIM,PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM,A,B,LADD,LNIONS,LNTYP,MCONF,MIONS,MITYP,MTYP,NCONF,NIONS,NITYP,NTYP,POSION)
          USE NEIGHBOUR
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: TIME, PARALLEL_SUPER,ML_SHMEM, MEMORY, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (TIME)           :: TIM
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (MEMORY)         :: MEM1
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          REAL(q), INTENT(IN)   :: A(:,:,:) !(1:3,1:3,1:MCONF)
          REAL(q), INTENT(IN)   :: B(:,:,:) !(1:3,1:3,1:MCONF)
          INTEGER, INTENT(IN)   :: LADD(:,:) !(1:MTYP,1:MCONF)
          INTEGER, INTENT(IN)   :: LNIONS(:,:,:) !(1:MITYP,1:MTYP,1:MCONF)
          INTEGER, INTENT(IN)   :: LNTYP(:,:) !(1:MIONS,1:MCONF)
          INTEGER, INTENT(IN)   :: MCONF
          INTEGER, INTENT(IN)   :: MIONS
          INTEGER, INTENT(IN)   :: MITYP
          INTEGER, INTENT(IN)   :: MTYP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NIONS(:) !(1:MCONF)
          INTEGER, INTENT(IN)   :: NITYP(:,:) !(1:MTYP,1:MCONF)
          INTEGER, INTENT(IN)   :: NTYP(:) !(1:MCONF)
          REAL(q), INTENT(IN)   :: POSION(:,:,:) !(1:3,1:MIONS,1:MCONF)
! Local variables
          REAL(q)               :: CPUTIM0
          REAL(q)               :: CPUTIM1
          REAL(q), ALLOCATABLE  :: C00(:,:)
          REAL(q), ALLOCATABLE  :: C00_HELP(:)
          REAL(q), ALLOCATABLE  :: C00_COUPLE(:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST1(:,:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST2(:,:)
          INTEGER               :: MCOL_C00
          INTEGER               :: MCOL_C00_COUPLE
          INTEGER               :: MCOL_CLM1
          INTEGER               :: MCOL_CLM2
          INTEGER               :: MCOL_PS
          INTEGER               :: MCOL_PS_COUPLE
          INTEGER               :: MCOL_EST1
          INTEGER               :: MCOL_EST2
          INTEGER               :: MNEIB_EST1
          INTEGER               :: MNEIB_EST2
          INTEGER               :: MROW_C00
          INTEGER               :: MROW_C00_COUPLE
          INTEGER               :: MROW_PS
          INTEGER               :: MROW_PS_COUPLE
          INTEGER               :: MROW_EST1
          INTEGER               :: MROW_EST2
          INTEGER               :: MROW_CLM1
          INTEGER               :: MROW_CLM2
          INTEGER, ALLOCATABLE  :: NNEIB_EST1(:)
          INTEGER, ALLOCATABLE  :: NNEIB_EST2(:)
          REAL(q), ALLOCATABLE  :: PS(:,:)
          REAL(q), ALLOCATABLE  :: PS_HELP(:)
          REAL(q), ALLOCATABLE  :: PS_COUPLE(:)
          REAL(q)               :: RMEM_LOC1
          REAL(q)               :: RMEM_LOC2
          REAL(q)               :: RMEM_LOC3
          REAL(q)               :: VPUTIM0
          REAL(q)               :: VPUTIM1
          REAL(q), ALLOCATABLE  :: XYZ_EST1(:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST2(:,:,:)
! Start profiling
          PROFILING_START('init_ps')
! Measure the initial times
          CALL VTIME (VPUTIM0,CPUTIM0)
! Initialize the memory usage
          CALL INIT_RMEM_INIT_PS
! Configure the size of structural data
          CALL EST_INIT_PS
! Calculate angular descriptors
          CALL PS_INIT_PS
! Count the memory usage
          CALL COUNT_RMEM_INIT_PS
! Measure the final times and add them
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(4)=TIM%CPUTIM(4)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(4)=TIM%VPUTIM(4)+VPUTIM1-VPUTIM0
! Stop profiling
          PROFILING_STOP('init_ps')

          CONTAINS

! Initialize the memory usage for INIT_PS

          SUBROUTINE INIT_RMEM_INIT_PS
            IMPLICIT NONE
            RMEM_LOC1=0.0_q
            RMEM_LOC2=0.0_q
            RMEM_LOC3=0.0_q
          END SUBROUTINE INIT_RMEM_INIT_PS

! Configure the structural data

          SUBROUTINE EST_INIT_PS
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IB_TMP
            INTEGER               :: ICONF
            INTEGER               :: IERR
            INTEGER               :: INIONS
            INTEGER               :: INTYP0
            INTEGER               :: MNEIB_TMP
! Start profiling
            PROFILING_START ('est_init_ps')
            IF(FFM%W1.GT.0.0_q) THEN
               MNEIB_EST1=0
               DO INTYP0=1, FF%MTYP
                  IF(FFM%NB(INTYP0).GT.0) THEN
                     DO IB_TMP=1, FFM%NB(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                        IB=IB_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                        IF(IB.LE.FFM%NB(INTYP0)) THEN
                           ICONF=FFM%LNCONF(IB,INTYP0)
                           INIONS=FFM%LNIONS(IB,INTYP0)
                           CALL SET_SIZE_EST_POINT (A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LADD(1:,ICONF),LNIONS(1:,1:,ICONF),MIONS,MITYP,MNEIB_TMP,MTYP, &
                                NIONS(ICONF),NITYP(1:,ICONF),NTYP(ICONF),FFM%RCUT1,POSION(1:,1:,ICONF))
                           MNEIB_EST1=MAX(MNEIB_EST1,MNEIB_TMP)
                        ENDIF
                     ENDDO
                  ENDIF
               ENDDO
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,MNEIB_EST1,1,MPI_INTEGER,MPI_MAX,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               MNEIB_EST2=0
               DO INTYP0=1, FF%MTYP
                  IF(FFM%NB(INTYP0).GT.0) THEN
                     DO IB_TMP=1, FFM%NB(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                        IB=IB_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                        IF(IB.LE.FFM%NB(INTYP0)) THEN
                           ICONF=FFM%LNCONF(IB,INTYP0)
                           INIONS=FFM%LNIONS(IB,INTYP0)
                           CALL SET_SIZE_EST_POINT (A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LADD(1:,ICONF),LNIONS(1:,1:,ICONF),MIONS,MITYP,MNEIB_TMP,MTYP, &
                                NIONS(ICONF),NITYP(1:,ICONF),NTYP(ICONF),FFM%RCUT2,POSION(1:,1:,ICONF))
                           MNEIB_EST2=MAX(MNEIB_EST2,MNEIB_TMP)
                        ENDIF
                     ENDDO
                  ENDIF
               ENDDO
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,MNEIB_EST2,1,MPI_INTEGER,MPI_MAX,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
! Stop profiling
            PROFILING_STOP ('est_init_ps')
          END SUBROUTINE EST_INIT_PS

! Calculate angular descriptors

          SUBROUTINE PS_INIT_PS
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IB_TMP
            INTEGER               :: ICONF
            INTEGER               :: IERR
            INTEGER               :: INIONS
            INTEGER               :: INTYP0
            INTEGER               :: IPROCESS
            INTEGER               :: IVAR
            INTEGER               :: LOCVAR_COL
            INTEGER               :: LOCVAR_COL_C00
            INTEGER               :: LOCVAR_COL_CLM1
            INTEGER               :: LOCVAR_COL_CLM1_COUPLE
            INTEGER               :: LOCVAR_COL_CLM2
            INTEGER               :: LOCVAR_COL_CLM2_COUPLE
            INTEGER               :: LOCVAR_COL_PS
            INTEGER               :: LOCVAR_COL_PS_SIC
            INTEGER               :: LOCVAR_COL_PS_SIC_COUPLE
            INTEGER               :: LOCVAR_ROW
            REAL(q)               :: RNORM_ALL
            REAL(q)               :: RNORM_C00
            REAL(q)               :: RNORM_PS
            INTEGER               :: TEST_COL
            INTEGER               :: TEST_ROW
! Allocate.
            CALL ALLOCATE_MB_ARRAY_INIT_PS
! Start profiling.
            PROFILING_START ('ps_init_ps')
            DO INTYP0=1, FF%MTYP
               IF(FFM%NB(INTYP0).GT.0) THEN
! Initialization of CLM1
                  IF(FFM%W1.GT.0.0_q) THEN
                     MLSHM%CLM1(1:MROW_CLM1,1:FFM%NB(INTYP0))=0.0_q
                  ENDIF
                  IF(FFM%W2.GT.0.0_q) THEN
                     MLSHM%CLM2(1:MROW_CLM2,1:FFM%NB(INTYP0))=0.0_q
                     IF(FFM%LSIC) THEN
                        MLSHM%PS_SIC(1:FFM%NNVAR2_SIC(INTYP0),1:FFM%NB(INTYP0))=0.0_q
                     ENDIF
                  ENDIF
#ifdef use_shmem
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Calculations of expansion coefficients
! This part is parallelized by MPI
                  DO IB_TMP=1, FFM%NB(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                     IB=IB_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                     IF(IB.LE.FFM%NB(INTYP0)) THEN
                        ICONF=FFM%LNCONF(IB,INTYP0)
                        INIONS=FFM%LNIONS(IB,INTYP0)
! Configure structural data
                        PROFILING_START ('set_est_init_ps')
                        IF(FFM%W1.GT.0.0_q) THEN
                           CALL SET_EST_DATA_POINT (1,A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LNTYP(1:,ICONF),LNIONS_EST1,MIONS,MROW_EST1,MTYP, &
                                NIONS(ICONF),NNEIB_EST1,NTYP(ICONF),FFM%RCUT1,FFM%RCUT1,FFM%RCUT2,POSION(1:,1:,ICONF),XYZ_EST1)
                        ENDIF
                        IF(FFM%W2.GT.0.0_q) THEN
                           CALL SET_EST_DATA_POINT (1,A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LNTYP(1:,ICONF),LNIONS_EST2,MIONS,MROW_EST2,MTYP, &
                                NIONS(ICONF),NNEIB_EST2,NTYP(ICONF),FFM%RCUT2,FFM%RCUT1,FFM%RCUT2,POSION(1:,1:,ICONF),XYZ_EST2)
                        ENDIF
                        PROFILING_STOP ('set_est_init_ps')
! Calculate expansion coefficients
                        PROFILING_START ('d0clm_soap_init_ps')
                        IF(FFM%W1.GT.0.0_q) THEN
                           LOCVAR_COL_CLM1=IB
                           LOCVAR_COL_CLM1_COUPLE=1
                           LOCVAR_COL_PS_SIC=1
                           LOCVAR_COL_PS_SIC_COUPLE=1
                           CALL D0CLM_SOAP (MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE), &
                                FFM%DRSPL1,FFM%FNL1,FFM%FWIN1,INTYP0,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE, &
                                FFM%LMAX1,LNIONS_EST1,.FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                                FF%MIONS,MROW_EST1,FFM%MRB1,FFM%MSPL1,MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY, &
                                MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                                NNEIB_EST1,FFM%NRB1,FFM%NSPL1,NTYP(ICONF), &
                                MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_LOC3,XYZ_EST1)
                                RMEM_LOC2=MAX(RMEM_LOC2,RMEM_LOC3)
                        ENDIF
                        IF(FFM%W2.GT.0.0_q) THEN
                           LOCVAR_COL_CLM2=IB
                           LOCVAR_COL_CLM2_COUPLE=1
                           IF(FFM%LSIC) THEN
                              LOCVAR_COL_PS_SIC=IB
                           ELSE
                              LOCVAR_COL_PS_SIC=1
                           ENDIF
                           LOCVAR_COL_PS_SIC_COUPLE=1
                           CALL D0CLM_SOAP (MLSHM%CLM2(:,LOCVAR_COL_CLM2),MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE),FFM%DRSPL2,FFM%FNL2,FFM%FWIN2, &
                                INTYP0,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX2,LNIONS_EST2, &
                                FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                                FFM%LWINDOW2,FF%MIONS,MROW_EST2,FFM%MRB2,FFM%MSPL2,MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY, &
                                MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                                NNEIB_EST2,FFM%NRB2,FFM%NSPL2,NTYP(ICONF), &
                                MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_LOC3,XYZ_EST2)
                                RMEM_LOC2=MAX(RMEM_LOC2,RMEM_LOC3)
                        ENDIF
                        PROFILING_STOP ('d0clm_soap_init_ps')
                     ENDIF
                  ENDDO
! Calculate C00.
                  IF(FFM%W1.GT.0.0_q) THEN
                     PROFILING_START ('d0c00_soap_init_ps')
                     DO IB_TMP=1, FFM%NB(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                        IB=IB_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                        IF(IB.LE.FFM%NB(INTYP0)) THEN
                           ICONF=FFM%LNCONF(IB,INTYP0)
                           LOCVAR_COL_C00=CEILING(REAL(IB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           LOCVAR_COL_CLM1=IB
                           LOCVAR_COL_CLM1_COUPLE=1
                           CALL D0C00_SOAP (C00(1:,LOCVAR_COL_C00),C00_COUPLE(1:),MLSHM%CLM1(:,LOCVAR_COL_CLM1), &
                                MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE), &
                                LADD(1:,ICONF),.FALSE.,FFM%LMAX1,FFM%LNORM1, &
                                MROW_C00,MROW_C00_COUPLE,FFM%MRB1,MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY, &
                                FFM%NRB1(0:),NTYP(ICONF))
                        ENDIF
                     ENDDO
                     PROFILING_STOP ('d0c00_soap_init_ps')
                  ENDIF
! Calculate PS.
                  IF(FFM%W2.GT.0.0_q) THEN
                     PROFILING_START ('d0ps_soap_init_ps')
                     DO IB_TMP=1, FFM%NB(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                        IB=IB_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                        IF(IB.LE.FFM%NB(INTYP0)) THEN
                           ICONF=FFM%LNCONF(IB,INTYP0)
                           LOCVAR_COL_PS=CEILING(REAL(IB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           LOCVAR_COL_CLM2=IB
                           LOCVAR_COL_CLM2_COUPLE=1
                           IF(FFM%LSIC) THEN
                              LOCVAR_COL_PS_SIC=IB
                           ELSE
                              LOCVAR_COL_PS_SIC=1
                           ENDIF
                           LOCVAR_COL_PS_SIC_COUPLE=1
!                           CALL D0PS_SOAP (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                           CALL SELECTOR_D0PS (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                                MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE), &
                                FFM%DESC_TYPE,FFM%IAFILT2, &
                                INTYP0,FFM%LAFILT2,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR, &
                                FFM%LFLAG_VAR_SIC,FFM%L_LNRB2,FFM%LMAX2,FFM%LNORM2, &
                                FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%MLNRB2,MROW_PS,MROW_PS_COUPLE, &
                                MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                                FFM%MRB2,MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY, &
                                FFM%NLNRB2,FFM%NRB2(0:),FFM%NRB_LNRB2,NTYP(ICONF), &
                                PS(1:,LOCVAR_COL_PS),PS_COUPLE(1:),MLSHM%PS_SIC(:, LOCVAR_COL_PS_SIC), &
                                MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%WVAR)
                        ENDIF
                     ENDDO
                     PROFILING_STOP ('d0ps_soap_init_ps')
                  ENDIF
! Normalization.
                  PROFILING_START ('normalization_d0_init_ps')
                  DO IB_TMP=1, FFM%NB(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                     IB=IB_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                     IF(IB.LE.FFM%NB(INTYP0)) THEN
                        ICONF=FFM%LNCONF(IB,INTYP0)
                        IF(FFM%W1.GT.0.0_q) THEN
                           LOCVAR_COL_C00=CEILING(REAL(IB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        ELSE
                           LOCVAR_COL_C00=1
                        ENDIF
                        IF(FFM%W2.GT.0.0_q) THEN
                           LOCVAR_COL_PS=CEILING(REAL(IB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        ELSE
                           LOCVAR_COL_PS=1
                        ENDIF
                        CALL NORMALIZATION_D0 (C00(1:,LOCVAR_COL_C00),C00_COUPLE(1:),FFM%LSUPERVEC,.FALSE.,FFM%LNORM1,FFM%LNORM2, &
                             MROW_C00,MROW_C00_COUPLE,MROW_PS,MROW_PS_COUPLE,FFM%NNVAR1,FFM%NNVAR2(INTYP0),PS(1:,LOCVAR_COL_PS),PS_COUPLE(1:), &
                             RNORM_ALL,RNORM_C00,RNORM_PS,FFM%W1,FFM%W2)
                     ENDIF
                  ENDDO
                  PROFILING_STOP ('normalization_d0_init_ps')
! Copy the calculated C00 to FFM%C00.
                  IF(FFM%W1.GT.0.0_q) THEN
                     DO IB=1, FFM%NB(INTYP0)
! Copy C00 to helping array C00_HELP.
                        IPROCESS=MOD(IB-1,PAR_SUP_HANDLE%COMM_WORLD%NCPU)
                        IF(PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.IPROCESS) THEN
                           LOCVAR_COL=CEILING(REAL(IB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           PROFILING_START ('copy_raddesc_init_ps')
                           C00_HELP(1:FFM%NNVAR1)=C00(1:FFM%NNVAR1,LOCVAR_COL)
                           PROFILING_STOP ('copy_raddesc_init_ps')
                        ENDIF
! Broadcast the helping array.
                        PROFILING_START ('bcast_raddesc_init_ps')
                         CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,C00_HELP(1:),FFM%NNVAR1,IPROCESS)
                        PROFILING_STOP ('bcast_raddesc_init_ps')
! Copy the helping array to FFM%C00.
                        PROFILING_START ('copy_raddesc_init_ps')
#ifdef scaLAPACK
                        TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_C00_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                           LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_C00_FFM%NB)
#else
                           LOCVAR_COL=IB
#endif
                           DO IVAR=1, FFM%NNVAR1
#ifdef scaLAPACK
                              TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_C00_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                              IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_C00_FFM%MB)
#else
                              LOCVAR_ROW=IVAR
#endif
                              FFM%C00(LOCVAR_ROW,LOCVAR_COL,INTYP0)=C00_HELP(IVAR)
                           ENDDO
#ifdef scaLAPACK
                        ENDIF
#endif
                        PROFILING_STOP ('copy_raddesc_init_ps')
                     ENDDO
                  ENDIF
! Calculate PS.
                  IF(FFM%W2.GT.0.0_q) THEN
! Copy the calculated PS to FFM%PS.
                     DO IB=1, FFM%NB(INTYP0)
! Copy PS to helping array PS_HELP.
                        IPROCESS=MOD(IB-1,PAR_SUP_HANDLE%COMM_WORLD%NCPU)
                        IF(PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.IPROCESS) THEN
                           LOCVAR_COL=CEILING(REAL(IB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           PROFILING_START ('copy_angdesc_init_ps')
                           PS_HELP(1:FFM%NNVAR2(INTYP0))=PS(1:FFM%NNVAR2(INTYP0),LOCVAR_COL)
                           PROFILING_STOP ('copy_angdesc_init_ps')
                        ENDIF
! Broadcast the helping array.
                        PROFILING_START ('bcast_angdesc_init_ps')
                         CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,PS_HELP(1:),FFM%NNVAR2(INTYP0),IPROCESS)
                        PROFILING_STOP ('bcast_angdesc_init_ps')
! Copy the helping array to FFM%PS.
                        PROFILING_START ('copy_angdesc_init_ps')
#ifdef scaLAPACK
                        TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_PS_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                           LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_PS_FFM%NB)
#else
                           LOCVAR_COL=IB
#endif
                           DO IVAR=1, FFM%NNVAR2(INTYP0)
#ifdef scaLAPACK
                              TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_PS_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                              IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_PS_FFM%MB)
#else
                              LOCVAR_ROW=IVAR
#endif
                              FFM%PS(LOCVAR_ROW,LOCVAR_COL,INTYP0)=PS_HELP(IVAR)
                           ENDDO
#ifdef scaLAPACK
                        ENDIF
#endif
                        PROFILING_STOP ('copy_angdesc_init_ps')
                     ENDDO
                  ENDIF
               ENDIF
            ENDDO
! Deallocate
            CALL DEALLOCATE_MB_ARRAY_INIT_PS
! Stop profiling
            PROFILING_STOP ('ps_init_ps')
          END SUBROUTINE PS_INIT_PS

! Count the memory usage for INIT_PS

          SUBROUTINE COUNT_RMEM_INIT_PS
             IMPLICIT NONE
             MEM1%RMEM(7)=MAX(MEM1%RMEM(7),RMEM_LOC1+RMEM_LOC2)
          END SUBROUTINE COUNT_RMEM_INIT_PS

! Allocate temporary arrays

          SUBROUTINE ALLOCATE_MB_ARRAY_INIT_PS
            IMPLICIT NONE
! Local variables
            INTEGER               :: INTYP0
            INTEGER               :: MB
! Define sizes.
            MB=FFM%NB(1)
            DO INTYP0=2, FF%MTYP
               MB=MAX(MB,FFM%NB(INTYP0))
            ENDDO
            IF(FFM%W1.GT.0.0_q) THEN
               MROW_C00=FFM%MMVAR1
               MCOL_C00=CEILING(REAL(MB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               MROW_CLM1=(FFM%LMAX1+1)**2*FF%MTYP*FFM%MRB1
               MCOL_CLM1=CEILING(REAL(MB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               MROW_EST1=MNEIB_EST1+1
               MCOL_EST1=1
               IF(FFM%LCOUPLE) THEN
                  MROW_C00_COUPLE=FFM%MMVAR1
                  MCOL_C00_COUPLE=CEILING(REAL(MB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  MROW_C00_COUPLE=1
                  MCOL_C00_COUPLE=1
               ENDIF
            ELSE
               MROW_C00=1
               MCOL_C00=1
               MROW_C00_COUPLE=1
               MCOL_C00_COUPLE=1
               MROW_CLM1=1
               MCOL_CLM1=1
               MROW_EST1=1
               MCOL_EST1=1
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               MROW_CLM2=(FFM%LMAX2+1)**2*FF%MTYP*FFM%MRB2
               MCOL_CLM2=CEILING(REAL(MB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               MROW_PS=FFM%MMVAR2
               MCOL_PS=CEILING(REAL(MB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               MROW_EST2=MNEIB_EST2+1
               MCOL_EST2=1
               IF(FFM%LCOUPLE) THEN
                  MROW_PS_COUPLE=FFM%MMVAR2
                  MCOL_PS_COUPLE=CEILING(REAL(MB,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  MROW_PS_COUPLE=1
                  MCOL_PS_COUPLE=1
               ENDIF
            ELSE
               MROW_CLM2=1
               MCOL_CLM2=1
               MROW_PS=1
               MCOL_PS=1
               MROW_PS_COUPLE=1
               MCOL_PS_COUPLE=1
               MROW_EST2=1
               MCOL_EST2=1
            ENDIF
! Allocate arrays.
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            ALLOCATE (C00(1:MROW_C00,1:MCOL_C00))
            RMEM_LOC1=RMEM_LOC1+REAL(MROW_C00,q)*REAL(MCOL_C00,q)*8/1.0E+06_q
            IF(ALLOCATED(C00_HELP)) THEN
               DEALLOCATE(C00_HELP)
            ENDIF
            ALLOCATE (C00_HELP(1:MROW_C00))
            RMEM_LOC1=RMEM_LOC1+REAL(MROW_C00,q)*8/1.0E+06_q
            IF(ALLOCATED(C00_COUPLE)) THEN
               DEALLOCATE(C00_COUPLE)
            ENDIF
            ALLOCATE (C00_COUPLE(1:MROW_C00_COUPLE))
            RMEM_LOC1=RMEM_LOC1+REAL(MROW_C00_COUPLE,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            ALLOCATE (LNIONS_EST1(1:MROW_EST1,1:MTYP))
            RMEM_LOC1=RMEM_LOC1+REAL((MROW_EST1),q)*REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            ALLOCATE (NNEIB_EST1(1:MTYP))
            RMEM_LOC1=RMEM_LOC1+REAL(FF%MTYP,q)/1.E0+06_q
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            ALLOCATE (XYZ_EST1(1:3,1:MROW_EST1,1:MTYP))
            RMEM_LOC1=RMEM_LOC1+3*REAL((MROW_EST1),q)*REAL(FF%MTYP,q)*8/1.0E+06_q
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            ALLOCATE (PS(1:MROW_PS,1:MCOL_PS))
            RMEM_LOC1=RMEM_LOC1+REAL(MROW_PS,q)*REAL(MCOL_PS,q)*8/1.0E+06_q
            IF(ALLOCATED(PS_HELP)) THEN
               DEALLOCATE(PS_HELP)
            ENDIF
            ALLOCATE (PS_HELP(1:MROW_PS))
            RMEM_LOC1=RMEM_LOC1+REAL(MROW_PS,q)*8/1.0E+06_q
            IF(ALLOCATED(PS_COUPLE)) THEN
               DEALLOCATE(PS_COUPLE)
            ENDIF
            ALLOCATE (PS_COUPLE(1:MROW_PS_COUPLE))
            RMEM_LOC1=RMEM_LOC1+REAL(MROW_PS_COUPLE,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            ALLOCATE (LNIONS_EST2(1:MROW_EST2,1:MTYP))
            RMEM_LOC1=RMEM_LOC1+REAL((MROW_EST2),q)*REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            ALLOCATE (NNEIB_EST2(1:MTYP))
            RMEM_LOC1=RMEM_LOC1+REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
            ALLOCATE (XYZ_EST2(1:3,1:MROW_EST2,1:MTYP))
            RMEM_LOC1=RMEM_LOC1+3*REAL((MROW_EST2),q)*REAL(FF%MTYP,q)*8/1.0E+06_q
          END SUBROUTINE ALLOCATE_MB_ARRAY_INIT_PS

! Deallocate temporary arrays

          SUBROUTINE DEALLOCATE_MB_ARRAY_INIT_PS
            IMPLICIT NONE
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            IF(ALLOCATED(C00_HELP)) THEN
               DEALLOCATE(C00_HELP)
            ENDIF
            IF(ALLOCATED(C00_COUPLE)) THEN
               DEALLOCATE(C00_COUPLE)
            ENDIF
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            IF(ALLOCATED(PS_HELP)) THEN
               DEALLOCATE(PS_HELP)
            ENDIF
            IF(ALLOCATED(PS_COUPLE)) THEN
               DEALLOCATE(PS_COUPLE)
            ENDIF
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
          END SUBROUTINE DEALLOCATE_MB_ARRAY_INIT_PS

        END SUBROUTINE INIT_PS
#endif

!****************************************************************************************************
! The calculated angular descriptors for all basis sets are stored in memory used by each process.
! In this subroutine, the number of basis sets, NB, is given as input.
! This treatment is necessary because when angular descriptor is added to the database, FFM%NB is 
! not renewed in some cases.
! It should be also noted that LHEAD(INTYP0)=FFM%LB(1,INTYP0) after the renewal.
!****************************************************************************************************

        SUBROUTINE STORE_PS_IN_ALL_PROCESSES (PAR_SUP_HANDLE,FF,FFM,NB)
          USE ML_FF_STRUCT, ONLY: PARALLEL_SUPER, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: NB(:) !(FF%MTYP)
! Local variables
          INTEGER               :: IB
          INTEGER               :: IB_INTYP0
          INTEGER               :: INTYP0
          INTEGER               :: LHEAD(1:FF%MTYP)
          INTEGER               :: NBTOT
          INTEGER               :: IVAR
          INTEGER               :: ISTATUS
! Start profiling.
          PROFILING_START ('store_ps_in_all_processes')
! Make list for locations of begining of basis sets for each atom type.
! And calculate the total number of basis sets.
          LHEAD(1)=1
          NBTOT=NB(1)
          DO INTYP0=2, FF%MTYP, 1
             LHEAD(INTYP0)=LHEAD(INTYP0-1)+NB(INTYP0-1)
             NBTOT=NBTOT+NB(INTYP0)
          ENDDO
! Loop over element type.
          DO INTYP0=1, FF%MTYP
! Collect the distributed angular descriptor data into process 0.
             IF(FFM%W1.GT.0.0_q) THEN
#ifdef scaLAPACK
                CALL SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE,PAR_SUP_HANDLE%DESC_C00_FFM,FFM%C00(1:,1:,INTYP0),PAR_SUP_HANDLE%CONTEXT_WORLD)
! Copy the collected angular descriptors into local arrays.
                IF (PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_ROW.EQ.0.AND.PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_COL.EQ.0) THEN
                   DO IB=1, NB(INTYP0)
                      IB_INTYP0=IB+LHEAD(INTYP0)-1
                      DO IVAR=1, FFM%NNVAR1
                         FFM%C00_ALL(IVAR,IB_INTYP0)=PAR_SUP_HANDLE%GENERAL_SINGLE(IVAR,IB)
                      ENDDO
                   ENDDO
                ENDIF
! Then, deallocate GENERAL_SINGLE array.
                CALL FINIT_SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE)
#endif
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
#ifdef scaLAPACK
! Collect the distributed angular descriptor data into process 0.
                CALL SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE,PAR_SUP_HANDLE%DESC_PS_FFM,FFM%PS(1:,1:,INTYP0),PAR_SUP_HANDLE%CONTEXT_WORLD)
! Copy the collected angular descriptors into local arrays.
                IF (PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_ROW.EQ.0.AND.PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_COL.EQ.0) THEN
                   DO IB=1, NB(INTYP0)
                      IB_INTYP0=IB+LHEAD(INTYP0)-1
                      DO IVAR=1, FFM%NNVAR2(INTYP0)
                         FFM%PS_ALL(IVAR,IB_INTYP0)=PAR_SUP_HANDLE%GENERAL_SINGLE(IVAR,IB)
                      ENDDO
                   ENDDO
                ENDIF
! Then, deallocate GENERAL_SINGLE array.
                CALL FINIT_SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE)
#endif
             ENDIF
          ENDDO ! Loop for element type
#ifdef use_shmem
          CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,ISTATUS)
#endif
! Broadcast C00_ALL and PS_ALL.
#ifdef scaLAPACK
! Broadcast over first process on all nodes, with root proc11 1 on node 1
          IF(FFM%W1.GT.0.0_q) THEN
#ifdef use_shmem
             IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                 CALL M_BCAST (PAR_SUP_HANDLE%COMM_inter_node_world,FFM%C00_ALL,FFM%MMVAR1*NBTOT,0)
             ENDIF
#else
              CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FFM%C00_ALL,FFM%MMVAR1*NBTOT,0)
#endif
          ENDIF
          IF(FFM%W2.GT.0.0_q) THEN
#ifdef use_shmem
             IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                 CALL M_BCAST (PAR_SUP_HANDLE%COMM_inter_node_world,FFM%PS_ALL,FFM%MMVAR2*NBTOT,0)
             ENDIF
#else
              CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FFM%PS_ALL,FFM%MMVAR2*NBTOT,0)
#endif
          ENDIF
#endif
#ifdef use_shmem
          CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,ISTATUS)
#endif
! Stop profiling.
          PROFILING_STOP ('store_ps_in_all_processes')
        END SUBROUTINE STORE_PS_IN_ALL_PROCESSES

!****************************************************************************************************
! The calculated regression coefficients are stored in all processes.
! Here, NB is not given as input variable because there is no necessity to do so.
!****************************************************************************************************

        SUBROUTINE STORE_WMAT_FFM_IN_ALL_PROCESS(PAR_SUP_HANDLE,MEM1,FF,FFM)
          USE ML_FF_STRUCT, ONLY: PARALLEL_SUPER, MEMORY, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (MEMORY)         :: MEM1
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
! Local variables
          INTEGER               :: IERR
          INTEGER               :: INTYP0
          INTEGER               :: LHEAD(1:FF%MTYP)
          REAL(q)               :: RMEM_HELP
! Start profiling.
          PROFILING_START ('store_wmat_in_all_processes')
! Make list.
          LHEAD(1)=1
          DO INTYP0=2, FF%MTYP, 1
             LHEAD(INTYP0)=LHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
          ENDDO
! Allocate FFM%WMAT_ALL.
          CALL ALLOCATE_WMAT_FFM_ALL
! Merge FFM%WMAT.
          DO INTYP0=1, FF%MTYP
#ifdef scaLAPACK
             CALL SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE,PAR_SUP_HANDLE%DESC_WMAT_FFM,FFM%WMAT(1:,1:,INTYP0),PAR_SUP_HANDLE%CONTEXT_WORLD)
! Copy the collected FFM%WMAT into local arrays.
             IF (PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_ROW.EQ.0.AND.PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_COL.EQ.0) THEN
                FFM%WMAT_ALL(LHEAD(INTYP0):LHEAD(INTYP0)+FFM%NB(INTYP0)-1)=PAR_SUP_HANDLE%GENERAL_SINGLE(1:FFM%NB(INTYP0),1)
             ENDIF
! Then, deallocate GENERAL_SINGLE array.
             CALL FINIT_SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE)
#endif
          ENDDO
! Broadcast WMAT_ALL.
#ifdef scaLAPACK
           CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FFM%WMAT_ALL(1:),FFM%NBTOT,0)
#endif
! Stop profiling.
          PROFILING_STOP ('store_wmat_in_all_processes')

          CONTAINS

! Allocate FFM%WMAT_ALL to store all regression coefficients in all processes.

          SUBROUTINE ALLOCATE_WMAT_FFM_ALL
            IMPLICIT NONE
            RMEM_HELP=0.0_q
#ifdef scaLAPACK
            IF(ALLOCATED(FFM%WMAT_ALL)) THEN
               DEALLOCATE(FFM%WMAT_ALL)
            ENDIF
            ALLOCATE(FFM%WMAT_ALL(1:FFM%NBTOT))
            RMEM_HELP=RMEM_HELP+REAL(FFM%NBTOT,q)*8/1.0E+06_q
#endif
            MEM1%RMEM_WMAT_ALL=MAX(MEM1%RMEM_WMAT_ALL,RMEM_HELP)
          END SUBROUTINE ALLOCATE_WMAT_FFM_ALL

        END SUBROUTINE STORE_WMAT_FFM_IN_ALL_PROCESS

!****************************************************************************************************
! The calculated inverse of SOAP matrices are stored in all processes.
!****************************************************************************************************

        SUBROUTINE STORE_CMAT_FFM_IN_ALL_PROCESS(PAR_SUP_HANDLE,FF,FFM)
          USE ML_FF_STRUCT, ONLY: PARALLEL_SUPER, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input variables
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
! Local variables
          INTEGER               :: IB
          INTEGER               :: IERR
          INTEGER               :: INTYP0
          REAL(q)               :: RMEM_HELP
! Start profiling.
          PROFILING_START ('store_cmat_in_all_processes')
! Merge FFM%CMAT
#ifdef scaLAPACK
          CALL SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE,PAR_SUP_HANDLE%DESC_CMAT_FFM,FFM%CMAT(1:,1:),PAR_SUP_HANDLE%CONTEXT_WORLD)
! Copy the collected FFM%CMAT into local arrays.
          IF (PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_ROW.EQ.0.AND.PAR_SUP_HANDLE%CONTEXT_SINGLE%ME_COL.EQ.0) THEN
             DO IB=1, FFM%NBTOT
                FFM%CMAT_ALL(1:FFM%NBTOT,IB)=PAR_SUP_HANDLE%GENERAL_SINGLE(1:FFM%NBTOT,IB)
             ENDDO
          ENDIF
! Then, deallocate GENERAL_SINGLE array.
          CALL FINIT_SCALAPACK_REDUCE_TO_ONE_CORE(PAR_SUP_HANDLE)
#ifdef use_shmem
          CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
#endif
! Broadcast CMAT_ALL.
#ifdef scaLAPACK
#ifdef use_shmem
          IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
              CALL M_BCAST (PAR_SUP_HANDLE%COMM_inter_node_world,FFM%CMAT_ALL(1:,1:),FFM%MBTOT*FFM%NBTOT,0)
          ENDIF
          CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
           CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FFM%CMAT_ALL(1:,1:),FFM%MBTOT*FFM%NBTOT,0)
#endif
#endif
! Stop profiling.
          PROFILING_STOP ('store_cmat_in_all_processes')

        END SUBROUTINE STORE_CMAT_FFM_IN_ALL_PROCESS

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Initialization of variance of the ab initio data
!****************************************************************************************************

        SUBROUTINE CAL_SIG (FF,ISYS,LADD,MCONF,MIONS,MTYP,NCONF,NCONF_SYS,NIONS,NITYP,NSYS,NTYP,TIFOR,TOTEN,TSIF)
          USE ML_FF_STRUCT, ONLY: FF_PAR
          IMPLICIT NONE
! Input variables
          TYPE (FF_PAR)       :: FF
          INTEGER, INTENT(IN) :: ISYS(:) !(1:NCONF)
          INTEGER, INTENT(IN) :: LADD(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN) :: MCONF
          INTEGER, INTENT(IN) :: MIONS
          INTEGER, INTENT(IN) :: MTYP
          INTEGER, INTENT(IN) :: NCONF
          INTEGER, INTENT(IN) :: NCONF_SYS(:) !(1:NSYS)
          INTEGER, INTENT(IN) :: NIONS(:) !(1:NCONF)
          INTEGER, INTENT(IN) :: NITYP(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN) :: NSYS
          INTEGER, INTENT(IN) :: NTYP(:) !(1:NCONF)
          REAL(q), INTENT(IN) :: TIFOR(:,:,:) !(1:3,1:MIONS,1:NCONF)
          REAL(q), INTENT(IN) :: TOTEN(:) !(1:NCONF)
          REAL(q), INTENT(IN) :: TSIF(:,:,:) !(1:3,1:3,1:NCONF)
! Local variables
          INTEGER             :: ICONF
          INTEGER             :: INIONS
          INTEGER             :: INTYP
          INTEGER             :: INTYP0
          INTEGER             :: ISYS_HELP
          INTEGER             :: IXYZ
          INTEGER             :: JXYZ
          INTEGER             :: KXYZ
          INTEGER             :: NSYS_NONE_ZERO
          INTEGER             :: NTOTEN(1:NSYS)
          INTEGER             :: NTIFOR(1:3,1:NSYS)
          INTEGER             :: NTSIF(1:3,1:3,1:NSYS)
          REAL(q)             :: TOTEN_ATOM_REF
          REAL(q)             :: TOTENAV(1:NSYS)
          REAL(q)             :: TIFORAV(1:3,1:NSYS)
          REAL(q)             :: TSIFAV(1:3,1:3,1:NSYS)
! Start profiling
          PROFILING_START('cal_sig')
! Calculate averages and variances if FF%LGENFF=.TRUE.
          FF%TIFORAV=0.0_q
          FF%TOTENAV=0.0_q
          FF%TSIFAV=0.0_q
          DO ICONF=1, NCONF
! Calculate reference atomic energy.
             TOTEN_ATOM_REF=0.0_q
             DO INTYP=1, NTYP(ICONF)
                INTYP0=LADD(INTYP,ICONF)
                TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
             ENDDO
             FF%TOTENAV=FF%TOTENAV+(TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)
             DO IXYZ=1, 3
                DO JXYZ=IXYZ, 3
                   FF%TSIFAV(JXYZ,IXYZ)=FF%TSIFAV(JXYZ,IXYZ)+TSIF(JXYZ,IXYZ,ICONF)
                ENDDO
             ENDDO
             DO IXYZ=1, 2
                DO JXYZ=IXYZ+1, 3
                   FF%TSIFAV(IXYZ,JXYZ)=FF%TSIFAV(JXYZ,IXYZ)
                ENDDO
             ENDDO
             DO INIONS=1, NIONS(ICONF)
                FF%TIFORAV(1:3)=FF%TIFORAV(1:3)+TIFOR(1:3,INIONS,ICONF)
             ENDDO
          ENDDO
          FF%TIFORAV(1:3)=FF%TIFORAV(1:3)/REAL((FF%NTIFOR/3),q)
          FF%TOTENAV=FF%TOTENAV/REAL(FF%NTOTEN,q)
          FF%TSIFAV(1:3,1:3)=FF%TSIFAV(1:3,1:3)/REAL((FF%NTSIF/6),q)
          FF%SIG=0.0_q
! Calculate total variance.
          IF((FF%IWEIGHT.EQ.1).OR.(FF%IWEIGHT.EQ.2).OR.(FF%IWEIGHT.EQ.4)) THEN
             DO ICONF=1, NCONF
                TOTEN_ATOM_REF=0.0_q
                DO INTYP=1, NTYP(ICONF)
                   INTYP0=LADD(INTYP,ICONF)
                   TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
                ENDDO
                FF%SIG(1)=FF%SIG(1)+((TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)-FF%TOTENAV)**2
                KXYZ=0
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      KXYZ=KXYZ+1
                      FF%SIG(KXYZ+4)=FF%SIG(KXYZ+4)+(TSIF(JXYZ,IXYZ,ICONF)-FF%TSIFAV(JXYZ,IXYZ))**2
                   ENDDO
                ENDDO
                DO INIONS=1, NIONS(ICONF)
                   DO IXYZ=1, 3
                      FF%SIG(IXYZ+1)=FF%SIG(IXYZ+1)+(TIFOR(IXYZ,INIONS,ICONF)-FF%TIFORAV(IXYZ))**2
                   ENDDO
                ENDDO
             ENDDO
             FF%SIG(1)=SQRT(FF%SIG(1)/REAL(FF%NTOTEN,q))
             DO IXYZ=1, 3
                FF%SIG(IXYZ+1)=SQRT(FF%SIG(IXYZ+1)/REAL((FF%NTIFOR/3),q))
             ENDDO
             DO IXYZ=1, 6
                FF%SIG(IXYZ+4)=SQRT(FF%SIG(IXYZ+4)/REAL((FF%NTSIF/6),q))
             ENDDO
! Calculate average of system-dependent variances.
          ELSE IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
             NTOTEN=0
             NTIFOR=0
             NTSIF=0
             TOTENAV=0.0_q
             TIFORAV=0.0_q
             TSIFAV=0.0_q
             DO ICONF=1, NCONF
                TOTEN_ATOM_REF=0.0_q
                DO INTYP=1, NTYP(ICONF)
                   INTYP0=LADD(INTYP,ICONF)
                   TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
                ENDDO
                NTOTEN(ISYS(ICONF))=NTOTEN(ISYS(ICONF))+1
                TOTENAV(ISYS(ICONF))=TOTENAV(ISYS(ICONF))+(TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      NTSIF(JXYZ,IXYZ,ISYS(ICONF))=NTSIF(JXYZ,IXYZ,ISYS(ICONF))+1
                      TSIFAV(JXYZ,IXYZ,ISYS(ICONF))=TSIFAV(JXYZ,IXYZ,ISYS(ICONF))+TSIF(JXYZ,IXYZ,ICONF)
                   ENDDO
                ENDDO 
                DO INIONS=1, NIONS(ICONF)
                   DO IXYZ=1, 3
                      NTIFOR(IXYZ,ISYS(ICONF))=NTIFOR(IXYZ,ISYS(ICONF))+1
                      TIFORAV(IXYZ,ISYS(ICONF))=TIFORAV(IXYZ,ISYS(ICONF))+TIFOR(IXYZ,INIONS,ICONF)
                   ENDDO
                ENDDO
             ENDDO
             DO ISYS_HELP=1, NSYS
                IF(NTOTEN(ISYS_HELP).GT.0) THEN
                   TOTENAV(ISYS_HELP)=TOTENAV(ISYS_HELP)/REAL(NTOTEN(ISYS_HELP),q)
                ELSE
                   TOTENAV(ISYS_HELP)=0.0_q
                ENDIF
                DO IXYZ=1, 3
                   IF(NTIFOR(IXYZ,ISYS_HELP).GT.0) THEN
                      TIFORAV(IXYZ,ISYS_HELP)=TIFORAV(IXYZ,ISYS_HELP)/REAL(NTIFOR(IXYZ,ISYS_HELP),q)
                   ELSE
                      TIFORAV(IXYZ,ISYS_HELP)=0.0_q
                   ENDIF
                   DO JXYZ=IXYZ, 3
                      IF(NTSIF(JXYZ,IXYZ,ISYS_HELP).GT.0) THEN
                         TSIFAV(JXYZ,IXYZ,ISYS_HELP)=TSIFAV(JXYZ,IXYZ,ISYS_HELP)/REAL(NTSIF(JXYZ,IXYZ,ISYS_HELP),q)
                      ELSE
                         TSIFAV(JXYZ,IXYZ,ISYS_HELP)=0.0_q
                      ENDIF
                   ENDDO
                ENDDO
             ENDDO
             FF%SIG_SYS=0.0_q
             DO ICONF=1, NCONF
                TOTEN_ATOM_REF=0.0_q
                DO INTYP=1, NTYP(ICONF)
                   INTYP0=LADD(INTYP,ICONF)
                   TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
                ENDDO
                FF%SIG_SYS(1,ISYS(ICONF))=FF%SIG_SYS(1,ISYS(ICONF))+((TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)-TOTENAV(ISYS(ICONF)))**2
                KXYZ=0
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      KXYZ=KXYZ+1
                      FF%SIG_SYS(KXYZ+4,ISYS(ICONF))=FF%SIG_SYS(KXYZ+4,ISYS(ICONF))+(TSIF(JXYZ,IXYZ,ICONF)-TSIFAV(JXYZ,IXYZ,ISYS(ICONF)))**2
                   ENDDO
                ENDDO
                DO INIONS=1, NIONS(ICONF)
                   DO IXYZ=1, 3
                      FF%SIG_SYS(IXYZ+1,ISYS(ICONF))=FF%SIG_SYS(IXYZ+1,ISYS(ICONF))+(TIFOR(IXYZ,INIONS,ICONF)-TIFORAV(IXYZ,ISYS(ICONF)))**2
                   ENDDO
                ENDDO
             ENDDO
             NSYS_NONE_ZERO=0
             DO ISYS_HELP=1, NSYS
                IF(NCONF_SYS(ISYS_HELP).GT.0) THEN
                   NSYS_NONE_ZERO=NSYS_NONE_ZERO+1
                ENDIF
                IF(NTOTEN(ISYS_HELP).GT.0) THEN
                   FF%SIG_SYS(1,ISYS_HELP)=FF%SIG_SYS(1,ISYS_HELP)/REAL(NTOTEN(ISYS_HELP),q)
                ELSE
                   FF%SIG_SYS(1,ISYS_HELP)=0.0_q
                ENDIF
                KXYZ=0
                DO IXYZ=1, 3
                   IF(NTIFOR(IXYZ,ISYS_HELP).GT.0) THEN
                      FF%SIG_SYS(IXYZ+1,ISYS_HELP)=FF%SIG_SYS(IXYZ+1,ISYS_HELP)/REAL(NTIFOR(IXYZ,ISYS_HELP),q)
                   ELSE
                      FF%SIG_SYS(IXYZ+1,ISYS_HELP)=0.0_q
                   ENDIF
                   DO JXYZ=IXYZ, 3
                      KXYZ=KXYZ+1
                      IF(NTSIF(JXYZ,IXYZ,ISYS_HELP).GT.0) THEN
                         FF%SIG_SYS(KXYZ+4,ISYS_HELP)=FF%SIG_SYS(KXYZ+4,ISYS_HELP)/REAL(NTSIF(JXYZ,IXYZ,ISYS_HELP),q)
                      ELSE
                         FF%SIG_SYS(KXYZ+4,ISYS_HELP)=0.0_q
                      ENDIF
                   ENDDO
                ENDDO
             ENDDO
             FF%SIG=0.0_q
             DO IXYZ=1, 10
                DO ISYS_HELP=1, NSYS
                   IF(NCONF_SYS(ISYS_HELP).GT.0) THEN
                      FF%SIG(IXYZ)=FF%SIG(IXYZ)+FF%SIG_SYS(IXYZ,ISYS_HELP)/REAL(NSYS_NONE_ZERO,q)
                   ENDIF
                ENDDO
             ENDDO
             DO IXYZ=1, 10
                FF%SIG(IXYZ)=SQRT(FF%SIG(IXYZ))
             ENDDO
          ENDIF
! Stop profiling
          PROFILING_STOP('cal_sig')
        END SUBROUTINE CAL_SIG
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Initialization of SOAP matrix that will be used for sparsification
!****************************************************************************************************
        SUBROUTINE INIT_SOAP(TIM,PAR_SUP_HANDLE,MEM1,FF,FFM)
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: TIME, PARALLEL_SUPER, MEMORY, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (TIME)           :: TIM
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (MEMORY)         :: MEM1
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
! Local variables
          REAL(q)               :: CPUTIM0
          REAL(q)               :: CPUTIM1
          INTEGER               :: IB
          INTEGER               :: IERR
          INTEGER               :: IPOLY
          INTEGER               :: INTYP0
          INTEGER               :: JB
          INTEGER               :: JNTYP0
          INTEGER               :: KNTYP0
          INTEGER               :: LOCVAR_COL
          INTEGER               :: MCOL_SOAP
          INTEGER               :: MROW_SOAP
          REAL(q)               :: RMEM_HELP
          REAL(q), ALLOCATABLE  :: SOAP1(:,:)
          REAL(q), ALLOCATABLE  :: SOAP2(:,:)
          INTEGER               :: TEST_COL
          REAL(q)               :: VPUTIM0
          REAL(q)               :: VPUTIM1
! Start profiling
          PROFILING_START('init_soap')
! Measure the initial times
          CALL VTIME (VPUTIM0,CPUTIM0)
! Allocate
          CALL ALLOCATE_TMP_ARRAY_INIT_SOAP
! Initialize SOAP matrix that will be used for the initial sparsification
          DO INTYP0=1, FF%MTYP
             IF(FFM%NB(INTYP0).GT.0) THEN
! Calculate SOAP kernel
                IPOLY=0
                IF(FFM%W1 .GT. 0.0_q) THEN
#ifdef scaLAPACK
                   PROFILING_START('pdgemm_soap1_init_soap')
                   CALL PDGEMM('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                        FFM%C00(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_C00_FFM%DESC, &
                        FFM%C00(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_C00_FFM%DESC, &
                        0.0_q,SOAP1(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
                   PROFILING_STOP('pdgemm_soap1_init_soap')
#else
                   PROFILING_START('dgemm_soap1_init_soap')
                   CALL DGEMM ('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NNVAR1,1.0_q,FFM%C00(1,1,INTYP0), &
                        FFM%MMVAR1,FFM%C00(1,1,INTYP0),FFM%MMVAR1,0.0_q,SOAP1(1,1),FFM%MB)
                   PROFILING_STOP('dgemm_soap1_init_soap')
#endif
                   PROFILING_START('poly_soap1_init_soap')
                   CALL POLY_SOAP_INIT1 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_FFM,IPOLY, &
                   FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NHYP1,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W1)
                   PROFILING_STOP('poly_soap1_init_soap')
                   IPOLY=1
                ENDIF
                IF(FFM%W2 .GT. 0.0_q) THEN
#ifdef scaLAPACK
                   PROFILING_START('pdgemm_soap2_init_soap')
                   CALL PDGEMM('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        0.0_q,SOAP1(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
                   PROFILING_STOP('pdgemm_soap2_init_soap')
#else
                   PROFILING_START('dgemm_soap2_init_soap')
                   CALL DGEMM ('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q,FFM%PS(1,1,INTYP0), &
                        FFM%MMVAR2,FFM%PS(1,1,INTYP0),FFM%MMVAR2,0.0_q,SOAP1(1,1),FFM%MB)
                   PROFILING_STOP('dgemm_soap2_init_soap')
#endif
                   PROFILING_START('poly_soap2_init_soap')
                   CALL POLY_SOAP_INIT1 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_FFM,IPOLY,FFM%LSUPERVEC, &
                        MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NHYP2,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W2)
                   PROFILING_STOP('poly_soap2_init_soap')
                ENDIF
! Calculate SOAP similarity measure for super vector.
                IF(FFM%LSUPERVEC) THEN
                   PROFILING_START('pdgemm_soap_all_init_soap')
                   CALL POLY_SOAP_INIT2 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_FFM,MROW_SOAP,MCOL_SOAP, &
                        1,FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NHYP2,SOAP2(1:,1:))
                   PROFILING_STOP('pdgemm_soap_all_init_soap')
                ENDIF
! Copy SOAP.
                PROFILING_START('dcopy_soap_init_soap')
                DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                   IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.1) THEN
                      TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                      IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                         CYCLE
                      ENDIF
                      LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
                      CALL DCOPY (FFM%NB(INTYP0),SOAP2(1,LOCVAR_COL),1,FFM%SOAP(1,LOCVAR_COL,INTYP0),1)
                   ELSE IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                      CALL PDCOPY(FFM%NB(INTYP0),SOAP2(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1,FFM%SOAP(1,1,INTYP0),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
                   ENDIF
#else
                   CALL DCOPY (FFM%NB(INTYP0),SOAP2(1,IB),1,FFM%SOAP(1,IB,INTYP0),1)
#endif
                ENDDO
                PROFILING_STOP('dcopy_soap_init_soap')
             ENDIF
          ENDDO
! Deallocate
          CALL DEALLOCATE_TMP_ARRAY_INIT_SOAP
! Measure the final times and add them
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(5)=TIM%CPUTIM(5)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(5)=TIM%VPUTIM(5)+VPUTIM1-VPUTIM0
! Stop profiling
          PROFILING_STOP('init_soap')

         CONTAINS

         SUBROUTINE ALLOCATE_TMP_ARRAY_INIT_SOAP
           IMPLICIT NONE
           RMEM_HELP=0.0_q
! Define size of arrays.
#ifdef scaLAPACK
           MROW_SOAP=PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M
           MCOL_SOAP=PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N
#else
           MROW_SOAP=FFM%MB
           MCOL_SOAP=FFM%MB
#endif
! Allocate arrays.
           IF(ALLOCATED(SOAP1)) THEN
              DEALLOCATE(SOAP1)
           ENDIF
           ALLOCATE (SOAP1(1:MROW_SOAP,1:MCOL_SOAP))
           RMEM_HELP=RMEM_HELP+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
           IF(ALLOCATED(SOAP2)) THEN
              DEALLOCATE(SOAP2)
           ENDIF
           ALLOCATE (SOAP2(1:MROW_SOAP,1:MCOL_SOAP))
           RMEM_HELP=RMEM_HELP+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
           MEM1%RMEM(5)=MAX(MEM1%RMEM(5),RMEM_HELP)
         END SUBROUTINE ALLOCATE_TMP_ARRAY_INIT_SOAP

         SUBROUTINE DEALLOCATE_TMP_ARRAY_INIT_SOAP
           IMPLICIT NONE
           IF(ALLOCATED(SOAP1)) THEN
              DEALLOCATE(SOAP1)
           ENDIF
           IF(ALLOCATED(SOAP2)) THEN
              DEALLOCATE(SOAP2)
           ENDIF
         END SUBROUTINE DEALLOCATE_TMP_ARRAY_INIT_SOAP

        END SUBROUTINE INIT_SOAP
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Subroutine to sparsify the descriptors.
! Sparsification is done for CUR decomposition of A=P P^T, where P is
! the matrix for the angular descriptors.
!****************************************************************************************************

        SUBROUTINE SPARS_DES_CUR (LAPACKWORK,PAR_SUP_HANDLE,LOGF,FF,FFM,NB)
          USE ML_FF_STRUCT, ONLY: LAPACK_WORK, PARALLEL_SUPER, LOG_PAR, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (LAPACK_WORK)               :: LAPACKWORK
          TYPE (PARALLEL_SUPER)            :: PAR_SUP_HANDLE
          TYPE (LOG_PAR)                   :: LOGF
          TYPE (FF_PAR)                    :: FF
          TYPE (FFM_PAR)                   :: FFM
          INTEGER                          :: NB(:) !(1:FF%MTYP)
! Local variables.
          REAL(q)          , ALLOCATABLE   :: A_SPARSDES_CUR(:,:)
          REAL(q)          , ALLOCATABLE   :: EIGENVALUE(:)
          INTEGER                          :: INTYP0
          INTEGER          , ALLOCATABLE   :: LFLAG_DES(:)
          INTEGER          , ALLOCATABLE   :: LVAR_HELP1(:)
          INTEGER          , ALLOCATABLE   :: LVAR_HELP2(:,:,:,:,:)
          INTEGER                          :: NDEL_DES
          INTEGER                          :: NNVAR2_NEW
          INTEGER                          :: NNVAR2_OLD(FF%MTYP)
          REAL(q)          , ALLOCATABLE   :: PIL(:)
          REAL(q)          , ALLOCATABLE   :: PS_HELP(:)
          REAL(q)          , ALLOCATABLE   :: U_HELP(:,:)
          REAL(q)          , ALLOCATABLE   :: V_HELP(:,:)
          REAL(q)          , ALLOCATABLE   :: V_SPARSDES_CUR(:,:)
          REAL(q)                          :: WRATIO_NEW
          REAL(q)                          :: WRATIO_OLD
          NNVAR2_OLD = 0
! Sparsification is done only for the angular descriptor.
          IF(FFM%W2.GT.0.0_q) THEN
! Start profiling.
            PROFILING_START('sparsdes_cur')
! Allocate helping arrays.
             CALL ALLOCATE_SPARSDES_CUR
             DO INTYP0=1, FF%MTYP
                IF(NB(INTYP0).GT.0) THEN
                   NNVAR2_OLD(INTYP0) = FFM%NNVAR2(INTYP0)
! Calculate A=PS PS^T matrix.
#ifdef scaLAPACK
                   CALL PDGEMM('N','T',FFM%NNVAR2(INTYP0),FFM%NNVAR2(INTYP0),NB(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        0.0_q,A_SPARSDES_CUR(1,1),1,1,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%DESC)
#else
                   CALL DGEMM ('N','T',FFM%NNVAR2(INTYP0),FFM%NNVAR2(INTYP0),NB(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),FFM%MMVAR2,FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                        0.0_q,A_SPARSDES_CUR(1,1),FFM%MMVAR2)
#endif
! Diagonalize A_SPARSDES_CUR.
                   CALL SVD_SPARSDES_CUR (WRATIO_OLD)
! Compute the leverage scoring.
                   CALL PIL_SPARSDES_CUR
! Select descriptors.
                   CALL SELECT_DES_CUR
! Reconstruct the data structure.
                   CALL RESTRUCTURE_PS_SPARS_DES_CUR
! Recompute A=PS PS^T matrix using sparsified descriptors.
#ifdef scaLAPACK
                   CALL PDGEMM('N','T',FFM%NNVAR2(INTYP0),FFM%NNVAR2(INTYP0),NB(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        0.0_q,A_SPARSDES_CUR(1,1),1,1,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%DESC)
#else
                   CALL DGEMM ('N','T',FFM%NNVAR2(INTYP0),FFM%NNVAR2(INTYP0),NB(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),FFM%MMVAR2,FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                        0.0_q,A_SPARSDES_CUR(1,1),FFM%MMVAR2)
#endif
! Diagonalize A_SPARSDES_CUR again.
                   CALL SVD_SPARSDES_CUR (WRATIO_NEW)
                   NNVAR2_NEW=FFM%NNVAR2(INTYP0)
                ENDIF
             ENDDO
! Deallocate helping arrays.
             CALL DEALLOCATE_SPARSDES_CUR
! Output the information on the sparsification.
             CALL LOGSECTION_SPARS_DES(LOGF, FF, FFM, NNVAR2_OLD)
! Stop profiling.
            PROFILING_STOP('sparsdes_cur')
          ENDIF

          CONTAINS

! Singular value decomposition, which equals to diagonalization for a squared matrix.

          SUBROUTINE SVD_SPARSDES_CUR (WRATIO)
            IMPLICIT NONE
! Input variables
            REAL(q) :: WRATIO
! Local variables
            INTEGER                          :: IVAR
            REAL(q)                          :: WMAX
            REAL(q)                          :: WMIN
! Start profiling.
            PROFILING_START('svd_sparsdes_cur')
! Diagonalize A_SPARSDES_CUR.
#ifdef scaLAPACK
! 1) Calculate the necessary size of work array.
            CALL SCALAPACK_WORK_ARRAY_SIZE_PDSYEV_INIT(PAR_SUP_HANDLE%SCAWORK)
            CALL PDSYEV('V','U',FFM%NNVAR2(INTYP0),A_SPARSDES_CUR(1,1),1,1,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%DESC, &
                 EIGENVALUE(1),V_SPARSDES_CUR(1,1),1,1,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC, &
                 PAR_SUP_HANDLE%SCAWORK%WORK(1),PAR_SUP_HANDLE%SCAWORK%LWORK,PAR_SUP_HANDLE%SCAWORK%INFO)
            CALL SCALAPACK_WORK_ARRAY_SIZE_PDSYEV_FIN(PAR_SUP_HANDLE%SCAWORK)
! 2) Diagonalization.
            CALL SCALAPACK_WORK_ARRAY_PDGESVD_INIT(PAR_SUP_HANDLE%SCAWORK)
            CALL PDSYEV('V','U',FFM%NNVAR2(INTYP0),A_SPARSDES_CUR(1,1),1,1,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%DESC, &
                 EIGENVALUE(1),V_SPARSDES_CUR(1,1),1,1,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC, &
                 PAR_SUP_HANDLE%SCAWORK%WORK(1),PAR_SUP_HANDLE%SCAWORK%LWORK,PAR_SUP_HANDLE%SCAWORK%INFO)
            CALL SCALAPACK_WORK_ARRAY_PDGESVD_FIN(PAR_SUP_HANDLE%SCAWORK)
#else
! 0) Copy A matrix to EIGENVECTOR.
            DO IVAR=1, FFM%NNVAR2(INTYP0)
               V_SPARSDES_CUR(1:FFM%NNVAR2(INTYP0),IVAR)=A_SPARSDES_CUR(1:FFM%NNVAR2(INTYP0),IVAR)
            ENDDO
! 1) Calculate the necessary size of work array.
            CALL LAPACK_WORK_ARRAY_SIZE_DSYEV_INIT(LAPACKWORK)
            CALL DSYEV ('V','U',FFM%NNVAR2(INTYP0),V_SPARSDES_CUR(1,1),FFM%MMVAR2,EIGENVALUE(1),LAPACKWORK%WORK(1),LAPACKWORK%LWORK,LAPACKWORK%INFO)
            CALL LAPACK_WORK_ARRAY_SIZE_DSYEV_FIN(LAPACKWORK)
! 2) Diagonalization.
            CALL LAPACK_WORK_ARRAY_DSYEV_INIT(LAPACKWORK)
            CALL DSYEV ('V','U',FFM%NNVAR2(INTYP0),V_SPARSDES_CUR(1,1),FFM%MMVAR2,EIGENVALUE(1),LAPACKWORK%WORK(1),LAPACKWORK%LWORK,LAPACKWORK%INFO)
            CALL LAPACK_WORK_ARRAY_DSYEV_FIN(LAPACKWORK)
#endif
! Check the ratio of the minumum singular value to the maximum one.
! Calculate the ratio of minimum eigenvalue to maximum one
            WMAX=ABS(EIGENVALUE(1))
            WMIN=ABS(EIGENVALUE(1))
            DO IVAR=2, FFM%NNVAR2(INTYP0), 1
               WMAX=MAX(WMAX,ABS(EIGENVALUE(IVAR)))
               WMIN=MIN(WMIN,ABS(EIGENVALUE(IVAR)))
            ENDDO
            WRATIO=WMIN/WMAX
! Stop profiling.
            PROFILING_STOP('svd_sparsdes_cur')
          END SUBROUTINE SVD_SPARSDES_CUR

! Leverage scoring. In this subroutine, leverage scorings of high singular values are computed differently from SPARS_ICUR.

          SUBROUTINE PIL_SPARSDES_CUR
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IERR
            INTEGER                          :: IVAR
            INTEGER                          :: LOCVAR_COL
            INTEGER                          :: LOCVAR_ROW
            INTEGER                          :: NDES
            INTEGER                          :: TEST_COL
            INTEGER                          :: TEST_ROW
! Start profiling.
            PROFILING_START('pil_sparsdes_cur')
! The number of the basis sets that must be disregarded.
! Here, the number of remained descriptors is set to that specified by the INCAR-tag diffrently from the sparsification of the basis sets.
            NDES=INT(FFM%RDES_SPARSDES*FFM%NNVAR2(INTYP0))
            NDEL_DES=FFM%NNVAR2(INTYP0)-NDES+1
! Calculate leverage scorings as indicators of correlations with high rank eigenvalues.
            PIL(1:FFM%NNVAR2(INTYP0))=0.0_q
            V_HELP=0.0_q
! Determine the left-singular vectors.
            DO IVAR=1, FFM%NRANK_SPARSDES
#ifdef scaLAPACK
               CALL PDCOPY(FFM%NNVAR2(INTYP0),V_SPARSDES_CUR,1,FFM%NNVAR2(INTYP0)-FFM%NRANK_SPARSDES+IVAR,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC,1,V_HELP,1,IVAR,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC,1)
#else
               CALL DCOPY(FFM%NNVAR2(INTYP0),V_SPARSDES_CUR(1,FFM%NNVAR2(INTYP0)-FFM%NRANK_SPARSDES+IVAR),1,V_HELP(1,IVAR),1)
#endif
            ENDDO
! Calculation of the leverage scoring.
#ifdef scaLAPACK
            CALL PDGEMM('N','T',FFM%NNVAR2(INTYP0),FFM%NNVAR2(INTYP0),FFM%NRANK_SPARSDES,1.0_q,V_HELP(1,1),1,1,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC, &
                 V_HELP(1,1),1,1,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC,0.0_q,U_HELP(1,1),1,1,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC)
#else
            CALL DGEMM ('N','T',FFM%NNVAR2(INTYP0),FFM%NNVAR2(INTYP0),FFM%NRANK_SPARSDES,1.0_q,V_HELP(1,1),FFM%MMVAR2, &
                 V_HELP,FFM%MMVAR2,0.0_q,U_HELP(1,1),FFM%MMVAR2)
#endif
! Then, the leverage scorings are calculated by the same method.
            DO IVAR=1, FFM%NNVAR2(INTYP0)
#ifdef scaLAPACK
               TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
               TEST_COL=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW.OR.PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                  CYCLE
               ENDIF
               LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%MB)
               LOCVAR_COL=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%NB)
#else
               LOCVAR_ROW=IVAR
               LOCVAR_COL=IVAR
#endif
               PIL(IVAR)=U_HELP(LOCVAR_ROW,LOCVAR_COL)
            ENDDO
#ifdef scaLAPACK
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,PIL(1),FFM%NNVAR2(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
            PROFILING_STOP('pil_sparsdes_cur')
          END SUBROUTINE PIL_SPARSDES_CUR

! Select descriptors by CUR.

          SUBROUTINE SELECT_DES_CUR
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IDEL_DES
            INTEGER                          :: IVAR
            INTEGER                          :: JVAR
            REAL(q)                          :: PILMIN
! Start profiling.
            PROFILING_START('select_sparsdes_cur')
! Select the basis sets that must be thrown away to prevent the overcompleteness
            LFLAG_DES=1
            IF(NDEL_DES.NE.0) THEN
               DO IVAR=1, NDEL_DES
                  PILMIN=0.0_q
                  DO JVAR=1, FFM%NNVAR2(INTYP0)
                     PILMIN=MAX(PILMIN,PIL(JVAR))
                  ENDDO
                  IDEL_DES=0
                  DO JVAR=1, FFM%NNVAR2(INTYP0)
                     IF((PILMIN.GT.PIL(JVAR)).AND.(LFLAG_DES(JVAR).EQ.1)) THEN
                        IDEL_DES=JVAR
                        PILMIN=PIL(JVAR)
                     ENDIF
                  ENDDO
                  IF(IDEL_DES.NE.0) THEN
                     LFLAG_DES(IDEL_DES)=0
                  ENDIF
               ENDDO
            ENDIF
! Stop profiling.
            PROFILING_STOP('select_sparsdes_cur')
          END SUBROUTINE SELECT_DES_CUR

! Restructure the angular descriptor data.

          SUBROUTINE RESTRUCTURE_PS_SPARS_DES_CUR
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IB
            INTEGER                          :: IERR
            INTEGER                          :: IRB
            INTEGER                          :: IVAR
            INTEGER                          :: JNTYP0
            INTEGER                          :: JJNTYP0
            INTEGER                          :: JRB
            INTEGER                          :: L
            INTEGER                          :: LOCVAR_COL
            INTEGER                          :: LOCVAR_ROW
            INTEGER                          :: NNVAR2_HELP
            INTEGER                          :: TEST_COL
            INTEGER                          :: TEST_ROW
! Start profiling.
            PROFILING_START('restruct_sparsdes_cur')
! Make a temporary list.
            LVAR_HELP1=0
            NNVAR2_HELP=0
            DO IVAR=1, FFM%NNVAR2(INTYP0)
               IF(LFLAG_DES(IVAR).EQ.1) THEN
                  NNVAR2_HELP=NNVAR2_HELP+1
                  LVAR_HELP1(IVAR)=NNVAR2_HELP
               ENDIF
            ENDDO
            IF (FFM%DESC_TYPE.EQ.0) THEN
               DO JNTYP0=1, FF%MTYP
                  DO JJNTYP0=1, FF%MTYP
                     DO L=0, FFM%LMAX2
                        DO IRB=1, FFM%NRB2(L)
                           DO JRB=IRB, FFM%NRB2(L)
                              LVAR_HELP2(JRB,IRB,L,JJNTYP0,JNTYP0)=FFM%LVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
               DO JNTYP0=1, FF%MTYP
                  DO L=0, FFM%LMAX2
                     DO IRB=1, FFM%NRB2(L)
                        DO JRB=IRB, FFM%NRB2(L)
                           LVAR_HELP2(JRB,IRB,L,1,JNTYP0)=FFM%LVAR(JRB,IRB,L,1,JNTYP0,INTYP0)
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ENDIF
! Copy to helping arrays.
            DO IB=1, NB(INTYP0)
               PS_HELP=0.0_q
#ifdef scaLAPACK
               TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_PS_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                  LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_PS_FFM%NB)
#else
                  LOCVAR_COL=IB
#endif
                  DO IVAR=1, FFM%NNVAR2(INTYP0)
                     IF(LFLAG_DES(IVAR).EQ.1) THEN
#ifdef scaLAPACK
                        TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_PS_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_PS_FFM%MB)
#else
                        LOCVAR_ROW=IVAR
#endif
                        PS_HELP(LVAR_HELP1(IVAR))=FFM%PS(LOCVAR_ROW,LOCVAR_COL,INTYP0)
                     ENDIF
                  ENDDO
#ifdef scaLAPACK
               ENDIF
#endif
#ifdef scaLAPACK
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,PS_HELP,NNVAR2_HELP,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
! Restructure the FFM%PS.
#ifdef scaLAPACK
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                  LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_PS_FFM%NB)
#else
                  LOCVAR_COL=IB
#endif
                  FFM%PS(1:PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,LOCVAR_COL,INTYP0)=0.0_q
                  DO IVAR=1, NNVAR2_HELP
#ifdef scaLAPACK
                     TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_PS_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_PS_FFM%MB)
#else
                     LOCVAR_ROW=IVAR
#endif
                     FFM%PS(LOCVAR_ROW,LOCVAR_COL,INTYP0)=PS_HELP(IVAR)
                  ENDDO
#ifdef scaLAPACK
               ENDIF
#endif
            ENDDO
! Restructure the related lists.
            FFM%NNVAR2(INTYP0)=0
            FFM%LFLAG_VAR(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP,1:FF%MTYP,INTYP0)=.FALSE.
            FFM%LVAR(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP,1:FF%MTYP,INTYP0)=0
            FFM%WVAR(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP,1:FF%MTYP,INTYP0)=0.0_q
            IF(FFM%LSIC) THEN
               FFM%NNVAR2_SIC(INTYP0)=0
               FFM%LVAR_SIC(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP,INTYP0)=0
               FFM%LFLAG_VAR_SIC(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP,INTYP0)=.FALSE.
            ENDIF
            IF (FFM%DESC_TYPE.EQ.0) THEN
               DO JNTYP0=1, FF%MTYP
                  DO JJNTYP0=1, FF%MTYP
                     DO L=0, FFM%LMAX2
                        DO IRB=1, FFM%NRB2(L)
                           DO JRB=IRB, FFM%NRB2(L)
                              IF(LFLAG_DES(LVAR_HELP2(JRB,IRB,L,JJNTYP0,JNTYP0)).EQ.1) THEN
                                 FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                                 FFM%LVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                                 FFM%LFLAG_VAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=.TRUE.
                                 IF(JRB.EQ.IRB) THEN
                                    FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=1.0_q
                                 ELSE
                                    FFM%WVAR(JRB,IRB,L,JJNTYP0,JNTYP0,INTYP0)=SQRT(2.0_q)
                                 ENDIF
                                 IF(FFM%LSIC) THEN
                                    IF(JJNTYP0.EQ.JNTYP0) THEN
                                       FFM%NNVAR2_SIC(INTYP0)=FFM%NNVAR2_SIC(INTYP0)+1
                                       FFM%LVAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=FFM%NNVAR2_SIC(INTYP0)
                                       FFM%LFLAG_VAR_SIC(JRB,IRB,L,JNTYP0,INTYP0)=.TRUE.
                                    ENDIF
                                 ENDIF
                              ENDIF
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ELSE IF (FFM%DESC_TYPE.EQ.1) THEN
               DO JNTYP0=1, FF%MTYP
                  DO L=0, FFM%LMAX2
                     DO IRB=1, FFM%NRB2(L)
                        DO JRB=IRB, FFM%NRB2(L)
                           IF(LFLAG_DES(LVAR_HELP2(JRB,IRB,L,1,JNTYP0)).EQ.1) THEN
                              FFM%NNVAR2(INTYP0)=FFM%NNVAR2(INTYP0)+1
                              FFM%LVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=FFM%NNVAR2(INTYP0)
                              FFM%LFLAG_VAR(JRB,IRB,L,1,JNTYP0,INTYP0)=.TRUE.
                              IF(JRB.EQ.IRB) THEN
                                 FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=1.0_q
                              ELSE
                                 FFM%WVAR(JRB,IRB,L,1,JNTYP0,INTYP0)=SQRT(2.0_q)
                              ENDIF
                           ENDIF
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ENDIF
! Stop profiling.
            PROFILING_STOP('restruct_sparsdes_cur')
          END SUBROUTINE RESTRUCTURE_PS_SPARS_DES_CUR

! Allocate helping arrays.

          SUBROUTINE ALLOCATE_SPARSDES_CUR
            IMPLICIT NONE
! Local variables
            INTEGER                          :: MCOL_A_SPARSDES_CUR
            INTEGER                          :: MCOL_V_SPARSDES_CUR
            INTEGER                          :: MROW_A_SPARSDES_CUR
            INTEGER                          :: MROW_V_SPARSDES_CUR
! Define sizes of helping arrays.
#ifdef scaLAPACK
! Size for A_SPARSDES_CUR.
            PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%M=FFM%MMVAR2
            PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%N=FFM%MMVAR2
            PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%MB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%NB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%IRSRC=0
            PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%ICSRC=0
            CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%DESC,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%M,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%N, &
                 PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%MB,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%NB, &
                 PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%IRSRC,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%ICSRC, &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%LLD, &
                 PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%LOC_M,PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%LOC_N)
            MCOL_A_SPARSDES_CUR=PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%LOC_N
            MROW_A_SPARSDES_CUR=PAR_SUP_HANDLE%DESC_A_SPARSDES_CUR%LOC_M
! Size for V_SPARSDES_CUR.
            PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%M=FFM%MMVAR2
            PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%N=FFM%MMVAR2
            PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%MB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%NB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%IRSRC=0
            PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%ICSRC=0
            CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%DESC,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%M,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%N, &
                 PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%MB,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%NB, &
                 PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%IRSRC,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%ICSRC, &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%LLD, &
                 PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%LOC_M,PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%LOC_N)
            MCOL_V_SPARSDES_CUR=PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%LOC_N
            MROW_V_SPARSDES_CUR=PAR_SUP_HANDLE%DESC_V_SPARSDES_CUR%LOC_M
#else
! Size for A_SPARSDES_CUR.
            MCOL_A_SPARSDES_CUR=FFM%MMVAR2
            MROW_A_SPARSDES_CUR=FFM%MMVAR2
! Size for V_SPARSDES_CUR.
            MCOL_V_SPARSDES_CUR=FFM%MMVAR2
            MROW_V_SPARSDES_CUR=FFM%MMVAR2
#endif
            IF(ALLOCATED(A_SPARSDES_CUR)) THEN
               DEALLOCATE(A_SPARSDES_CUR)
            ENDIF
            ALLOCATE (A_SPARSDES_CUR(1:MROW_A_SPARSDES_CUR,1:MCOL_A_SPARSDES_CUR))
            IF(ALLOCATED(EIGENVALUE)) THEN
               DEALLOCATE(EIGENVALUE)
            ENDIF
            ALLOCATE (EIGENVALUE(1:FFM%MMVAR2))
            IF(ALLOCATED(LFLAG_DES)) THEN
               DEALLOCATE(LFLAG_DES)
            ENDIF
            ALLOCATE (LFLAG_DES(1:FFM%MMVAR2))
            IF(ALLOCATED(LVAR_HELP1)) THEN
               DEALLOCATE(LVAR_HELP1)
            ENDIF
            ALLOCATE (LVAR_HELP1(1:FFM%MMVAR2))
            IF(ALLOCATED(LVAR_HELP2)) THEN
               DEALLOCATE(LVAR_HELP2)
            ENDIF
            ALLOCATE (LVAR_HELP2(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP,1:FF%MTYP))
            IF(ALLOCATED(PIL)) THEN
               DEALLOCATE(PIL)
            ENDIF
            ALLOCATE (PIL(1:FFM%MMVAR2))
            IF(ALLOCATED(PS_HELP)) THEN
               DEALLOCATE(PS_HELP)
            ENDIF
            ALLOCATE (PS_HELP(1:FFM%MMVAR2))
            IF(ALLOCATED(U_HELP)) THEN
               DEALLOCATE(U_HELP)
            ENDIF
            ALLOCATE (U_HELP(1:MROW_V_SPARSDES_CUR,1:MCOL_V_SPARSDES_CUR))
            IF(ALLOCATED(V_HELP)) THEN
               DEALLOCATE(V_HELP)
            ENDIF
            ALLOCATE (V_HELP(1:MROW_V_SPARSDES_CUR,1:MCOL_V_SPARSDES_CUR))
            IF(ALLOCATED(V_SPARSDES_CUR)) THEN
               DEALLOCATE(V_SPARSDES_CUR)
            ENDIF
            ALLOCATE (V_SPARSDES_CUR(1:MROW_V_SPARSDES_CUR,1:MCOL_V_SPARSDES_CUR))
          END SUBROUTINE ALLOCATE_SPARSDES_CUR

! Deallocate helping arrays.

          SUBROUTINE DEALLOCATE_SPARSDES_CUR
            IMPLICIT NONE
            IF(ALLOCATED(A_SPARSDES_CUR)) THEN
               DEALLOCATE(A_SPARSDES_CUR)
            ENDIF
            IF(ALLOCATED(EIGENVALUE)) THEN
               DEALLOCATE(EIGENVALUE)
            ENDIF
            IF(ALLOCATED(LFLAG_DES)) THEN
               DEALLOCATE(LFLAG_DES)
            ENDIF
            IF(ALLOCATED(LVAR_HELP1)) THEN
               DEALLOCATE(LVAR_HELP1)
            ENDIF
            IF(ALLOCATED(LVAR_HELP2)) THEN
               DEALLOCATE(LVAR_HELP2)
            ENDIF
            IF(ALLOCATED(PIL)) THEN
               DEALLOCATE(PIL)
            ENDIF
            IF(ALLOCATED(PS_HELP)) THEN
               DEALLOCATE(PS_HELP)
            ENDIF
            IF(ALLOCATED(U_HELP)) THEN
               DEALLOCATE(U_HELP)
            ENDIF
            IF(ALLOCATED(V_HELP)) THEN
               DEALLOCATE(V_HELP)
            ENDIF
            IF(ALLOCATED(V_SPARSDES_CUR)) THEN
               DEALLOCATE(V_SPARSDES_CUR)
            ENDIF
          END SUBROUTINE DEALLOCATE_SPARSDES_CUR

        END SUBROUTINE SPARS_DES_CUR
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Subroutine throwing away the problematic samples that can cause the overcompleteness
!****************************************************************************************************

        SUBROUTINE SPARS_ICUR (EPS_LOW,TIM,LAPACKWORK,PAR_SUP_HANDLE,MEM1,LOGF,FF,FFM,A,B,ISYS,LADD,LB,LNITYP,LNIONS,LNTYP,LSYS,MCONF,MITYP,MIONS,MTYP, &
                   NCONF,NCONF_SYS,NITYP,NIONS,NSTEP,NSYS,NTYP,POSION,TIFOR,TOTEN,TSIF,TYPE,OMEGA,SZNAM2,SZNAM2_INPUT)
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: TIME, LAPACK_WORK, PARALLEL_SUPER, MEMORY, LOG_PAR,FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (TIME)                      :: TIM
          TYPE (LAPACK_WORK)               :: LAPACKWORK
          TYPE (PARALLEL_SUPER)            :: PAR_SUP_HANDLE
          TYPE (MEMORY)                    :: MEM1
          TYPE (LOG_PAR)                   :: LOGF
          TYPE (FF_PAR)                    :: FF
          TYPE (FFM_PAR)                   :: FFM
          REAL(q)          , INTENT(IN)    :: EPS_LOW
          INTEGER          , INTENT(IN)    :: MITYP
          INTEGER          , INTENT(IN)    :: MCONF
          INTEGER          , INTENT(IN)    :: MIONS
          INTEGER          , INTENT(IN)    :: MTYP
          INTEGER          , INTENT(IN)    :: NSTEP
          INTEGER          , INTENT(IN)    :: NSYS
! Input and/or output variables
          REAL(q)          , INTENT(INOUT) :: A(:,:,:) !(1:3,1:3,1:MCONF)
          REAL(q)          , INTENT(INOUT) :: B(:,:,:) !(1:3,1:3,1:MCONF)
          INTEGER          , INTENT(INOUT) :: ISYS(:) !(1:MCONF)
          INTEGER          , INTENT(INOUT) :: LADD(:,:) !(1:MTYP,1:MCONF)
          INTEGER          , INTENT(INOUT) :: LB(:,:) !(1:MIONS,1:MCONF)
          INTEGER          , INTENT(INOUT) :: LNITYP(:,:) !(1:MIONS,1:MCONF)
          INTEGER          , INTENT(INOUT) :: LNIONS(:,:,:) !(1:MITYP,1:MTYP,1:MCONF)
          INTEGER          , INTENT(INOUT) :: LNTYP(:,:) !(1:MIONS,1:MCONF)
          INTEGER          , INTENT(INOUT) :: LSYS(:) !(1:MCONF)
          INTEGER          , INTENT(INOUT) :: NCONF
          INTEGER          , INTENT(INOUT) :: NCONF_SYS(:) !(1:NSYS)
          INTEGER          , INTENT(INOUT) :: NITYP(:,:) !(1:MTYP,1:MCONF)
          INTEGER          , INTENT(INOUT) :: NIONS(:) !(1:MCONF)
          INTEGER          , INTENT(INOUT) :: NTYP(:) !(1:MCONF)
          REAL(q)          , INTENT(INOUT) :: POSION(:,:,:) !(1:3,1:MIONS,1:MCONF)
          CHARACTER(LEN=40), INTENT(INOUT) :: SZNAM2(:) !(1:MCONF)
          CHARACTER(LEN=40), INTENT(INOUT) :: SZNAM2_INPUT(:) !(1:MCONF)
          REAL(q)          , INTENT(INOUT) :: TIFOR(:,:,:) !(1:3,1:MIONS,1:MCONF)
          REAL(q)          , INTENT(INOUT) :: TOTEN(:) !(1:MCONF)
          REAL(q)          , INTENT(INOUT) :: TSIF(:,:,:) !(1:3,1:3,1:MCONF)
          CHARACTER (LEN=2), INTENT(INOUT) :: TYPE(:) !(1:MTYP)
          REAL(q)          , INTENT(INOUT) :: OMEGA(:) !(1:MCONF)
! Local variables
          REAL(q)                          :: CPUTIM0,CPUTIM1
          REAL(q)          , ALLOCATABLE   :: FMAT_FFM_TRANSPOSED(:,:)
          REAL(q)          , ALLOCATABLE   :: EIGENVALUE(:)
          REAL(q)          , ALLOCATABLE   :: EIGENVECTOR(:,:)
          REAL(q)                          :: EPS
          REAL(q)                          :: EPS_HIGH
          INTEGER                          :: INTYP0
          INTEGER                          :: JCONF
          INTEGER                          :: JNTYP0
          INTEGER          , ALLOCATABLE   :: LFLAG_BASIS(:,:)
          INTEGER          , ALLOCATABLE   :: LFLAG_CONF(:)
          INTEGER          , ALLOCATABLE   :: LDEL_BASIS(:,:)
          INTEGER          , ALLOCATABLE   :: LDEL_CONF(:)
          LOGICAL                          :: LREBUILD
          INTEGER          , ALLOCATABLE   :: NB0(:)
          INTEGER          , ALLOCATABLE   :: NDEL_BASIS(:)
          INTEGER                          :: NDEL_BASIS_TOT
          INTEGER                          :: NDEL_CONF
          INTEGER                          :: NDEL_CONF3
          INTEGER          , ALLOCATABLE   :: NRANK_HIGH(:)
          INTEGER          , ALLOCATABLE   :: NRANK_LOW(:)
          REAL(q)          , ALLOCATABLE   :: PIL_HIGH(:,:)
          REAL(q)          , ALLOCATABLE   :: PIL_LOW(:,:)
          REAL(q)          , ALLOCATABLE   :: PILC(:)
          REAL(q)                          :: RMEM_CUR
          REAL(q)                          :: RMEM_RST
          REAL(q)                          :: RMEM_SVD
          REAL(q)          , ALLOCATABLE   :: SINGULARVALUE(:)
          REAL(q)          , ALLOCATABLE   :: SOAP(:,:)
          REAL(q)          , ALLOCATABLE   :: SOAP_TRANSPOSED(:,:)
          REAL(q)          , ALLOCATABLE   :: U(:,:)
          REAL(q)          , ALLOCATABLE   :: V_ALL(:,:)
          REAL(q)          , ALLOCATABLE   :: V_HIGH(:,:)
          REAL(q)          , ALLOCATABLE   :: V_LOW(:,:)
          REAL(q)                          :: VPUTIM0
          REAL(q)                          :: VPUTIM1
          REAL(q)                          :: WMAX
          REAL(q)                          :: WMIN
          REAL(q)          , ALLOCATABLE   :: WRATIO_OLD(:)
          REAL(q)          , ALLOCATABLE   :: WRATIO_NEW(:)
! Start profiling
          PROFILING_START('spars_icur')
! Measure the initial times
          CALL VTIME (VPUTIM0,CPUTIM0)
! Initialize the memory usage
          CALL INIT_RMEM_SPARS
! Constants
          CALL SET_CONSTANTS
! Allocate arrays necessary for CUR
          CALL ALLOCATE_CUR_ARRAY
! Allocate arrays necessary for SVD
          CALL ALLOCATE_SVD_ARRAY
! Initialize parameters
          CALL INIT_VARIABLES
! Element loop
          DO INTYP0=1, FF%MTYP
! Copy SOAP matrix
             CALL COPY_SOAP_SPARS
! Check the eigenvalues if necessary
             CALL EIGEN_SOAP_SPARS (WRATIO_OLD(INTYP0))
! If FF%ISVD=1, leverage scorings are calculated using diagonalization.
! If FF%ISVD=2, leverage scorings are calculated using SVD.
! Since the SOAP matrix is symmetric, both methods should provide the same results.
             IF(FF%ISVD.EQ.2) THEN
! Copy SOAP matrix
                CALL COPY_SOAP_SPARS
! Singular value decomposition of covariance matrix
                CALL SVD_SOAP_SPARS
             ENDIF
! Calculations of leverage scorings
             CALL PIL_SPARS
          ENDDO
! Deallocate arrays necessary for SVD
          CALL DEALLOCATE_SVD_ARRAY
! Select samples that should be deleted.
          CALL SELECT_SAMPLES_SPARS
! Restructuring of data
          CALL RESTRUCTURE_SPARS
! Allocate arrays necessary for SVD again
          CALL ALLOCATE_SVD_ARRAY
! Element loop, again
          DO INTYP0=1, FF%MTYP
! Check the eigenvalues if necessary
             IF(FF%LGENFF) THEN
                CALL COPY_SOAP_SPARS
                CALL EIGEN_SOAP_SPARS (WRATIO_NEW(INTYP0))
             ELSE
                WRATIO_NEW(INTYP0)=0.0_q
             ENDIF
! Calculate the inverse matrix
             IF(FF%LGENFF) THEN
! SOAP must be copied if LU factorization is used
                CALL COPY_SOAP_SPARS
             ENDIF
          ENDDO
! Deallocate arrays necessary for SVD again
          CALL DEALLOCATE_SVD_ARRAY
! Output
          CALL LOGLINE_SPRSC(FF, FFM, LOGF, NB0, NCONF, NCONF + NDEL_CONF)
! Deallocate
          CALL DEALLOCATE_CUR_ARRAY
! Record the memory usage
          CALL COUNT_RMEM_SPARS
! Measure the initial times
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(5)=TIM%CPUTIM(5)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(5)=TIM%VPUTIM(5)+VPUTIM1-VPUTIM0
! Stop profiling
          PROFILING_STOP('spars_icur')

          CONTAINS

! Initialize variables that count the memory usage

          SUBROUTINE INIT_RMEM_SPARS
            IMPLICIT NONE
            RMEM_CUR=0.0_q
            RMEM_SVD=0.0_q
            RMEM_RST=0.0_q
          END SUBROUTINE INIT_RMEM_SPARS

! Set constants for the sparsification.

          SUBROUTINE SET_CONSTANTS
             IMPLICIT NONE
             EPS=1E-12_q
             EPS_HIGH=1E-04_q
          END SUBROUTINE SET_CONSTANTS

! Initialization of variables.

          SUBROUTINE INIT_VARIABLES
             IMPLICIT NONE
             NB0(1:FF%MTYP)=FFM%NB(1:FF%MTYP)
          END SUBROUTINE INIT_VARIABLES

! Copy SOAP matrix
! scaLAPACK parallel

          SUBROUTINE COPY_SOAP_SPARS
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IB
            PROFILING_START ('soap_spars')
            DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
               CALL PDCOPY(FFM%NB(INTYP0),FFM%SOAP(1,1,INTYP0),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1, &
                    SOAP(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
#else
               CALL DCOPY (FFM%NB(INTYP0),FFM%SOAP(1,IB,INTYP0),1,SOAP(1,IB),1)
#endif
            ENDDO
            PROFILING_STOP ('soap_spars')
          END SUBROUTINE COPY_SOAP_SPARS

! Calculations of eigenvalues of covariance matrix

          SUBROUTINE EIGEN_SOAP_SPARS (WRATIO)
            IMPLICIT NONE
! Input, output variables
            REAL(q), INTENT(INOUT) :: WRATIO
! Local variables
            INTEGER                          :: IB
            INTEGER                          :: INFO
#ifdef scaLAPACK
! First, calculate the size of work array
            PROFILING_START('pdsyev_eigen_cmat_spars')
            CALL SCALAPACK_WORK_ARRAY_SIZE_PDSYEV_INIT(PAR_SUP_HANDLE%SCAWORK)
            CALL PDSYEV('V','U',FFM%NB(INTYP0),SOAP(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                 EIGENVALUE(1),EIGENVECTOR(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                 PAR_SUP_HANDLE%SCAWORK%WORK(1),PAR_SUP_HANDLE%SCAWORK%LWORK,PAR_SUP_HANDLE%SCAWORK%INFO)
            CALL SCALAPACK_WORK_ARRAY_SIZE_PDSYEV_FIN(PAR_SUP_HANDLE%SCAWORK)
! Then, calculate the eigenvalues and eigenvectors of covariance matrix
            CALL SCALAPACK_WORK_ARRAY_PDSYEV_INIT(PAR_SUP_HANDLE%SCAWORK)
            CALL PDSYEV('V','U',FFM%NB(INTYP0),SOAP(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                 EIGENVALUE(1),EIGENVECTOR(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                 PAR_SUP_HANDLE%SCAWORK%WORK(1),PAR_SUP_HANDLE%SCAWORK%LWORK,PAR_SUP_HANDLE%SCAWORK%INFO)
            CALL SCALAPACK_WORK_ARRAY_PDSYEV_FIN(PAR_SUP_HANDLE%SCAWORK)
            PROFILING_STOP ('pdsyev_eigen_cmat_spars')
#else
            PROFILING_START('dsyev_eigen_cmat_spars')
! First, calculate the size of work array
            CALL LAPACK_WORK_ARRAY_SIZE_DSYEV_INIT(LAPACKWORK)
            DO IB=1, FFM%NB(INTYP0)
               EIGENVECTOR(1:FFM%NB(INTYP0),IB)=SOAP(1:FFM%NB(INTYP0),IB)
            ENDDO
            CALL DSYEV ('V','U',FFM%NB(INTYP0),EIGENVECTOR(1,1),FFM%MB,EIGENVALUE(1),LAPACKWORK%WORK(1),LAPACKWORK%LWORK,LAPACKWORK%INFO)
            CALL LAPACK_WORK_ARRAY_SIZE_DSYEV_FIN(LAPACKWORK)
! Then, calculate the eigenvalues and eigenvectors of covariance matrix
            CALL LAPACK_WORK_ARRAY_DSYEV_INIT(LAPACKWORK)
            CALL DSYEV ('V','U',FFM%NB(INTYP0),EIGENVECTOR(1,1),FFM%MB,EIGENVALUE(1),LAPACKWORK%WORK(1),LAPACKWORK%LWORK,LAPACKWORK%INFO)
            CALL LAPACK_WORK_ARRAY_DSYEV_FIN(LAPACKWORK)
            PROFILING_STOP ('dsyev_eigen_cmat_spars')
#endif
! Calculate the ratio of minimum eigenvalue to maximum one
            WMAX=ABS(EIGENVALUE(1))
            WMIN=ABS(EIGENVALUE(1))
            DO IB=2, FFM%NB(INTYP0), 1
               WMAX=MAX(WMAX,ABS(EIGENVALUE(IB)))
               WMIN=MIN(WMIN,ABS(EIGENVALUE(IB)))
            ENDDO
            WRATIO=WMIN/WMAX
          END SUBROUTINE EIGEN_SOAP_SPARS

! Singular value decomposition of SOAP matrix

          SUBROUTINE SVD_SOAP_SPARS
            IMPLICIT NONE
! Local variables
            INTEGER                          :: INFO
#ifdef scaLAPACK
            PROFILING_START('pdgesvd_svd_cmat_spars')
! First, calculate the size of work array
            CALL SCALAPACK_WORK_ARRAY_SIZE_PDGESVD_INIT(PAR_SUP_HANDLE%SCAWORK)
            CALL PDGESVD('V','V',FFM%NB(INTYP0),FFM%NB(INTYP0),SOAP(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,SINGULARVALUE(1), &
                 U(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,V_ALL(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                 PAR_SUP_HANDLE%SCAWORK%WORK,PAR_SUP_HANDLE%SCAWORK%LWORK,PAR_SUP_HANDLE%SCAWORK%INFO)
            CALL SCALAPACK_WORK_ARRAY_SIZE_PDGESVD_FIN(PAR_SUP_HANDLE%SCAWORK)
! Then, execute singular value decomposition of covariance matrix
            CALL SCALAPACK_WORK_ARRAY_PDGESVD_INIT(PAR_SUP_HANDLE%SCAWORK)
            CALL PDGESVD('V','V',FFM%NB(INTYP0),FFM%NB(INTYP0),SOAP(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,SINGULARVALUE(1), &
                 U(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,V_ALL(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                 PAR_SUP_HANDLE%SCAWORK%WORK,PAR_SUP_HANDLE%SCAWORK%LWORK,PAR_SUP_HANDLE%SCAWORK%INFO)
            CALL SCALAPACK_WORK_ARRAY_PDGESVD_FIN(PAR_SUP_HANDLE%SCAWORK)
            PROFILING_STOP('pdgesvd_svd_cmat_spars')
#else
            PROFILING_START('dgesvd_svd_cmat_spars')
! First, calculate the size of work array
            CALL LAPACK_WORK_ARRAY_SIZE_DGESVD_INIT(LAPACKWORK)
            CALL DGESVD('A','A',FFM%NB(INTYP0),FFM%NB(INTYP0),SOAP(1,1),FFM%MB,SINGULARVALUE(1),U(1,1),FFM%MB, &
                 V_ALL(1,1),FFM%MB,LAPACKWORK%WORK(1),LAPACKWORK%LWORK,LAPACKWORK%INFO)
            CALL LAPACK_WORK_ARRAY_SIZE_DGESVD_FIN(LAPACKWORK)
! Then, execute singular value decomposition of covariance matrix
            CALL LAPACK_WORK_ARRAY_DGESVD_INIT(LAPACKWORK)
            CALL DGESVD('A','A',FFM%NB(INTYP0),FFM%NB(INTYP0),SOAP(1,1),FFM%MB,SINGULARVALUE(1),U(1,1),FFM%MB, &
                 V_ALL(1,1),FFM%MB,LAPACKWORK%WORK(1),LAPACKWORK%LWORK,LAPACKWORK%INFO)
            CALL LAPACK_WORK_ARRAY_DGESVD_FIN(LAPACKWORK)
            PROFILING_STOP('dgesvd_svd_cmat_spars')
#endif
          END SUBROUTINE SVD_SOAP_SPARS

! Calculations of leverage scoring.

          SUBROUTINE PIL_SPARS
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IB
            INTEGER                          :: IERR
            INTEGER                          :: LOCVAR_COL
            INTEGER                          :: LOCVAR_ROW
            INTEGER                          :: TEST_COL
            INTEGER                          :: TEST_ROW
            PROFILING_START('pil_spars')
! Maximum and minimum eigen- or singular values.
! If FF%ISVD=1, the values are given from the eigenvalues provided by the diagonalization.
            IF(FF%ISVD.EQ.1) THEN
               WMAX=ABS(EIGENVALUE(1))
               WMIN=ABS(EIGENVALUE(1))
               DO IB=2, FFM%NB(INTYP0), 1
                  WMAX=MAX(WMAX,ABS(EIGENVALUE(IB)))
                  WMIN=MIN(WMIN,ABS(EIGENVALUE(IB)))
               ENDDO
! If FF%ISVD=2, the values are given from the singular provided by the diagonalization. 
            ELSE IF(FF%ISVD.EQ.2) THEN
               WMAX=ABS(SINGULARVALUE(1))
               WMIN=ABS(SINGULARVALUE(1))
               DO IB=2, FFM%NB(INTYP0), 1
                  WMAX=MAX(WMAX,ABS(SINGULARVALUE(IB)))
                  WMIN=MIN(WMIN,ABS(SINGULARVALUE(IB)))
               ENDDO
            ENDIF
! Calculate high and low ranks.
! If FF%ISVD=1, both ranks are provided from the eigenvalues.
            IF(FF%ISVD.EQ.1) THEN
               NRANK_HIGH(INTYP0)=FFM%NB(INTYP0)
               DO IB=FFM%NB(INTYP0), 1, -1
                  IF(EIGENVALUE(IB)/WMAX.LT.EPS_HIGH) THEN
                     NRANK_HIGH(INTYP0)=FFM%NB(INTYP0)-IB+1
                     EXIT
                  ENDIF
               ENDDO
               NRANK_LOW(INTYP0)=FFM%NB(INTYP0)+1
               DO IB=FFM%NB(INTYP0), 1, -1
                  IF(EIGENVALUE(IB)/WMAX.LT.EPS_LOW ) THEN
                     NRANK_LOW(INTYP0)=FFM%NB(INTYP0)-IB+1
                     EXIT
                  ENDIF
               ENDDO
! If FF%ISVD=2, both ranks are provided from the singularvalues.
            ELSE IF(FF%ISVD.EQ.2) THEN
               NRANK_HIGH(INTYP0)=FFM%NB(INTYP0)
               DO IB=1, FFM%NB(INTYP0)
                  IF(SINGULARVALUE(IB)/WMAX.LT.EPS_HIGH) THEN
                     NRANK_HIGH(INTYP0)=IB
                     EXIT
                  ENDIF
               ENDDO
               NRANK_LOW(INTYP0)=FFM%NB(INTYP0)+1
               DO IB=1, FFM%NB(INTYP0)
                  IF(SINGULARVALUE(IB)/WMAX.LT.EPS_LOW ) THEN
                     NRANK_LOW(INTYP0)=IB
                     EXIT
                  ENDIF
               ENDDO
            ENDIF
! The number of the basis sets that must be discarded.
            NDEL_BASIS(INTYP0)=FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1
            IF(NDEL_BASIS(INTYP0).EQ.0) THEN
               NRANK_LOW(INTYP0)=FFM%NB(INTYP0)
            ENDIF
! Calculate leverage scorings as indicators of correlations with high and low rank eigenvalues.
! Initialization of leverage scorings
            PIL_HIGH(1:FFM%MB,INTYP0)=0.0_q
            PIL_LOW(1:FFM%MB,INTYP0)=0.0_q
            V_HIGH=0.0_q
            V_LOW=0.0_q
! Determine the left-singular vectors.
! If FF%ISVD=1, these values are provided from the eigenvectors given from the diagonalization.
            IF(FF%ISVD.EQ.1) THEN
! Copy the eigenvectors with small eigenvalues.
               DO IB=1, FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1
#ifdef scaLAPACK
                  CALL PDCOPY(FFM%NB(INTYP0),EIGENVECTOR(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1, V_LOW(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
#else
                  CALL DCOPY(FFM%NB(INTYP0),EIGENVECTOR(1,IB),1,V_LOW(1,IB),1)
#endif
               ENDDO
! Copy the eigenvectors with large eigenvalues.
               DO IB=1, NRANK_HIGH(INTYP0)
#ifdef scaLAPACK
                  CALL PDCOPY(FFM%NB(INTYP0),EIGENVECTOR(1,1),1,FFM%NB(INTYP0)-NRANK_HIGH(INTYP0)+IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1, V_HIGH(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
#else
                  CALL DCOPY(FFM%NB(INTYP0),EIGENVECTOR(1,FFM%NB(INTYP0)-NRANK_HIGH(INTYP0)+IB),1,V_HIGH(1,IB),1)
#endif
               ENDDO
! If FF%ISVD=2, these values are provided from the left-singular matrices given from the SVD.
            ELSE IF(FF%ISVD.EQ.2) THEN
               DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                  CALL PDCOPY(NRANK_HIGH(INTYP0),V_ALL(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1,V_HIGH(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
                  CALL PDCOPY(FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1,V_ALL(1,1),NRANK_LOW(INTYP0),IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1,V_LOW(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
#else
                  CALL DCOPY(NRANK_HIGH(INTYP0),V_ALL(1,IB),1,V_HIGH(1,IB),1)
                  CALL DCOPY(FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1,V_ALL(NRANK_LOW(INTYP0),IB),1,V_LOW(1,IB),1)
#endif
               ENDDO
            ENDIF
! Calculation of the leverage scoring for large eigenvalues or singularvalues.
! Because of the order of the matrices are different between the diagonalization and the SVD, 
! the calculation method is a little bit different.
            IF(FF%ISVD.EQ.1) THEN
#ifdef scaLAPACK
               CALL PDGEMM('N','T',FFM%NB(INTYP0),FFM%NB(INTYP0),NRANK_HIGH(INTYP0),1.0_q,V_HIGH(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                    V_HIGH(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,0.0_q,U(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
#else
               CALL DGEMM ('N','T',FFM%NB(INTYP0),FFM%NB(INTYP0),NRANK_HIGH(INTYP0),1.0_q,V_HIGH(1,1), &
                    FFM%MB,V_HIGH,FFM%MB,0.0_q,U(1,1),FFM%MB)
#endif
            ELSE IF(FF%ISVD.EQ.2) THEN
#ifdef scaLAPACK
               CALL PDGEMM('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),NRANK_HIGH(INTYP0),1.0_q,V_HIGH(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                    V_HIGH(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,0.0_q,U(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
#else
               CALL DGEMM ('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),NRANK_HIGH(INTYP0),1.0_q,V_HIGH(1,1), &
                 FFM%MB,V_HIGH,FFM%MB,0.0_q,U(1,1),FFM%MB)
#endif
            ENDIF
! Then, the leverage scorings are calculated by the same method.
            DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
               TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
               TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW.OR.PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                  CYCLE
               ENDIF
               LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_SOAP_FFM%MB)
               LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
#else
               LOCVAR_ROW=IB
               LOCVAR_COL=IB
#endif
               PIL_HIGH(IB,INTYP0)=U(LOCVAR_ROW,LOCVAR_COL)
            ENDDO
! Calculation of the leverage scoring for small eigenvalues or singular values.
! Similarly to the leverage scoring for large eigenvalues or singular velues, 
! calculation method is a little bit different between the diagonalization and SVD.
            IF(FF%ISVD.EQ.1) THEN
#ifdef scaLAPACK
               CALL PDGEMM('N','T',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1,1.0_q, &
                    V_LOW(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,V_LOW(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                    0.0_q,U(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
#else
               CALL DGEMM ('N','T',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1,1.0_q,V_LOW(1,1), &
                    FFM%MB,V_LOW,FFM%MB,0.0_q,U(1,1),FFM%MB)
#endif
            ELSE IF(FF%ISVD.EQ.2) THEN
#ifdef scaLAPACK
               CALL PDGEMM('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1,1.0_q, &
                    V_LOW(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,V_LOW(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC, &
                    0.0_q,U(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
#else
               CALL DGEMM ('T','N',FFM%NB(INTYP0),FFM%NB(INTYP0),FFM%NB(INTYP0)-NRANK_LOW(INTYP0)+1,1.0_q,V_LOW(1,1), &
                    FFM%MB,V_LOW,FFM%MB,0.0_q,U(1,1),FFM%MB)
#endif
            ENDIF
! Then, the method is the same for the both cases.
            DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
               TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
               TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW.OR.PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                  CYCLE
               ENDIF 
               LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_SOAP_FFM%MB)
               LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
#else
               LOCVAR_ROW=IB
               LOCVAR_COL=IB
#endif
               PIL_LOW(IB,INTYP0)=U(LOCVAR_ROW,LOCVAR_COL)
            ENDDO
#ifdef scaLAPACK
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,PIL_HIGH(1,INTYP0),FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,PIL_LOW(1,INTYP0),FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
            PROFILING_STOP('pil_spars')
          END SUBROUTINE PIL_SPARS

! Select basis sets and configurations that should be deleted.

          SUBROUTINE SELECT_SAMPLES_SPARS
            USE ml_ff_tutor, ONLY: ml_tutor, isError, STORAGE_LRC
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IB
            INTEGER                          :: ICONF
            INTEGER                          :: IDEL_BASIS 
            INTEGER                          :: IDEL_CONF
            INTEGER                          :: INTYP0_LOC
            INTEGER                          :: JB
            INTEGER                          :: JCONF 
            INTEGER                          :: NCONF_LOC
            REAL(q)                          :: PILMAX
            REAL(q)                          :: PILMIN
            INTEGER                          :: BASIS_HELP
            PROFILING_START('select_samples_spars')
            IF (FF%ISTART.EQ.3) THEN
               BASIS_HELP=FF%MCONF_NEW
            ELSE
               BASIS_HELP=MIN(FF%MCONF_NEW,FF%NSW)
            ENDIF
! Select the basis sets that must be thrown away to prevent the overcompleteness
            LFLAG_BASIS=1
            DO INTYP0_LOC=1, FF%MTYP
               IF(NDEL_BASIS(INTYP0_LOC).NE.0) THEN
                  DO IB=1, NDEL_BASIS(INTYP0_LOC)
                     PILMAX=0.0_q
                     IDEL_BASIS=0
                     DO JB=1, FFM%NB(INTYP0_LOC)
                        IF((PILMAX .LT. PIL_LOW(JB,INTYP0_LOC)) .AND.  &
                           (LFLAG_BASIS(JB,INTYP0_LOC) .EQ. 1)) THEN
                           IDEL_BASIS=JB
                           PILMAX=PIL_LOW(JB,INTYP0_LOC)
                        ENDIF
                     ENDDO
                     IF(IDEL_BASIS.NE.0) THEN
                        LFLAG_BASIS(IDEL_BASIS,INTYP0_LOC)=0
                     ENDIF
                  ENDDO
               ENDIF
            ENDDO
! If FF%LCONF_DISCARD=.TRUE., count the number of remaining configurations
            IF(FF%LCONF_DISCARD) THEN
               LFLAG_CONF=0
               DO INTYP0_LOC=1, FF%MTYP
                  DO IB=1, FFM%NB(INTYP0_LOC)
                     IF(LFLAG_BASIS(IB,INTYP0_LOC).EQ.1) THEN
                        LFLAG_CONF(FFM%LNCONF(IB,INTYP0_LOC))=1
                     ENDIF
                  ENDDO
               ENDDO
               NCONF_LOC=0
               DO ICONF=1, NCONF
                  IF(LFLAG_CONF(ICONF) .EQ. 1) THEN
                     NCONF_LOC=NCONF_LOC+1
                  ENDIF
               ENDDO
! Otherwise, set all flag as 1.
            ELSE
               LFLAG_CONF=1
               NCONF_LOC=NCONF
            ENDIF
! If FF%LCONF_DISCARD=.TRUE., decrease the configurations to satisfy the number less than MCONF.
! If the number of remaining configurations is larger then the predetermined basis sets should be deleted further.
            IF(FF%LCONF_DISCARD) THEN
               IF(NCONF_LOC .GT. FF%MCONF-BASIS_HELP) THEN
! First, evaluate the leverage scoring of each configuration
                  PILC=0.0_q
                  DO INTYP0_LOC=1, FF%MTYP
                     DO IB=1, FFM%NB(INTYP0_LOC)
                        PILC(FFM%LNCONF(IB,INTYP0_LOC))=PILC(FFM%LNCONF(IB,INTYP0_LOC))+PIL_HIGH(IB,INTYP0_LOC)
                     ENDDO
                  ENDDO
! Then, select the configurations with minimum leverage scoring as samples that will be thrown away.
                  DO ICONF=1, NCONF_LOC-(FF%MCONF-BASIS_HELP)
                     PILMIN=1E+16_q
                     IDEL_CONF=0
                     DO JCONF=1, NCONF
                        IF((PILMIN.GT.PILC(JCONF)) .AND. &
                           (LFLAG_CONF(JCONF).EQ.1)) THEN
                           PILMIN=PILC(JCONF)
                           IDEL_CONF=JCONF
                        ENDIF
                     ENDDO
                     IF(IDEL_CONF.NE.0) THEN
                        LFLAG_CONF(IDEL_CONF)=0
                     ENDIF
                  ENDDO
! Then, select the basis sets in the configurations that should be deleted.
                  DO INTYP0_LOC=1, FF%MTYP
                     DO IB=1, FFM%NB(INTYP0_LOC)
                        IF((LFLAG_BASIS(IB,INTYP0_LOC).EQ.1) .AND. &
                           (LFLAG_CONF(FFM%LNCONF(IB,INTYP0_LOC)).EQ.0)) THEN
                           LFLAG_BASIS(IB,INTYP0_LOC)=0
                        ENDIF
                     ENDDO
                  ENDDO
               ENDIF
! Otherwise, stop the calculation if NCONF_LOC=NCONF>MCONF-MCONF_NEW
            ELSE
!               IF(NCONF_LOC .GT. FF%MCONF-FF%MCONF_NEW) THEN
               IF(NCONF_LOC .GT. FF%MCONF) THEN
                  CALL ml_tutor%error("Not enough storage reserved for &
                     &reference structures, please increase ML_MCONF.")
               ENDIF
            ENDIF 
! Count the numbers of basis sets that will be thrown away.
            DO INTYP0_LOC=1, FF%MTYP
               NDEL_BASIS(INTYP0_LOC)=0
               DO IB=1, FFM%NB(INTYP0_LOC)
                  IF(LFLAG_BASIS(IB,INTYP0_LOC).EQ.0) THEN
                     NDEL_BASIS(INTYP0_LOC)=NDEL_BASIS(INTYP0_LOC)+1
                  ENDIF
               ENDDO
            ENDDO
! If FF%LBASIS_DISCARD=.TRUE., the basis sets are discarded to satisfy NB < MB.
! basis sets need to be thrown away additionally.
            IF(FF%LBASIS_DISCARD) THEN
               DO INTYP0_LOC=1, FF%MTYP
                  IF(FFM%NB(INTYP0_LOC)-NDEL_BASIS(INTYP0_LOC).GT.FFM%MB_TARGET) THEN
                     DO IB=1, (FFM%NB(INTYP0_LOC)-NDEL_BASIS(INTYP0_LOC)-FFM%MB_TARGET)
                        PILMAX=0.0_q
                        IDEL_BASIS=0
                        DO JB=1, FFM%NB(INTYP0_LOC)
                           IF((PILMAX.LT.PIL_LOW(JB,INTYP0_LOC)) .AND.  &
                              (LFLAG_BASIS(JB,INTYP0_LOC).EQ.1)) THEN
                              IDEL_BASIS=JB
                              PILMAX=PIL_LOW(JB,INTYP0_LOC)
                           ENDIF
                        ENDDO
                        IF(IDEL_BASIS.NE.0) THEN
                           LFLAG_BASIS(IDEL_BASIS,INTYP0_LOC)=0
                        ENDIF
                     ENDDO
                  ENDIF
               ENDDO
! Otherwise, stop the calculation when NB > MB.
            ELSE
               DO INTYP0_LOC=1, FF%MTYP
                  IF(FFM%NB(INTYP0_LOC)-NDEL_BASIS(INTYP0_LOC).GT.FFM%MB_TARGET) THEN
                     CALL ml_tutor%write(isError, STORAGE_LRC)
                  ENDIF
               ENDDO
            ENDIF
! Finally, count the number of deleting basis sets and configurations and make the lists
            NDEL_CONF=0
            DO ICONF=1, NCONF
               IF(LFLAG_CONF(ICONF).EQ.0) THEN
                  NDEL_CONF=NDEL_CONF+1
                  LDEL_CONF(NDEL_CONF)=ICONF
               ENDIF
            ENDDO
            NDEL_BASIS_TOT=0
            DO INTYP0_LOC=1, FF%MTYP
               NDEL_BASIS(INTYP0_LOC)=0
               DO IB=1, FFM%NB(INTYP0_LOC)
                  IF(LFLAG_BASIS(IB,INTYP0_LOC).EQ.0) THEN
                     NDEL_BASIS(INTYP0_LOC)=NDEL_BASIS(INTYP0_LOC)+1
                     LDEL_BASIS(NDEL_BASIS(INTYP0_LOC),INTYP0_LOC)=IB
                  ENDIF
               ENDDO
               NDEL_BASIS_TOT=NDEL_BASIS_TOT+NDEL_BASIS(INTYP0_LOC)
            ENDDO
! Check the status of sparsification.
! If the number of remained basis set equals zero, the machine fails the sparsification.
! In this case, FF%ISPARS is set as .FALSE.
            FF%ISPARS=.TRUE.
             DO INTYP0_LOC=1, FF%MTYP
               IF(FFM%NB(INTYP0_LOC)-NDEL_BASIS(INTYP0_LOC).LE.0) THEN
                  FF%ISPARS=.FALSE.
               ENDIF
            ENDDO
! Check the necessity of data restructuring.
! If the sparsification is judged to be failed, the machine does not need to restructure the data.
! In this situation, LREBUID is set as .FALSE.
            IF(FF%ISPARS) THEN
               IF((NDEL_BASIS_TOT.NE.0).OR.(NDEL_CONF.NE.0)) THEN
                  LREBUILD=.TRUE.
               ELSE
                  LREBUILD=.FALSE.
               ENDIF
            ENDIF
! Check the necessity of force field generation.
! If any of basis sets equals zero, the machine cannot generate force fields.
! In this case, FF%LGENFF is changed to be .FALSE.
            DO INTYP0_LOC=1, FF%MTYP
               IF(FFM%NB(INTYP0_LOC)-NDEL_BASIS(INTYP0_LOC).LE.1) THEN
                  FF%LGENFF=.FALSE.
               ENDIF
            ENDDO
! Check the necessity of the calculations of variances in training data.
! If the number of remained configuration is zero, the machine cannot generate force field and cannot calculate the variances.
! In this case, the calculations are skipped.
            IF(NCONF-NDEL_CONF.LE.0) THEN
               FF%LGENFF=.FALSE.
               LREBUILD=.FALSE.
               FF%LSIG=.FALSE.
            ENDIF
            PROFILING_STOP('select_samples_spars')
          END SUBROUTINE SELECT_SAMPLES_SPARS

! Restructuring of data

          SUBROUTINE RESTRUCTURE_SPARS
            IMPLICIT NONE
! Local variables
            INTEGER                          :: IB
            INTEGER                          :: ICONF
            INTEGER                          :: IDATA
            INTEGER                          :: INIONS
            INTEGER                          :: INTYP0
            INTEGER                          :: IXYZ
            INTEGER                          :: JB
            INTEGER                          :: JXYZ
            INTEGER                          :: LOCVAR_COL
            INTEGER                          :: LOCVAR_ROW
            INTEGER                          :: NDEL_BASIS2
            INTEGER                          :: NDEL_BASIS3
            INTEGER                          :: NDEL_CONF2
            INTEGER                          :: NDEL_CONF3
            INTEGER                          :: TEST_COL
            INTEGER                          :: TEST_ROW
            PROFILING_START('restructure_spars')
            IF(LREBUILD) THEN
! Restructuring of the SOAP matrix
! Allocate necessary array for restructuring of SOAP matrix
#ifdef scaLAPACK
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                  CALL ALLOCATE_SOAP_TRANSPOSED
               ENDIF
#endif
! Copy the rows of SOAP matrix to deleted rows
               DO INTYP0=1, FF%MTYP
                  IF(NDEL_BASIS(INTYP0) .NE. 0) THEN
                     NDEL_BASIS2=0
                     NDEL_BASIS3=0
                     PROFILING_START('restructure_soap_row_spars')
                     DO IB=FFM%NB(INTYP0), 1, -1
                        NDEL_BASIS2=NDEL_BASIS2+1
                        IF(NDEL_BASIS2.EQ.NDEL_BASIS(INTYP0)+1) EXIT
                        IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                           NDEL_BASIS3=NDEL_BASIS3+1
! For both the cases of 1- and 2-dimesional scaLAPACK grids, column dimension is distributed.
! Hence, PDCOPY is necessary.
#ifdef scaLAPACK
                           CALL PDCOPY(FFM%NB(INTYP0),FFM%SOAP(1,1,INTYP0),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1, &
                                FFM%SOAP(1,1,INTYP0),1,LDEL_BASIS(NDEL_BASIS3,INTYP0),PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
! In case of non-scaLAPACK version, just call DCOPY.
#else
                           CALL DCOPY (FFM%NB(INTYP0),FFM%SOAP(1,IB,INTYP0),1, &
                                FFM%SOAP(1,LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0),1)
#endif
                        ENDIF
#ifdef scaLAPACK
                        TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                        IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
                        DO JB=1, FFM%NB(INTYP0)
                           TEST_ROW=MOD((JB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                           IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_ROW=GLOBAL2LOCAL(JB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_SOAP_FFM%MB)
                           FFM%SOAP(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
                        ENDDO
#else
                        FFM%SOAP(1:FFM%MB,IB,INTYP0)=0.0_q
#endif
                     ENDDO
                     PROFILING_STOP('restructure_soap_row_spars')
! Copy the columns of SOAP matrix to deleted columns
                     NDEL_BASIS2=0
                     NDEL_BASIS3=0
! for the parallel version we first have to transpose SOAP to be able to use PDCOPY
! If CONTEXT_WORLD%NDIM=1, restructuring can be simply executed similarly to the serial processor version
! because each process owns all row-dimensional data.
! If CONTEXT_WORLD%NDIM=2, however, matrix needs to be transposed to make PDCOPY available.
                     PROFILING_START('restructure_soap_col_spars')
#ifdef scaLAPACK
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                        CALL PDTRAN(FFM%NB(INTYP0),FFM%NB(INTYP0),1.0_q,FFM%SOAP(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,0.0_q,SOAP_TRANSPOSED(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
                        DO IB=FFM%NB(INTYP0), 1, -1
                           NDEL_BASIS2=NDEL_BASIS2+1
                           IF(NDEL_BASIS2.EQ.NDEL_BASIS(INTYP0)+1) EXIT
                           IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                              NDEL_BASIS3=NDEL_BASIS3+1
                              CALL PDCOPY(FFM%NB(INTYP0),SOAP_TRANSPOSED(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1, &
                                   SOAP_TRANSPOSED(1,1),1,LDEL_BASIS(NDEL_BASIS3,INTYP0),PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
                           ENDIF
                           TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                           IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
                           DO JB=1, FFM%NB(INTYP0)
                              TEST_ROW=MOD((JB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                              IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_ROW=GLOBAL2LOCAL(JB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_SOAP_FFM%MB)
                              SOAP_TRANSPOSED(LOCVAR_ROW,LOCVAR_COL)=0.0_q
                           ENDDO
                        ENDDO
                        CALL PDTRAN(FFM%NB(INTYP0),FFM%NB(INTYP0),1.0_q,SOAP_TRANSPOSED(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,0.0_q,FFM%SOAP(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC)
                     ELSE IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ. 1) THEN
                        DO IB=FFM%NB(INTYP0), 1, -1
                           NDEL_BASIS2=NDEL_BASIS2+1
                           IF(NDEL_BASIS2.EQ.NDEL_BASIS(INTYP0)+1) EXIT
                           IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                              NDEL_BASIS3=NDEL_BASIS3+1
                              DO JB=1, FFM%NB(INTYP0)
                                 TEST_COL=MOD((JB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                                 IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                    CYCLE
                                 ENDIF
                                 LOCVAR_COL=GLOBAL2LOCAL(JB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
                                 FFM%SOAP(LDEL_BASIS(NDEL_BASIS3,INTYP0),LOCVAR_COL,INTYP0)=FFM%SOAP(IB,LOCVAR_COL,INTYP0)
                                 FFM%SOAP(IB,LOCVAR_COL,INTYP0)=0.0_q
                              ENDDO
                           ENDIF
                        ENDDO
                     ENDIF
#else
                     DO IB=FFM%NB(INTYP0), 1, -1
                        NDEL_BASIS2=NDEL_BASIS2+1
                        IF(NDEL_BASIS2.EQ.NDEL_BASIS(INTYP0)+1) EXIT
                        IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                           NDEL_BASIS3=NDEL_BASIS3+1
                           DO JB=1, FFM%NB(INTYP0)
                              FFM%SOAP(LDEL_BASIS(NDEL_BASIS3,INTYP0),JB,INTYP0)=FFM%SOAP(IB,JB,INTYP0)
                              FFM%SOAP(IB,JB,INTYP0)=0.0_q
                           ENDDO
                        ENDIF
                     ENDDO
#endif
                     PROFILING_STOP('restructure_soap_col_spars')
                  ENDIF
               ENDDO
! Deallocate necessary array for restructuring of SOAP matrix
#ifdef scaLAPACK
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                  CALL DEALLOCATE_SOAP_TRANSPOSED
               ENDIF
#endif
! Restructure the design matrix
! Restructure the design matrix for the many-body fitting
               IF(FF%LMLMB) THEN
#ifdef scaLAPACK
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                     CALL ALLOCATE_FMAT_FFM_TRANSPOSED
                  ENDIF
#endif
! Restructure the array along the column (configurational) dimension
                  PROFILING_START('restructure_fmatmb_col_spars')
                  IF(NDEL_CONF .NE. 0) THEN
                     NDEL_CONF2=0
                     NDEL_CONF3=0
                     DO ICONF=NCONF, 1, -1
                        NDEL_CONF2=NDEL_CONF2+1
                        IF(NDEL_CONF2.EQ.NDEL_CONF+1) EXIT
                        IF(LFLAG_CONF(ICONF) .EQ. 1) THEN
                           NDEL_CONF3=NDEL_CONF3+1
                           DO INTYP0=1, FF%MTYP
#ifdef scaLAPACK
                              CALL PDCOPY(FFM%NB(INTYP0),FFM%FMAT(1,1,INTYP0),1,FFM%LTOTEN(ICONF),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1, &
                                   FFM%FMAT(1,1,INTYP0),1,FFM%LTOTEN(LDEL_CONF(NDEL_CONF3)),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1)
#else
                              CALL DCOPY (FFM%NB(INTYP0),FFM%FMAT(1,FFM%LTOTEN(ICONF),INTYP0),1, &
                                   FFM%FMAT(1,FFM%LTOTEN(LDEL_CONF(NDEL_CONF3)),INTYP0),1)
#endif
                              DO INIONS=1, NIONS(ICONF)
                                 DO IXYZ=1, 3
#ifdef scaLAPACK
                                    CALL PDCOPY(FFM%NB(INTYP0),FFM%FMAT(1,1,INTYP0),1,FFM%LTIFOR(IXYZ,INIONS,ICONF),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1, &
                                         FFM%FMAT(1,1,INTYP0),1,FFM%LTIFOR(IXYZ,INIONS,LDEL_CONF(NDEL_CONF3)),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1)
#else
                                    CALL DCOPY (FFM%NB(INTYP0),FFM%FMAT(1,FFM%LTIFOR(IXYZ,INIONS,ICONF),INTYP0),1, &
                                         FFM%FMAT(1,FFM%LTIFOR(IXYZ,INIONS,LDEL_CONF(NDEL_CONF3)),INTYP0),1)
#endif
                                 ENDDO
                              ENDDO
                              DO IXYZ=1, 3
                                 DO JXYZ=IXYZ, 3
#ifdef scaLAPACK
                                    CALL PDCOPY(FFM%NB(INTYP0),FFM%FMAT(1,1,INTYP0),1,FFM%LTSIF(JXYZ,IXYZ,ICONF),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1, &
                                         FFM%FMAT(1,1,INTYP0),1,FFM%LTSIF(JXYZ,IXYZ,LDEL_CONF(NDEL_CONF3)),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1)
#else
                                    CALL DCOPY (FFM%NB(INTYP0),FFM%FMAT(1,FFM%LTSIF(JXYZ,IXYZ,ICONF),INTYP0),1, &
                                         FFM%FMAT(1,FFM%LTSIF(JXYZ,IXYZ,LDEL_CONF(NDEL_CONF3)),INTYP0),1)
#endif
                                 ENDDO
                              ENDDO
                           ENDDO
                        ENDIF
                        DO INTYP0=1, FF%MTYP
#ifdef scaLAPACK
                           TEST_COL=MOD((FFM%LTOTEN(ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                           IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_COL=GLOBAL2LOCAL(FFM%LTOTEN(ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
                           DO IB=1, FFM%NB(INTYP0)
                              TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                              IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
                              FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
                           ENDDO
#else
                           FFM%FMAT(1:FFM%NB(INTYP0),FFM%LTOTEN(ICONF),INTYP0)=0.0_q
#endif
                           DO INIONS=1, NIONS(ICONF)
                              DO IXYZ=1, 3
#ifdef scaLAPACK
                                 TEST_COL=MOD((FFM%LTIFOR(IXYZ,INIONS,ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                                 IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                    CYCLE
                                 ENDIF
                                 LOCVAR_COL=GLOBAL2LOCAL(FFM%LTIFOR(IXYZ,INIONS,ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
                                 DO IB=1, FFM%NB(INTYP0)
                                    TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                                    IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                       CYCLE
                                    ENDIF
                                    LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
                                    FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
                                 ENDDO
#else
                                 FFM%FMAT(1:FFM%NB(INTYP0),FFM%LTIFOR(IXYZ,INIONS,ICONF),INTYP0)=0.0_q
#endif
                              ENDDO
                           ENDDO
                           DO IXYZ=1, 3
                              DO JXYZ=IXYZ, 3
#ifdef scaLAPACK
                                 TEST_COL=MOD((FFM%LTSIF(JXYZ,IXYZ,ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                                 IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                    CYCLE
                                 ENDIF
                                 LOCVAR_COL=GLOBAL2LOCAL(FFM%LTSIF(JXYZ,IXYZ,ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
                                 DO IB=1, FFM%NB(INTYP0)
                                    TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                                    IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                       CYCLE
                                    ENDIF
                                    LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
                                    FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
                                 ENDDO
#else
                                 FFM%FMAT(1:FFM%NB(INTYP0),FFM%LTSIF(JXYZ,IXYZ,ICONF),INTYP0)=0.0_q
#endif
                              ENDDO
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDIF
                  PROFILING_STOP('restructure_fmatmb_col_spars')
! Restructure the array along the basis set (row) dimension
! for the parallel version we first have to transpose FFM%FMAT to be able to use PDCOPY
! unfortunately PDCOPY can only copy vectors if they are considered as rows (of SCALAPACK)
                  PROFILING_START('restructure_fmatmb_row_spars')
                  DO INTYP0=1, FF%MTYP
                     IF(NDEL_BASIS(INTYP0).NE.0) THEN
                        NDEL_BASIS2=0
                        NDEL_BASIS3=0
#ifdef scaLAPACK
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                           CALL PDTRAN(FFM%NDATA,FFM%NB(INTYP0),1.0_q,FFM%FMAT(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,0.0_q, &
                                FMAT_FFM_TRANSPOSED(1,1),1,1,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%DESC)
                           DO IB=FFM%NB(INTYP0), 1, -1
                              NDEL_BASIS2=NDEL_BASIS2+1
                              IF(NDEL_BASIS2 .EQ. NDEL_BASIS(INTYP0)+1) THEN
                                 EXIT
                              ENDIF
                              IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                                 NDEL_BASIS3=NDEL_BASIS3+1
                                 CALL PDCOPY(FFM%NDATA,FMAT_FFM_TRANSPOSED(1,1),1,IB,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%DESC,1, &
                                      FMAT_FFM_TRANSPOSED(1,1),1,LDEL_BASIS(NDEL_BASIS3,INTYP0),PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%DESC,1)
                              ENDIF
                              TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                              IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%NB)
                              DO IDATA=1, FFM%NDATA
                                 TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                                 IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                    CYCLE
                                 ENDIF
                                 LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%MB)
                                 FMAT_FFM_TRANSPOSED(LOCVAR_ROW,LOCVAR_COL)=0.0_q
                              ENDDO
                           ENDDO
                           CALL PDTRAN(FFM%NB(INTYP0),FFM%NDATA,1.0_q,FMAT_FFM_TRANSPOSED(1,1),1,1,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%DESC,0.0_q, &
                                FFM%FMAT(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC)
                        ELSE IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.1) THEN
                           DO IB=FFM%NB(INTYP0), 1, -1
                              NDEL_BASIS2=NDEL_BASIS2+1
                              IF(NDEL_BASIS2.EQ.NDEL_BASIS(INTYP0)+1) THEN
                                 EXIT
                              ENDIF
                              IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                                 NDEL_BASIS3=NDEL_BASIS3+1
                                 DO IDATA=1, FFM%NDATA
                                    TEST_COL=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                                    IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                       CYCLE
                                    ENDIF
                                    LOCVAR_COL=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
                                    FFM%FMAT(LDEL_BASIS(NDEL_BASIS3,INTYP0),LOCVAR_COL,INTYP0)=FFM%FMAT(IB,LOCVAR_COL,INTYP0)
                                    FFM%FMAT(IB,LOCVAR_COL,INTYP0)=0.0_q
                                 ENDDO
                              ENDIF
                           ENDDO
                        ENDIF
#else
                        DO IB=FFM%NB(INTYP0), 1, -1
                           NDEL_BASIS2=NDEL_BASIS2+1
                           IF(NDEL_BASIS2 .EQ. NDEL_BASIS(INTYP0)+1) THEN
                              EXIT
                           ENDIF
                           IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                              NDEL_BASIS3=NDEL_BASIS3+1
                              DO IDATA=1, FFM%NDATA
                                 FFM%FMAT(LDEL_BASIS(NDEL_BASIS3,INTYP0),IDATA,INTYP0)=FFM%FMAT(IB,IDATA,INTYP0)
                                 FFM%FMAT(IB,IDATA,INTYP0)=0.0_q
                              ENDDO
                           ENDIF
                        ENDDO
#endif
                     ENDIF
                  ENDDO
                  PROFILING_STOP('restructure_fmatmb_row_spars')
#ifdef scaLAPACK
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                     CALL DEALLOCATE_FMAT_FFM_TRANSPOSED
                  ENDIF
#endif
               ENDIF
! Restructuring of radial descriptor----------------------------------------------------------------
! For both the cases of 1- and 2-dimensional scaLAPACK grids, column dimension is distributed.
! Hence, PDCOPY is necessary when scaLAPACK is used.
               IF(FF%LMLMB) THEN
                  PROFILING_START('restructure_c00_spars')
                  IF(FFM%W1 .GT. 0.0_q) THEN
                     DO INTYP0=1, FF%MTYP
                        IF(NDEL_BASIS(INTYP0) .NE. 0) THEN
                           NDEL_BASIS2=0
                           NDEL_BASIS3=0
                           DO IB=FFM%NB(INTYP0), 1, -1
                              NDEL_BASIS2=NDEL_BASIS2+1
                              IF(NDEL_BASIS2 .EQ. NDEL_BASIS(INTYP0)+1) EXIT
                              IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                                 NDEL_BASIS3=NDEL_BASIS3+1
#ifdef scaLAPACK
                                 CALL PDCOPY(FFM%NNVAR1,FFM%C00(1,1,INTYP0),1,IB,PAR_SUP_HANDLE%DESC_C00_FFM%DESC,1, &
                                      FFM%C00(1,1,INTYP0),1,LDEL_BASIS(NDEL_BASIS3,INTYP0),PAR_SUP_HANDLE%DESC_C00_FFM%DESC,1)
#else
                                 CALL DCOPY (FFM%NNVAR1,FFM%C00(1,IB,INTYP0),1,FFM%C00(1,LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0),1)
#endif
                              ENDIF
#ifdef scaLAPACK
                              TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_C00_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                              IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_C00_FFM%NB)
                              FFM%C00(1:PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M,LOCVAR_COL,INTYP0)=0.0_q
#else
                              FFM%C00(1:FFM%NNVAR1,IB,INTYP0)=0.0_q
#endif
                           ENDDO
                        ENDIF
                     ENDDO
                  ENDIF
                  PROFILING_STOP('restructure_c00_spars')
               ENDIF
! Restructuring of angular descriptor----------------------------------------------------------------
! PDCOPY is necessary similarly to the case of C00.
               IF(FF%LMLMB) THEN
                  PROFILING_START('restructure_ps_spars')
                  IF(FFM%W2 .GT. 0.0_q) THEN
                     DO INTYP0=1, FF%MTYP
                        IF(NDEL_BASIS(INTYP0) .NE. 0) THEN
                           NDEL_BASIS2=0
                           NDEL_BASIS3=0
                           DO IB=FFM%NB(INTYP0), 1, -1
                              NDEL_BASIS2=NDEL_BASIS2+1
                              IF(NDEL_BASIS2 .EQ. NDEL_BASIS(INTYP0)+1) EXIT
                              IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                                 NDEL_BASIS3=NDEL_BASIS3+1
#ifdef scaLAPACK
                                 CALL PDCOPY(FFM%NNVAR2(INTYP0),FFM%PS(1,1,INTYP0),1,IB,PAR_SUP_HANDLE%DESC_PS_FFM%DESC,1,FFM%PS(1,1,INTYP0),1,LDEL_BASIS(NDEL_BASIS3,INTYP0),PAR_SUP_HANDLE%DESC_PS_FFM%DESC,1)
#else
                                 CALL DCOPY (FFM%NNVAR2(INTYP0),FFM%PS(1,IB,INTYP0),1,FFM%PS(1,LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0),1)
#endif
                              ENDIF
#ifdef scaLAPACK
                              TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_PS_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                              IF (PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_PS_FFM%NB)
                              FFM%PS(1:PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,LOCVAR_COL,INTYP0)=0.0_q
#else
                              FFM%PS(1:FFM%NNVAR2(INTYP0),IB,INTYP0)=0.0_q
#endif
                           ENDDO
                        ENDIF
                     ENDDO
                  ENDIF
                  PROFILING_STOP('restructure_ps_spars')
               ENDIF
! Restructuring of ab initio data--------------------------------------------------------------------
               PROFILING_START('restructure_abinit_spars')
               IF(NDEL_CONF .NE. 0) THEN
                  NDEL_CONF2=0
                  NDEL_CONF3=0
                  DO ICONF=NCONF, 1, -1
                     NDEL_CONF2=NDEL_CONF2+1
                     IF(NDEL_CONF2 .EQ. NDEL_CONF+1) EXIT
                     IF(LFLAG_CONF(ICONF) .EQ. 1) THEN
                        NDEL_CONF3=NDEL_CONF3+1
                        CALL DCOPY (9,A(1,1,ICONF),1,A(1,1,LDEL_CONF(NDEL_CONF3)),1)
                        A(1:3,1:3,ICONF)=0.0_q
                        CALL DCOPY (9,B(1,1,ICONF),1,B(1,1,LDEL_CONF(NDEL_CONF3)),1)
                        B(1:3,1:3,ICONF)=0.0_q
                        ISYS(LDEL_CONF(NDEL_CONF3))=ISYS(ICONF)
                        ISYS(ICONF)=0
                        CALL DCOPY (1,OMEGA(ICONF),1,OMEGA(LDEL_CONF(NDEL_CONF3)),1)
                        OMEGA(ICONF)=0.0_q
                        CALL DCOPY (3*MIONS,POSION(1,1,ICONF),1,POSION(1,1,LDEL_CONF(NDEL_CONF3)),1)
                        POSION(1:3,1:MIONS,ICONF)=0.0_q
                        SZNAM2(LDEL_CONF(NDEL_CONF3))=SZNAM2(ICONF)
                        SZNAM2_INPUT(LDEL_CONF(NDEL_CONF3))=SZNAM2_INPUT(ICONF)
                        SZNAM2(ICONF)=''
                        SZNAM2_INPUT(ICONF)=''
                        CALL DCOPY (3*MIONS,TIFOR(1,1,ICONF),1,TIFOR(1,1,LDEL_CONF(NDEL_CONF3)),1)
                        TIFOR(1:3,1:MIONS,ICONF)=0.0_q
                        CALL DCOPY (1,TOTEN(ICONF),1,TOTEN(LDEL_CONF(NDEL_CONF3)),1)
                        TOTEN(ICONF)=0.0_q
                        CALL DCOPY (9,TSIF(1,1,ICONF),1,TSIF(1,1,LDEL_CONF(NDEL_CONF3)),1)
                        TSIF(1:3,1:3,ICONF)=0.0_q
                     ELSE
                        A(1:3,1:3,ICONF)=0.0_q
                        B(1:3,1:3,ICONF)=0.0_q
                        ISYS(ICONF)=0
                        OMEGA(ICONF)=0.0_q
                        POSION(1:3,1:MIONS,ICONF)=0.0_q
                        SZNAM2(ICONF)=''
                        SZNAM2_INPUT(ICONF)=''
                        TIFOR(1:3,1:MIONS,ICONF)=0.0_q
                        TOTEN(ICONF)=0.0_q
                        TSIF(1:3,1:3,ICONF)=0.0_q
                     ENDIF
                  ENDDO
               ENDIF
               PROFILING_STOP('restructure_abinit_spars')
! Restructuring of list and size of training data----------------------------------------------------
! The orders of list LTIFOR, LTOTEN,LTSIF should be remain !!!
               PROFILING_START('restructure_size_spars')
               IF(NDEL_CONF .NE. 0) THEN
                  NDEL_CONF2=0
                  NDEL_CONF3=0
                  DO ICONF=NCONF, 1, -1
                     NDEL_CONF2=NDEL_CONF2+1
                     IF(NDEL_CONF2.EQ.NDEL_CONF+1) EXIT
                     IF(LFLAG_CONF(ICONF) .EQ. 1) THEN
                        NDEL_CONF3=NDEL_CONF3+1
                        FF%NTOTEN=FF%NTOTEN-1
                        FF%NTSIF=FF%NTSIF-6
                        DO INIONS=1, NIONS(LDEL_CONF(NDEL_CONF3))
                           FF%NTIFOR=FF%NTIFOR-3
                        ENDDO
                        IF(FF%LMLMB) THEN
                           FFM%LTIFOR(1:3,1:MIONS,ICONF)=0
                           FFM%LTOTEN(ICONF)=0
                           FFM%LTSIF(1:3,1:3,ICONF)=0
                           FFM%NDATA=FFM%NDATA-7
                           FFM%NTOTEN=FFM%NTOTEN-1
                           FFM%NTSIF=FFM%NTSIF-6
                           DO INIONS=1, NIONS(LDEL_CONF(NDEL_CONF3))
                              FFM%NDATA=FFM%NDATA-3
                              FFM%NTIFOR=FFM%NTIFOR-3
                           ENDDO
                        ENDIF
                     ELSE
                        FF%NTOTEN=FF%NTOTEN-1
                        FF%NTSIF=FF%NTSIF-6
                        DO INIONS=1, NIONS(ICONF)
                           FF%NTIFOR=FF%NTIFOR-3
                        ENDDO
                        IF(FF%LMLMB) THEN
                           FFM%LTIFOR(1:3,1:MIONS,ICONF)=0
                           FFM%LTOTEN(ICONF)=0
                           FFM%LTSIF(1:3,1:3,ICONF)=0
                           FFM%NDATA=FFM%NDATA-7
                           FFM%NTOTEN=FFM%NTOTEN-1
                           FFM%NTSIF=FFM%NTSIF-6
                           DO INIONS=1, NIONS(ICONF)
                              FFM%NDATA=FFM%NDATA-3
                              FFM%NTIFOR=FFM%NTIFOR-3
                           ENDDO
                        ENDIF
                     ENDIF
                  ENDDO
               ENDIF
               PROFILING_STOP('restructure_size_spars')
! Restructuring of list data along to the basis set direction----------------------------------------
               PROFILING_START('restructure_list_spars')
               DO INTYP0=1, FF%MTYP
                  IF(NDEL_BASIS(INTYP0) .NE. 0) THEN
                     NDEL_BASIS2=0
                     NDEL_BASIS3=0
                     DO IB=FFM%NB(INTYP0), 1, -1
                        NDEL_BASIS2=NDEL_BASIS2+1
                        IF(NDEL_BASIS2 .EQ. NDEL_BASIS(INTYP0)+1) EXIT
! If the IB-th basis set is chosen as basis set, copy it to the array used for the deleted basiset
                        IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                           NDEL_BASIS3=NDEL_BASIS3+1
! Here, a little bit complex procedure is adopted. The list LB specifies the basis set number of
! an atom in a configuratoin. If the order of basis set is changed, this list should be also changed.
! For example, if the IB-th basis set data is copied to the JB-th basis set, LB of the atom and
! configuration giving the IB-th basis set should be changed as JB. In addition, since the JB-th 
! basis set is deleted, the atom and configuration giving the JB-th basis set is now not selected 
! as any basis set. Hence, LB for that atom /configuraton should be set as zero.
                           LB(FFM%LNIONS(IB,INTYP0),FFM%LNCONF(IB,INTYP0))=LDEL_BASIS(NDEL_BASIS3,INTYP0)
                           LB(FFM%LNIONS(LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0),FFM%LNCONF(LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0))=0
                        ELSE
                           LB(FFM%LNIONS(IB,INTYP0),FFM%LNCONF(IB,INTYP0))=0
                        ENDIF
                     ENDDO
                  ENDIF
               ENDDO
               DO INTYP0=1, FF%MTYP
                  IF(NDEL_BASIS(INTYP0) .NE. 0) THEN
                     NDEL_BASIS2=0
                     NDEL_BASIS3=0
                     DO IB=FFM%NB(INTYP0), 1, -1
                        NDEL_BASIS2=NDEL_BASIS2+1
                        IF(NDEL_BASIS2 .EQ. NDEL_BASIS(INTYP0)+1) EXIT
! If the IB-th basis set is chosen as basis set, copy it to the array used for the deleted basiset
                        IF(LFLAG_BASIS(IB,INTYP0) .EQ. 1) THEN
                           NDEL_BASIS3=NDEL_BASIS3+1
! FFM%LNCONF specifies the configuration giving a basis set. The order of this list should be changed
! in a usual manner.
                           FFM%LNCONF(LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0)=FFM%LNCONF(IB,INTYP0)
                           FFM%LNCONF(IB,INTYP0)=0
! Similar for FFM%LNIONS.
                           FFM%LNIONS(LDEL_BASIS(NDEL_BASIS3,INTYP0),INTYP0)=FFM%LNIONS(IB,INTYP0)
                           FFM%LNIONS(IB,INTYP0)=0
! Otherwise, set the variables as zero
                        ELSE
                           FFM%LNCONF(IB,INTYP0)=0
                           FFM%LNIONS(IB,INTYP0)=0
                        ENDIF
                     ENDDO
                  ENDIF
               ENDDO
! Restructuring of list data along to the configurational direction----------------------------------
               IF(NDEL_CONF .NE. 0) THEN
                  NDEL_CONF2=0
                  NDEL_CONF3=0
                  DO ICONF=NCONF, 1, -1
                     NDEL_CONF2=NDEL_CONF2+1
                     IF(NDEL_CONF2 .EQ. NDEL_CONF+1) EXIT
                     IF(LFLAG_CONF(ICONF) .EQ. 1) THEN
                        NDEL_CONF3=NDEL_CONF3+1
! The unecessary basis sets were already delted previously. Hence, FFM%LNCONF is
! defined now only for the selected basis sets. However, FFM%LNCONF should be changed
! because the order of configuration numbers is changed. 
! Since the basis sets related to the deleting configurations were already deleted
! in the previous step, FFM%LNCONF for the basis sets related to the deleting configuration
! should not exist anymore. Hence, nothing is done for the deleting configuration.
                        DO INIONS=1, NIONS(ICONF)
                           IB=LB(INIONS,ICONF)
                           IF(IB .NE. 0) THEN
                              INTYP0=LNTYP(INIONS,ICONF)
                              FFM%LNCONF(IB,INTYP0)=LDEL_CONF(NDEL_CONF3)
                           ENDIF
                        ENDDO
                        LB(1:MIONS,LDEL_CONF(NDEL_CONF3))=LB(1:MIONS,ICONF)
                        LB(1:MIONS,ICONF)=0
                        LADD(1:MTYP,LDEL_CONF(NDEL_CONF3))=LADD(1:MTYP,ICONF)
                        LADD(1:MTYP,ICONF)=0
                        LNITYP(1:MIONS,LDEL_CONF(NDEL_CONF3))=LNITYP(1:MIONS,ICONF)
                        LNITYP(1:MIONS,ICONF)=0
                        LNIONS(1:MITYP,1:MTYP,LDEL_CONF(NDEL_CONF3))=LNIONS(1:MITYP,1:MTYP,ICONF)
                        LNIONS(1:MITYP,1:MTYP,ICONF)=0
                        LNTYP(1:MIONS,LDEL_CONF(NDEL_CONF3))=LNTYP(1:MIONS,ICONF)
                        LNTYP(1:MIONS,ICONF)=0
                        LSYS(LDEL_CONF(NDEL_CONF3))=LSYS(ICONF)
                        LSYS(ICONF)=0
                     ELSE
                        LB(1:MIONS,ICONF)=0
                        LADD(1:MTYP,ICONF)=0
                        LNITYP(1:MIONS,ICONF)=0
                        LNIONS(1:MITYP,1:MTYP,ICONF)=0
                        LNTYP(1:MIONS,ICONF)=0
                        LSYS(ICONF)=0
                     ENDIF
                  ENDDO
               ENDIF
               PROFILING_STOP('restructure_list_spars')
! Restructuring of the size data for each configuration----------------------------------------------
               PROFILING_START('restructure_size_spars')
               IF(NDEL_CONF .NE. 0) THEN
                  NDEL_CONF2=0
                  NDEL_CONF3=0
                  DO ICONF=NCONF, 1, -1
                     NDEL_CONF2=NDEL_CONF2+1
                     IF(NDEL_CONF2 .EQ. NDEL_CONF+1) EXIT
                     IF(LFLAG_CONF(ICONF) .EQ. 1) THEN
                        NDEL_CONF3=NDEL_CONF3+1
                        NTYP(LDEL_CONF(NDEL_CONF3))=NTYP(ICONF)
                        NTYP(ICONF)=0
                        NIONS(LDEL_CONF(NDEL_CONF3))=NIONS(ICONF)
                        NIONS(ICONF)=0
                        NITYP(1:MTYP,LDEL_CONF(NDEL_CONF3))=NITYP(1:MTYP,ICONF)
                        NITYP(1:MTYP,ICONF)=0
                     ELSE
                        NTYP(ICONF)=0
                        NIONS(ICONF)=0
                        NITYP(1:MTYP,ICONF)=0
                     ENDIF
                  ENDDO
               ENDIF
! Change the size of configurations------------------------------------------------------------------
               NCONF=NCONF-NDEL_CONF
               NCONF_SYS=0
               DO ICONF=1, NCONF
                  NCONF_SYS(ISYS(ICONF))=NCONF_SYS(ISYS(ICONF))+1
               ENDDO
               PROFILING_STOP('restructure_size_spars')
! Finally change the size of basiss sets-------------------------------------------------------------
               PROFILING_START('restructure_list_spars')
               FFM%NBTOT=FFM%NBTOT-NDEL_BASIS_TOT
               DO INTYP0=1, FF%MTYP
                  FFM%NB(INTYP0)=FFM%NB(INTYP0)-NDEL_BASIS(INTYP0)
               ENDDO
               FFM%LBHEAD(1)=0
               DO INTYP0=2, FF%MTYP
                  FFM%LBHEAD(INTYP0)=FFM%LBHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
               ENDDO
               PROFILING_STOP('restructure_list_spars')
            ENDIF
            IF(FF%LGENFF) THEN
               FFM%NBTOT=0
               DO INTYP0=1, FF%MTYP
                  DO IB=1, FFM%NB(INTYP0), 1
                     FFM%NBTOT=FFM%NBTOT+1
                     FFM%LB(IB,INTYP0)=FFM%NBTOT
                  ENDDO
               ENDDO
            ENDIF
            PROFILING_STOP('restructure_spars')
          END SUBROUTINE RESTRUCTURE_SPARS

! Count the memory usage

          SUBROUTINE COUNT_RMEM_SPARS
             IMPLICIT NONE
             MEM1%RMEM(5)=MAX(MEM1%RMEM(5),RMEM_CUR+RMEM_SVD)
             MEM1%RMEM(5)=MAX(MEM1%RMEM(5),RMEM_CUR+RMEM_RST)
             MEM1%RMEM_RST=MAX(MEM1%RMEM_RST,RMEM_RST)
             MEM1%RMEM_SVD=MAX(MEM1%RMEM_SVD,RMEM_SVD)
          END SUBROUTINE COUNT_RMEM_SPARS

! Allocate temporary arrays necesary for CUR

          SUBROUTINE ALLOCATE_CUR_ARRAY
            IMPLICIT NONE
            IF(ALLOCATED(LFLAG_BASIS)) THEN
               DEALLOCATE(LFLAG_BASIS)
            ENDIF
            ALLOCATE (LFLAG_BASIS(1:FFM%MB,1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FFM%MB,q)*REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(LFLAG_CONF)) THEN
               DEALLOCATE(LFLAG_CONF)
            ENDIF
            ALLOCATE (LFLAG_CONF(1:MCONF))
            RMEM_CUR=RMEM_CUR+REAL(MCONF,q)/1.0E+06_q
            IF(ALLOCATED(LDEL_BASIS)) THEN
               DEALLOCATE(LDEL_BASIS)
            ENDIF
            ALLOCATE (LDEL_BASIS(1:FFM%MB,1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FFM%MB,q)*REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(LDEL_CONF)) THEN
               DEALLOCATE(LDEL_CONF)
            ENDIF
            ALLOCATE (LDEL_CONF(1:MCONF))
            RMEM_CUR=RMEM_CUR+REAL(MCONF,q)/1.0E+06_q
            IF(ALLOCATED(NB0)) THEN
               DEALLOCATE(NB0)
            ENDIF
            ALLOCATE (NB0(FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(NDEL_BASIS)) THEN
               DEALLOCATE(NDEL_BASIS)
            ENDIF
            ALLOCATE (NDEL_BASIS(1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(NRANK_HIGH)) THEN
               DEALLOCATE(NRANK_HIGH)
            ENDIF
            ALLOCATE (NRANK_HIGH(1:FF%MTYP))
            IF(ALLOCATED(NRANK_LOW)) THEN
               DEALLOCATE(NRANK_LOW)
            ENDIF
            ALLOCATE (NRANK_LOW(1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(PIL_HIGH)) THEN
               DEALLOCATE(PIL_HIGH)
            ENDIF
            ALLOCATE (PIL_HIGH(1:FFM%MB,1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FFM%MB,q)*REAL(FF%MTYP,q)*8/1.0E+06_q
            IF(ALLOCATED(PIL_LOW)) THEN
               DEALLOCATE(PIL_LOW)
            ENDIF
            ALLOCATE (PIL_LOW(1:FFM%MB,1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FFM%MB,q)*REAL(FF%MTYP,q)*8/1.0E+06_q
            IF(ALLOCATED(PILC)) THEN
               DEALLOCATE(PILC)
            ENDIF
            ALLOCATE (PILC(1:MCONF))
            RMEM_CUR=RMEM_CUR+REAL(MCONF,q)*8/1.0E+06_q
            IF(ALLOCATED(WRATIO_NEW)) THEN
               DEALLOCATE(WRATIO_NEW)
            ENDIF
            ALLOCATE(WRATIO_NEW(1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FF%MTYP,q)*8/1.0E+06_q
            IF(ALLOCATED(WRATIO_OLD)) THEN
               DEALLOCATE(WRATIO_OLD)
            ENDIF
            ALLOCATE(WRATIO_OLD(1:FF%MTYP))
            RMEM_CUR=RMEM_CUR+REAL(FF%MTYP,q)*8/1.0E+06_q
          END SUBROUTINE ALLOCATE_CUR_ARRAY

! Allocate temporary allays necessary for SVD

          SUBROUTINE ALLOCATE_SVD_ARRAY
           IMPLICIT NONE
#ifdef scaLAPACK
           IF(ALLOCATED(EIGENVECTOR)) THEN
               DEALLOCATE(EIGENVECTOR)
            ENDIF
            ALLOCATE (EIGENVECTOR(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
            RMEM_SVD=RMEM_SVD+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
            IF(ALLOCATED(SOAP)) THEN
               DEALLOCATE(SOAP)
            ENDIF
            ALLOCATE (SOAP(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
            RMEM_SVD=RMEM_SVD+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
            IF(ALLOCATED(U)) THEN
               DEALLOCATE(U)
            ENDIF
            ALLOCATE (U(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
            RMEM_SVD=RMEM_SVD+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
            IF(FF%ISVD.EQ.2) THEN
               IF(ALLOCATED(V_ALL)) THEN
                  DEALLOCATE(V_ALL)
               ENDIF
               ALLOCATE (V_ALL(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
               RMEM_SVD=RMEM_SVD+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
            ENDIF
            IF(ALLOCATED(V_HIGH)) THEN
               DEALLOCATE(V_HIGH)
            ENDIF
            ALLOCATE (V_HIGH(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
            RMEM_SVD=RMEM_SVD+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
            IF(ALLOCATED(V_LOW)) THEN
               DEALLOCATE(V_LOW)
            ENDIF
            ALLOCATE (V_LOW(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
            RMEM_SVD=RMEM_SVD+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
#else
           IF(ALLOCATED(EIGENVECTOR)) THEN
               DEALLOCATE(EIGENVECTOR)
            ENDIF
            ALLOCATE (EIGENVECTOR(1:FFM%MB,1:FFM%MB))
            RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*REAL(FFM%MB,q)*8/1.0E+06_q
            IF(ALLOCATED(SOAP)) THEN
               DEALLOCATE(SOAP)
            ENDIF
            ALLOCATE (SOAP(1:FFM%MB,1:FFM%MB))
            RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*REAL(FFM%MB,q)*8/1.0E+06_q
            IF(ALLOCATED(U)) THEN
               DEALLOCATE(U)
            ENDIF
            ALLOCATE (U(1:FFM%MB,1:FFM%MB))
            RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*REAL(FFM%MB,q)*8/1.0E+06_q
            IF(FF%ISVD.EQ.2) THEN
               IF(ALLOCATED(V_ALL)) THEN
                  DEALLOCATE(V_ALL)
               ENDIF
               ALLOCATE (V_ALL(1:FFM%MB,1:FFM%MB))
               RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*REAL(FFM%MB,q)*8/1.0E+06_q
            ENDIF
            IF(ALLOCATED(V_HIGH)) THEN
               DEALLOCATE(V_HIGH)
            ENDIF
            ALLOCATE (V_HIGH(1:FFM%MB,1:FFM%MB))
            RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*REAL(FFM%MB,q)*8/1.0E+06_q
            IF(ALLOCATED(V_LOW)) THEN
               DEALLOCATE(V_LOW)
            ENDIF
            ALLOCATE (V_LOW(1:FFM%MB,1:FFM%MB))
            RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*REAL(FFM%MB,q)*8/1.0E+06_q
#endif
            IF(ALLOCATED(EIGENVALUE)) THEN
               DEALLOCATE(EIGENVALUE)
            ENDIF
            ALLOCATE (EIGENVALUE(1:FFM%MB))
            RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*8/1.0E+06_q
            IF(FF%ISVD.EQ.2) THEN
               IF(ALLOCATED(SINGULARVALUE)) THEN
                  DEALLOCATE(SINGULARVALUE)
               ENDIF
               ALLOCATE (SINGULARVALUE(1:FFM%MB)) 
               RMEM_SVD=RMEM_SVD+REAL(FFM%MB,q)*8/1.0E+06_q
            ENDIF
          END SUBROUTINE ALLOCATE_SVD_ARRAY

! allocate temporary arrays necessary for restrucutre the SOAP matrix

          SUBROUTINE ALLOCATE_SOAP_TRANSPOSED
            IMPLICIT NONE
#ifdef scaLAPACK
            IF(ALLOCATED(SOAP_TRANSPOSED)) THEN
               DEALLOCATE (SOAP_TRANSPOSED)
            ENDIF
            ALLOCATE (SOAP_TRANSPOSED(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N))
            RMEM_RST=RMEM_RST+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*8/1.0E+06_q
#endif
          END SUBROUTINE ALLOCATE_SOAP_TRANSPOSED

! allocate temporary arrays necessary for restrucutre the FFM%FMAT matrix

          SUBROUTINE ALLOCATE_FMAT_FFM_TRANSPOSED
            IMPLICIT NONE
#ifdef scaLAPACK
            PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%M=FFM%MDATA
            PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%N=FFM%MB
            PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%MB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%NB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%IRSRC=0
            PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%ICSRC=0
            CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%DESC,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%M, &
                 PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%N, &
                 PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%MB,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%NB, &
                 PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%ICSRC, &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LLD, &
                 PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LOC_N)
            IF(ALLOCATED(FMAT_FFM_TRANSPOSED)) THEN
               DEALLOCATE (FMAT_FFM_TRANSPOSED)
            ENDIF
            ALLOCATE (FMAT_FFM_TRANSPOSED(PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LOC_N))
            RMEM_RST=RMEM_RST+REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM_TRANSPOSED%LOC_N,q)*8/1.0E+06_q
#endif
          END SUBROUTINE ALLOCATE_FMAT_FFM_TRANSPOSED

! Deallocate temporary arrays necessary for CUR

          SUBROUTINE DEALLOCATE_CUR_ARRAY
            IMPLICIT NONE
            IF(ALLOCATED(LFLAG_CONF)) THEN
               DEALLOCATE (LFLAG_CONF)
            ENDIF
            IF(ALLOCATED(LDEL_BASIS)) THEN
               DEALLOCATE (LDEL_BASIS)
            ENDIF
            IF(ALLOCATED(LDEL_CONF)) THEN
               DEALLOCATE (LDEL_CONF)
            ENDIF
            IF(ALLOCATED(NB0)) THEN
               DEALLOCATE (NB0)
            ENDIF
            IF(ALLOCATED(NDEL_BASIS)) THEN
               DEALLOCATE (NDEL_BASIS)
            ENDIF
            IF(ALLOCATED(NRANK_HIGH)) THEN
               DEALLOCATE (NRANK_HIGH)
            ENDIF
            IF(ALLOCATED(NRANK_LOW)) THEN
               DEALLOCATE (NRANK_LOW)
            ENDIF
            IF(ALLOCATED(PIL_HIGH)) THEN
               DEALLOCATE (PIL_HIGH)
            ENDIF
            IF(ALLOCATED(PIL_LOW)) THEN
               DEALLOCATE (PIL_LOW)
            ENDIF
            IF(ALLOCATED(PILC)) THEN
               DEALLOCATE (PILC)
            ENDIF
            IF(ALLOCATED(WRATIO_NEW)) THEN
               DEALLOCATE(WRATIO_NEW)
            ENDIF
            IF(ALLOCATED(WRATIO_OLD)) THEN
               DEALLOCATE(WRATIO_OLD)
            ENDIF
          END SUBROUTINE DEALLOCATE_CUR_ARRAY

! Deallocate temporary arrays necessary for SVD

          SUBROUTINE DEALLOCATE_SVD_ARRAY
            IMPLICIT NONE
#ifdef scaLAPACK
            IF(ALLOCATED(EIGENVECTOR)) THEN
               DEALLOCATE (EIGENVECTOR)
            ENDIF
#endif
            IF(ALLOCATED(EIGENVALUE)) THEN
               DEALLOCATE(EIGENVALUE)
            ENDIF
            IF(ALLOCATED(SINGULARVALUE)) THEN
               DEALLOCATE(SINGULARVALUE)
            ENDIF
            IF(ALLOCATED(SOAP)) THEN
               DEALLOCATE (SOAP)
            ENDIF
            IF(ALLOCATED(U)) THEN
               DEALLOCATE (U)
            ENDIF
            IF(ALLOCATED(V_ALL)) THEN
               DEALLOCATE (V_ALL)
            ENDIF
            IF(ALLOCATED(V_HIGH)) THEN
               DEALLOCATE (V_HIGH)
            ENDIF
            IF(ALLOCATED(V_LOW)) THEN
               DEALLOCATE (V_LOW)
            ENDIF
          END SUBROUTINE DEALLOCATE_SVD_ARRAY

! Deallocate temporary arrays necessary for restrucutre the SOAP matrix

          SUBROUTINE DEALLOCATE_SOAP_TRANSPOSED
            IMPLICIT NONE
#ifdef scaLAPACK
            IF(ALLOCATED(SOAP_TRANSPOSED)) THEN
               DEALLOCATE (SOAP_TRANSPOSED)
            ENDIF
#endif
          END SUBROUTINE DEALLOCATE_SOAP_TRANSPOSED

! Deallocate temporary arrays necessary for restrucutre the FFM%FMAT matrix

          SUBROUTINE DEALLOCATE_FMAT_FFM_TRANSPOSED
            IMPLICIT NONE
#ifdef scaLAPACK
            IF(ALLOCATED(FMAT_FFM_TRANSPOSED)) THEN
               DEALLOCATE (FMAT_FFM_TRANSPOSED)
            ENDIF
#endif
          END SUBROUTINE DEALLOCATE_FMAT_FFM_TRANSPOSED

        END SUBROUTINE SPARS_ICUR
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Initialization of list summarizing orders of training data sets and basis sets
!****************************************************************************************************

        SUBROUTINE INIT_LIST (TIM,FF,FFM,NCONF,NIONS)
          USE ML_FF_STRUCT, ONLY: TIME, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (TIME)         :: TIM
          TYPE (FF_PAR)       :: FF
          TYPE (FFM_PAR)      :: FFM
          INTEGER, INTENT(IN) :: NCONF
          INTEGER, INTENT(IN) :: NIONS(:) !(1:NCONF)
! Local variables
          REAL(q) CPUTIM0,CPUTIM1
          INTEGER ICONF
          INTEGER IDATA
          INTEGER INIONS
          INTEGER INTYP0
          INTEGER IXYZ,JXYZ
          INTEGER NBTOT
          REAL(q) VPUTIM0,VPUTIM1
! Start profiling
          PROFILING_START('init_list')
! Measure the initial times
          CALL VTIME (VPUTIM0,CPUTIM0)
          FF%NTIFOR=0
          FF%NTOTEN=0
          FF%NTSIF=0
          IF(FF%ISTART.EQ.1 .OR. FF%ISTART.EQ.4) THEN
             DO ICONF=1, NCONF
                FF%NTOTEN=FF%NTOTEN+1
                DO INIONS=1, NIONS(ICONF)
                   DO IXYZ=1, 3
                      FF%NTIFOR=FF%NTIFOR+1
                   ENDDO
                ENDDO
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      FF%NTSIF=FF%NTSIF+1
                   ENDDO
                ENDDO
             ENDDO
          ENDIF
          IF(FF%LMLMB) THEN
             FFM%LTIFOR=0
             FFM%LTOTEN=0
             FFM%LTSIF=0
             FFM%NDATA=0
             FFM%NTIFOR=0
             FFM%NTOTEN=0
             FFM%NTSIF=0
             IF(FF%ISTART.EQ.1 .OR. FF%ISTART.EQ.4) THEN
                DO ICONF=1, NCONF
                   FFM%NDATA=FFM%NDATA+1
                   FFM%NTOTEN=FFM%NTOTEN+1
                   FFM%LTOTEN(ICONF)=FFM%NDATA
                   DO INIONS=1, NIONS(ICONF)
                      DO IXYZ=1, 3
                         FFM%NDATA=FFM%NDATA+1
                         FFM%NTIFOR=FFM%NTIFOR+1
                         FFM%LTIFOR(IXYZ,INIONS,ICONF)=FFM%NDATA
                      ENDDO
                   ENDDO
                   DO IXYZ=1, 3
                      DO JXYZ=IXYZ, 3
                         FFM%NDATA=FFM%NDATA+1
                         FFM%NTSIF=FFM%NTSIF+1
                         FFM%LTSIF(JXYZ,IXYZ,ICONF)=FFM%NDATA
                      ENDDO
                   ENDDO
                ENDDO
             ENDIF
          ENDIF
! Record the final time
! Measure the final times and add them
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(4)=TIM%CPUTIM(4)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(4)=TIM%VPUTIM(4)+VPUTIM1-VPUTIM0
! Start profiling
          PROFILING_STOP('init_list')
        END SUBROUTINE INIT_LIST
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
        SUBROUTINE INIT_LIST_NEW (TIM,FF,FFM,NIONS_NEW)
          USE ML_FF_STRUCT, ONLY: TIME, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (TIME)         :: TIM
          TYPE (FF_PAR)       :: FF
          TYPE (FFM_PAR)      :: FFM
          INTEGER, INTENT(IN) :: NIONS_NEW
! Local variables
          REAL(q) CPUTIM0,CPUTIM1
          INTEGER ICONF
          INTEGER IDATA
          INTEGER INIONS
          INTEGER INTYP0
          INTEGER IXYZ,JXYZ
          INTEGER NBTOT
          REAL(q) VPUTIM0,VPUTIM1
! Start profiling
          PROFILING_START('init_list_new')
! Measure the initial times
          CALL VTIME (VPUTIM0,CPUTIM0)
! About the lists for the many-body interactions, these arrays are not
! allocated if FF%ISTART=2. Therefore, the following part needs to be
! skipped when FF%ISTART=2.
          IF(FF%LMLMB.AND.FF%ISTART.NE.2) THEN
             IDATA=0
             DO ICONF=1, FF%MCONF_NEW
                IDATA=IDATA+1
                FFM%LTOTEN_NEW(ICONF)=IDATA
                DO INIONS=1, NIONS_NEW
                   DO IXYZ=1, 3
                      IDATA=IDATA+1
                      FFM%LTIFOR_NEW(IXYZ,INIONS,ICONF)=IDATA
                   ENDDO
                ENDDO
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      IDATA=IDATA+1
                      FFM%LTSIF_NEW(JXYZ,IXYZ,ICONF)=IDATA
                   ENDDO
                ENDDO
             ENDDO
          ENDIF
! Record the final time
! Measure the final times and add them
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(4)=TIM%CPUTIM(4)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(4)=TIM%VPUTIM(4)+VPUTIM1-VPUTIM0
! Start profiling
          PROFILING_STOP('init_list_new')
        END SUBROUTINE INIT_LIST_NEW
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Initialization of design matrix
! This subroutine calculates the design matrix elements using FFM%PS_ALL
! that are owned by all processes. This does not need communications,
! but need more memory to store FFM%PS_ALL
!****************************************************************************************************

        SUBROUTINE INIT_FMAT (AB,PAR_SUP_HANDLE,MLSHM,FF,FFM,A,B,LADD,LNITYP,LNIONS,LNTYP, &
                   MCONF,MITYP,MIONS,MTYP,NCONF,NITYP,NIONS,NTYP,POSION,OMEGA)
          USE NEIGHBOUR
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: ABINITIO, PARALLEL_SUPER, ML_SHMEM, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)       :: AB
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          REAL(q), INTENT(IN)   :: A(:,:,:) !(1:3,1:3,1:NCONF)
          REAL(q), INTENT(IN)   :: B(:,:,:) !(1:3,1:3,1:NCONF)
          INTEGER, INTENT(IN)   :: LADD(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: LNITYP(:,:) !(1:MIONS,1:NCONF)
          INTEGER, INTENT(IN)   :: LNIONS(:,:,:) !(1:MITYP,1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: LNTYP(:,:) !(1:MIONS,1:NCONF)
          INTEGER, INTENT(IN)   :: MCONF
          INTEGER, INTENT(IN)   :: MIONS
          INTEGER, INTENT(IN)   :: MITYP
          INTEGER, INTENT(IN)   :: MTYP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NIONS(:) !(1:NCONF)
          INTEGER, INTENT(IN)   :: NITYP(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: NTYP(:) !(1:NCONF)
          REAL(q), INTENT(IN)   :: POSION(:,:,:) !(1:3,1:MIONS,1:NCONF)
          REAL(q), INTENT(IN)   :: OMEGA(:) !(1:NCONF)
! Local variables
          REAL(q), ALLOCATABLE  :: C00(:,:,:)
          REAL(q), ALLOCATABLE  :: C00_COUPLE(:)
          REAL(q), ALLOCATABLE  :: C00_DUMMY(:)
          REAL(q)               :: CPUTIM0
          REAL(q)               :: CPUTIM1
          REAL(q), ALLOCATABLE  :: DC00(:,:,:,:)
          REAL(q), ALLOCATABLE  :: DCLM1(:,:,:,:)
          REAL(q), ALLOCATABLE  :: DCLM2(:,:,:,:)
          REAL(q), ALLOCATABLE  :: DPS(:,:,:,:)
          REAL(q), ALLOCATABLE  :: DPS_SIC(:,:,:,:)
          REAL(q), ALLOCATABLE  :: DRBS(:,:,:,:)
          REAL(q), ALLOCATABLE  :: DSOAP11(:,:)
          REAL(q), ALLOCATABLE  :: DSOAP12(:,:)
          REAL(q), ALLOCATABLE  :: DSOAP21(:,:,:)
          REAL(q), ALLOCATABLE  :: DSOAP22(:,:,:)
          REAL(q), ALLOCATABLE  :: ENERGY_HELP(:)
          REAL(q), ALLOCATABLE  :: FORCE_HELP1(:,:,:,:)
          REAL(q), ALLOCATABLE  :: FORCE_HELP2(:)
          INTEGER               :: ICONF
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: INITYP
          INTEGER               :: INITYP_TMP
          INTEGER               :: KNIONS
          INTEGER               :: KNIONS_TMP
          INTEGER               :: KNITYP
          INTEGER               :: KNTYP0
          INTEGER, ALLOCATABLE  :: LHEAD(:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST1(:,:,:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST2(:,:,:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST_MAX(:,:,:)
          INTEGER               :: MCOL_C00
          INTEGER               :: MCOL_C00_COUPLE
          INTEGER               :: MCOL_CLM1
          INTEGER               :: MCOL_CLM2
          INTEGER               :: MCOL_DC00
          INTEGER               :: MCOL_DCLM1
          INTEGER               :: MCOL_DCLM2
          INTEGER               :: MCOL_DPS
          INTEGER               :: MCOL_DPS_SIC
          INTEGER               :: MCOL_DSOAP1
          INTEGER               :: MCOL_DSOAP2
          INTEGER               :: MCOL_EST1
          INTEGER               :: MCOL_EST2
          INTEGER               :: MCOL_EST_MAX
          INTEGER               :: MCOL_MIONS
          INTEGER               :: MCOL_MITYP
          INTEGER               :: MCOL_PS
          INTEGER               :: MCOL_PS_COUPLE
          INTEGER               :: MCOL_RBS
          INTEGER               :: MCOL_RNORM_C00
          INTEGER               :: MCOL_RNORM_PS
          INTEGER               :: MCOL_RNORM_ALL
          INTEGER               :: MCOL_SOAP
          INTEGER               :: MCOL_VEC_LOC_ENERGY
          INTEGER               :: MCOL_VEC_LOC_FORCE1
          INTEGER               :: MCOL_VEC_LOC_FORCE2
          INTEGER               :: MCOL_VEC_LOC_STRESS1
          INTEGER               :: MCOL_VEC_LOC_STRESS2
          INTEGER               :: MNEIB_EST1
          INTEGER               :: MNEIB_EST2
          INTEGER               :: MNEIB_EST_MAX
          INTEGER               :: MROW_C00
          INTEGER               :: MROW_C00_COUPLE
          INTEGER               :: MROW_CLM1
          INTEGER               :: MROW_CLM2
          INTEGER               :: MROW_DC00
          INTEGER               :: MROW_DCLM1
          INTEGER               :: MROW_DCLM2
          INTEGER               :: MROW_DPS
          INTEGER               :: MROW_DPS_SIC
          INTEGER               :: MROW_DSOAP1
          INTEGER               :: MROW_DSOAP2
          INTEGER               :: MROW_EST1
          INTEGER               :: MROW_EST2
          INTEGER               :: MROW_EST_MAX
          INTEGER               :: MROW_PS
          INTEGER               :: MROW_PS_COUPLE
          INTEGER               :: MROW_RBS
          INTEGER               :: MROW_RNORM_C00
          INTEGER               :: MROW_RNORM_PS
          INTEGER               :: MROW_RNORM_ALL
          INTEGER               :: MROW_SOAP
          INTEGER               :: MROW_VEC_LOC_ENERGY
          INTEGER               :: MROW_VEC_LOC_FORCE1
          INTEGER               :: MROW_VEC_LOC_FORCE2
          INTEGER               :: MROW_VEC_LOC_STRESS1
          INTEGER               :: MROW_VEC_LOC_STRESS2
          INTEGER               :: NB_MAX
          INTEGER               :: NCOL_NITYP
          INTEGER, ALLOCATABLE  :: NNEIB_EST1(:,:)
          INTEGER, ALLOCATABLE  :: NNEIB_EST2(:,:)
          INTEGER, ALLOCATABLE  :: NNEIB_EST_MAX(:,:)
          REAL(q), ALLOCATABLE  :: PS(:,:,:)
          REAL(q), ALLOCATABLE  :: PS_COUPLE(:)
          REAL(q), ALLOCATABLE  :: PS_DUMMY(:)
          REAL(q), ALLOCATABLE  :: RBS(:,:,:,:)
          REAL(q)               :: RMEM_HELP1
          REAL(q)               :: RMEM_HELP2
          REAL(q)               :: RMEM_MB
          REAL(q), ALLOCATABLE  :: RNORM_ALL(:,:)
          REAL(q), ALLOCATABLE  :: RNORM_C00(:,:)
          REAL(q), ALLOCATABLE  :: RNORM_PS(:,:)
          REAL(q), ALLOCATABLE  :: SOAP1(:,:)
          REAL(q), ALLOCATABLE  :: SOAP2(:,:)
          REAL(q), ALLOCATABLE  :: STRESS_HELP(:,:,:,:)
          REAL(q), ALLOCATABLE  :: VEC_LOC_ENERGY(:,:)
          REAL(q), ALLOCATABLE  :: VEC_LOC_FORCE1(:,:)
          REAL(q), ALLOCATABLE  :: VEC_LOC_FORCE2(:,:)
          REAL(q), ALLOCATABLE  :: VEC_LOC_STRESS1(:,:)
          REAL(q), ALLOCATABLE  :: VEC_LOC_STRESS2(:,:)
          REAL(q)               :: VPUTIM0
          REAL(q)               :: VPUTIM1
          REAL(q), ALLOCATABLE  :: XYZ_EST1(:,:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST2(:,:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST_MAX(:,:,:,:)
! Start profilin g
          PROFILING_START ('init_fmat')
! Construct design matrix for manybody fitting
          RMEM_MB=0.0_q
          IF(FF%LMLMB) THEN
! Measure the initial times
             CALL VTIME (VPUTIM0,CPUTIM0)
! Configure the maximum number ofneghbouring atoms
             CALL SET_SIZE_EST_INIT_FMAT_MB
! Allocate
             CALL ALLOCATE_MB_ARRAY_INIT_FMAT
! Initialize the variable necessary for counting the memory usage
             RMEM_HELP1=0.0_q
! Make list for the location of the begining of basis sets for each atom type.
! In this subroutine, LHEAD should be LB(1,INTYP0)
             LHEAD(1)=1
             DO INTYP0=2, FF%MTYP, 1
                LHEAD(INTYP0)=LHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
             ENDDO
! Calculate design matrix.
             DO ICONF=1, NCONF, 1
! Initialization of helping design-matrix arrays.
                CALL INIT_FMAT_HELP_INIT_MB
! Initialization of expansion coefficients
                CALL INIT_CLM_INIT_FMAT_MB
! Initialization of SOAP matrix.
                CALL INIT_SOAP_INIT_FMAT_MB
! Configure structural data
                CALL SET_EST_DATA_INIT_FMAT_MB
! Calculate expansion coefficients
                CALL D0CLM_INIT_FMAT_MB
! Calculate angular descriptor
                DO INTYP=1, NTYP(ICONF)
                   INTYP0=LADD(INTYP,ICONF)
! Set column size for atom index.
                   NCOL_NITYP=0
                   DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                      INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                      IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                         NCOL_NITYP=NCOL_NITYP+1
                      ENDIF
                   ENDDO
! Calculate 1-point correlation descriptor
                   CALL D0C00_INIT_FMAT_MB
! Calculate 2-point correlation descriptor
                   CALL D0PS_INIT_FMAT_MB
! Normalization.
                   CALL NORMALIZATION_D0_INIT_FMAT_MB
! Calculate SOAP kernel.
                   CALL SOAP_KERNEL_INIT_FMAT_MB
! Calculate energy matrix elements, and copy them to global arrays.
                   CALL ENERGY_INIT_FMAT_MB
                ENDDO
! Calculate derivatives of SOAP kernel
! MPI-parallel over KNIONS loop.
                DO KNIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                   KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(KNIONS.LE.NIONS(ICONF)) THEN
                      KNTYP0=LNTYP(KNIONS,ICONF)
                      KNITYP=LNITYP(KNIONS,ICONF)
! Calculate derivatives of expansion coefficients.
                      CALL D1CLM_INIT_FMAT_MB
! Calculate derivatives of angular descriptor.
                      CALL D1C00_INIT_FMAT_MB
                      CALL D1PS_INIT_FMAT_MB
! Normalization.
                      CALL NORMALIZATION_D1_INIT_FMAT_MB
! Element loop.
                      DO INTYP=1, NTYP(ICONF)
                         INTYP0=LADD(INTYP,ICONF)
! Calculate derivatives of SOAP similarity kernel.
                         CALL DSOAP_KERNEL_INIT_FMAT_MB
! Calculate force and stress components.
                         CALL FORCE_AND_STRESS_INIT_FMAT_MB
                      ENDDO ! End of INTYP (element) loop
                   ENDIF
                ENDDO ! End of KNIONS (atom) loop
! Transfer and copy the calculated force components in design matrix into the distributed FFM%FMAT array.
                DO INTYP=1, NTYP(ICONF)
                   INTYP0=LADD(INTYP,ICONF)
                   CALL COPY_FORCE_AND_STRESS_INIT_FMAT_MB
                ENDDO ! End of element loop
             ENDDO ! End of configuration loop
! Deallocate helping arrays needed
             CALL DEALLOCATE_MB_ARRAY_INIT_FMAT
          ENDIF
! Stop profiling
          PROFILING_STOP ('init_fmat')

          CONTAINS

! Subroutine to initialize the SOAP matrices.

          SUBROUTINE INIT_SOAP_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IERR
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  DO IB=1, NB_MAX
                     MLSHM%SOAP_C00(1:NIONS(ICONF),IB)=0.0_q
                  ENDDO
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  DO IB=1, NB_MAX
                     MLSHM%SOAP_PS(1:NIONS(ICONF),IB)=0.0_q
                  ENDDO
               ENDIF
            ELSE
               DO IB=1, NB_MAX
                  MLSHM%SOAP_ALL(1:NIONS(ICONF),IB)=0.0_q
               ENDDO
            ENDIF
#ifdef use_shmem
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
          END SUBROUTINE INIT_SOAP_INIT_FMAT_MB

! Subroutine to calculate radial descriptors by using fast method.

          SUBROUTINE D0C00_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: INIONS
            INTEGER               :: INITYP
            INTEGER               :: INITYP_TMP
            INTEGER               :: LOCVAR_COL_C00
            INTEGER               :: LOCVAR_COL_CLM1
            INTEGER               :: LOCVAR_COL_CLM1_COUPLE
            IF(FFM%W1.GT.0.0_q) THEN
! Calculate C00.
! MPI-parallel over INITYP loop.
               PROFILING_START('d0c00_soap_init_fmat_mb')
               DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                     INIONS=LNIONS(INITYP,INTYP0,ICONF)
                     LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM1=INIONS
                     LOCVAR_COL_CLM1_COUPLE=1
                     CALL D0C00_SOAP (C00(1:,LOCVAR_COL_C00,INTYP0),C00_COUPLE(1:),MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE), &
                          LADD(1:,ICONF),.FALSE.,FFM%LMAX1,FFM%LNORM1, &
                          MROW_C00,MROW_C00_COUPLE,FFM%MRB1,MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY,FFM%NRB1(0:),NTYP(ICONF))
                  ENDIF
               ENDDO
               PROFILING_STOP('d0c00_soap_init_fmat_mb')
            ENDIF
          END SUBROUTINE D0C00_INIT_FMAT_MB

! Subroutine to calculate angular descriptors by using fast method.

          SUBROUTINE D0PS_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: INIONS
            INTEGER               :: INTYP
            INTEGER               :: INITYP
            INTEGER               :: INITYP_TMP
            INTEGER               :: LOCVAR_COL_CLM2
            INTEGER               :: LOCVAR_COL_CLM2_COUPLE
            INTEGER               :: LOCVAR_COL_PS
            INTEGER               :: LOCVAR_COL_PS_SIC
            INTEGER               :: LOCVAR_COL_PS_SIC_COUPLE
            IF(FFM%W2.GT.0.0_q) THEN
! Calculate normalized PS.
! MPI-parallel.
               PROFILING_START('d0ps_soap_init_fmat_mb')
               DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                     INIONS=LNIONS(INITYP,INTYP0,ICONF)
                     LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM2=INIONS
                     LOCVAR_COL_CLM2_COUPLE=1
                     IF(FFM%LSIC) THEN
                        LOCVAR_COL_PS_SIC=INIONS
                     ELSE
                        LOCVAR_COL_PS_SIC=1
                     ENDIF 
                     LOCVAR_COL_PS_SIC_COUPLE=1
!                     CALL D0PS_SOAP (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                     CALL SELECTOR_D0PS (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                          MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE), &
                          FFM%DESC_TYPE,FFM%IAFILT2, &
                          INTYP0,FFM%LAFILT2,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC, &
                          FFM%L_LNRB2,FFM%LMAX2,FFM%LNORM2,FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                          FFM%MLNRB2,MROW_PS,MROW_PS_COUPLE,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                          FFM%MRB2,MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY, &
                          FFM%NLNRB2,FFM%NRB2(0:),FFM%NRB_LNRB2,NTYP(ICONF), &
                          PS(1:,LOCVAR_COL_PS,INTYP0),PS_COUPLE(1:),MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC), &
                          MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%WVAR)
                  ENDIF
               ENDDO
               PROFILING_STOP('d0ps_soap_init_fmat_mb')
            ENDIF
          END SUBROUTINE D0PS_INIT_FMAT_MB

! Normalization.

          SUBROUTINE NORMALIZATION_D0_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IERR
            INTEGER               :: INIONS 
            INTEGER               :: INITYP
            INTEGER               :: INITYP_TMP
            INTEGER               :: LOCVAR_COL_C00
            INTEGER               :: LOCVAR_COL_PS
            INTEGER               :: LOCVAR_COL_RNORM_ALL
            INTEGER               :: LOCVAR_COL_RNORM_C00
            INTEGER               :: LOCVAR_COL_RNORM_PS
! Initializations of norm.
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  RNORM_C00(1:NITYP(INTYP0,ICONF),INTYP0)=0.0_q
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  RNORM_PS(1:NITYP(INTYP0,ICONF),INTYP0)=0.0_q
               ENDIF
            ELSE
               RNORM_ALL(1:NITYP(INTYP0,ICONF),INTYP0)=0.0_q
            ENDIF
! MPI-parallel.
            PROFILING_START('normalization_d0_init_fmat_mb')
            DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
               INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
               IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                  INIONS=LNIONS(INITYP,INTYP0,ICONF)
                  IF(.NOT.FFM%LSUPERVEC) THEN
                     IF(FFM%W1.GT.0.0_q) THEN
                        LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        LOCVAR_COL_RNORM_C00=INITYP
                     ELSE
                        LOCVAR_COL_C00=1
                        LOCVAR_COL_RNORM_C00=1
                     ENDIF
                     IF(FFM%W2.GT.0.0_q) THEN
                        LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        LOCVAR_COL_RNORM_PS=INITYP
                     ELSE
                        LOCVAR_COL_PS=1
                        LOCVAR_COL_RNORM_PS=1
                     ENDIF
                     LOCVAR_COL_RNORM_ALL=1
                  ELSE
                     IF(FFM%W1.GT.0.0_q) THEN
                        LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     ELSE
                        LOCVAR_COL_C00=1
                     ENDIF
                     IF(FFM%W2.GT.0.0_q) THEN
                        LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     ELSE
                        LOCVAR_COL_PS=1
                     ENDIF
                     LOCVAR_COL_RNORM_C00=1
                     LOCVAR_COL_RNORM_PS=1
                     LOCVAR_COL_RNORM_ALL=INITYP
                  ENDIF
                  CALL NORMALIZATION_D0 (C00(1:,LOCVAR_COL_C00,INTYP0),C00_COUPLE(1:),FFM%LSUPERVEC,.FALSE.,FFM%LNORM1,FFM%LNORM2, &
                       MROW_C00,MROW_C00_COUPLE,MROW_PS,MROW_PS_COUPLE,FFM%NNVAR1,FFM%NNVAR2(INTYP0),PS(1:,LOCVAR_COL_PS,INTYP0),PS_COUPLE(1:), &
                       RNORM_ALL(LOCVAR_COL_RNORM_ALL,INTYP0),RNORM_C00(LOCVAR_COL_RNORM_C00,INTYP0),RNORM_PS(LOCVAR_COL_RNORM_PS,INTYP0),FFM%W1,FFM%W2)
               ENDIF
            ENDDO
            PROFILING_STOP('normalization_d0_init_fmat_mb')
            PROFILING_START('allred_rnorm_init_fmat_mb')
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_C00(1,INTYP0),NITYP(INTYP0,ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_PS(1,INTYP0),NITYP(INTYP0,ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDIF
            ELSE
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_ALL(1,INTYP0),NITYP(INTYP0,ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
            PROFILING_STOP('allred_rnorm_init_fmat_mb')
          END SUBROUTINE NORMALIZATION_D0_INIT_FMAT_MB

! Subroutine to calculate SOAP similarity kernel using fast method.

          SUBROUTINE SOAP_KERNEL_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IERR
            INTEGER               :: IHEAD
            INTEGER               :: INIONS
            INTEGER               :: INITYP
            INTEGER               :: INITYP_TMP
            INTEGER               :: IPOLY
            INTEGER               :: LOCVAR_COL
            IPOLY=0
! Set header in the array.
            IHEAD=LHEAD(INTYP0)
! Calculate contribution from 1-point correlation function
            IF(FFM%W1.GT.0.0_q) THEN
               IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                  PROFILING_START('dgemm_soap1_init_fmat_mb')
#ifdef scaLAPACK
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB(INTYP0),FFM%NNVAR1,1.0_q,C00(1,1,INTYP0), &
                       MROW_C00,FFM%C00_ALL(1,IHEAD),FFM%MMVAR1,0.0_q,SOAP1(1,1),MROW_SOAP)
#else
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB(INTYP0),FFM%NNVAR1,1.0_q,C00(1,1,INTYP0), &
                       MROW_C00,FFM%C00(1,1,INTYP0),FFM%MMVAR1,0.0_q,SOAP1(1,1),MROW_SOAP)
#endif
                  PROFILING_STOP('dgemm_soap1_init_fmat_mb')
                  PROFILING_START('poly_soap1_init_fmat_mb')
                  IF (FF%LTOTEN_SYSTEM) THEN
                     CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,1,NCOL_NITYP,FFM%NB(INTYP0),FFM%NHYP1,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W1)
                  ELSE
                     CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,NIONS(ICONF),NCOL_NITYP,FFM%NB(INTYP0),FFM%NHYP1,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W1)
                  ENDIF
                  PROFILING_STOP('poly_soap1_init_fmat_mb')
                  IPOLY=1
               ENDIF
! Store the calculated SOAP1 to SOAP_C00.
! MPI-parallel.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  PROFILING_START('gather_soap_c00_init_fmat_mb')
                  IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                     DO IB=1, FFM%NB(INTYP0)
                        DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                           INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                           IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                              INIONS=LNIONS(INITYP,INTYP0,ICONF)
                              LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                              MLSHM%SOAP_C00(INIONS,IB)=FFM%W1*REAL(FFM%NHYP1,q)*(SOAP1(LOCVAR_COL,IB))**(FFM%NHYP1-1)
                           ENDIF
                        ENDDO
                     ENDDO
                  ENDIF
! wait so that all shared memory arrays finish writing
#ifdef use_shmem
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_C00 at the end of INTYP loop.
                  IF(INTYP.EQ.NTYP(ICONF)) THEN
                     PROFILING_START ('allred_soap_c00_init_fmat_mb')
#ifdef use_shmem
                     IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN 
                        CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_C00,MLSHM%MROW_SOAP_C00_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                             PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                     ENDIF
                     CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_C00,MLSHM%MROW_SOAP_C00_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
                     PROFILING_STOP ('allred_soap_c00_init_fmat_mb')
                  ENDIF
                  PROFILING_STOP('gather_soap_c00_init_fmat_mb')
               ENDIF
            ENDIF
! Calculate contribution from 2-point correlation function
            IF(FFM%W2.GT.0.0_q) THEN
               IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                  PROFILING_START('dgemm_soap2_init_fmat_mb')
#ifdef scaLAPACK
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q,PS(1,1,INTYP0),MROW_PS, &
                       FFM%PS_ALL(1,IHEAD),FFM%MMVAR2,0.0_q,SOAP1(1,1),MROW_SOAP)
#else
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q,PS(1,1,INTYP0),MROW_PS, &
                       FFM%PS(1,1,INTYP0),FFM%MMVAR2,0.0_q,SOAP1(1,1),MROW_SOAP)
#endif
                  PROFILING_STOP('dgemm_soap2_init_fmat_mb')
                  PROFILING_START('poly_soap2_init_fmat_mb')
                  IF (FF%LTOTEN_SYSTEM) THEN
                     CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,1,NCOL_NITYP,FFM%NB(INTYP0),FFM%NHYP2,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W2)
                  ELSE
                     CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,NIONS(ICONF),NCOL_NITYP,FFM%NB(INTYP0),FFM%NHYP2,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W2)
                  ENDIF
                  PROFILING_STOP('poly_soap2_init_fmat_mb')
               ENDIF
! Store the calculated SOAP1 to SOAP_PS.
! MPI-parallel.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  PROFILING_START('gather_soap_ps_init_fmat_mb')
                  IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                     DO IB=1, FFM%NB(INTYP0)
                        DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                           INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                           IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                              INIONS=LNIONS(INITYP,INTYP0,ICONF)
                              LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                              MLSHM%SOAP_PS(INIONS,IB)=FFM%W2*REAL(FFM%NHYP2,q)*(SOAP1(LOCVAR_COL,IB))**(FFM%NHYP2-1)
                           ENDIF
                        ENDDO
                     ENDDO
                  ENDIF
#ifdef use_shmem
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_PS at the end of INTYP loop.
                  IF(INTYP.EQ.NTYP(ICONF)) THEN
                     PROFILING_START ('allred_soap_ps_init_fmat_mb')
#ifdef use_shmem
                     IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                        CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_PS,MLSHM%MROW_SOAP_PS_GLOBAL*NB_MAX,MPI_REAL8, &
                             MPI_SUM,PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                     ENDIF
                     CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_PS,MLSHM%MROW_SOAP_PS_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
                     PROFILING_STOP ('allred_soap_ps_init_fmat_mb')
                  ENDIF
                  PROFILING_STOP('gather_soap_ps_init_fmat_mb')
               ENDIF
            ENDIF
            IF(FFM%LSUPERVEC) THEN
! Store the calculated SOAP1 to SOAP_ALL.
! MPI-parallel.
               PROFILING_START('gather_soap_all_init_fmat_mb')
               IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                  DO IB=1, FFM%NB(INTYP0)
                     DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                        INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                        IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                           INIONS=LNIONS(INITYP,INTYP0,ICONF)
                           LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           MLSHM%SOAP_ALL(INIONS,IB)=REAL(FFM%NHYP2,q)*(SOAP2(LOCVAR_COL,IB))**(FFM%NHYP2-1)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDIF
#ifdef use_shmem
               CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_PS at the end of INTYP loop.
               IF(INTYP.EQ.NTYP(ICONF)) THEN
                  PROFILING_START ('allred_soap_all_init_fmat_mb')
#ifdef use_shmem
                  IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_ALL,MLSHM%MROW_SOAP_ALL_GLOBAL*NB_MAX,MPI_REAL8, &
                          MPI_SUM,PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                  ENDIF
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_ALL,MLSHM%MROW_SOAP_ALL_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
                  PROFILING_STOP ('allred_soap_all_init_fmat_mb')
               ENDIF
               PROFILING_STOP('gather_soap_all_init_fmat_mb')
! Calculate SOAP similarity measure for super vector.
               PROFILING_START('poly_soap_all_init_fmat_mb')
               IF (FF%LTOTEN_SYSTEM) THEN
                  CALL POLY_SOAP2 (MROW_SOAP,MCOL_SOAP,1,NCOL_NITYP,FFM%NB(INTYP0),FFM%NHYP2,SOAP2(1:,1:))
               ELSE
                  CALL POLY_SOAP2 (MROW_SOAP,MCOL_SOAP,NIONS(ICONF),NCOL_NITYP,FFM%NB(INTYP0),FFM%NHYP2,SOAP2(1:,1:))
               ENDIF
               PROFILING_STOP('poly_soap_all_init_fmat_mb')
            ENDIF
          END SUBROUTINE SOAP_KERNEL_INIT_FMAT_MB

! Subroutine to calculate energy components in the design-matrix and copy them to global arrays.

          SUBROUTINE ENERGY_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IERR
            INTEGER               :: LOCVAR_COL
            INTEGER               :: LOCVAR_ROW
            INTEGER               :: TEST_COL
            INTEGER               :: TEST_ROW
            PROFILING_START('energy_init_fmat_mb')
            IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
               VEC_LOC_ENERGY=1.0_q
               CALL DGEMV ('T',NCOL_NITYP,FFM%NB(INTYP0),1.0_q, &
                    SOAP2,MROW_SOAP,VEC_LOC_ENERGY(1,1), &
                    1,0.0_q,ENERGY_HELP(1),1)
            ELSE
               ENERGY_HELP=0.0_q
            ENDIF
            PROFILING_STOP('energy_init_fmat_mb')
! All-reduce ENERGY_HELP.
            PROFILING_START ('allred_energy_init_fmat_mb')
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,ENERGY_HELP,FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            PROFILING_STOP ('allred_energy_init_fmat_mb')
! Store the design matrix elements
            IF(FFM%NB(INTYP0).GT.0) THEN
#ifdef scaLAPACK
               TEST_COL=MOD((FFM%LTOTEN(ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                  LOCVAR_COL=GLOBAL2LOCAL(FFM%LTOTEN(ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                  LOCVAR_COL=FFM%LTOTEN(ICONF)
#endif
                  DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                     TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
#else
                     LOCVAR_ROW=IB
#endif
                     FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=ENERGY_HELP(IB)
                  ENDDO
#ifdef scaLAPACK
               ENDIF
#endif
            ENDIF
          END SUBROUTINE ENERGY_INIT_FMAT_MB

! Subroutine to calculate derivatives of expansion coefficients by using fast method.

          SUBROUTINE D1CLM_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: LOCVAR_COL_EST1
            INTEGER               :: LOCVAR_COL_EST2
            PROFILING_START('d1clm_soap_init_fmat_mb')
            IF(FFM%W1.GT.0.0_q) THEN
               LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               CALL D1CLM_SOAP (DCLM1,FFM%DRSPL1,FFM%FNL1,FFM%FWIN1,KNIONS,KNTYP0, &
                    LADD(1:,ICONF),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1), &
                    .FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                    MCOL_DCLM1,MCOL_DPS_SIC,FF%MIONS,FFM%MRB1, &
                    MROW_DCLM1,MROW_DPS_SIC,MROW_EST1,FFM%MSPL1,MTYP, &
                    NNEIB_EST1(1:,LOCVAR_COL_EST1),FFM%NRB1(0:),FFM%NSPL1,NTYP(ICONF), &
                    DPS_SIC,FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST1(1:,1:,1:,LOCVAR_COL_EST1))
               RMEM_HELP1=MAX(RMEM_HELP1,RMEM_HELP2)
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               CALL D1CLM_SOAP (DCLM2,FFM%DRSPL2,FFM%FNL2,FFM%FWIN2,KNIONS,KNTYP0, &
                    LADD(1:,ICONF),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LMAX2,LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                    FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW2, &
                    MCOL_DCLM2,MCOL_DPS_SIC,FF%MIONS,FFM%MRB2, &
                    MROW_DCLM2,MROW_DPS_SIC,MROW_EST2,FFM%MSPL2,MTYP, &
                    NNEIB_EST2(1:,LOCVAR_COL_EST2),FFM%NRB2(0:),FFM%NSPL2,NTYP(ICONF), &
                    DPS_SIC,FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST2(1:,1:,1:,LOCVAR_COL_EST2))
               RMEM_HELP1=MAX(RMEM_HELP1,RMEM_HELP2)
            ENDIF
            PROFILING_STOP('d1clm_soap_init_fmat_mb')
          END SUBROUTINE D1CLM_INIT_FMAT_MB

! Subroutine to calculate derivatives of radial descriptors by using fast method.

          SUBROUTINE D1C00_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER :: LOCVAR_COL_EST1
            INTEGER :: LOCVAR_COL_EST_MAX
            IF(FFM%W1 .GT. 0.0_q) THEN
               PROFILING_START('d1c00_soap1_init_fmat_mb')
               LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               IF(.NOT.FFM%LSUPERVEC) THEN
                  LOCVAR_COL_EST_MAX=1
               ELSE
                  LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ENDIF
               CALL D1C00_SOAP (MLSHM%CLM1,DC00,DCLM1,FFM%LSUPERVEC,KNTYP0, &
                    LADD(1:,ICONF),FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1),LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX), &
                    MLSHM%MCOL_CLM1_GLOBAL,MCOL_DC00,MCOL_DCLM1,FFM%MRB1,MROW_EST1,MROW_EST_MAX,MLSHM%MROW_CLM1_GLOBAL,MROW_DC00,MROW_DCLM1, &
                    AB%MTYP,AB%MTYP_ALLOCATE,NNEIB_EST1(1:,LOCVAR_COL_EST1),NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NRB1(0:),NTYP(ICONF))
               PROFILING_STOP('d1c00_soap1_init_fmat_mb')
            ENDIF
          END SUBROUTINE D1C00_INIT_FMAT_MB

! Subroutine to calculate derivatives of angular descriptors.

          SUBROUTINE D1PS_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER :: LOCVAR_COL_EST2
            INTEGER :: LOCVAR_COL_EST_MAX
            IF(FFM%W2 .GT. 0.0_q) THEN
               PROFILING_START('d1ps_soap_init_fmat_mb')
               LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               IF(.NOT.FFM%LSUPERVEC) THEN
                  LOCVAR_COL_EST_MAX=1
               ELSE
                  LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ENDIF
!               CALL D1PS_SOAP (FFM%AFILT2,MLSHM%CLM2,DCLM2,DPS,DPS_SIC,FFM%IAFILT2,FFM%LSUPERVEC,KNTYP0, &
               CALL SELECTOR_D1PS (FFM%AFILT2,MLSHM%CLM2,DCLM2,FFM%DESC_TYPE,DPS,DPS_SIC,FFM%IAFILT2,FFM%LSUPERVEC,KNTYP0, &
                    FFM%LAFILT2,LADD(1:,ICONF),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%L_LNRB2,FFM%LMAX2, &
                    LNIONS_EST2(1:,1:,LOCVAR_COL_EST2),LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX),FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                    MLSHM%MCOL_CLM2_GLOBAL,MCOL_DCLM2,MCOL_DPS,MCOL_DPS_SIC,MLSHM%MCOL_PS_SIC_GLOBAL,FFM%MLNRB2,FFM%MRB2, &
                    MROW_EST2,MROW_EST_MAX,MLSHM%MROW_CLM2_GLOBAL,MROW_DCLM2, &
                    MROW_DPS,MROW_DPS_SIC,MLSHM%MROW_PS_SIC_GLOBAL,MTYP,AB%MTYP_ALLOCATE, &
                    NIONS(ICONF),FFM%NLNRB2,NNEIB_EST2(1:,LOCVAR_COL_EST2),NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX), &
                    FFM%NRB2(0:),FFM%NRB_LNRB2,NTYP(ICONF),MLSHM%PS_SIC,FFM%WVAR)
               PROFILING_STOP('d1ps_soap_init_fmat_mb')
            ENDIF
          END SUBROUTINE D1PS_INIT_FMAT_MB

! Normalization.

          SUBROUTINE NORMALIZATION_D1_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER :: LOCVAR_COL_EST1 
            INTEGER :: LOCVAR_COL_EST2
            INTEGER :: LOCVAR_COL_EST_MAX
            PROFILING_START('normalization_d1_init_fmat_mb')
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST1=1
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST2=1
               ENDIF
               LOCVAR_COL_EST_MAX=1
            ELSE
               IF(FFM%W1.GT.0.0_q) THEN
                  LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST1=1
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST2=1
               ENDIF
               LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ENDIF
            CALL NORMALIZATION_D1 (DC00,DPS,FFM%LSUPERVEC,KNTYP0, &
                 LADD(1:,ICONF),LNIONS_EST1(1:,1:,LOCVAR_COL_EST1),LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                 LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX),LNITYP(1:,ICONF),FFM%LNORM1,FFM%LNORM2, &
                 MCOL_DC00,MCOL_DPS,MCOL_RNORM_ALL,MCOL_RNORM_C00,MCOL_RNORM_PS,MIONS,MITYP,MROW_EST1, &
                 MROW_EST2,MROW_EST_MAX,MROW_DC00,MROW_DPS,MROW_RNORM_C00,MROW_RNORM_PS,FF%MTYP_ALLOCATE, &
                 NNEIB_EST1(1:,LOCVAR_COL_EST1),NNEIB_EST2(1:,LOCVAR_COL_EST2), &
                 NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NNVAR1,FFM%NNVAR2,NTYP(ICONF), &
                 FFM%RCUT1,FFM%RCUT2,RNORM_ALL(1:,1:),RNORM_C00(1:,1:),RNORM_PS(1:,1:),FFM%W1,FFM%W2)
            PROFILING_STOP('normalization_d1_init_fmat_mb')
          END SUBROUTINE NORMALIZATION_D1_INIT_FMAT_MB

! Subroutine to calculate derivatives of SOAP similarity kernel.

          SUBROUTINE DSOAP_KERNEL_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IHEAD
            INTEGER               :: IXYZ
            INTEGER               :: LOCVAR_COL
            INTEGER               :: NNEIB_EST_DUMMY
! Local variables
! Calculate header.
            IHEAD=LHEAD(INTYP0)
! Calculate LOCVAR_COL.
            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Calculate derivatives of 1-point correlation kernel
            IF(FFM%W1 .GT. 0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
                     PROFILING_START('dgemm_dsoap1_init_fmat_mb')
#ifdef scaLAPACK
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                          DC00(1,1,IXYZ,INTYP0),MROW_DC00,FFM%C00_ALL(1,IHEAD),FFM%MMVAR1, &
                          0.0_q,DSOAP11(1,1),MROW_DSOAP1)
#else
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                          DC00(1,1,IXYZ,INTYP0),MROW_DC00,FFM%C00(1,1,INTYP0),FFM%MMVAR1, &
                          0.0_q,DSOAP11(1,1),MROW_DSOAP1)
#endif
                     PROFILING_STOP('dgemm_dsoap1_init_fmat_mb')
                     PROFILING_START('poly_dsoap1_init_fmat_mb')
                     IF(.NOT.FFM%LSUPERVEC) THEN
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST1(1:,INTYP0,LOCVAR_COL)   ,MROW_EST1   ,MROW_DSOAP1,MCOL_DSOAP1,MLSHM%MROW_SOAP_C00_GLOBAL,MLSHM%MCOL_SOAP_C00_GLOBAL, &
                             NNEIB_EST1(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP11(1:,1:),DSOAP21(1:,1:,IXYZ),MLSHM%SOAP_C00,FFM%W1)
                     ELSE
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST_MAX(1:,INTYP0,LOCVAR_COL),MROW_EST_MAX,MROW_DSOAP1,MCOL_DSOAP1,MLSHM%MROW_SOAP_ALL_GLOBAL,MLSHM%MCOL_SOAP_ALL_GLOBAL, &
                             NNEIB_EST_MAX(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP11(1:,1:),DSOAP21(1:,1:,IXYZ),MLSHM%SOAP_ALL,FFM%W1)
                     ENDIF
                     PROFILING_STOP('poly_dsoap1_init_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF
! Calculate derivatives of 2-point correlation kernel
            IF(FFM%W2 .GT. 0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
                     PROFILING_START('dgemm_dsoap2_init_fmat_mb')
#ifdef scaLAPACK
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                          DPS(1,1,IXYZ,INTYP0),MROW_DPS,FFM%PS_ALL(1,IHEAD),FFM%MMVAR2, &
                          0.0_q,DSOAP12(1,1),MROW_DSOAP2)
#else
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                          DPS(1,1,IXYZ,INTYP0),MROW_DPS,FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                          0.0_q,DSOAP12(1,1),MROW_DSOAP2)
#endif
                     PROFILING_STOP('dgemm_dsoap2_init_fmat_mb')
                     PROFILING_START('poly_dsoap2_init_fmat_mb')
                     IF(.NOT.FFM%LSUPERVEC) THEN
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST2(1:,INTYP0,LOCVAR_COL)   ,MROW_EST2   ,MROW_DSOAP2,MCOL_DSOAP2,MLSHM%MROW_SOAP_PS_GLOBAL,MLSHM%MCOL_SOAP_PS_GLOBAL, &
                             NNEIB_EST2(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP12(1:,1:),DSOAP22(1:,1:,IXYZ),MLSHM%SOAP_PS,FFM%W2)
                     ELSE
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST_MAX(1:,INTYP0,LOCVAR_COL),MROW_EST_MAX,MROW_DSOAP2,MCOL_DSOAP2,MLSHM%MROW_SOAP_ALL_GLOBAL,MLSHM%MCOL_SOAP_ALL_GLOBAL, &
                             NNEIB_EST_MAX(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP12(1:,1:),DSOAP22(1:,1:,IXYZ),MLSHM%SOAP_ALL,FFM%W2)
                     ENDIF
                     PROFILING_STOP('poly_dsoap2_init_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF
          END SUBROUTINE DSOAP_KERNEL_INIT_FMAT_MB

! Subroutine to calculate force and stress components in the design matrix by using fast method.
! Copying subroutine is seperately written later.

          SUBROUTINE FORCE_AND_STRESS_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: INEIB
            INTEGER               :: IXYZ
            INTEGER               :: JXYZ
            INTEGER               :: LOCVAR_COL
            INTEGER               :: NNEIB_EST_DUMMY
            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Contributions from radial descriptor.
            IF(FFM%W1.GT.0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
! Calculate force components.
                     PROFILING_START('force_init_fmat_mb')
                     DO INEIB=1, NNEIB_EST_DUMMY+1
                        IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                           VEC_LOC_FORCE1(INEIB,1)=0.0_q
                        ELSE
                           VEC_LOC_FORCE1(INEIB,1)=1.0_q
                        ENDIF
                     ENDDO
                     CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                          VEC_LOC_FORCE1(1,1),1,1.0_q,FORCE_HELP1(1,IXYZ,LOCVAR_COL,INTYP0),1)
                     PROFILING_STOP('force_init_fmat_mb')
! Calculate stress components.
                     PROFILING_START('stress_init_fmat_mb')
                     DO JXYZ=IXYZ, 3
                        DO INEIB=1, NNEIB_EST_DUMMY+1
                           IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                              VEC_LOC_STRESS1(INEIB,1)=0.0_q
                           ELSE
                              IF(.NOT.FFM%LSUPERVEC) THEN
                                 VEC_LOC_STRESS1(INEIB,1)=-XYZ_EST1(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ELSE
                                 VEC_LOC_STRESS1(INEIB,1)=-XYZ_EST_MAX(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ENDIF
                           ENDIF
                        ENDDO
                        CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                             VEC_LOC_STRESS1(1,1),1,1.0_q,STRESS_HELP(1,JXYZ,IXYZ,INTYP0),1)
                     ENDDO
                     PROFILING_STOP('stress_init_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF
! Contributions from angular descriptors.
            IF(FFM%W2.GT.0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
! Calculate force components.
                     PROFILING_START('force_init_fmat_mb')
                     DO INEIB=1, NNEIB_EST_DUMMY+1
                        IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                           VEC_LOC_FORCE2(INEIB,1)=0.0_q
                        ELSE
                           VEC_LOC_FORCE2(INEIB,1)=1.0_q
                        ENDIF
                     ENDDO
                     CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                          VEC_LOC_FORCE2(1,1),1,1.0_q,FORCE_HELP1(1,IXYZ,LOCVAR_COL,INTYP0),1)
                     PROFILING_STOP('force_init_fmat_mb')
! Calculate stress components.
                     PROFILING_START('stress_init_fmat_mb')
                     DO JXYZ=IXYZ, 3
                        DO INEIB=1, NNEIB_EST_DUMMY+1
                           IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                              VEC_LOC_STRESS2(INEIB,1)=0.0_q
                           ELSE
                              IF(.NOT.FFM%LSUPERVEC) THEN
                                 VEC_LOC_STRESS2(INEIB,1)=-XYZ_EST2(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ELSE
                                 VEC_LOC_STRESS2(INEIB,1)=-XYZ_EST_MAX(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ENDIF
                           ENDIF
                        ENDDO
                        CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                             VEC_LOC_STRESS2(1,1),1,1.0_q,STRESS_HELP(1,JXYZ,IXYZ,INTYP0),1)
                     ENDDO
                     PROFILING_STOP('stress_init_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF
          END SUBROUTINE FORCE_AND_STRESS_INIT_FMAT_MB

! Subroutine to copy the calculated force and stress components in the design-matrix to global arrays.

          SUBROUTINE COPY_FORCE_AND_STRESS_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IB
            INTEGER               :: IERR
            INTEGER               :: IPROCESS
            INTEGER               :: IXYZ
            INTEGER               :: JXYZ
            INTEGER               :: KNIONS
            INTEGER               :: LOCVAR_COL
            INTEGER               :: LOCVAR_ROW
            INTEGER               :: TEST_COL
            INTEGER               :: TEST_ROW
            PROFILING_START('copy_force_init_fmat_mb')
            DO KNIONS=1, NIONS(ICONF)
               IPROCESS=MOD(KNIONS-1,PAR_SUP_HANDLE%COMM_WORLD%NCPU)
               DO IXYZ=1, 3
! Transfer the force elements to all processes.
                  IF(PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.IPROCESS) THEN
                     LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     FORCE_HELP2(1:FFM%NB(INTYP0))=FORCE_HELP1(1:FFM%NB(INTYP0),IXYZ,LOCVAR_COL,INTYP0)
                  ENDIF
                   CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FORCE_HELP2(1:),FFM%NB(INTYP0),IPROCESS)
! Store the design matrix elements
#ifdef scaLAPACK
                  TEST_COL=MOD((FFM%LTIFOR(IXYZ,KNIONS,ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                     LOCVAR_COL=GLOBAL2LOCAL(FFM%LTIFOR(IXYZ,KNIONS,ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                     LOCVAR_COL=FFM%LTIFOR(IXYZ,KNIONS,ICONF)
#endif
                     DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
#else
                        LOCVAR_ROW=IB
#endif
                        FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=FORCE_HELP2(IB)
                     ENDDO
#ifdef scaLAPACK
                  ENDIF
#endif
               ENDDO
            ENDDO
            PROFILING_STOP('copy_force_init_fmat_mb')
! Transfer and copy the calculated stress components in design matrix into the distributed FFM%FMAT array.
            PROFILING_START('copy_stress_init_fmat_mb')
            DO IXYZ=1, 3
               DO JXYZ=IXYZ, 3
! All-reduce STRESS_HELP.
                  PROFILING_START ('allred_stress_init_fmat_mb')
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,STRESS_HELP(1,JXYZ,IXYZ,INTYP0),FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                  PROFILING_STOP ('allred_stress_init_fmat_mb')
! Store the design matrix elements
#ifdef scaLAPACK
                  TEST_COL=MOD((FFM%LTSIF(JXYZ,IXYZ,ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                     LOCVAR_COL=GLOBAL2LOCAL(FFM%LTSIF(JXYZ,IXYZ,ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                     LOCVAR_COL=FFM%LTSIF(JXYZ,IXYZ,ICONF)
#endif
                     DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
#else
                        LOCVAR_ROW=IB
#endif
                        FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=STRESS_HELP(IB,JXYZ,IXYZ,INTYP0)
                     ENDDO
#ifdef scaLAPACK
                  ENDIF
#endif
               ENDDO
            ENDDO
            PROFILING_STOP('copy_stress_init_fmat_mb')
          END SUBROUTINE COPY_FORCE_AND_STRESS_INIT_FMAT_MB

! Subroutine to initialize the helping design-matrix arrays.

          SUBROUTINE INIT_FMAT_HELP_INIT_MB
            IMPLICIT NONE
! Initialization of force components in design-matrix.
            FORCE_HELP1=0.0_q
! Initialization of stress components in design-matrix.
            STRESS_HELP=0.0_q
          END SUBROUTINE INIT_FMAT_HELP_INIT_MB

! Subroutine to calculate the number of atom neighbours.

          SUBROUTINE SET_SIZE_EST_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: ICONF
            INTEGER               :: MNEIB_HELP
            PROFILING_START('st_init_fmat_mb')
            IF(FFM%W1.GT.0.0_q) THEN
               MNEIB_EST1=0
               DO ICONF=1, NCONF, 1
                  CALL SET_SIZE_EST (PAR_SUP_HANDLE%COMM_WORLD,A(1:,1:,ICONF),B(1:,1:,ICONF),LADD(1:,ICONF),LNIONS(1:,1:,ICONF), &
                       MIONS,MITYP,MNEIB_HELP,MTYP,NIONS(ICONF),NITYP(1:,ICONF),NTYP(ICONF), &
                       FFM%RCUT1,POSION(1:,1:,ICONF))
                  MNEIB_EST1=MAX(MNEIB_EST1,MNEIB_HELP)
               ENDDO
            ELSE
               MNEIB_EST1=1
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               MNEIB_EST2=0
               DO ICONF=1, NCONF, 1
                  CALL SET_SIZE_EST (PAR_SUP_HANDLE%COMM_WORLD,A(1:,1:,ICONF),B(1:,1:,ICONF),LADD(1:,ICONF),LNIONS(1:,1:,ICONF), &
                       MIONS,MITYP,MNEIB_HELP,MTYP,NIONS(ICONF),NITYP(1:,ICONF),NTYP(ICONF), &
                       FFM%RCUT2,POSION(1:,1:,ICONF))
                  MNEIB_EST2=MAX(MNEIB_EST2,MNEIB_HELP)
               ENDDO
            ELSE
               MNEIB_EST2=1
            ENDIF
            IF(.NOT.FFM%LSUPERVEC) THEN
               MNEIB_EST_MAX=1
            ELSE
               MNEIB_EST_MAX=MAX(MNEIB_EST1,MNEIB_EST2)
            ENDIF
            PROFILING_STOP('st_init_fmat_mb')
          END SUBROUTINE SET_SIZE_EST_INIT_FMAT_MB

! Subroutine to configure the structural data.

          SUBROUTINE SET_EST_DATA_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: INIONS
            INTEGER               :: INIONS_TMP
            INTEGER               :: LOCVAR_COL
            PROFILING_START('st_init_fmat_mb')
            DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
               INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
               IF(INIONS.LE.NIONS(ICONF)) THEN
                  LOCVAR_COL=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                  IF(FFM%W1.GT.0.0_q) THEN
                     CALL SET_EST_DATA_POINT (1,A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LNTYP(1:,ICONF),LNIONS_EST1(1:,1:,LOCVAR_COL),MIONS,MROW_EST1,MTYP, &
                          NIONS(ICONF),NNEIB_EST1(1:,LOCVAR_COL),NTYP(ICONF),FFM%RCUT1,FFM%RCUT1,FFM%RCUT2,POSION(1:,1:,ICONF), &
                          XYZ_EST1(1:,1:,1:,LOCVAR_COL))
                  ENDIF
                  IF(FFM%W2.GT.0.0_q) THEN
                     CALL SET_EST_DATA_POINT (1,A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LNTYP(1:,ICONF),LNIONS_EST2(1:,1:,LOCVAR_COL),MIONS,MROW_EST2,MTYP, &
                          NIONS(ICONF),NNEIB_EST2(1:,LOCVAR_COL),NTYP(ICONF),FFM%RCUT2,FFM%RCUT1,FFM%RCUT2,POSION(1:,1:,ICONF), &
                          XYZ_EST2(1:,1:,1:,LOCVAR_COL))
                  ENDIF
               ENDIF
            ENDDO
            IF(FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q.AND.FFM%W2.GT.0.0_q) THEN
                  IF(MNEIB_EST1.GE.MNEIB_EST2) THEN
                      LNIONS_EST_MAX=LNIONS_EST1
                      NNEIB_EST_MAX=NNEIB_EST1
                      XYZ_EST_MAX=XYZ_EST1
                  ELSE
                      LNIONS_EST_MAX=LNIONS_EST2
                      NNEIB_EST_MAX=NNEIB_EST2
                      XYZ_EST_MAX=XYZ_EST2
                  ENDIF
               ELSE
                  IF(FFM%W1.NE.0.0_q) THEN
                      LNIONS_EST_MAX=LNIONS_EST1
                      NNEIB_EST_MAX=NNEIB_EST1
                      XYZ_EST_MAX=XYZ_EST1
                  ELSE IF(FFM%W2.NE.0.0_q) THEN
                      LNIONS_EST_MAX=LNIONS_EST2
                      NNEIB_EST_MAX=NNEIB_EST2
                      XYZ_EST_MAX=XYZ_EST2
                  ENDIF
               ENDIF
            ENDIF
            PROFILING_STOP('st_init_fmat_mb')
          END SUBROUTINE SET_EST_DATA_INIT_FMAT_MB

! Subroutine to initialize the expansion coefficients CLM.

          SUBROUTINE INIT_CLM_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER :: IERR
            IF(FFM%W1.GT.0.0_q) THEN
               MLSHM%CLM1(1:MROW_CLM1,1:NIONS(ICONF))=0.0_q
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               MLSHM%CLM2(1:MROW_CLM2,1:NIONS(ICONF))=0.0_q
               IF(FFM%LSIC) THEN
                  MLSHM%PS_SIC(1:FFM%MMVAR2_SIC,1:NIONS(ICONF))=0.0_q
               ENDIF
            ENDIF
#ifdef use_shmem
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
          END SUBROUTINE INIT_CLM_INIT_FMAT_MB

! Subroutine to calculate the expansion coefficients.

          SUBROUTINE D0CLM_INIT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IERR
            INTEGER               :: INIONS
            INTEGER               :: INIONS_TMP
            INTEGER               :: INTYP0
            INTEGER               :: LOCVAR_COL_CLM1
            INTEGER               :: LOCVAR_COL_CLM1_COUPLE
            INTEGER               :: LOCVAR_COL_CLM2
            INTEGER               :: LOCVAR_COL_CLM2_COUPLE
            INTEGER               :: LOCVAR_COL_EST1
            INTEGER               :: LOCVAR_COL_EST2
            INTEGER               :: LOCVAR_COL_PS_SIC
            INTEGER               :: LOCVAR_COL_PS_SIC_COUPLE
! MPI parallelization
            PROFILING_START('d0clm_soap_init_fmat_mb')
            DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
               INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
               IF(INIONS.LE.NIONS(ICONF)) THEN
                  INTYP0=LNTYP(INIONS,ICONF)
                  IF(FFM%W1.GT.0.0_q) THEN
                     LOCVAR_COL_CLM1=INIONS
                     LOCVAR_COL_EST1=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM1_COUPLE=1
                     LOCVAR_COL_PS_SIC=1
                     LOCVAR_COL_PS_SIC_COUPLE=1
                     CALL D0CLM_SOAP (MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE),FFM%DRSPL1,FFM%FNL1,FFM%FWIN1, &
                          INTYP0,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1), &
                          .FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                          FF%MIONS,MROW_EST1,FFM%MRB1,FFM%MSPL1,MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                          NNEIB_EST1(1:,LOCVAR_COL_EST1),FFM%NRB1(0:),FFM%NSPL1,NTYP(ICONF), &
                          MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST1(1:,1:,1:,LOCVAR_COL_EST1))
                     RMEM_HELP1=MAX(RMEM_HELP1,RMEM_HELP2)
                  ENDIF
                  IF(FFM%W2.GT.0.0_q) THEN
                     LOCVAR_COL_CLM2=INIONS
                     LOCVAR_COL_EST2=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM2_COUPLE=1
                     IF(FFM%LSIC) THEN
                        LOCVAR_COL_PS_SIC=INIONS
                     ELSE
                        LOCVAR_COL_PS_SIC=1
                     ENDIF
                     LOCVAR_COL_PS_SIC_COUPLE=1
                     CALL D0CLM_SOAP (MLSHM%CLM2(:,LOCVAR_COL_CLM2),MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE),FFM%DRSPL2,FFM%FNL2,FFM%FWIN2, &
                          INTYP0,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX2,LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                          FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW2, &
                          FF%MIONS,MROW_EST2,FFM%MRB2,FFM%MSPL2,MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                          NNEIB_EST2(1:,LOCVAR_COL_EST2),FFM%NRB2(0:),FFM%NSPL2,NTYP(ICONF), &
                          MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST2(1:,1:,1:,LOCVAR_COL_EST2))
                     RMEM_HELP1=MAX(RMEM_HELP1,RMEM_HELP2)
                  ENDIF
               ENDIF
            ENDDO
#ifdef use_shmem
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
            PROFILING_STOP('d0clm_soap_init_fmat_mb')
! Reduction of expansion coefficients so that each process possesses the whole array CLM and PS_SIC.
            PROFILING_START ('allred_clm_init_fmat_mb')
#ifdef use_shmem
            IF(FFM%W1.GT.0.0_q) THEN
               IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM1,MLSHM%MROW_CLM1_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM, &
                       PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
               ENDIF
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM2,MLSHM%MROW_CLM2_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM, &
                       PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                  IF(FFM%LSIC) THEN
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC,MLSHM%MROW_PS_SIC_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM, &
                          PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                  ENDIF
               ENDIF
            ENDIF
!!!            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
            IF(FFM%W1.GT.0.0_q) THEN
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM1,MLSHM%MROW_CLM1_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM2,MLSHM%MROW_CLM2_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               IF(FFM%LSIC) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC,MLSHM%MROW_PS_SIC_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDIF
            ENDIF
#endif
            PROFILING_STOP ('allred_clm_init_fmat_mb')
          END SUBROUTINE D0CLM_INIT_FMAT_MB

          SUBROUTINE ALLOCATE_MB_ARRAY_INIT_FMAT
            IMPLICIT NONE
! Local variables
            INTEGER :: INTYP0 
! Definition of array sizes.
            NB_MAX=FFM%NB(1)
            DO INTYP0=2, FF%MTYP, 1
               NB_MAX=MAX(NB_MAX,FFM%NB(INTYP0))
            ENDDO
! Sizes for FORCE_HELP.
            MCOL_MIONS=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_MITYP=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of SOAP.
            MROW_SOAP=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_SOAP=FFM%MB
! Size of VEC_LOC_ENERGY.
            MROW_VEC_LOC_ENERGY=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_VEC_LOC_ENERGY=1
! Sizes for structural list.
            IF(.NOT.FFM%LSUPERVEC) THEN
               MROW_EST_MAX=1
               MCOL_EST_MAX=1
               MROW_RNORM_ALL=1
               MCOL_RNORM_ALL=MTYP
            ELSE
               MROW_EST_MAX=MNEIB_EST_MAX+1
               MCOL_EST_MAX=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               MROW_RNORM_ALL=MITYP
               MCOL_RNORM_ALL=MTYP
            ENDIF
! Sizes of arrays related to radial descriptor.
            IF(FFM%W1.GT.0.0_q) THEN
! Size of C00.
               MROW_C00=FFM%MMVAR1
               MCOL_C00=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of C00_COUPLE.
               IF(FFM%LCOUPLE) THEN
                  MROW_C00_COUPLE=FFM%MMVAR1
                  MCOL_C00_COUPLE=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  MROW_C00_COUPLE=1
                  MCOL_C00_COUPLE=1
               ENDIF
! Size of CLM1.
               MROW_CLM1=(FFM%LMAX1+1)**2*FF%MTYP*FFM%MRB1
               MCOL_CLM1=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of DCLM1.
               MROW_DCLM1=(FFM%LMAX1+1)**2*FF%MTYP*FFM%MRB1
               MCOL_DCLM1=MNEIB_EST1+1
! Size of DC00.
               MROW_DC00=FFM%MMVAR1
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MCOL_DC00=MNEIB_EST1+1
               ELSE
                  MCOL_DC00=MNEIB_EST_MAX+1
               ENDIF
! Size of DSOAP1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_DSOAP1=MNEIB_EST1+1
               ELSE
                  MROW_DSOAP1=MNEIB_EST_MAX+1
               ENDIF
               MCOL_DSOAP1=FFM%MB
! Size of structural lists.
               MROW_EST1=MNEIB_EST1+1
               MCOL_EST1=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of RNORM_C00
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_RNORM_C00=MITYP
                  MCOL_RNORM_C00=MTYP
               ELSE
                  MROW_RNORM_C00=1
                  MCOL_RNORM_C00=MTYP
               ENDIF
! Size of VEC_LOC_FORCE1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_FORCE1=MNEIB_EST1+1
               ELSE
                  MROW_VEC_LOC_FORCE1=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_FORCE1=1
! Size of VEC_LOC_STRESS1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_STRESS1=MNEIB_EST1+1
               ELSE
                  MROW_VEC_LOC_STRESS1=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_STRESS1=1
            ELSE
               MROW_C00=1
               MCOL_C00=1
               MROW_C00_COUPLE=1
               MCOL_C00_COUPLE=1
               MROW_CLM1=1
               MCOL_CLM1=1
               MROW_DC00=1
               MCOL_DC00=1
               MROW_DCLM1=1
               MCOL_DCLM1=1
               MROW_DSOAP1=1
               MCOL_DSOAP1=1
               MROW_EST1=1
               MCOL_EST1=1
               MROW_RNORM_C00=1
               MCOL_RNORM_C00=MTYP
               MROW_VEC_LOC_FORCE1=1
               MCOL_VEC_LOC_FORCE1=1
               MROW_VEC_LOC_STRESS1=1
               MCOL_VEC_LOC_STRESS1=1
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
! Size of CLM2.
               MROW_CLM2=(FFM%LMAX2+1)**2*FF%MTYP*FFM%MRB2
               MCOL_CLM2=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of DCLM2.
               MROW_DCLM2=(FFM%LMAX2+1)**2*FF%MTYP*FFM%MRB2
               MCOL_DCLM2=MNEIB_EST2+1
! Size of DPS.
               MROW_DPS=FFM%MMVAR2
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MCOL_DPS=MNEIB_EST2+1
               ELSE
                  MCOL_DPS=MNEIB_EST_MAX+1
               ENDIF
! Size of DPS_SIC.
               IF(FFM%LSIC) THEN
                  MROW_DPS_SIC=FFM%MMVAR2
                  MCOL_DPS_SIC=MNEIB_EST2+1
               ELSE
                  MROW_DPS_SIC=1
                  MCOL_DPS_SIC=1
               ENDIF
! Size of DSOAP2.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_DSOAP2=MNEIB_EST2+1
               ELSE
                  MROW_DSOAP2=MNEIB_EST_MAX+1
               ENDIF
               MCOL_DSOAP2=FFM%MB
! Size of structural lists.
               MROW_EST2=MNEIB_EST2+1
               MCOL_EST2=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of PS.
               MROW_PS=FFM%MMVAR2
               MCOL_PS=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of PS_COUPLE.
               IF(FFM%LCOUPLE) THEN
                  MROW_PS_COUPLE=FFM%MMVAR2
                  MCOL_PS_COUPLE=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  MROW_PS_COUPLE=1
                  MCOL_PS_COUPLE=1
               ENDIF
! Size of RNORM_PS
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_RNORM_PS=MITYP
                  MCOL_RNORM_PS=MTYP
               ELSE
                  MROW_RNORM_PS=1
                  MCOL_RNORM_PS=MTYP
               ENDIF
! Size of VEC_LOC_FORCE2.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_FORCE2=MNEIB_EST2+1
               ELSE
                  MROW_VEC_LOC_FORCE2=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_FORCE2=1
! Size of VEC_LOC_STRESS2.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_STRESS2=MNEIB_EST2+1
               ELSE
                  MROW_VEC_LOC_STRESS2=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_STRESS2=1
            ELSE
               MROW_CLM2=1
               MCOL_CLM2=1
               MROW_DCLM2=1
               MCOL_DCLM2=1
               MROW_DPS=1
               MCOL_DPS=1
               MROW_DPS_SIC=1
               MCOL_DPS_SIC=1
               MROW_DSOAP2=1
               MCOL_DSOAP2=1
               MROW_EST2=1
               MCOL_EST2=1
               MROW_PS=1
               MCOL_PS=1
               MROW_PS_COUPLE=1
               MCOL_PS_COUPLE=1
               MROW_RNORM_PS=1
               MCOL_RNORM_PS=MTYP
               MROW_VEC_LOC_FORCE2=1
               MCOL_VEC_LOC_FORCE2=1
               MROW_VEC_LOC_STRESS2=1
               MCOL_VEC_LOC_STRESS2=1
            ENDIF
! Then, allocate all arrays.
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            ALLOCATE (C00(1:MROW_C00,1:MCOL_C00,1:MTYP))
            RMEM_MB=RMEM_MB+REAL(MROW_C00,q)*REAL(MCOL_C00,q)*REAL(MTYP,q)*8/1.0E+06_q
            IF(ALLOCATED(C00_COUPLE)) THEN
               DEALLOCATE(C00_COUPLE)
            ENDIF
            ALLOCATE (C00_COUPLE(1:MROW_C00_COUPLE))
            RMEM_MB=RMEM_MB+REAL(MROW_C00_COUPLE,q)*8/1.0E+06_q
            IF(ALLOCATED(DCLM1)) THEN
               DEALLOCATE(DCLM1)
            ENDIF
            ALLOCATE (DCLM1(1:3,1:MROW_DCLM1,1:FF%MTYP,1:MCOL_DCLM1))
            RMEM_MB=RMEM_MB+3*REAL(MROW_DCLM1,q)*8*REAL(FF%MTYP,q)*REAL(MCOL_DCLM1,q)/1.0E+06_q
            DCLM1=0.0_q
            IF(ALLOCATED(DCLM2)) THEN
               DEALLOCATE(DCLM2)
            ENDIF
            ALLOCATE (DCLM2(1:3,1:MROW_DCLM2,1:FF%MTYP,1:MCOL_DCLM2))
            RMEM_MB=RMEM_MB+3*REAL(MROW_DCLM2,q)*8*REAL(FF%MTYP,q)*REAL(MCOL_DCLM2,q)/1.0E+06_q
            DCLM2=0.0_q
            IF(ALLOCATED(DC00)) THEN
               DEALLOCATE(DC00)
            ENDIF
            ALLOCATE (DC00(1:MROW_DC00,1:MCOL_DC00,0:3,1:MTYP))
            RMEM_MB=RMEM_MB+REAL(MROW_DC00,q)*REAL(MCOL_DC00,q)*REAL(MTYP,q)*4*8/1.0E+06_q
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            ALLOCATE (PS(1:MROW_PS,1:MCOL_PS,1:MTYP))
            RMEM_MB=RMEM_MB+REAL(MROW_PS,q)*REAL(MCOL_PS,q)*REAL(MTYP,q)*8/1.0E+06_q
            IF(ALLOCATED(PS_COUPLE)) THEN
               DEALLOCATE(PS_COUPLE)
            ENDIF
            ALLOCATE (PS_COUPLE(1:MROW_PS_COUPLE))
            RMEM_MB=RMEM_MB+REAL(MROW_PS_COUPLE,q)*8/1.0E+06_q
            IF(ALLOCATED(DPS)) THEN
               DEALLOCATE(DPS)
            ENDIF
            ALLOCATE (DPS(1:MROW_DPS,1:MCOL_DPS,0:3,1:MTYP))
            RMEM_MB=RMEM_MB+REAL(MROW_DPS,q)*REAL(MCOL_DPS,q)*REAL(MTYP,q)*4*8/1.0E+06_q
            IF(ALLOCATED(DPS_SIC)) THEN
               DEALLOCATE(DPS_SIC)
            ENDIF
            ALLOCATE (DPS_SIC(1:MROW_DPS_SIC,1:MCOL_DPS_SIC,1:3,1:MTYP))
            RMEM_MB=RMEM_MB+REAL(MROW_DPS_SIC,q)*REAL(MCOL_DPS_SIC,q)*REAL(MTYP,q)*3*8/1.0E+06_q
            IF(ALLOCATED(DSOAP11)) THEN
               DEALLOCATE(DSOAP11)
            ENDIF
            ALLOCATE (DSOAP11(1:MROW_DSOAP1,1:MCOL_DSOAP1))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP1,q)*REAL(MCOL_DSOAP1,q)*8/1.0E+06_q
            IF(ALLOCATED(DSOAP21)) THEN
               DEALLOCATE(DSOAP21)
            ENDIF
            ALLOCATE (DSOAP21(1:MROW_DSOAP1,1:MCOL_DSOAP1,1:3))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP1,q)*REAL(MCOL_DSOAP1,q)*3*8/1.0E+06_q
            IF(ALLOCATED(DSOAP12)) THEN
               DEALLOCATE(DSOAP12)
            ENDIF
            ALLOCATE (DSOAP12(1:MROW_DSOAP2,1:MCOL_DSOAP2))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP2,q)*REAL(MCOL_DSOAP2,q)*8/1.0E+06_q
            IF(ALLOCATED(DSOAP22)) THEN
               DEALLOCATE(DSOAP22)
            ENDIF
            ALLOCATE (DSOAP22(1:MROW_DSOAP2,1:MCOL_DSOAP2,1:3))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP2,q)*REAL(MCOL_DSOAP2,q)*3*8/1.0E+06_q
            IF(ALLOCATED(ENERGY_HELP)) THEN
               DEALLOCATE(ENERGY_HELP)
            ENDIF
            ALLOCATE(ENERGY_HELP(1:FFM%MB))
            RMEM_MB=RMEM_MB+REAL(FFM%MB,q)*8/1.0E+06_q
            ENERGY_HELP=0.0_q
            IF(ALLOCATED(FORCE_HELP1)) THEN
               DEALLOCATE(FORCE_HELP1)
            ENDIF
            ALLOCATE(FORCE_HELP1(1:FFM%MB,1:3,1:MCOL_MIONS,1:FF%MTYP))
            RMEM_MB=RMEM_MB+REAL(FFM%MB,q)*REAL(MCOL_MIONS,q)*REAL(FF%MTYP,q)*3*8/1.0E+06_q
            FORCE_HELP1=0.0_q
            IF(ALLOCATED(FORCE_HELP2)) THEN
               DEALLOCATE(FORCE_HELP2)
            ENDIF
            ALLOCATE(FORCE_HELP2(1:FFM%MB))
            RMEM_MB=RMEM_MB+REAL(FFM%MB,q)*8/1.0E+06_q
            FORCE_HELP2=0.0_q
            IF(ALLOCATED(LHEAD)) THEN
               DEALLOCATE(LHEAD)
            ENDIF
            ALLOCATE(LHEAD(1:FF%MTYP))
            RMEM_MB=RMEM_MB+REAL(FF%MTYP,q)/1.0E+06_q
            IF(ALLOCATED(STRESS_HELP)) THEN
               DEALLOCATE(STRESS_HELP)
            ENDIF
            ALLOCATE(STRESS_HELP(1:FFM%MB,1:3,1:3,1:FF%MTYP))
            RMEM_MB=RMEM_MB+REAL(FFM%MB,q)*REAL(FF%MTYP,q)*9*8/1.0E+06_q
            STRESS_HELP=0.0_q
            IF(ALLOCATED(SOAP1)) THEN
               DEALLOCATE(SOAP1)
            ENDIF
            ALLOCATE (SOAP1(1:MROW_SOAP,1:MCOL_SOAP))
            RMEM_MB=RMEM_MB+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
            IF(ALLOCATED(SOAP2)) THEN
               DEALLOCATE(SOAP2)
            ENDIF
            ALLOCATE (SOAP2(1:MROW_SOAP,1:MCOL_SOAP))
            RMEM_MB=RMEM_MB+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
            IF(ALLOCATED(RNORM_ALL)) THEN
               DEALLOCATE(RNORM_ALL)
            ENDIF
            ALLOCATE (RNORM_ALL(1:MROW_RNORM_ALL,1:MCOL_RNORM_ALL))
            RMEM_MB=RMEM_MB+REAL(MROW_RNORM_ALL,q)*REAL(MCOL_RNORM_ALL,q)*8/1.0E+06_q
            IF(ALLOCATED(RNORM_C00)) THEN
               DEALLOCATE(RNORM_C00)
            ENDIF
            ALLOCATE (RNORM_C00(1:MROW_RNORM_C00,1:MCOL_RNORM_C00))
            RMEM_MB=RMEM_MB+REAL(MROW_RNORM_C00,q)*REAL(MCOL_RNORM_C00,q)*8/1.0E+06_q
            IF(ALLOCATED(RNORM_PS)) THEN
               DEALLOCATE(RNORM_PS)
            ENDIF
            ALLOCATE (RNORM_PS(1:MROW_RNORM_PS,1:MCOL_RNORM_PS))
            RMEM_MB=RMEM_MB+REAL(MROW_RNORM_PS,q)*REAL(MCOL_RNORM_PS,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            ALLOCATE (LNIONS_EST1(1:MROW_EST1,1:MTYP,1:MCOL_EST1))
            RMEM_MB=RMEM_MB+REAL(MROW_EST1,q)*REAL(MTYP,q)*REAL(MCOL_EST1,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            ALLOCATE (NNEIB_EST1(1:MTYP,1:MCOL_EST1))
            RMEM_MB=RMEM_MB+REAL(MTYP,q)*REAL(MCOL_EST1,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            ALLOCATE (XYZ_EST1(1:3,1:MROW_EST1,1:MTYP,1:MCOL_EST1))
            RMEM_MB=RMEM_MB+3*REAL(MROW_EST1,q)*REAL(MTYP,q)*REAL(MCOL_EST1,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            ALLOCATE (LNIONS_EST2(1:MROW_EST2,1:MTYP,1:MCOL_EST2))
            RMEM_MB=RMEM_MB+REAL(MROW_EST2,q)*REAL(MTYP,q)*REAL(MCOL_EST2,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            ALLOCATE (NNEIB_EST2(1:MTYP,1:MCOL_EST2))
            RMEM_MB=RMEM_MB+REAL(MTYP,q)*REAL(MCOL_EST2,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
            ALLOCATE (XYZ_EST2(1:3,1:MROW_EST2,1:MTYP,1:MCOL_EST2))
            RMEM_MB=RMEM_MB+3*REAL(MROW_EST2,q)*REAL(MTYP,q)*REAL(MCOL_EST2,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST_MAX)) THEN
               DEALLOCATE(LNIONS_EST_MAX)
            ENDIF
            ALLOCATE (LNIONS_EST_MAX(1:MROW_EST_MAX,1:MTYP,1:MCOL_EST_MAX))
            RMEM_MB=RMEM_MB+REAL(MROW_EST_MAX,q)*REAL(MTYP,q)*REAL(MCOL_EST_MAX,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST_MAX)) THEN
               DEALLOCATE(NNEIB_EST_MAX)
            ENDIF
            ALLOCATE (NNEIB_EST_MAX(1:MTYP,1:MCOL_EST_MAX))
            RMEM_MB=RMEM_MB+REAL(MTYP,q)*REAL(MCOL_EST_MAX,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST_MAX)) THEN
               DEALLOCATE(XYZ_EST_MAX)
            ENDIF
            ALLOCATE (XYZ_EST_MAX(1:3,1:MROW_EST_MAX,1:MTYP,1:MCOL_EST_MAX))
            RMEM_MB=RMEM_MB+3*REAL(MROW_EST_MAX,q)*REAL(MTYP,q)*REAL(MCOL_EST_MAX,q)*8/1.0E+06_q
            IF(ALLOCATED(VEC_LOC_FORCE1)) THEN
               DEALLOCATE(VEC_LOC_FORCE1)
            ENDIF
            ALLOCATE (VEC_LOC_FORCE1(1:MROW_VEC_LOC_FORCE1,1:MCOL_VEC_LOC_FORCE1))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_FORCE1,q)*REAL(MCOL_VEC_LOC_FORCE1,q)*8/1.0E+06_q
            VEC_LOC_FORCE1=0.0_q
            IF(ALLOCATED(VEC_LOC_STRESS1)) THEN
               DEALLOCATE(VEC_LOC_STRESS1)
            ENDIF
            ALLOCATE (VEC_LOC_STRESS1(1:MROW_VEC_LOC_STRESS1,1:MCOL_VEC_LOC_STRESS1))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_STRESS1,q)*REAL(MCOL_VEC_LOC_STRESS1,q)*8/1.0E+06_q
            VEC_LOC_STRESS1=0.0_q
            IF(ALLOCATED(VEC_LOC_FORCE2)) THEN
               DEALLOCATE(VEC_LOC_FORCE2)
            ENDIF
            ALLOCATE (VEC_LOC_FORCE2(1:MROW_VEC_LOC_FORCE2,1:MCOL_VEC_LOC_FORCE2))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_FORCE2,q)*REAL(MCOL_VEC_LOC_FORCE2,q)*8/1.0E+06_q
            VEC_LOC_FORCE2=0.0_q
            IF(ALLOCATED(VEC_LOC_STRESS2)) THEN
               DEALLOCATE(VEC_LOC_STRESS2)
            ENDIF
            ALLOCATE (VEC_LOC_STRESS2(1:MROW_VEC_LOC_STRESS2,1:MCOL_VEC_LOC_STRESS2))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_STRESS2,q)*REAL(MCOL_VEC_LOC_STRESS2,q)*8/1.0E+06_q
            VEC_LOC_STRESS2=0.0_q
            IF(ALLOCATED(VEC_LOC_ENERGY)) THEN
               DEALLOCATE(VEC_LOC_ENERGY)
            ENDIF
            ALLOCATE (VEC_LOC_ENERGY(1:MROW_VEC_LOC_ENERGY,1:MCOL_VEC_LOC_ENERGY))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_ENERGY,q)*REAL(MCOL_VEC_LOC_ENERGY,q)*8/1.0E+06_q
            VEC_LOC_ENERGY=0.0_q
          END SUBROUTINE ALLOCATE_MB_ARRAY_INIT_FMAT

! Deallocate temporary arrays necessary for many-body interactions

          SUBROUTINE DEALLOCATE_MB_ARRAY_INIT_FMAT
            IMPLICIT NONE
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            IF(ALLOCATED(C00_COUPLE)) THEN
               DEALLOCATE(C00_COUPLE)
            ENDIF
            IF(ALLOCATED(DC00)) THEN
               DEALLOCATE(DC00)
            ENDIF
            IF(ALLOCATED(DCLM1)) THEN
               DEALLOCATE(DCLM1)
            ENDIF
            IF(ALLOCATED(DCLM2)) THEN
               DEALLOCATE(DCLM2)
            ENDIF
            IF(ALLOCATED(LHEAD)) THEN
               DEALLOCATE(LHEAD)
            ENDIF
            IF(ALLOCATED(RNORM_ALL)) THEN
               DEALLOCATE(RNORM_ALL)
            ENDIF
            IF(ALLOCATED(RNORM_C00)) THEN
               DEALLOCATE(RNORM_C00)
            ENDIF
            IF(ALLOCATED(RNORM_PS)) THEN
               DEALLOCATE(RNORM_PS)
            ENDIF
            IF(ALLOCATED(DPS)) THEN
               DEALLOCATE(DPS)
            ENDIF
            IF(ALLOCATED(DPS_SIC)) THEN
               DEALLOCATE(DPS_SIC)
            ENDIF
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            IF(ALLOCATED(PS_COUPLE)) THEN
               DEALLOCATE(PS_COUPLE)
            ENDIF
            IF(ALLOCATED(ENERGY_HELP)) THEN
               DEALLOCATE(ENERGY_HELP)
            ENDIF
            IF(ALLOCATED(FORCE_HELP1)) THEN
               DEALLOCATE(FORCE_HELP1)
            ENDIF
            IF(ALLOCATED(FORCE_HELP2)) THEN
               DEALLOCATE(FORCE_HELP2)
            ENDIF
            IF(ALLOCATED(STRESS_HELP)) THEN
               DEALLOCATE(STRESS_HELP)
            ENDIF
            IF(ALLOCATED(DSOAP11)) THEN
               DEALLOCATE(DSOAP11)
            ENDIF
            IF(ALLOCATED(DSOAP21)) THEN
               DEALLOCATE(DSOAP21)
            ENDIF
            IF(ALLOCATED(DSOAP12)) THEN
               DEALLOCATE(DSOAP12)
            ENDIF
            IF(ALLOCATED(DSOAP22)) THEN
               DEALLOCATE(DSOAP22)
            ENDIF
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            IF(ALLOCATED(LNIONS_EST_MAX)) THEN
               DEALLOCATE(LNIONS_EST_MAX)
            ENDIF
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            IF(ALLOCATED(NNEIB_EST_MAX)) THEN
               DEALLOCATE(NNEIB_EST_MAX)
            ENDIF
            IF(ALLOCATED(SOAP1)) THEN
               DEALLOCATE(SOAP1)
            ENDIF
            IF(ALLOCATED(SOAP2)) THEN
               DEALLOCATE(SOAP2)
            ENDIF
            IF(ALLOCATED(VEC_LOC_ENERGY)) THEN
               DEALLOCATE(VEC_LOC_ENERGY)
            ENDIF
            IF(ALLOCATED(VEC_LOC_FORCE1)) THEN
               DEALLOCATE(VEC_LOC_FORCE1)
            ENDIF
            IF(ALLOCATED(VEC_LOC_FORCE2)) THEN
               DEALLOCATE(VEC_LOC_FORCE2)
            ENDIF
            IF(ALLOCATED(VEC_LOC_STRESS1)) THEN
               DEALLOCATE(VEC_LOC_STRESS1)
            ENDIF
            IF(ALLOCATED(VEC_LOC_STRESS2)) THEN
               DEALLOCATE(VEC_LOC_STRESS2)
            ENDIF
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
            IF(ALLOCATED(XYZ_EST_MAX)) THEN
               DEALLOCATE(XYZ_EST_MAX)
            ENDIF
          END SUBROUTINE DEALLOCATE_MB_ARRAY_INIT_FMAT

        END SUBROUTINE INIT_FMAT
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Subroutine generating force field from ab initio data
!****************************************************************************************************

        SUBROUTINE GEN_FF (AB,TIM,LAPACKWORK,PAR_SUP_HANDLE,MEM1,LOGF,FF,FFM,A,B,ISYS,LADD,LNITYP,LNIONS,LNTYP, &
                   MCONF,MITYP,MIONS,MTYP,NCONF,NCONF_SYS,NITYP,NIONS,NSTEP,NSYS,NTYP,POSION, &
                   OMEGA)
          USE NEIGHBOUR
#ifndef ML_LEARNING_NOT_ACTIVE
          USE REGRESSION
#endif
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: ABINITIO, TIME, LAPACK_WORK, PARALLEL_SUPER, MEMORY, LOG_PAR, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)       :: AB
          TYPE (TIME)           :: TIM
          TYPE (LAPACK_WORK)    :: LAPACKWORK
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (MEMORY)         :: MEM1
          TYPE (LOG_PAR)        :: LOGF
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          REAL(q), INTENT(IN)   :: A(:,:,:) !(1:3,1:3,1:NCONF)
          REAL(q), INTENT(IN)   :: B(:,:,:) !(1:3,1:3,1:NCONF)
          INTEGER, INTENT(IN)   :: ISYS(:) !(1:NCONF)
          INTEGER, INTENT(IN)   :: LADD(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: LNITYP(:,:) !(1:MIONS,1:NCONF)
          INTEGER, INTENT(IN)   :: LNIONS(:,:,:) !(1:MITYP,1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: LNTYP(:,:) !(1:MIONS,1:NCONF)
          INTEGER, INTENT(IN)   :: MCONF
          INTEGER, INTENT(IN)   :: MIONS
          INTEGER, INTENT(IN)   :: MITYP
          INTEGER, INTENT(IN)   :: MTYP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NCONF_SYS(:) !(1:NSYS)
          INTEGER, INTENT(IN)   :: NIONS(:) !(1:NCONF)
          INTEGER, INTENT(IN)   :: NITYP(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: NSTEP
          INTEGER, INTENT(IN)   :: NSYS
          INTEGER, INTENT(IN)   :: NTYP(:) !(1:NCONF)
          REAL(q), INTENT(IN)   :: POSION(:,:,:) !(1:3,1:MIONS,1:NCONF)
          REAL(q), INTENT(IN)   :: OMEGA(:) !(1:NCONF)
! Local varia  bles
          REAL(q)               :: EPS
! Start profiling
          PROFILING_START ('gen_ff')
! Constant
          EPS=1E-10_q
! Reset FF%NSTEP_FROM_GENFF
          FF%NSTEP_FROM_GENFF=0
! Reset FF%NSTEP_FROM_SAMPLING
          FF%NSTEP_FROM_SAMPLING=0
! Initialize IFF parameter
          FF%IFF=.TRUE.
! Start of manybody fitting
          CALL GEN_FF_MB(AB,TIM,LAPACKWORK,PAR_SUP_HANDLE,MEM1,LOGF,FF,FFM,A,B,EPS, &
                   ISYS,LADD,LNITYP,LNIONS,LNTYP,MIONS,MITYP,MTYP,NCONF,NCONF_SYS,NIONS, &
                   NITYP,NSYS,NTYP,POSION,OMEGA)
! Output summary
          CALL SUMMARY_REPORT(AB,PAR_SUP_HANDLE,LOGF,FF,FFM,LADD,MCONF,MIONS,MITYP,MTYP,NCONF,NIONS,NITYP,NSTEP,NTYP)
! Stop profiling
          PROFILING_STOP ('gen_ff')
        END SUBROUTINE GEN_FF

! Calculation of data matrix
        SUBROUTINE GEN_FF_MB(AB,TIM,LAPACKWORK,PAR_SUP_HANDLE,MEM1,LOGF,FF,FFM,A,B,EPS, &
                   ISYS,LADD,LNITYP,LNIONS,LNTYP,MIONS,MITYP,MTYP,NCONF,NCONF_SYS,NIONS, &
                   NITYP,NSYS,NTYP,POSION,OMEGA)
          USE NEIGHBOUR
#ifndef ML_LEARNING_NOT_ACTIVE
          USE REGRESSION
#endif
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: ABINITIO, TIME, LAPACK_WORK, PARALLEL_SUPER, MEMORY, LOG_PAR,FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)       :: AB
          TYPE (TIME)           :: TIM
          TYPE (LAPACK_WORK)    :: LAPACKWORK
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (MEMORY)         :: MEM1
          TYPE (LOG_PAR)        :: LOGF
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          REAL(q), INTENT(IN)   :: A(:,:,:) !(1:3,1:3,1:NCONF)
          REAL(q), INTENT(IN)   :: B(:,:,:) !(1:3,1:3,1:NCONF)
          REAL(q), INTENT(IN)   :: EPS
          INTEGER, INTENT(IN)   :: ISYS(:) !(1:NCONF)
          INTEGER, INTENT(IN)   :: LADD(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: LNITYP(:,:) !(1:MIONS,1:NCONF)
          INTEGER, INTENT(IN)   :: LNIONS(:,:,:) !(1:MITYP,1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: LNTYP(:,:) !(1:MIONS,1:NCONF)
          INTEGER, INTENT(IN)   :: MIONS
          INTEGER, INTENT(IN)   :: MITYP
          INTEGER, INTENT(IN)   :: MTYP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NCONF_SYS(:) !(1:NSYS)
          INTEGER, INTENT(IN)   :: NIONS(:) !(1:NCONF)
          INTEGER, INTENT(IN)   :: NITYP(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: NSYS
          INTEGER, INTENT(IN)   :: NTYP(:) !(1:NCONF)
          REAL(q), INTENT(IN)   :: POSION(:,:,:) !(1:3,1:MIONS,1:NCONF)
          REAL(q), INTENT(IN)   :: OMEGA(:) !(1:NCONF)
! Local variables
          REAL(q)               :: CPUTIM0
          REAL(q)               :: CPUTIM1
          INTEGER               :: IB
          INTEGER               :: ICONF
          INTEGER               :: IDATA
          INTEGER               :: IERR
          INTEGER               :: INIONS
          INTEGER               :: INIONS_TMP
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: ISYS_HELP
          INTEGER               :: IXYZ
          INTEGER               :: JXYZ
          INTEGER               :: KXYZ
          INTEGER               :: LOC_M_CMAT_FFM
          INTEGER               :: LOC_N_CMAT_FFM
          INTEGER               :: LOC_M_DMAT_FMAT_FFM
          INTEGER               :: LOC_M_DMAT_YMAT_FFM
          INTEGER               :: LOC_M_FMAT_FFM
          INTEGER               :: LOC_N_FMAT_FFM
          INTEGER               :: LOC_M_WMAT_FFM
          INTEGER               :: LOC_N_WMAT_FFM
          INTEGER               :: LOC_M_YMAT_FFM
          INTEGER               :: LOC_N_YMAT_FFM
          INTEGER               :: LOCVAR_COL
          INTEGER               :: LOCVAR_ROW
          INTEGER               :: NB_MAX
          INTEGER               :: NSYS_NONE_ZERO
          INTEGER               :: NTOTEN(1:NSYS)
          INTEGER               :: NTIFOR(1:3,1:NSYS)
          INTEGER               :: NTSIF(1:3,1:3,1:NSYS)
          REAL(q)               :: QAV(1:FF%MTYP,1:NSYS)
          REAL(q)               :: RMEM_BLEA_MB
          REAL(q)               :: RMEM_COUL
          REAL(q)               :: RMEM_HELP
          REAL(q)               :: SIGMA
          INTEGER               :: TEST_COL
          INTEGER               :: TEST_ROW
          REAL(q)               :: TOTEN_ATOM_REF
          REAL(q)               :: TOTENAV(1:NSYS)
          REAL(q)               :: TIFORAV(1:3,1:NSYS)
          REAL(q)               :: TSIFAV(1:3,1:3,1:NSYS)
          REAL(q)               :: VPUTIM0
          REAL(q)               :: VPUTIM1
          REAL(q), ALLOCATABLE  :: ZMAT_FFM(:,:)
          INTEGER               :: ITEST
! Start profiling
          PROFILING_START('gen_ff_mb')
! Record the initial time
          CALL VTIME (VPUTIM0,CPUTIM0)
! Initialize the memory usage
          RMEM_BLEA_MB=0.0_q
          IF(FF%LMLMB) THEN
             IF(FF%IFF) THEN
! Measure the initial times
                CALL VTIME (VPUTIM0,CPUTIM0)
                CALL YMAT_MB
                CALL DMAT_MB
! Set sizes of arrays necessary for regressions.
#ifdef scaLAPACK
                LOC_M_CMAT_FFM     =PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M
                LOC_N_CMAT_FFM     =PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N
                LOC_M_DMAT_FMAT_FFM=PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N
                LOC_M_DMAT_YMAT_FFM=PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M
                LOC_M_FMAT_FFM     =PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M
                LOC_N_FMAT_FFM     =PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N
                LOC_M_WMAT_FFM     =PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M
                LOC_N_WMAT_FFM     =PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N
                LOC_M_YMAT_FFM     =PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M
                LOC_N_YMAT_FFM     =PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N
#else
                LOC_M_CMAT_FFM     =FFM%MBTOT
                LOC_N_CMAT_FFM     =FFM%MBTOT
                LOC_M_DMAT_FMAT_FFM=FFM%MDATA
                LOC_M_DMAT_YMAT_FFM=FFM%MDATA
                LOC_M_FMAT_FFM     =FFM%MB
                LOC_N_FMAT_FFM     =FFM%MDATA
                LOC_M_WMAT_FFM     =FFM%MB
                LOC_N_WMAT_FFM     =1
                LOC_M_YMAT_FFM     =FFM%MDATA
                LOC_N_YMAT_FFM     =1
#endif
! Determine the parameters in MLFF.
                CALL BLEA_MB (FFM,LAPACKWORK,PAR_SUP_HANDLE,LOGF,FFM%CMAT,FFM%MBTOT,FFM%NBTOT,FFM%NBTOT,LOC_M_CMAT_FFM,LOC_N_CMAT_FFM, &
                     FFM%DMAT_FMAT, &
                     FFM%DMAT_YMAT, &
                     FFM%MB,FFM%NB,FFM%NDATA, &
                     FFM%WMAT,FFM%NB, &
                     FFM%YMAT,FFM%MDATA,FFM%NDATA,LOC_M_YMAT_FFM,LOC_N_YMAT_FFM, &
                     FF%IFF,FFM%IREG,FFM%LBHEAD,FF%MTYP, &
                     RMEM_BLEA_MB,FFM%SIGV,FFM%SIGV0,FFM%SIGW,FFM%SIGW0,FF%IALGO_LINREG,FF%NSTEP,FF%ML_EPS_REG)
! Measure the final times and add them
                CALL VTIME (VPUTIM1,CPUTIM1)
                TIM%VPUTIM(8)=TIM%VPUTIM(8)+VPUTIM1-VPUTIM0
                TIM%CPUTIM(8)=TIM%CPUTIM(8)+CPUTIM1-CPUTIM0
! Predict all energies, forces and stress tensors for training datasets.
                IF(FF%IFF) THEN
                   CALL ALLOCATE_ZMAT_MB
                   CALL ZMAT_MB
                   CALL DEALLOCATE_ZMAT_MB
                ENDIF
! Measure the final times and add them
                CALL VTIME (VPUTIM1,CPUTIM1)
                TIM%VPUTIM(11)=TIM%VPUTIM(11)+VPUTIM1-VPUTIM0
                TIM%CPUTIM(11)=TIM%CPUTIM(11)+CPUTIM1-CPUTIM0
             ENDIF
          ELSE
             AB%TOTEN_MB(1:NCONF)=0.0_q
             AB%TIFOR_MB(1:3,1:MIONS,1:NCONF)=0.0_q
             AB%TSIF_MB(1:3,1:3,1:NCONF)=0.0_q
             FFM%SIG(1:10)=0.0_q
             IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
                FFM%SIG_SYS(1:10,1:FF%NSYS)=0.0_q
             ENDIF
          ENDIF
! Calculate the memory usage
          MEM1%RMEM(9)=MAX(MEM1%RMEM(9),RMEM_BLEA_MB)
! Record the final time
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%VPUTIM(11)=TIM%VPUTIM(11)+VPUTIM1-VPUTIM0
          TIM%CPUTIM(11)=TIM%CPUTIM(11)+CPUTIM1-CPUTIM0
! Stop profiling
          PROFILING_STOP('gen_ff_mb')
         
          CONTAINS

! Calculate data vector for many-body interactions
! MPI- and scaLAPACK-parallel
          SUBROUTINE YMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: ICONF
            INTEGER               :: IDATA
            INTEGER               :: IERR
            INTEGER               :: INIONS
            INTEGER               :: INIONS_TMP
            INTEGER               :: INTYP
            INTEGER               :: INTYP0
            INTEGER               :: ISYS_HELP
            INTEGER               :: IXYZ
            INTEGER               :: JXYZ
            INTEGER               :: KXYZ
            INTEGER               :: LOCVAR_COL
            INTEGER               :: LOCVAR_ROW
            INTEGER               :: NSYS_NONE_ZERO
            INTEGER               :: TEST_COL
            INTEGER               :: TEST_ROW
            REAL(q)               :: TOTEN_ATOM_REF
! Start profiling
            PROFILING_START ('ymat_mb')
! Initialization of data vector
            FFM%YMAT=0.0_q
! Calculate averages of energes, forces and stress tensors.
            FFM%TIFORAV=0.0_q
            FFM%TOTENAV=0.0_q
            FFM%TSIFAV=0.0_q
            DO ICONF=1, NCONF
! Calculate reference atomic energy.
               TOTEN_ATOM_REF=0.0_q
               DO INTYP=1, NTYP(ICONF)
                  INTYP0=LADD(INTYP,ICONF)
                  TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
               ENDDO
! Calculate averages over all the training data.
               IF (FF%LTOTEN_SYSTEM) THEN
                  FFM%TOTENAV=FFM%TOTENAV +AB%TOTEN(ICONF)-TOTEN_ATOM_REF
               ELSE
                  FFM%TOTENAV=FFM%TOTENAV +(AB%TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)
               ENDIF
               DO IXYZ=1, 3
                  DO JXYZ=IXYZ, 3
                     FFM%TSIFAV(JXYZ,IXYZ)=FFM%TSIFAV(JXYZ,IXYZ)+AB%TSIF(JXYZ,IXYZ,ICONF)
                  ENDDO
               ENDDO
               DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(INIONS.LE. NIONS(ICONF)) THEN
                     DO IXYZ=1, 3
                        FFM%TIFORAV(IXYZ)=FFM%TIFORAV(IXYZ)+AB%TIFOR(IXYZ,INIONS,ICONF)
                     ENDDO
                  ENDIF
               ENDDO
            ENDDO
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,FFM%TIFORAV,3,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            FFM%TIFORAV(1:3)=FFM%TIFORAV(1:3)/REAL((FFM%NTIFOR/3),q)
            FFM%TOTENAV=FFM%TOTENAV/REAL(FFM%NTOTEN,q)
            FFM%TSIFAV(1:3,1:3)=FFM%TSIFAV(1:3,1:3)/REAL((FFM%NTSIF/6),q)
! Calculate averages over model systems, if necessary.
            IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
               NTOTEN=0
               NTIFOR=0
               NTSIF=0
               TOTENAV=0.0_q
               TIFORAV=0.0_q
               TSIFAV=0.0_q
               DO ICONF=1, NCONF
                  TOTEN_ATOM_REF=0.0_q
                  DO INTYP=1, NTYP(ICONF)
                     INTYP0=LADD(INTYP,ICONF)
                     TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
                  ENDDO
                  NTOTEN(ISYS(ICONF))=NTOTEN(ISYS(ICONF))+1
                  IF (FF%LTOTEN_SYSTEM) THEN
                     TOTENAV(ISYS(ICONF))=TOTENAV(ISYS(ICONF))+(AB%TOTEN(ICONF)-TOTEN_ATOM_REF)
                  ELSE
                     TOTENAV(ISYS(ICONF))=TOTENAV(ISYS(ICONF))+(AB%TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)
                  ENDIF
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
                        NTSIF(JXYZ,IXYZ,ISYS(ICONF))=NTSIF(JXYZ,IXYZ,ISYS(ICONF))+1
                        TSIFAV(JXYZ,IXYZ,ISYS(ICONF))=TSIFAV(JXYZ,IXYZ,ISYS(ICONF))+(AB%TSIF(JXYZ,IXYZ,ICONF))
                     ENDDO
                  ENDDO
                  DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                     INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                     IF(INIONS.LE. NIONS(ICONF)) THEN
                        DO IXYZ=1, 3
                           NTIFOR(IXYZ,ISYS(ICONF))=NTIFOR(IXYZ,ISYS(ICONF))+1
                           TIFORAV(IXYZ,ISYS(ICONF))=TIFORAV(IXYZ,ISYS(ICONF))+(AB%TIFOR(IXYZ,INIONS,ICONF))
                        ENDDO
                     ENDIF
                  ENDDO
               ENDDO
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,TIFORAV,3*NSYS,MPI_REAL8  ,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,NTIFOR ,3*NSYS,MPI_INTEGER,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               NSYS_NONE_ZERO=0
               DO ISYS_HELP=1, NSYS
                  IF(NCONF_SYS(ISYS_HELP).GT.0) THEN
                     NSYS_NONE_ZERO=NSYS_NONE_ZERO+1
                  ENDIF
                  IF(NTOTEN(ISYS_HELP).GT.0) THEN
                     TOTENAV(ISYS_HELP)=TOTENAV(ISYS_HELP)/REAL(NTOTEN(ISYS_HELP),q)
                  ELSE
                     TOTENAV(ISYS_HELP)=0.0_q
                  ENDIF
                  DO IXYZ=1, 3
                     IF(NTIFOR(IXYZ,ISYS_HELP).GT.0) THEN
                        TIFORAV(IXYZ,ISYS_HELP)=TIFORAV(IXYZ,ISYS_HELP)/REAL(NTIFOR(IXYZ,ISYS_HELP),q)
                     ELSE
                        TIFORAV(IXYZ,ISYS_HELP)=0.0_q
                     ENDIF
                  ENDDO
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
                        IF(NTSIF(JXYZ,IXYZ,ISYS_HELP).GT.0) THEN
                           TSIFAV(JXYZ,IXYZ,ISYS_HELP)=TSIFAV(JXYZ,IXYZ,ISYS_HELP)/REAL(NTSIF(JXYZ,IXYZ,ISYS_HELP),q)
                        ELSE
                           TSIFAV(JXYZ,IXYZ,ISYS_HELP)=0.0_q
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
            ENDIF
! Subtract contributions by pairwise and electrostatic interactions
! scaLAPACK-parallel
            DO ICONF=1, NCONF
               IDATA=FFM%LTOTEN(ICONF)
! Calculate reference atomic energy.
               TOTEN_ATOM_REF=0.0_q
               DO INTYP=1, NTYP(ICONF)
                  INTYP0=LADD(INTYP,ICONF)
                  TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
               ENDDO
! Calculate training data set and store it.
#ifdef scaLAPACK
               TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
               TEST_COL=MOD((    1-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                  CYCLE
               ENDIF
               LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
               LOCVAR_COL=GLOBAL2LOCAL(    1,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB)
#else
               LOCVAR_ROW=IDATA
               LOCVAR_COL=1
#endif
! If ISCALE_TOTEN=1, the energy is scaled to the total energy of isolated atoms.
               IF(FFM%ISCALE_TOTEN.EQ.1) THEN
                  IF (FF%LTOTEN_SYSTEM) THEN
                     FFM%YMAT(LOCVAR_ROW,LOCVAR_COL)=AB%TOTEN(ICONF)-TOTEN_ATOM_REF
                  ELSE
                     FFM%YMAT(LOCVAR_ROW,LOCVAR_COL)=(AB%TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)
                  ENDIF
! If ISCALE_TOTEN=2, the energy is scaled to the average of the training data.
               ELSE IF(FFM%ISCALE_TOTEN.EQ.2) THEN
                  IF (FF%LTOTEN_SYSTEM) THEN
                     FFM%YMAT(LOCVAR_ROW,LOCVAR_COL)=(AB%TOTEN(ICONF)-TOTEN_ATOM_REF)-FFM%TOTENAV
                  ELSE
                     FFM%YMAT(LOCVAR_ROW,LOCVAR_COL)=(AB%TOTEN(ICONF)-TOTEN_ATOM_REF)/REAL(NIONS(ICONF),q)-FFM%TOTENAV
                  ENDIF
               ENDIF
            ENDDO
            DO ICONF=1, NCONF
               DO IXYZ=1, 3
                  DO JXYZ=IXYZ, 3
                     IDATA=FFM%LTSIF(JXYZ,IXYZ,ICONF)
#ifdef scaLAPACK
                     TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     TEST_COL=MOD((    1-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
                     LOCVAR_COL=GLOBAL2LOCAL(    1,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB)
#else
                     LOCVAR_ROW=IDATA
                     LOCVAR_COL=1
#endif
                     FFM%YMAT(LOCVAR_ROW,LOCVAR_COL)=AB%TSIF(JXYZ,IXYZ,ICONF)
                  ENDDO
               ENDDO
            ENDDO
            DO ICONF=1, NCONF
               DO INIONS=1, NIONS(ICONF)
                  DO IXYZ=1, 3
                     IDATA=FFM%LTIFOR(IXYZ,INIONS,ICONF)
#ifdef scaLAPACK
                     TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     TEST_COL=MOD((    1-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
                     LOCVAR_COL=GLOBAL2LOCAL(    1,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB)
#else
                     LOCVAR_ROW=IDATA
                     LOCVAR_COL=1
#endif
                     FFM%YMAT(LOCVAR_ROW,LOCVAR_COL)=AB%TIFOR(IXYZ,INIONS,ICONF)
                  ENDDO
               ENDDO
            ENDDO
! Calculate variance.
! MPI-parallel
            FFM%SIG=0.0_q
! Calculate variances of all training data.
            IF((FF%IWEIGHT.EQ.1).OR.(FF%IWEIGHT.EQ.2).OR.(FF%IWEIGHT.EQ.4)) THEN
               DO ICONF=1, NCONF
                  TOTEN_ATOM_REF=0.0_q
                  DO INTYP=1, NTYP(ICONF)
                     INTYP0=LADD(INTYP,ICONF)
                     TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
                  ENDDO
                  FFM%SIG(1)=FFM%SIG(1)+(AB%TOTEN(ICONF)-TOTEN_ATOM_REF-REAL(NIONS(ICONF),q)*FFM%TOTENAV)**2/REAL(NIONS(ICONF),q)**2
                  KXYZ=0
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
                        KXYZ=KXYZ+1
                        FFM%SIG(KXYZ+4)=FFM%SIG(KXYZ+4)+(AB%TSIF(JXYZ,IXYZ,ICONF)-FFM%TSIFAV(JXYZ,IXYZ))**2
                     ENDDO
                  ENDDO
                  DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                     INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                     IF(INIONS.LE.NIONS(ICONF)) THEN
                        DO IXYZ=1, 3
                           FFM%SIG(IXYZ+1)=FFM%SIG(IXYZ+1)+(AB%TIFOR(IXYZ,INIONS,ICONF)-FFM%TIFORAV(IXYZ))**2
                        ENDDO
                     ENDIF
                  ENDDO
               ENDDO
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,FFM%SIG(2),3,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               FFM%SIG(1)=SQRT(FFM%SIG(1)/REAL(FFM%NTOTEN,q))
               DO IXYZ=1, 3
                  FFM%SIG(IXYZ+1)=SQRT(FFM%SIG(IXYZ+1)/REAL((FFM%NTIFOR/3),q))
               ENDDO
               DO IXYZ=1, 6
                  FFM%SIG(IXYZ+4)=SQRT(FFM%SIG(IXYZ+4)/REAL((FFM%NTSIF/6),q))
               ENDDO
! Calculate variances of system-dependent training data.
            ELSE IF((FF%IWEIGHT.EQ.3).OR.(FF%IWEIGHT.EQ.5)) THEN
               FFM%SIG_SYS=0.0_q
               DO ICONF=1, NCONF
                  TOTEN_ATOM_REF=0.0_q
                  DO INTYP=1, NTYP(ICONF)
                     INTYP0=LADD(INTYP,ICONF)
                     TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
                  ENDDO
                  FFM%SIG_SYS(1,ISYS(ICONF))=FFM%SIG_SYS(1,ISYS(ICONF))+ &
                  ((AB%TOTEN(ICONF)-TOTEN_ATOM_REF-REAL(NIONS(ICONF),q)*TOTENAV(ISYS(ICONF)))/REAL(NIONS(ICONF),q))**2
                  KXYZ=0
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
                        KXYZ=KXYZ+1
                        FFM%SIG_SYS(KXYZ+4,ISYS(ICONF))=FFM%SIG_SYS(KXYZ+4,ISYS(ICONF))+ &
                        (AB%TSIF(JXYZ,IXYZ,ICONF)-TSIFAV(JXYZ,IXYZ,ISYS(ICONF)))**2
                     ENDDO
                  ENDDO
                  DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                     INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                     IF(INIONS.LE.NIONS(ICONF)) THEN
                        DO IXYZ=1, 3
                           FFM%SIG_SYS(IXYZ+1,ISYS(ICONF))=FFM%SIG_SYS(IXYZ+1,ISYS(ICONF))+ &
                           (AB%TIFOR(IXYZ,INIONS,ICONF)-TIFORAV(IXYZ,ISYS(ICONF)))**2
                        ENDDO
                     ENDIF
                  ENDDO
               ENDDO
               DO ISYS_HELP=1, NSYS
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,FFM%SIG_SYS(2,ISYS_HELP),3,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDDO
               DO ISYS_HELP=1, NSYS
                  IF(NTOTEN(ISYS_HELP).GT.0) THEN
                     FFM%SIG_SYS(1,ISYS_HELP)=FFM%SIG_SYS(1,ISYS_HELP)/REAL(NTOTEN(ISYS_HELP),q)
                  ELSE
                     FFM%SIG_SYS(1,ISYS_HELP)=0.0_q
                  ENDIF
                  KXYZ=0
                  DO IXYZ=1, 3
                     IF(NTIFOR(IXYZ,ISYS_HELP).GT.0) THEN
                        FFM%SIG_SYS(IXYZ+1,ISYS_HELP)=FFM%SIG_SYS(IXYZ+1,ISYS_HELP)/REAL(NTIFOR(IXYZ,ISYS_HELP),q)
                     ELSE
                        FFM%SIG_SYS(IXYZ+1,ISYS_HELP)=0.0_q
                     ENDIF
                     DO JXYZ=IXYZ, 3
                        KXYZ=KXYZ+1
                        IF(NTSIF(JXYZ,IXYZ,ISYS_HELP).GT.0) THEN
                           FFM%SIG_SYS(KXYZ+4,ISYS_HELP)=FFM%SIG_SYS(KXYZ+4,ISYS_HELP)/REAL(NTSIF(JXYZ,IXYZ,ISYS_HELP),q)
                        ELSE
                           FFM%SIG_SYS(KXYZ+4,ISYS_HELP)=0.0_q
                        ENDIF
                     ENDDO
                  ENDDO
               ENDDO
               DO IXYZ=1, 10
                  DO ISYS_HELP=1, NSYS
                     IF(NCONF_SYS(ISYS_HELP).GT.0) THEN
                        FFM%SIG(IXYZ)=FFM%SIG(IXYZ)+FFM%SIG_SYS(IXYZ,ISYS_HELP)/REAL(NSYS_NONE_ZERO,q)
                     ENDIF
                  ENDDO
               ENDDO
               DO IXYZ=1, 10
                  FFM%SIG(IXYZ)=SQRT(FFM%SIG(IXYZ))
               ENDDO
               DO IXYZ=1, 10
                  DO ISYS_HELP=1, NSYS
                     FFM%SIG_SYS(IXYZ,ISYS_HELP)=SQRT(FFM%SIG_SYS(IXYZ,ISYS_HELP))
                  ENDDO
               ENDDO
            ENDIF
! Stop profiling
            PROFILING_STOP ('ymat_mb')
          END SUBROUTINE YMAT_MB

! Calculate scaling matrix for many-body interactions
! scaLAPACK-parallel
          SUBROUTINE DMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: ICONF
            INTEGER               :: IDATA
            INTEGER               :: INIONS
            INTEGER               :: IXYZ
            INTEGER               :: JXYZ
            INTEGER               :: KXYZ
            INTEGER               :: LOCVAR_COL
            INTEGER               :: LOCVAR_ROW
            REAL(q)               :: SIGMA
            INTEGER               :: TEST_COL
            INTEGER               :: TEST_ROW
! Start profiling
            PROFILING_START ('dmat_mb')
! Scale energy data for FMAT
            DO ICONF=1, NCONF
               IDATA =FFM%LTOTEN(ICONF)
#ifdef scaLAPACK
               TEST_COL=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                  CYCLE
               ENDIF
               LOCVAR_COL=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
               LOCVAR_COL=IDATA
#endif
! If FF%IWEIGHT=1, set SIGMA to FF%WTOTEN.
               IF(FF%IWEIGHT.EQ.1) THEN
                  SIGMA=FF%WTOTEN
! If FF%IWEIGHT=2, set SIGMA to variance in total energy (TOTEN) in ab initio data for all systems.
               ELSE IF(FF%IWEIGHT.EQ.2) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     SIGMA=FFM%SIG(1)/FF%WTOTEN
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
! If FF%IWEIGHT=3, set SIGMA to variance in total energy (AB%TOTEN) in ab initio data for individual system.
               ELSE IF(FF%IWEIGHT.EQ.3) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     SIGMA=FFM%SIG(1)/FF%WTOTEN
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
! If FF%IWEIGHT=4, set SIGMA to variance in total energy (AB%TOTEN) in ab initio data for all systems.
! Here, the number of configuration is taken into account.
               ELSE IF(FF%IWEIGHT.EQ.4) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                        SIGMA=FFM%SIG(1)/FF%WTOTEN*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                     ELSE
                        SIGMA=FFM%SIG(1)/FF%WTOTEN
                     ENDIF
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
! If FF%IWEIGHT=5, set SIGMA to variance in total energy (AB%TOTEN) in ab initio data for individual system.
! Here, the number of configuration is taken into account.
               ELSE IF(FF%IWEIGHT.EQ.5) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                        SIGMA=FFM%SIG(1)/FF%WTOTEN*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                     ELSE
                        SIGMA=FFM%SIG(1)/FF%WTOTEN
                     ENDIF
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
               ENDIF
               FFM%DMAT_FMAT(LOCVAR_COL)=1.0_q/SIGMA
            ENDDO
! Scale force data for FMAT
            DO ICONF=1, NCONF
               DO INIONS=1, NIONS(ICONF)
                  DO IXYZ=1, 3
                     IDATA=FFM%LTIFOR(IXYZ,INIONS,ICONF)
#ifdef scaLAPACK
                     TEST_COL=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_COL=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                     LOCVAR_COL=IDATA
#endif
! If FF%IWEIGHT=1, set SIGMA as FF%WTIFOR.
                     IF(FF%IWEIGHT.EQ.1) THEN
                        SIGMA=FF%WTIFOR
! If FF%IWEIGHT=2, set SIGMA as variance in force (AB%TIFOR) in ab initio data for for all systems.
                     ELSE IF(FF%IWEIGHT.EQ.2) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in force (AB%TIFOR) in ab initio data for individual system.
                     ELSE IF(FF%IWEIGHT.EQ.3) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
! If FF%IWEIGHT=4, set SIGMA to variance in force (AB%TIFOR) in ab initio data for all systems.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.4) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                           ENDIF
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
! If FF%IWEIGHT=5, set SIGMA to variance in force (AB%TIFOR) in ab initio data for individual system.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.5) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                           ENDIF
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
                     ENDIF
                     FFM%DMAT_FMAT(LOCVAR_COL)=1.0_q/SIGMA
                  ENDDO
               ENDDO
            ENDDO
! Scale stress data for FMAT
            DO ICONF=1, NCONF
               KXYZ=0
               DO IXYZ=1, 3
                  DO JXYZ=IXYZ, 3
                     KXYZ=KXYZ+1
                     IDATA=FFM%LTSIF(JXYZ,IXYZ,ICONF)
#ifdef scaLAPACK
                     TEST_COL=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_COL=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                     LOCVAR_COL=IDATA
#endif
! If FF%IWEIGHT=1, set SIGMA as FF%WTSIF.
                     IF(FF%IWEIGHT.EQ.1) THEN
                        SIGMA=FF%WTSIF
! If FF%IWEIGHT=2, set SIGMA as variance in stress (AB%TSIF) in ab initio data for all systems.
                     ELSE IF(FF%IWEIGHT.EQ.2) THEN
                        IF(FFM%SIG(KXYZ+4).GT.EPS) THEN
                           SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in stress (AB%TSIF) in ab initio data for individual system.
                     ELSE IF(FF%IWEIGHT.EQ.3) THEN
                        IF(FFM%SIG(KXYZ+4) .GT. EPS) THEN
                           SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
! If FF%IWEIGHT=4, set SIGMA to variance in stress (AB%TSIF) in ab initio data for all systems.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.4) THEN
                        IF(FFM%SIG(KXYZ+4).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                           ENDIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
! If FF%IWEIGHT=5, set SIGMA to variance in stress (AB%TSIF) in ab initio data for individual system.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.5) THEN
                        IF(FFM%SIG(KXYZ+4).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                           ENDIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
                     ENDIF
                     FFM%DMAT_FMAT(LOCVAR_COL)=1.0_q/SIGMA
                  ENDDO
               ENDDO
            ENDDO
! Scale energy data for YMAT
            DO ICONF=1, NCONF
               IDATA =FFM%LTOTEN(ICONF)
#ifdef scaLAPACK
               TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                  CYCLE
               ENDIF
               LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
#else
               LOCVAR_ROW=IDATA
#endif
! If FF%IWEIGHT=1, set SIGMA as FF%WTOTEN.
               IF(FF%IWEIGHT.EQ.1) THEN
                  SIGMA=FF%WTOTEN
! If FF%IWEIGHT=2, set SIGMA as variance in energy (AB%TOTEN) in ab initio data for all systems.
               ELSE IF(FF%IWEIGHT.EQ.2) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     SIGMA=FFM%SIG(1)/FF%WTOTEN
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in energy (AB%TOTEN) in ab initio data for individual system.
               ELSE IF(FF%IWEIGHT.EQ.3) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     SIGMA=FFM%SIG(1)/FF%WTOTEN
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
! If FF%IWEIGHT=4, set SIGMA to variance in total energy (AB%TOTEN) in ab initio data for all systems.
! Here, the number of configuration is taken into account.
               ELSE IF(FF%IWEIGHT.EQ.4) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                        SIGMA=FFM%SIG(1)/FF%WTOTEN*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                     ELSE
                        SIGMA=FFM%SIG(1)/FF%WTOTEN
                     ENDIF
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
! If FF%IWEIGHT=5, set SIGMA to variance in total energy (AB%TOTEN) in ab initio data for individual system.
! Here, the number of configuration is taken into account.
               ELSE IF(FF%IWEIGHT.EQ.5) THEN
                  IF(FFM%SIG(1).GT.EPS) THEN
                     IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                        SIGMA=FFM%SIG(1)/FF%WTOTEN*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                     ELSE
                        SIGMA=FFM%SIG(1)/FF%WTOTEN
                     ENDIF
                  ELSE
                     SIGMA=5.0E-3_q
                  ENDIF
               ENDIF
               FFM%DMAT_YMAT(LOCVAR_ROW)=1.0_q/SIGMA
            ENDDO
! Scale force data for YMAT.
            DO ICONF=1, NCONF
               DO INIONS=1, NIONS(ICONF)
                  DO IXYZ=1, 3
                     IDATA=FFM%LTIFOR(IXYZ,INIONS,ICONF)
#ifdef scaLAPACK
                     TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
#else
                     LOCVAR_ROW=IDATA
#endif
! If FF%IWEIGHT=1, set SIGMA as FF%WTIFOR.
                     IF(FF%IWEIGHT.EQ.1) THEN
                        SIGMA=FF%WTIFOR
! If FF%IWEIGHT=2, set SIGMA as variance in force (AB%TIFOR) in ab initio data for all systems.
                     ELSE IF(FF%IWEIGHT.EQ.2) THEN
                        IF(FFM%SIG(IXYZ+1) .GT. EPS) THEN
                           SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in force (AB%TIFOR) in ab initio data for individual system.
                     ELSE IF(FF%IWEIGHT.EQ.3) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
! If FF%IWEIGHT=4, set SIGMA to variance in force (AB%TIFOR) in ab initio data for all systems.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.4) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                           ENDIF
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
! If FF%IWEIGHT=5, set SIGMA to variance in force (AB%TIFOR) in ab initio data for individual system.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.5) THEN
                        IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(IXYZ+1)/FF%WTIFOR
                           ENDIF
                        ELSE
                           SIGMA=5.0E-2_q
                        ENDIF
                     ENDIF
                     FFM%DMAT_YMAT(LOCVAR_ROW)=1.0_q/SIGMA
                  ENDDO
               ENDDO
            ENDDO
! Scale stress data for YMAT
            DO ICONF=1, NCONF
               KXYZ=0
               DO IXYZ=1, 3
                  DO JXYZ=IXYZ, 3
                     KXYZ=KXYZ+1
                     IDATA=FFM%LTSIF(JXYZ,IXYZ,ICONF)
#ifdef scaLAPACK
                     TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
#else
                     LOCVAR_ROW=IDATA
#endif
! If FF%IWEIGHT=1, set SIGMA as FF%WTSIF.
                     IF(FF%IWEIGHT.EQ.1) THEN
                        SIGMA=FF%WTSIF
! If FF%IWEIGHT=2, set SIGMA as variance in stress (AB%TSIF) in ab initio data for all systems.
                     ELSE IF(FF%IWEIGHT.EQ.2) THEN
                        IF(FFM%SIG(KXYZ+4) .GT. EPS) THEN
                           SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in stress (AB%TSIF) in ab initio data for individual system.
                     ELSE IF(FF%IWEIGHT.EQ.3) THEN
                        IF(FFM%SIG(KXYZ+4).GT.EPS) THEN
                           SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
! If FF%IWEIGHT=4, set SIGMA to variance in stress (AB%TSIF) in ab initio data for all systems.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.4) THEN
                        IF(FFM%SIG(KXYZ+4).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                           ENDIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
! If FF%IWEIGHT=5, set SIGMA to variance in stress (AB%TSIF) in ab initio data for individual system.
! Here, the number of configuration is taken into account.
                     ELSE IF(FF%IWEIGHT.EQ.5) THEN
                        IF(FFM%SIG(KXYZ+4).GT.EPS) THEN
                           IF(NCONF_SYS(ISYS(ICONF)).GT.0) THEN
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF*SQRT(REAL(NCONF_SYS(ISYS(ICONF)),q)/REAL(NCONF,q))
                           ELSE
                              SIGMA=FFM%SIG(KXYZ+4)/FF%WTSIF
                           ENDIF
                        ELSE
                           SIGMA=5.0_q
                        ENDIF
                     ENDIF
                     FFM%DMAT_YMAT(LOCVAR_ROW)=1.0_q/SIGMA
                  ENDDO
               ENDDO
            ENDDO
! Stop profiling
            PROFILING_STOP ('dmat_mb')
          END SUBROUTINE DMAT_MB

! Allocate temporary array for many-body interactions
          SUBROUTINE ALLOCATE_ZMAT_MB
            IMPLICIT NONE
#ifdef scaLAPACK
            IF(ALLOCATED(ZMAT_FFM)) THEN
               DEALLOCATE(ZMAT_FFM)
            ENDIF
            ALLOCATE(ZMAT_FFM(1:PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N))
#else
            IF(ALLOCATED(ZMAT_FFM)) THEN
               DEALLOCATE(ZMAT_FFM)
            ENDIF
            ALLOCATE(ZMAT_FFM(1:FFM%MDATA,1:1))
#endif
          END SUBROUTINE ALLOCATE_ZMAT_MB

! Predicting many-body interactions
! scaLAPACK-parallel
          SUBROUTINE ZMAT_MB
            IMPLICIT NONE
!Local variables
            INTEGER               :: ICONF
            INTEGER               :: IDATA
            INTEGER               :: IERR
            INTEGER               :: INIONS
            INTEGER               :: INTYP
            INTEGER               :: INTYP0
            INTEGER               :: IXYZ
            INTEGER               :: JXYZ
            INTEGER               :: LOCVAR_COL
            INTEGER               :: LOCVAR_ROW
            INTEGER               :: TEST_ROW
            REAL(q)               :: TOTEN_ATOM_REF
! Start profiling
            PROFILING_START ('zmat_mb')
! Initialization
            AB%TIFOR_MB=0.0_q
            AB%TOTEN_MB=0.0_q
            AB%TSIF_MB=0.0_q
! Prediction
            DO INTYP0=1, FF%MTYP
               ZMAT_FFM=0.0_q
#ifdef scaLAPACK
               CALL PDGEMV ('T',FFM%NB(INTYP0),FFM%NDATA,1.0_q,FFM%FMAT(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC, &
                    FFM%WMAT(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_WMAT_FFM%DESC,1, &
                    0.0_q,ZMAT_FFM(1,1),1,1,PAR_SUP_HANDLE%DESC_YMAT_FFM%DESC,1)
#else
               CALL DGEMV ('T',FFM%NB(INTYP0),FFM%NDATA,1.0_q,FFM%FMAT(1,1,INTYP0),FFM%MB,FFM%WMAT(1,1,INTYP0),1,0.0_q,ZMAT_FFM(1,1),1)
#endif
               DO ICONF=1, NCONF
                  IDATA=FFM%LTOTEN(ICONF)
#ifdef scaLAPACK
                  TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                     CYCLE
                  ENDIF
                  LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
                  LOCVAR_COL=GLOBAL2LOCAL(    1,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB)
#else
                  LOCVAR_ROW=IDATA
                  LOCVAR_COL=1
#endif
                  IF (FF%LTOTEN_SYSTEM) THEN
                     AB%TOTEN_MB(ICONF)=AB%TOTEN_MB(ICONF)+ZMAT_FFM(LOCVAR_ROW,LOCVAR_COL)
                  ELSE
                     AB%TOTEN_MB(ICONF)=AB%TOTEN_MB(ICONF)+ZMAT_FFM(LOCVAR_ROW,LOCVAR_COL)*REAL(NIONS(ICONF),q)
                  ENDIF
               ENDDO
               DO ICONF=1, NCONF
                  DO INIONS=1, NIONS(ICONF)
                     DO IXYZ=1, 3
                        IDATA=FFM%LTIFOR(IXYZ,INIONS,ICONF)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
                        LOCVAR_COL=GLOBAL2LOCAL(    1,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB)
#else
                        LOCVAR_ROW=IDATA
                        LOCVAR_COL=1
#endif
                        AB%TIFOR_MB(IXYZ,INIONS,ICONF)=AB%TIFOR_MB(IXYZ,INIONS,ICONF)+ZMAT_FFM(LOCVAR_ROW,LOCVAR_COL)
                     ENDDO
                  ENDDO
               ENDDO
               DO ICONF=1, NCONF
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
                        IDATA=FFM%LTSIF(JXYZ,IXYZ,ICONF)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IDATA-1)/PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IDATA,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_YMAT_FFM%MB)
                        LOCVAR_COL=GLOBAL2LOCAL(    1,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB)
#else
                        LOCVAR_ROW=IDATA
                        LOCVAR_COL=1
#endif
                        AB%TSIF_MB(JXYZ,IXYZ,ICONF)=AB%TSIF_MB(JXYZ,IXYZ,ICONF)+ZMAT_FFM(LOCVAR_ROW,LOCVAR_COL)
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
            DO ICONF=1, NCONF
               DO IXYZ=1, 2
                  DO JXYZ=IXYZ+1, 3
                     AB%TSIF_MB(IXYZ,JXYZ,ICONF)=AB%TSIF_MB(JXYZ,IXYZ,ICONF)
                  ENDDO
               ENDDO
            ENDDO
#ifdef scaLAPACK
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,AB%TOTEN_MB,NCONF,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
!            CALL MPI_ALLREDUCE(MPI_IN_PLACE,AB%TIFOR_MB,NCONF*3*AB%MIONS_ALLOCATE,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,AB%TIFOR_MB,NCONF*SIZE(AB%TIFOR_MB,1)*SIZE(AB%TIFOR_MB,2),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,AB%TSIF_MB,NCONF*9,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
            DO ICONF=1, NCONF
! Calculate reference atomic energy.
               TOTEN_ATOM_REF=0.0_q
               DO INTYP=1, NTYP(ICONF)
                  INTYP0=LADD(INTYP,ICONF)
                  TOTEN_ATOM_REF=TOTEN_ATOM_REF+NITYP(INTYP0,ICONF)*FF%EATOM_REF(INTYP0)
               ENDDO
! If FFM%ISCALE_TOTEN=1, the energy is scaled to the energy of isolated atoms. In this case, energy of isolated atoms need to be added.
               IF(FFM%ISCALE_TOTEN.EQ.1) THEN
                  AB%TOTEN_MB(ICONF)=AB%TOTEN_MB(ICONF)+TOTEN_ATOM_REF
! If FFM%ISCALE_TOTEN=2, the energy is scaled to the average of the training data. Hence, the average needs to be further added.
               ELSE IF(FFM%ISCALE_TOTEN.EQ.2) THEN
                  AB%TOTEN_MB(ICONF)=AB%TOTEN_MB(ICONF)+TOTEN_ATOM_REF+FFM%TOTENAV*REAL(NIONS(ICONF),q)
               ENDIF
            ENDDO
! Stop profiling
            PROFILING_STOP ('zmat_mb')
          END SUBROUTINE ZMAT_MB

! Deallocate temporary array for many-body interactions
          SUBROUTINE DEALLOCATE_ZMAT_MB
            IMPLICIT NONE
            IF(ALLOCATED(ZMAT_FFM)) THEN
               DEALLOCATE(ZMAT_FFM)
            ENDIF
          END SUBROUTINE DEALLOCATE_ZMAT_MB

        END SUBROUTINE GEN_FF_MB

! Summary report of force field generation
! MPI-parallel
        SUBROUTINE SUMMARY_REPORT(AB,PAR_SUP_HANDLE,LOGF,FF,FFM,LADD,MCONF,MIONS,MITYP,MTYP,NCONF,NIONS,NITYP,NSTEP,NTYP)
          USE LOGFILE
          USE ML_FF_STRUCT, ONLY : ABINITIO, PARALLEL_SUPER, LOG_PAR, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input and output variables
          TYPE (ABINITIO)       :: AB
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (LOG_PAR)        :: LOGF
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: LADD(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: MCONF
          INTEGER, INTENT(IN)   :: MIONS
          INTEGER, INTENT(IN)   :: MITYP
          INTEGER, INTENT(IN)   :: MTYP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NIONS(:) !(1:NCONF)
          INTEGER, INTENT(IN)   :: NITYP(:,:) !(1:MTYP,1:NCONF)
          INTEGER, INTENT(IN)   :: NSTEP
          INTEGER, INTENT(IN)   :: NTYP(:) !(1:NCONF)
! Local variables
          INTEGER               :: ICONF
          INTEGER               :: IERR
          INTEGER               :: INIONS
          INTEGER               :: INIONS_TMP
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: IXYZ
          INTEGER               :: JXYZ
          INTEGER               :: NBMAX(1:FF%MTYP)

! Carry out only if force field is used
          IF(FF%IFF) THEN
! Initialization
             FF%STIFOR=0.0_q
             FF%STOTEN_LAST=0.0_q
             FF%STIFOR_LAST=0.0_q
             FF%STSIF_LAST=0.0_q
             FF%STOTEN=0.0_q
             FF%STSIF=0.0_q
! Set the maximum basis set candidates provided by the training data
             NBMAX=0
             DO ICONF=1, NCONF
                DO INTYP=1, NTYP(ICONF)
                   INTYP0=LADD(INTYP,ICONF)
                   NBMAX(INTYP0)=NBMAX(INTYP0)+NITYP(INTYP0,ICONF)
                ENDDO
             ENDDO
! Calculate error for the energy for all configurations
             DO ICONF=1, NCONF
                FF%STOTEN=FF%STOTEN+((AB%TOTEN(ICONF)-AB%TOTEN_MB(ICONF))/REAL(NIONS(ICONF),q))**2
             ENDDO
! Calculate error for the energy for the recent configuration
             DO ICONF=NCONF, NCONF
                FF%STOTEN_LAST=FF%STOTEN_LAST+((AB%TOTEN(ICONF)-AB%TOTEN_MB(ICONF))/REAL(NIONS(ICONF),q))**2
             ENDDO
! Calculate error for the forces for all configurations
             DO ICONF=1, NCONF
                DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                   INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(INIONS.LE.NIONS(ICONF)) THEN
                      DO IXYZ=1, 3
                         FF%STIFOR=FF%STIFOR+(AB%TIFOR(IXYZ,INIONS,ICONF)-AB%TIFOR_MB(IXYZ,INIONS,ICONF))**2
                      ENDDO
                   ENDIF
                ENDDO
             ENDDO
             CALL MPI_ALLREDUCE(MPI_IN_PLACE,FF%STIFOR,1,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)

! Calculate error for the forces for the recent configuration
             DO ICONF=NCONF, NCONF
                DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                   INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(INIONS.LE.NIONS(ICONF)) THEN
                      DO IXYZ=1, 3
                         FF%STIFOR_LAST=FF%STIFOR_LAST+(AB%TIFOR(IXYZ,INIONS,ICONF)-AB%TIFOR_MB(IXYZ,INIONS,ICONF))**2
                      ENDDO
                   ENDIF
                ENDDO
             ENDDO
             CALL MPI_ALLREDUCE(MPI_IN_PLACE,FF%STIFOR_LAST,1,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)

! Calculate error for the stress for all configurations
             DO ICONF=1, NCONF
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      FF%STSIF=FF%STSIF+(AB%TSIF(JXYZ,IXYZ,ICONF)-AB%TSIF_MB(JXYZ,IXYZ,ICONF))**2
                   ENDDO
                ENDDO
             ENDDO
 
! Calculate error for the stress for all configurations
             DO ICONF=NCONF, NCONF
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      FF%STSIF_LAST=FF%STSIF_LAST+(AB%TSIF(JXYZ,IXYZ,ICONF)-AB%TSIF_MB(JXYZ,IXYZ,ICONF))**2
                   ENDDO
                ENDDO
             ENDDO

             FF%STOTEN=SQRT(FF%STOTEN/REAL(FFM%NTOTEN,q))
             FF%STIFOR=SQRT(FF%STIFOR/REAL(FFM%NTIFOR,q))
             FF%STOTEN_LAST=SQRT(FF%STOTEN_LAST)
             FF%STIFOR_LAST=SQRT(FF%STIFOR_LAST/NIONS(NCONF)/3)
             FF%STSIF_LAST=SQRT(FF%STSIF_LAST/6.0_q)
             FF%STSIF=SQRT(FF%STSIF/REAL(FFM%NTSIF,q))
          ENDIF
        END SUBROUTINE SUMMARY_REPORT
#endif

!****************************************************************************************************
! Predict energy, force and stress.
!****************************************************************************************************
        SUBROUTINE PES_FF (AB,ABN,TIM,PAR_SUP_HANDLE,MLSHM,MEM1,LOGF,FF,FFM,LDO_AB_INITIO, &
                   NCONF,NCONF_NEW,NCONF_SYS,NSTEP,&
                   NEAREST_NEIGHBOR_RADIAL, &
                   NEAREST_NEIGHBOR_ANGULAR )        
          USE ML_FF_CONSTANT
          USE ML_FF_STRUCT, ONLY: ABINITIO, ABINITIONEW, TIME, PARALLEL_SUPER, ML_SHMEM, MEMORY, LOG_PAR, FF_PAR, FFM_PAR, ML_IO_WRITE 
          USE VERLET_CELL_LIST_MOD, ONLY : VERLET_CELL_LIST_TYPE
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)       :: AB
          TYPE (ABINITIONEW)    :: ABN
          TYPE (TIME)           :: TIM
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (MEMORY)         :: MEM1
          TYPE (LOG_PAR)        :: LOGF
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NCONF_NEW
          INTEGER, INTENT(IN)   :: NCONF_SYS
          INTEGER, INTENT(IN)   :: NSTEP
! Output variables
          LOGICAL, INTENT(OUT)  :: LDO_AB_INITIO
          !> nearest neighbor object for radial descriptor
          TYPE( VERLET_CELL_LIST_TYPE ),INTENT( INOUT ) :: NEAREST_NEIGHBOR_RADIAL
          !> nearest neighbor object for angular descriptor
          TYPE( VERLET_CELL_LIST_TYPE ),INTENT( INOUT ) :: NEAREST_NEIGHBOR_ANGULAR
! Local variables
          REAL(q), ALLOCATABLE  :: C00(:,:,:)
          REAL(q), ALLOCATABLE  :: C00_HELP(:)
          REAL(q)               :: CPUTIM0
          REAL(q)               :: CPUTIM1
          REAL(q), ALLOCATABLE  :: ENERGY_HELP(:,:,:)
          REAL(q)               :: EPS
          REAL(q), ALLOCATABLE  :: FORCE_HELP(:,:,:)
          REAL(q), ALLOCATABLE  :: FORCE_HELP2(:)
          INTEGER               :: IB
          INTEGER               :: IDATA
          INTEGER               :: IERR
          INTEGER               :: INIONS
          INTEGER               :: INITYP
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: IPROCESS
          INTEGER               :: IVAR
          INTEGER               :: IXYZ
          INTEGER               :: JXYZ
          INTEGER               :: KXYZ
          LOGICAL               :: LTEST_LOC
          INTEGER               :: LOCVAR_COL
          INTEGER               :: LOCVAR_ROW
          INTEGER               :: MCOL_C00
          INTEGER               :: MCOL_ENERGY_HELP
          INTEGER               :: MCOL_FORCE_HELP
          INTEGER               :: MCOL_PS
          INTEGER               :: MCOL_STRESS_HELP
          INTEGER               :: MROW_C00
          INTEGER               :: MROW_ENERGY_HELP
          INTEGER               :: MROW_FORCE_HELP
          INTEGER               :: MROW_PS
          INTEGER               :: MROW_STRESS_HELP
          REAL(q), ALLOCATABLE  :: PS(:,:,:)
          REAL(q), ALLOCATABLE  :: PS_HELP(:)
          REAL(q)               :: RMEM_HELP1
          REAL(q)               :: RMEM_HELP2
          REAL(q), ALLOCATABLE  :: STRESS_HELP(:,:,:)
          INTEGER               :: TEST_COL
          INTEGER               :: TEST_ROW
          REAL(q)               :: VPUTIM0
          REAL(q)               :: VPUTIM1
! Variables for debugging.
          INTEGER               :: LFLAG_NAN
! Start profiling
          PROFILING_START('pes_ff')
! Constant
          RMEM_HELP1=0.0_q
          RMEM_HELP2=0.0_q
          EPS=1E-10_q
! Allocate helping arrays for storing descriptors and design-matrix elements.
          CALL ALLOCATE_HELP_ARRAYS_PES_FF
! Predict many-body interactions
          ! Record the initial time
          CALL VTIME (VPUTIM0,CPUTIM0)
          ! Initialize the memory usage
          RMEM_HELP2=0.0_q
          CALL MANYBODY (AB,ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,C00,ENERGY_HELP,FORCE_HELP, &
               MCOL_ENERGY_HELP, &
               MROW_C00,MROW_ENERGY_HELP,MROW_FORCE_HELP,MROW_PS,MROW_STRESS_HELP, &
               NCONF,NCONF_NEW,NCONF_SYS,PS,RMEM_HELP2,STRESS_HELP,&
               NEAREST_NEIGHBOR_RADIAL, &
               NEAREST_NEIGHBOR_ANGULAR )
          ! Record the memory usage
          MEM1%RMEM(11)=MAX(MEM1%RMEM(11),RMEM_HELP1+RMEM_HELP2)
          ! Record the final time
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(11)=TIM%CPUTIM(11)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(11)=TIM%VPUTIM(11)+VPUTIM1-VPUTIM0
! Summations of all components
!          ABN%TOTEN=ABN%TOTEN_MB
!          ABN%TIFOR(1:3,1:ABN%MIONS,ABN%NCONF)=ABN%TIFOR_MB(1:3,1:ABN%MIONS,ABN%NCONF)
!          ABN%TSIF(1:3,1:3,ABN%NCONF)=ABN%TSIF_MB(1:3,1:3,ABN%NCONF)
          IF (.NOT.FF%LSECOND_TIME_ML_TO_VASP) THEN
! Renew NSTEP_FROM_GENFF
             FF%NSTEP_FROM_GENFF=FF%NSTEP_FROM_GENFF+1
! Renew NSTEP_FROM_SAMPLING
             FF%NSTEP_FROM_SAMPLING=FF%NSTEP_FROM_SAMPLING+1
          ENDIF

! Judgement, only called if non-fast method is invoked
          IF (FF%IERR.EQ.FF%IERR_COUNTER) THEN
             CALL JUDGE
          ENDIF

#ifndef ML_LEARNING_NOT_ACTIVE
! Copy descriptors and design-matrix elements if necessary.
          IF (FF%ISTART/=2) THEN
             IF (LDO_AB_INITIO.OR.FF%ISTART.EQ.3) THEN
                CALL COPY_DESCRIPTORS_AND_DESIGN_MATRICES
             ENDIF
          ENDIF
#endif

! Deallocate helping arrays used for storing descriptors and design-matrix elements.
          CALL DEALLOCATE_HELP_ARRAYS_PES_FF
! Stop profiling
          PROFILING_STOP ('pes_ff')

          CONTAINS

! Judge whether ab initio calculation is necessary or not
! Not parallelized since it should be fast
          SUBROUTINE JUDGE
            USE RANDOM_NUMBER_GENERATOR
            USE ML_FF_CONSTANT
            IMPLICIT NONE
! varaibles needed for random number
            REAL(q) :: RANDOM_HELP
! Start profiling
            PROFILING_START('judge')
! Estimate average and maximum errors in energy.
            IF (FF%LTOTEN_SYSTEM) THEN
               ABN%BEAV(1,ABN%NCONF) = SQRT( MAX( ABN%BE(1,ABN%NCONF)/REAL(ABN%NIONS,q),&
                                                  1E-12_q / EUNIT**2 ) )
            ELSE
               ! max condition is to prevent NaN in BEEF output caused by
               ! numerical instabilities in matrix inversion 
               ABN%BEAV(1,ABN%NCONF) = SQRT( MAX( ABN%BE(1,ABN%NCONF)/REAL(ABN%NIONS,q)**2,&
                                                  1E-12_q / EUNIT**2 ) )
            ENDIF
            ABN%BEMAX(1,ABN%NCONF)=ABN%BEAV(1,ABN%NCONF)
! Estimate average and maximum errors in forces.
            ABN%BEAV(2,ABN%NCONF)=0.0_q
            ABN%BEMAX(2,ABN%NCONF)=0.0_q
            DO INIONS=1, ABN%NIONS
               ABN%BEAV(2,ABN%NCONF)=ABN%BEAV(2,ABN%NCONF)+ABN%BE(3*(INIONS-1)+2,ABN%NCONF)+ABN%BE(3*(INIONS-1)+3,ABN%NCONF)+ABN%BE(3*(INIONS-1)+4,ABN%NCONF)
               ABN%BEMAX(2,ABN%NCONF)=MAX(ABN%BEMAX(2,ABN%NCONF),SQRT(ABN%BE(3*(INIONS-1)+2,ABN%NCONF)+ABN%BE(3*(INIONS-1)+3,ABN%NCONF)+ABN%BE(3*(INIONS-1)+4,ABN%NCONF)))
            ENDDO
            ! NOTE (2021-07-14 GK,FK,AS): Here we decided to add the divisor 3
            ! in the final calculation of BEAV(2) which is more consistent with
            ! e.g. FF%STIFOR(_LAST). Actually, the same argument would apply to
            ! BEMAX(2) above but this line was NOT changed due to compatibility
            ! reasons and potential side effects.
            ABN%BEAV(2,ABN%NCONF)=SQRT(ABN%BEAV(2,ABN%NCONF)/REAL(ABN%NIONS,q)/3)
! Estimate average and maximum errors in stress tensor.
            ABN%BEAV(3,ABN%NCONF)=0.0_q
            ABN%BEMAX(3,ABN%NCONF)=0.0_q
            DO IXYZ=1, 6
               ABN%BEAV(3,ABN%NCONF)=ABN%BEAV(3,ABN%NCONF)+ABN%BE(3*ABN%NIONS+1+IXYZ,ABN%NCONF)
               ABN%BEMAX(3,ABN%NCONF)=MAX(ABN%BEMAX(3,ABN%NCONF),SQRT(ABN%BE(3*ABN%NIONS+1+IXYZ,ABN%NCONF)))
            ENDDO
            ABN%BEAV(3,ABN%NCONF)=SQRT(ABN%BEAV(3,ABN%NCONF)/6.0_q)
! If FF%LMLONLY=.TRUE., LDO_AB_INITIO is always set as .FALSE. to execute MD or structural optimization
! using the machine-learning force field.
            IF(FF%LMLONLY) THEN
               LDO_AB_INITIO=.FALSE.
            ELSE
! Otherwise, execute usual sampling procedure as follows.
! 1) If the estimated error is larger than the product of CDOUB by the predetermined threshold,
!    LDO_AB_INITIO is set as .TRUE. to execute the ab initio calculation, and LDOUB is set as 
!    .TRUE. to generate the force field immediately.
! 2) Otherwise, the following procedure is executed.
!         2-1) Check whether machine should try to sample the ab initio data or not following the procedure
!              explained below.
!              A) If LSAMPLE=.FALSE., and if the number of MD step from the previous sampling exceeds NDSTEP, 
!                 set LSAMPLE=.TRUE. This setting means that the machine tries to get samples.
!              B) If LSAMPLE=.TRUE., machine tries to get samples.
!              LSAMPLE is set as .TURE. to switch on the sampling.
!         2-2) If the estimated error is larger than the predetermined threshold, and if sampling
!              is switched on (LSAMPLE=.TRUE.), LDO_AB_INITIO is set as .TRUE. to execute the 
!              ab initio calculation.
!         2-3) Otherwise, LDO_AB_INITIO is set as .FALSE. to skip the ab initio calculation.
! Set LSAMPLE following the procedure explained in 2-1).
               IF (FF%LNMDINT_RANDOM) THEN
                  IF((.NOT.FF%LSAMPLE).AND.(FF%NSTEP_FROM_SAMPLING.GE.FF%NMDINT_RANDOM)) THEN
                     FF%LSAMPLE=.TRUE.
! Generate random number only on process 0 to guarantee the same random number on each process
                     IF (PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.0) THEN
                        CALL RANE_ION(RANDOM_HELP)
                        FF%NMDINT_RANDOM=MAX(1,NINT(REAL(FF%NMDINT,q)*RANDOM_HELP))
                     ENDIF
! Broadcast the FF%NMDINT_RANDOM containing the random number
                      CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FF%NMDINT_RANDOM,0)
                  ENDIF
               ELSE
                  IF((.NOT.FF%LSAMPLE).AND.(FF%NSTEP_FROM_SAMPLING.GE.FF%NMDINT)) THEN
                     FF%LSAMPLE=.TRUE.
                  ENDIF
               ENDIF
! If error is larger than CDOUB*threshold, sampling is stopped, and ab initio calculation
! is enforce to be executed following the procedure explained in 1).
               FF%LTHRESHOLD=.FALSE. ! Reset threshold-exceeded marker.
               IF(ABN%BEMAX(2,ABN%NCONF) .GT. FF%CDOUB*FF%CTIFOR) THEN
                  LDO_AB_INITIO=.TRUE.
                  FF%LTHRESHOLD=.TRUE.
                  FF%LDOUB=.TRUE.
                  FF%NSTEP_FROM_SAMPLING=0
! Otherwise execute the nomral procedure 2).
               ELSE
! Judge necessity of ab initio calculation using the estimated error
! ab initio calculation will be executed for sampling the data.
                  IF(ABN%BEMAX(2,ABN%NCONF) .GT. FF%CTIFOR) THEN
                     ! Remember that threshold was exceeded, even if sampling
                     ! was turned off already (see NMDINT if-block above).
                     ! Required to trigger correct status description
                     ! "interval" in the log file.
                     FF%LTHRESHOLD=.TRUE.
                     IF(FF%LSAMPLE) THEN
                        LDO_AB_INITIO=.TRUE.
                        FF%NSTEP_FROM_SAMPLING=0
                     ELSE
                        LDO_AB_INITIO=.FALSE.
                     ENDIF
                  ELSE
                     LDO_AB_INITIO=.FALSE.
                  ENDIF
               ENDIF
            ENDIF
! If we reached the last MD step we want to enforce sampling with force field generation
            IF (FF%FORCING_UPDATE) THEN
                FF%LSAMPLE=.TRUE.
                LDO_AB_INITIO=.TRUE.
                FF%NSTEP_FROM_SAMPLING=0
            ENDIF
! If FF%LTEST=.TRUE., LDO_AB_INITIO is set as .TRUE. when MOD(NSTEP,FF%NTEST)=1.
            LTEST_LOC=.FALSE.
            IF (FF%LTEST.AND.FF%NTEST.NE.0) THEN
               IF((MOD(NSTEP,FF%NTEST).EQ.1).OR.(FF%NTEST.EQ.1)) THEN
                  LTEST_LOC=.TRUE.
                  LDO_AB_INITIO=.TRUE.
               ENDIF
            ENDIF
! If FF%ISTART=4 no update is done since learning was done in the first step
            IF (FF%ISTART.EQ.4) THEN
               FF%LSAMPLE=.FALSE.
               LDO_AB_INITIO=.FALSE.
               FF%LDOUB=.FALSE.
               FF%LTHRESHOLD=.FALSE.
            ENDIF
! Stop profiling
            PROFILING_STOP('judge')
          END SUBROUTINE JUDGE

#ifndef ML_LEARNING_NOT_ACTIVE
          SUBROUTINE COPY_DESCRIPTORS_AND_DESIGN_MATRICES
             IMPLICIT NONE
! Initialization of design-matrix elements.
             CALL INIT_FMAT_NEW_MB_JUDGE
! Copy the design-matrix elements.
             CALL COPY_FMAT_NEW_MB_JUDGE
! Copy the descriptors.
             CALL COPY_DESCRIPTORS_NEW_MB
          END SUBROUTINE COPY_DESCRIPTORS_AND_DESIGN_MATRICES
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
! Subroutine to initialize the design-matrix elements.

          SUBROUTINE INIT_FMAT_NEW_MB_JUDGE
            IMPLICIT NONE
! Start profiling.
            PROFILING_START ('init_fmat_new_mb')
! Initialization of energy components.
            DO INTYP=1, ABN%NTYP
               INTYP0=ABN%LADD(INTYP)
#ifdef scaLAPACK
               TEST_COL=MOD((FFM%LTOTEN_NEW(NCONF_NEW)-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                  CYCLE
               ENDIF
               LOCVAR_COL=GLOBAL2LOCAL(FFM%LTOTEN_NEW(NCONF_NEW),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB)
#else
               LOCVAR_COL=FFM%LTOTEN_NEW(NCONF_NEW)
#endif
               DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                  TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                     CYCLE
                  ENDIF
                  LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB)
#else
                  LOCVAR_ROW=IB
#endif
                  FFM%FMAT_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
               ENDDO
            ENDDO
! Initialization of force components.
            DO INTYP=1, ABN%NTYP
               INTYP0=ABN%LADD(INTYP)
               DO INIONS=1, ABN%NIONS
                  DO IXYZ=1, 3
#ifdef scaLAPACK
                     TEST_COL=MOD((FFM%LTIFOR_NEW(IXYZ,INIONS,NCONF_NEW)-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_COL=GLOBAL2LOCAL(FFM%LTIFOR_NEW(IXYZ,INIONS,NCONF_NEW),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB)
#else
                     LOCVAR_COL=FFM%LTIFOR_NEW(IXYZ,INIONS,NCONF_NEW)
#endif
                     DO  IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB)
#else
                        LOCVAR_ROW=IB
#endif
                        FFM%FMAT_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
! Initialization of stress components.
            DO INTYP=1, ABN%NTYP
               INTYP0=ABN%LADD(INTYP)
               DO IXYZ=1, 3
                  DO JXYZ=IXYZ, 3
#ifdef scaLAPACK
                     TEST_COL=MOD((FFM%LTSIF_NEW(JXYZ,IXYZ,NCONF_NEW)-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_COL=GLOBAL2LOCAL(FFM%LTSIF_NEW(JXYZ,IXYZ,NCONF_NEW),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB)
#else
                     LOCVAR_COL=FFM%LTSIF_NEW(JXYZ,IXYZ,NCONF_NEW)
#endif
                     DO  IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB)
#else
                        LOCVAR_ROW=IB
#endif
                        FFM%FMAT_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0)=0.0_q
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
! Stop profiling.
            PROFILING_STOP ('init_fmat_new_mb')
          END SUBROUTINE INIT_FMAT_NEW_MB_JUDGE
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
          SUBROUTINE COPY_DESCRIPTORS_NEW_MB
            IMPLICIT NONE
! Start profiling.
            PROFILING_START ('copy_desc_new_mb')
! Copy the calculated descriptors to helping arrays.
            DO INTYP=1, ABN%NTYP
               INTYP0=ABN%LADD(INTYP)
               DO INITYP=1, ABN%NITYP(INTYP0)
                  IPROCESS=MOD(INITYP-1,PAR_SUP_HANDLE%COMM_WORLD%NCPU)
                  IF(PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.IPROCESS) THEN
                     LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Copy the radial descriptors.
                     IF(FFM%W1.GT.0.0_q) THEN
                        PROFILING_START ('copy_raddesc_new_mb')
                        C00_HELP(1:FFM%NNVAR1)=C00(1:FFM%NNVAR1,LOCVAR_COL,INTYP0)
                        PROFILING_STOP ('copy_raddesc_new_mb')
                     ENDIF
! Copy the angular descriptors.
                     IF(FFM%W2.GT.0.0_q) THEN
                        PROFILING_START ('copy_angdesc_new_mb')
                        PS_HELP(1:FFM%NNVAR2(INTYP0))=PS(1:FFM%NNVAR2(INTYP0),LOCVAR_COL,INTYP0)
                        PROFILING_STOP ('copy_angdesc_new_mb')
                     ENDIF
                  ENDIF
! Copy radial descriptor to global array.
                  IF(FFM%W1.GT.0.0_q) THEN
! Broadcast the helping radial descriptor array.
                     PROFILING_START ('bcast_raddesc_new_mb')
                      CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,C00_HELP(1:),FFM%NNVAR1,IPROCESS)
                     PROFILING_STOP ('bcast_raddesc_new_mb')
! Then, copy it to the global array.
                     PROFILING_START ('copy_raddesc_new_mb')
#ifdef scaLAPACK
                     TEST_COL=MOD((INITYP-1)/PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                        LOCVAR_COL=GLOBAL2LOCAL(INITYP,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB)
#else
                        LOCVAR_COL=INITYP
#endif
                        DO IVAR=1, FFM%NNVAR1
#ifdef scaLAPACK
                           TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                           IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB)
#else
                           LOCVAR_ROW=IVAR
#endif
                           FFM%C00_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0,NCONF_NEW)=C00_HELP(IVAR)
                        ENDDO
#ifdef scaLAPACK
                     ENDIF
#endif
                     PROFILING_STOP ('copy_raddesc_new_mb')
                  ENDIF
! Copy the angular descriptors.
                  IF(FFM%W2.GT.0.0_q) THEN
! Broadcast the helping angular descriptor array.
                     PROFILING_START ('bcast_angdesc_new_mb')
                      CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,PS_HELP(1:),FFM%NNVAR2(INTYP0),IPROCESS)
                     PROFILING_STOP ('bcast_angdesc_new_mb')
! Then, copy it to the global array.
                     PROFILING_START ('copy_angdesc_new_mb')
#ifdef scaLAPACK
                     TEST_COL=MOD((INITYP-1)/PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                        LOCVAR_COL=GLOBAL2LOCAL(INITYP,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB)
#else
                        LOCVAR_COL=INITYP
#endif
                        DO IVAR=1, FFM%NNVAR2(INTYP0)
#ifdef scaLAPACK
                           TEST_ROW=MOD((IVAR-1)/PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                           IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_ROW=GLOBAL2LOCAL(IVAR,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB)
#else
                           LOCVAR_ROW=IVAR
#endif
                           FFM%PS_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0,NCONF_NEW)=PS_HELP(IVAR)
                        ENDDO
#ifdef scaLAPACK
                     ENDIF
#endif
                     PROFILING_STOP ('copy_angdesc_new_mb')
                  ENDIF
               ENDDO
            ENDDO
! Stop profiling.
            PROFILING_STOP ('copy_desc_new_mb')
          END SUBROUTINE COPY_DESCRIPTORS_NEW_MB
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
          SUBROUTINE COPY_FMAT_NEW_MB_JUDGE
            IMPLICIT NONE
! Start profiling.
            PROFILING_START ('copy_fmat_new_mb')
! Copy the design matrix.
            DO INTYP=1, ABN%NTYP
               INTYP0=ABN%LADD(INTYP)
               IF(FFM%NB(INTYP0).GT.0) THEN
! Copy the energy components.
                  PROFILING_START ('copy_energy_fmat_new_mb')
#ifdef scaLAPACK
                  TEST_COL=MOD((FFM%LTOTEN_NEW(NCONF_NEW)-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                  IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                     LOCVAR_COL=GLOBAL2LOCAL(FFM%LTOTEN_NEW(NCONF_NEW),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB)
#else
                     LOCVAR_COL=FFM%LTOTEN_NEW(NCONF_NEW)
#endif
                     DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                        TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                           CYCLE
                        ENDIF
                        LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB)
#else
                        LOCVAR_ROW=IB
#endif
                        FFM%FMAT_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0)=ENERGY_HELP(IB,1,INTYP0)
                     ENDDO
#ifdef scaLAPACK
                  ENDIF
#endif
                  PROFILING_STOP ('copy_energy_fmat_new_mb')
! Copy the force components.
                  PROFILING_START ('copy_force_fmat_new_mb')
                  DO INIONS=1, ABN%NIONS, 1
                     IPROCESS=MOD(INIONS-1,PAR_SUP_HANDLE%COMM_WORLD%NCPU)
                     DO IXYZ=1, 3
                        IF(PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.IPROCESS) THEN
                           LOCVAR_COL=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           FORCE_HELP2(1:FFM%NB(INTYP0))=FORCE_HELP(1:FFM%NB(INTYP0),3*(LOCVAR_COL-1)+IXYZ,INTYP0)
                        ENDIF
                         CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FORCE_HELP2(1:),FFM%NB(INTYP0),IPROCESS)
#ifdef scaLAPACK
                        TEST_COL=MOD((FFM%LTIFOR_NEW(IXYZ,INIONS,NCONF_NEW)-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                           LOCVAR_COL=GLOBAL2LOCAL(FFM%LTIFOR_NEW(IXYZ,INIONS,NCONF_NEW),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB)
#else
                           LOCVAR_COL=FFM%LTIFOR_NEW(IXYZ,INIONS,NCONF_NEW)
#endif
                           DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                              TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                              IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB)
#else
                              LOCVAR_ROW=IB
#endif
                              FFM%FMAT_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0)=FORCE_HELP2(IB)
                           ENDDO
#ifdef scaLAPACK
                        ENDIF
#endif
                     ENDDO
                  ENDDO ! End of ion loop
                  PROFILING_STOP ('copy_force_fmat_new_mb')
! Copy the stress components.
                  PROFILING_START ('copy_stress_fmat_new_mb')
                  KXYZ=0
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
                        KXYZ=KXYZ+1
#ifdef scaLAPACK
                        TEST_COL=MOD((FFM%LTSIF_NEW(JXYZ,IXYZ,NCONF_NEW)-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                        IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                           LOCVAR_COL=GLOBAL2LOCAL(FFM%LTSIF_NEW(JXYZ,IXYZ,NCONF_NEW),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB)
#else
                           LOCVAR_COL=FFM%LTSIF_NEW(JXYZ,IXYZ,NCONF_NEW)
#endif
                           DO IB=1, FFM%NB(INTYP0)
#ifdef scaLAPACK
                              TEST_ROW=MOD((IB-1)/PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                              IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                                 CYCLE
                              ENDIF
                              LOCVAR_ROW=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB)
#else
                              LOCVAR_ROW=IB
#endif
                              FFM%FMAT_NEW(LOCVAR_ROW,LOCVAR_COL,INTYP0)=STRESS_HELP(IB,KXYZ,INTYP0)
                           ENDDO
#ifdef scaLAPACK
                        ENDIF
#endif
                     ENDDO ! End of Cartesian coordinate loop (JXYZ).
                  ENDDO ! End of Cartesian coordinate loop (IXYZ).
                  PROFILING_STOP ('copy_stress_fmat_new_mb')
               ENDIF
            ENDDO ! End of element loop
! Start profiling.
            PROFILING_STOP ('copy_fmat_new_mb')
          END SUBROUTINE COPY_FMAT_NEW_MB_JUDGE
#endif

! Subroutine to allocate helping arrays used for storing descriptors and design-matrix elements.
! If the program judges that the force field needs to be trained, the stored descriptors and 
! elements are copied to FFM%C00_NEW, FFM%PS_NEW and FFM%FMAT_NEW.

          SUBROUTINE ALLOCATE_HELP_ARRAYS_PES_FF
            IMPLICIT NONE
! Initialize memory counter.
            RMEM_HELP1=0.0_q
! Define sizes of arrays.
! Size of C00.
! Even when FFM%W1=0, C00 must be declared because it is explicitly sent
! through MANYBODY subroutine. In this case, MROW_C00 and MCOL_C00 are
! set as unity.
            IF(FFM%W1.GT.0.0_q) THEN
               MROW_C00=FFM%MMVAR1
               MCOL_C00=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ELSE
               MROW_C00=1
               MCOL_C00=1
            ENDIF
! Size of FFM%PS.
! Even when FFM%W2=0, PS must be declared because it is explicitly sent
! through MANYBODY subroutine. In this case, MROW_PS and MCOL_PS are
! set as unity.
            IF(FFM%W2.GT.0.0_q) THEN
               MROW_PS=FFM%MMVAR2
               MCOL_PS=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ELSE
               MROW_PS=1
               MCOL_PS=1
            ENDIF
! Size of helpiing array for design matrix energy elements.
            MROW_ENERGY_HELP=FFM%MB
            MCOL_ENERGY_HELP=1
! Size of helpiing array for design matrix energy elements.
            MROW_FORCE_HELP=FFM%MB
            MCOL_FORCE_HELP=3*CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_FORCE_HELP=MCOL_FORCE_HELP + CEILING(REAL(6,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of helping array for stress design matrix elements.
            MROW_STRESS_HELP=FFM%MB
            MCOL_STRESS_HELP=6
! Allocate arrays.
! Allocate C00.
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            ALLOCATE (C00(1:MROW_C00,1:MCOL_C00,1:ABN%MTYP_ALLOCATE))
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_C00,q)*REAL(MCOL_C00,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E+06_q
! Allocate C00_HELP.
            IF(FFM%W1.GT.0.0_q) THEN
               IF(ALLOCATED(C00_HELP)) THEN
                  DEALLOCATE(C00_HELP)
               ENDIF
               ALLOCATE (C00_HELP(1:FFM%NNVAR1))
               RMEM_HELP1=RMEM_HELP1+REAL(FFM%NNVAR1,q)*8/1.0E+06_q
            ENDIF
! Allocate PS.
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            ALLOCATE (PS(1:MROW_PS,1:MCOL_PS,1:ABN%MTYP_ALLOCATE)) 
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_PS,q)*REAL(MCOL_PS,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E+06_q
! Allocate PS_HELP.
            IF(FFM%W2.GT.0.0_q) THEN
               IF(ALLOCATED(PS_HELP)) THEN
                  DEALLOCATE(PS_HELP)
               ENDIF
               ALLOCATE (PS_HELP(1:FFM%MMVAR2))
               RMEM_HELP1=RMEM_HELP1+REAL(FFM%MMVAR2,q)*8/1.0E+06_q
            ENDIF
! Allocate ENERGY_HELP.
            IF(ALLOCATED(ENERGY_HELP)) THEN
               DEALLOCATE(ENERGY_HELP)
            ENDIF
            ALLOCATE(ENERGY_HELP(1:MROW_ENERGY_HELP,1:MCOL_ENERGY_HELP,1:ABN%MTYP_ALLOCATE)) 
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_ENERGY_HELP,q)*REAL(MCOL_ENERGY_HELP,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E+06_q
! Allocate FORCE_HELP.
            IF(ALLOCATED(FORCE_HELP)) THEN
               DEALLOCATE(FORCE_HELP)
            ENDIF
            ! + 1 in second dimension for energy
            IF ( PAR_SUP_HANDLE%COMM_WORLD%NODE_ME .EQ. 0 ) THEN
              ALLOCATE(FORCE_HELP(1:MROW_FORCE_HELP,1:MCOL_FORCE_HELP+1,1:ABN%MTYP_ALLOCATE)) 
            ELSE
              ALLOCATE(FORCE_HELP(1:MROW_FORCE_HELP,1:MCOL_FORCE_HELP,1:ABN%MTYP_ALLOCATE)) 
            END IF
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_FORCE_HELP,q)*REAL(MCOL_FORCE_HELP,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E+06_q
! Allocate FORCE_HELP2.
            IF(ALLOCATED(FORCE_HELP2)) THEN
               DEALLOCATE(FORCE_HELP2)
            ENDIF
            ALLOCATE(FORCE_HELP2(1:FFM%MB))
            RMEM_HELP1=RMEM_HELP1+REAL(FFM%MB,q)*8/1.0E+06_q
! Allocate STRESS_HELP.
            IF(ALLOCATED(STRESS_HELP)) THEN
               DEALLOCATE(STRESS_HELP)
            ENDIF
            ALLOCATE(STRESS_HELP(1:MROW_STRESS_HELP,1:MCOL_STRESS_HELP,1:ABN%MTYP_ALLOCATE)) 
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_STRESS_HELP,q)*REAL(MCOL_STRESS_HELP,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E+06_q
          END SUBROUTINE ALLOCATE_HELP_ARRAYS_PES_FF

! Subroutine to deallocate helping arrays used for storing descriptors and design-matrix elements.

          SUBROUTINE DEALLOCATE_HELP_ARRAYS_PES_FF
            IMPLICIT NONE
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            IF(ALLOCATED(C00_HELP)) THEN
               DEALLOCATE(C00_HELP)
            ENDIF
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            IF(ALLOCATED(PS_HELP)) THEN
               DEALLOCATE(PS_HELP)
            ENDIF
            IF(ALLOCATED(ENERGY_HELP)) THEN
               DEALLOCATE(ENERGY_HELP)
            ENDIF
            IF(ALLOCATED(FORCE_HELP)) THEN
               DEALLOCATE(FORCE_HELP)
            ENDIF
            IF(ALLOCATED(FORCE_HELP2)) THEN
               DEALLOCATE(FORCE_HELP2)
            ENDIF
            IF(ALLOCATED(STRESS_HELP)) THEN
               DEALLOCATE(STRESS_HELP)
            ENDIF
          END SUBROUTINE DEALLOCATE_HELP_ARRAYS_PES_FF

        END SUBROUTINE PES_FF


!****************************************************************************************************
! Subroutine for calculating many-body interactions
!****************************************************************************************************
        SUBROUTINE MANYBODY (AB,ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,C00,ENERGY_HELP,FORCE_HELP, &
                   MCOL_ENERGY_HELP, &
                   MROW_C00,MROW_ENERGY_HELP,MROW_FORCE_HELP,MROW_PS,MROW_STRESS_HELP, &
                   NCONF,NCONF_NEW,NCONF_SYS,PS,RMEM,STRESS_HELP,&
                   NEAREST_NEIGHBOR_RADIAL,&
                   NEAREST_NEIGHBOR_ANGULAR )
          USE NEIGHBOUR
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: ABINITIO, ABINITIONEW, PARALLEL_SUPER, ML_SHMEM, FF_PAR, FFM_PAR, ML_IO_WRITE
          USE FORCE_FIELD_ADDITIONAL
          USE VERLET_CELL_LIST_MOD, ONLY : VERLET_CELL_LIST_TYPE
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)       :: AB
          TYPE (ABINITIONEW)    :: ABN
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: MCOL_ENERGY_HELP
          INTEGER, INTENT(IN)   :: MROW_C00
          INTEGER, INTENT(IN)   :: MROW_ENERGY_HELP
          INTEGER, INTENT(IN)   :: MROW_FORCE_HELP
          INTEGER, INTENT(IN)   :: MROW_PS
          INTEGER, INTENT(IN)   :: MROW_STRESS_HELP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NCONF_NEW
          INTEGER, INTENT(IN)   :: NCONF_SYS
! Output variables
          REAL(q), INTENT(OUT)  :: C00(:,:,:) !(1:MROW_C00,1:MCOL_C00,1:MTYP)
          REAL(q), INTENT(OUT)  :: ENERGY_HELP(:,:,:) !(1:MROW_ENERGY_HELP,1:MCOL_ENERGY_HELP,1:MTYP)
          REAL(q), INTENT(OUT)  :: FORCE_HELP(:,:,:) !(1:MROW_FORCE_HELP,1:MCOL_FORCE_HELP,1:MTYP)
          REAL(q), INTENT(OUT)  :: PS(:,:,:) !(1:MROW_PS,1:MCOL_PS,1:MTYP)
          REAL(q), INTENT(OUT)  :: STRESS_HELP(:,:,:) !(1:MROW_STRESS_HELP,1:MCOL_STRESS_HELP,1:MTYP)
          REAL(q), INTENT(OUT)  :: RMEM ! Memory usage
          !> nearest neighbor object for radial descriptor
          TYPE( VERLET_CELL_LIST_TYPE ),INTENT( INOUT ) :: NEAREST_NEIGHBOR_RADIAL
          !> nearest neighbor object for angular descriptor
          TYPE( VERLET_CELL_LIST_TYPE ),INTENT( INOUT ) :: NEAREST_NEIGHBOR_ANGULAR
! Local variables
          REAL(q)               :: BE_HELP
          REAL(q)               :: DRIFT(1:3)
          REAL(q)               :: DRIFT2(1:3)
          REAL(q), ALLOCATABLE  :: EATOM_HELP(:,:,:)
          REAL(q), ALLOCATABLE  :: ENERGY_COUPLE_HELP(:,:,:)
          REAL(q), ALLOCATABLE  :: HEAT_HELP1(:,:,:,:)
          REAL(q), ALLOCATABLE  :: HEAT_HELP2(:,:,:,:)
          INTEGER               :: IB
          INTEGER               :: INIONS
          INTEGER               :: INIONS_TMP
          INTEGER, ALLOCATABLE  :: LHEAD(:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST1(:,:,:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST2(:,:,:)
          INTEGER, ALLOCATABLE  :: LNIONS_EST_MAX(:,:,:)
          INTEGER               :: LOCVAR_COL
          INTEGER               :: MCOL_EATOM
          INTEGER               :: MCOL_ENERGY_COUPLE_HELP
          INTEGER               :: MCOL_EST1 
          INTEGER               :: MCOL_EST2
          INTEGER               :: MCOL_EST_MAX
          INTEGER               :: MCOL_MIONS
          INTEGER               :: MNEIB_EST1
          INTEGER               :: MNEIB_EST2
          INTEGER               :: MNEIB_EST_MAX
          INTEGER               :: MROW_EATOM
          INTEGER               :: MROW_ENERGY_COUPLE_HELP 
          INTEGER               :: MROW_EST1
          INTEGER               :: MROW_EST2
          INTEGER               :: MROW_EST_MAX
          INTEGER               :: MROW_HEAT1
          INTEGER               :: MROW_HEAT2
          INTEGER               :: NB_MAX
          INTEGER, ALLOCATABLE  :: NNEIB_EST1(:,:)
          INTEGER, ALLOCATABLE  :: NNEIB_EST2(:,:)
          INTEGER, ALLOCATABLE  :: NNEIB_EST_MAX(:,:)
          REAL(q)               :: RMEM_HELP1
          REAL(q)               :: RMEM_HELP2
          REAL(q), ALLOCATABLE  :: NORMALIZATION_XYZ1(:,:,:)
          REAL(q), ALLOCATABLE  :: NORMALIZATION_XYZ2(:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST1(:,:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST2(:,:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST1_NORM(:,:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST2_NORM(:,:,:,:)
          REAL(q), ALLOCATABLE  :: XYZ_EST_MAX(:,:,:,:)
!TEST
!          INTEGER               :: II, JJ
!TEST
! Start profiling.
          PROFILING_START ('manybody')
! Configure and size of array.
          PROFILING_START('st_manybody')

          RMEM_HELP1 = 0.0_q
          RMEM_HELP2 = 0.0_q
          RMEM = 0.0_q
! Allocate.
! Configure structural data.
          IF (FF%LFAST .AND. FF%IERR_COUNTER.NE.FF%IERR) THEN
             CALL COMPUTE_NEAREST_NEIGHBOR_ARRAYS( NEAREST_NEIGHBOR_RADIAL, &
                                                   NEAREST_NEIGHBOR_ANGULAR, &
                                                   ABN%A( 1:, 1:, ABN%NCONF ), &
                                                   ABN%B( 1:, 1:, ABN%NCONF ), &
                                                   ABN%LNTYP( 1: ), &
                                                   ABN%MTYP, &
                                                   ABN%NIONS, &
                                                   ABN%MIONS, &
                                                   ABN%POSION( 1:, 1:, ABN%NCONF ),&
                                                   PAR_SUP_HANDLE,&
                                                   ! radial variables
                                                   MNEIB_EST1, &
                                                   FFM%W1, &
                                                   FFM%RCUT1, &
                                                   ! angular variables
                                                   MNEIB_EST2, &
                                                   FFM%W2, &
                                                   FFM%RCUT2 )
             CALL ALLOCATE_NEAREST_NEIGHBOR_MANYBODY
             CALL UPDATE_NEAREST_NEIGHBOR_ARRAYS( NEAREST_NEIGHBOR_RADIAL, &
                                                  NEAREST_NEIGHBOR_ANGULAR, &
                                                  ABN%A( 1:, 1:, ABN%NCONF ), &
                                                  ABN%B( 1:, 1:, ABN%NCONF ), &
                                                  ABN%LNTYP( 1: ), &
                                                  ABN%MTYP, &
                                                  ABN%NIONS, &
                                                  ABN%MIONS, &
                                                  ABN%POSION( 1:, 1:, ABN%NCONF ),&
                                                  PAR_SUP_HANDLE%COMM_WORLD%NCPU, &
                                                  PAR_SUP_HANDLE%COMM_WORLD%NODE_ME, &
                                                  ! radial variables
                                                  LNIONS_EST1 , &
                                                  NNEIB_EST1 ,&
                                                  NORMALIZATION_XYZ1 , &
                                                  XYZ_EST1, &
                                                  XYZ_EST1_NORM, &
                                                  FFM%W1, &
                                                  ! angular variables
                                                  LNIONS_EST2, &
                                                  NNEIB_EST2, &
                                                  NORMALIZATION_XYZ2, &
                                                  XYZ_EST2, &
                                                  XYZ_EST2_NORM, &
                                                  FFM%W2 &
                                                 )
          ELSE
             IF(FFM%W1.GT.0.0_q) THEN
                CALL SET_SIZE_EST (PAR_SUP_HANDLE%COMM_WORLD,ABN%A(1:,1:,ABN%NCONF),ABN%B(1:,1:,ABN%NCONF),ABN%LADD(1:),ABN%LNIONS(1:,1:),ABN%MIONS,ABN%MITYP,MNEIB_EST1,ABN%MTYP,ABN%NIONS,ABN%NITYP(1:),ABN%NTYP,FFM%RCUT1,ABN%POSION(1:,1:,ABN%NCONF))
             ELSE
                MNEIB_EST1=1
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                CALL SET_SIZE_EST (PAR_SUP_HANDLE%COMM_WORLD,ABN%A(1:,1:,ABN%NCONF),ABN%B(1:,1:,ABN%NCONF),ABN%LADD(1:),ABN%LNIONS(1:,1:),ABN%MIONS,ABN%MITYP,MNEIB_EST2,ABN%MTYP,ABN%NIONS,ABN%NITYP(1:),ABN%NTYP,FFM%RCUT2,ABN%POSION(1:,1:,ABN%NCONF))
             ELSE
                MNEIB_EST2=1
             ENDIF
             CALL ALLOCATE_NEAREST_NEIGHBOR_MANYBODY
             DO INIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                IF(INIONS.LE.ABN%NIONS) THEN
                   LOCVAR_COL=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                   IF(FFM%W1.GT.0.0_q) THEN
                      CALL SET_EST_DATA_POINT (1,ABN%A(1:,1:,ABN%NCONF),ABN%B(1:,1:,ABN%NCONF),INIONS,ABN%LNTYP(1:), &
                           LNIONS_EST1(1:,1:,LOCVAR_COL),ABN%MIONS,MROW_EST1,ABN%MTYP, &
                           ABN%NIONS,NNEIB_EST1(1:,LOCVAR_COL),ABN%NTYP,FFM%RCUT1,FFM%RCUT1,FFM%RCUT2,ABN%POSION(1:,1:,ABN%NCONF), &
                           XYZ_EST1(1:,1:,1:,LOCVAR_COL))
                   ENDIF
                   IF(FFM%W2.GT.0.0_q) THEN
                      CALL SET_EST_DATA_POINT (1,ABN%A(1:,1:,ABN%NCONF),ABN%B(1:,1:,ABN%NCONF),INIONS,ABN%LNTYP(1:), &
                           LNIONS_EST2(1:,1:,LOCVAR_COL),ABN%MIONS,MROW_EST2,ABN%MTYP, &
                           ABN%NIONS,NNEIB_EST2(1:,LOCVAR_COL),ABN%NTYP,FFM%RCUT2,FFM%RCUT1,FFM%RCUT2,ABN%POSION(1:,1:,ABN%NCONF), &
                           XYZ_EST2(1:,1:,1:,LOCVAR_COL))
                   ENDIF
                ENDIF
             ENDDO
          ENDIF

          IF(.NOT.FFM%LSUPERVEC) THEN
             MNEIB_EST_MAX=1
          ELSE
             MNEIB_EST_MAX=MAX(MNEIB_EST1,MNEIB_EST2)
          ENDIF
          CALL ALLOCATE_MB_ARRAY_MANYBODY
          IF(FFM%LSUPERVEC) THEN
             IF(FFM%W1.GT.0.0_q.AND.FFM%W2.GT.0.0_q) THEN
                IF(MNEIB_EST1.GE.MNEIB_EST2) THEN
                    LNIONS_EST_MAX=LNIONS_EST1
                    NNEIB_EST_MAX=NNEIB_EST1
                    XYZ_EST_MAX=XYZ_EST1
                ELSE
                    LNIONS_EST_MAX=LNIONS_EST2
                    NNEIB_EST_MAX=NNEIB_EST2
                    XYZ_EST_MAX=XYZ_EST2
                ENDIF
             ELSE
                IF(FFM%W1.NE.0.0_q) THEN
                    LNIONS_EST_MAX=LNIONS_EST1
                    NNEIB_EST_MAX=NNEIB_EST1
                    XYZ_EST_MAX=XYZ_EST1
                ELSE IF(FFM%W2.NE.0.0_q) THEN
                    LNIONS_EST_MAX=LNIONS_EST2
                    NNEIB_EST_MAX=NNEIB_EST2
                    XYZ_EST_MAX=XYZ_EST2
                ENDIF
             ENDIF
          ENDIF
          PROFILING_STOP('st_manybody')
          IF (FF%LFAST .AND. FF%IERR_COUNTER.NE.FF%IERR) THEN
             CALL FMAT_NEW_MB3(AB,ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,LHEAD,LNIONS_EST1,LNIONS_EST2, &
                     LNIONS_EST_MAX,MCOL_EATOM, &
                     MNEIB_EST1,MNEIB_EST2,MNEIB_EST_MAX, &
                     MROW_C00,MROW_EATOM, &
                     MROW_EST1,MROW_EST2,MROW_EST_MAX, &
                     MROW_PS,NB_MAX,NNEIB_EST1,NNEIB_EST2,NNEIB_EST_MAX,NORMALIZATION_XYZ1,NORMALIZATION_XYZ2, &
                     XYZ_EST1,XYZ_EST2,XYZ_EST1_NORM,XYZ_EST2_NORM,XYZ_EST_MAX,EATOM_HELP, &
                     ENERGY_COUPLE_HELP,ENERGY_HELP,HEAT_HELP1,HEAT_HELP2, &
                     RMEM_HELP1,RMEM_HELP2,ABN%TIFOR_MB(1:,1:,ABN%NCONF),ABN%TSIF_MB(1:,1:,ABN%NCONF))
             CALL ZMAT_NEW_MB_NEW(ABN,PAR_SUP_HANDLE,FF,FFM,LHEAD,LNIONS_EST1,LNIONS_EST2,LNIONS_EST_MAX,  &
                      MNEIB_EST1,MNEIB_EST2,MNEIB_EST_MAX,XYZ_EST1,XYZ_EST2,XYZ_EST_MAX,EATOM_HELP, &
                      ENERGY_COUPLE_HELP,ENERGY_HELP,HEAT_HELP1,HEAT_HELP2,NNEIB_EST1,NNEIB_EST2, &
                      NNEIB_EST_MAX,ABN%QHEAT(1:,ABN%NCONF),RMEM,ABN%TIFOR_MB(1:,1:,ABN%NCONF),ABN%TOTEN_MB(ABN%NCONF),ABN%VEL(:,:,ABN%NCONF))
          ELSE
! Calculate design matrix
             CALL FMAT_NEW_MB(AB,ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,LHEAD,LNIONS_EST1,LNIONS_EST2, &
                        LNIONS_EST_MAX,MCOL_EATOM,MNEIB_EST1,MNEIB_EST2,MNEIB_EST_MAX, &
                        MROW_C00,MROW_EATOM,MROW_EST1,MROW_EST2,MROW_EST_MAX, &
                        MROW_PS,NB_MAX,NNEIB_EST1,NNEIB_EST2,NNEIB_EST_MAX,XYZ_EST1,XYZ_EST2, &
                        XYZ_EST_MAX,C00,EATOM_HELP,ENERGY_COUPLE_HELP,ENERGY_HELP,FORCE_HELP, &
                        HEAT_HELP1,HEAT_HELP2,PS,RMEM_HELP1,RMEM_HELP2,STRESS_HELP)
! Calculate energy, force and stress tensor
             CALL ZMAT_NEW_MB(ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,LHEAD, &
                     MNEIB_EST1,MNEIB_EST2,MNEIB_EST_MAX, &
                     XYZ_EST1,XYZ_EST2,XYZ_EST_MAX,EATOM_HELP, &
                     ENERGY_COUPLE_HELP,ENERGY_HELP,FORCE_HELP,HEAT_HELP1,HEAT_HELP2,NNEIB_EST1,NNEIB_EST2, &
                     NNEIB_EST_MAX,ABN%QHEAT(1:,ABN%NCONF),RMEM,STRESS_HELP,ABN%TIFOR_MB(1:,1:,ABN%NCONF),ABN%TOTEN_MB(ABN%NCONF), &
                     ABN%TSIF_MB(1:,1:,ABN%NCONF),ABN%VEL(:,:,ABN%NCONF), &
                     LNIONS_EST1,LNIONS_EST2,LNIONS_EST_MAX)
          ENDIF
!TEST
!          IF (ML_IO_WRITE) THEN
!            print *,"testing mode",FFM%NHYP2
!            WRITE(776,*) ABN%NCONF,ABN%TOTEN_MB(ABN%NCONF)
!            DO II=1,ABN%NIONS
!               DO JJ=1,3
!                  WRITE(777,*) ABN%NCONF,II,JJ,ABN%TIFOR_MB(JJ,II,ABN%NCONF)
!               ENDDO
!            ENDDO
!            DO II=1,3
!               DO JJ=1,3
!                  WRITE(778,*) ABN%NCONF,II,JJ,ABN%TSIF_MB(JJ,II,ABN%NCONF)
!               ENDDO
!            ENDDO
!         ENDIF
!            STOP
!TEST
! Bayesian error estimation
          IF (FF%IERR.GT.0) THEN
             IF (FF%IERR_COUNTER.EQ.FF%IERR) THEN
                CALL BAYES_ERR(ABN,PAR_SUP_HANDLE,FF,FFM, &
                           MROW_ENERGY_HELP,MROW_FORCE_HELP,MROW_STRESS_HELP,NCONF,NCONF_SYS,ABN%NIONS,ABN%NTYP, &
                           MCOL_MIONS,ENERGY_HELP,FORCE_HELP,RMEM_HELP1,STRESS_HELP,ABN%BE(1:,ABN%NCONF))
             ENDIF
          ENDIF
! Record dynamical memory usage
          RMEM=RMEM_HELP1+RMEM_HELP2
! Dallocate
          CALL DEALLOCATE_MB_ARRAY_MANYBODY
! Stop profiling
          PROFILING_STOP ('manybody')

          CONTAINS

! Allocate temporary arrays
          SUBROUTINE ALLOCATE_MB_ARRAY_MANYBODY
            IMPLICIT NONE
! Local variables
            INTEGER               :: INTYP
            INTEGER               :: INTYP0
! Initialize memory countor
            RMEM_HELP1=0.0_q
! Define array sizes.
! Set maximum number of basis sets
            NB_MAX=FFM%NB(1)
            DO INTYP0=2, FF%MTYP, 1
               NB_MAX=MAX(NB_MAX,FFM%NB(INTYP0))
            ENDDO
! Set column size of atomic index.
            MCOL_MIONS=CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Set sizes of arrays.
! Size of EATOM_HELP if necessary.
            IF(FFM%LEATOM.OR.FFM%LHEAT.OR.FFM%LCOUPLE) THEN
               MROW_EATOM=FFM%MB
               MCOL_EATOM=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ELSE
               MROW_EATOM=1
               MCOL_EATOM=1
            ENDIF
! Sizes for structural list.
            IF(.NOT.FFM%LSUPERVEC) THEN
               MROW_EST_MAX=1
               MCOL_EST_MAX=1
            ELSE
               MROW_EST_MAX=MNEIB_EST_MAX+1
               MCOL_EST_MAX=CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ENDIF
! Size of ENERGY_COUPLE_HELP
            IF(FFM%LCOUPLE) THEN
               MROW_ENERGY_COUPLE_HELP=MROW_ENERGY_HELP
               MCOL_ENERGY_COUPLE_HELP=MCOL_ENERGY_HELP
            ELSE
               MROW_ENERGY_COUPLE_HELP=1
               MCOL_ENERGY_COUPLE_HELP=1
            ENDIF
            IF(FFM%W1.GT.0.0_q) THEN
! Size of structural lists.
               MROW_EST1=MNEIB_EST1+1
               MCOL_EST1=CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of HEAT_HELP1 if necessary.
               IF(FFM%LHEAT) THEN
                  IF(.NOT.FFM%LSUPERVEC) THEN
                     MROW_HEAT1=MNEIB_EST1+1
                  ELSE
                     MROW_HEAT1=MNEIB_EST_MAX+1
                  ENDIF 
               ELSE
                  MROW_HEAT1=1
               ENDIF
            ELSE
               MROW_EST1=1
               MCOL_EST1=1
               MROW_HEAT1=1
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
! Size of structural lists.
               MROW_EST2=MNEIB_EST2+1
               MCOL_EST2=CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of HEAT_HELP2 if necessary.
               IF(FFM%LHEAT) THEN
                  IF(.NOT.FFM%LSUPERVEC) THEN
                     MROW_HEAT2=MNEIB_EST2+1
                  ELSE
                     MROW_HEAT2=MNEIB_EST_MAX+1
                  ENDIF
               ELSE
                  MROW_HEAT2=1
               ENDIF
            ELSE
               MROW_HEAT2=1
               MROW_EST2=1
               MCOL_EST2=1
            ENDIF
! Allocate arrays.
            IF(ALLOCATED(EATOM_HELP)) THEN
               DEALLOCATE(EATOM_HELP)
            ENDIF
            ALLOCATE(EATOM_HELP(1:MROW_EATOM,1:MCOL_EATOM,1:FF%MTYP_ALLOCATE))
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_EATOM,q)*REAL(MCOL_EATOM,q)*REAL(FF%MTYP,q)*8/1.0E6_q
            IF(ALLOCATED(ENERGY_COUPLE_HELP)) THEN
               DEALLOCATE(ENERGY_COUPLE_HELP)
            ENDIF
            ALLOCATE(ENERGY_COUPLE_HELP(1:MROW_ENERGY_COUPLE_HELP,1:MCOL_ENERGY_COUPLE_HELP,1:ABN%MTYP_ALLOCATE))
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_ENERGY_COUPLE_HELP,q)*REAL(MCOL_ENERGY_COUPLE_HELP,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E+06_q
            IF(ALLOCATED(HEAT_HELP1)) THEN
               DEALLOCATE(HEAT_HELP1)
            ENDIF
            ALLOCATE(HEAT_HELP1(1:MROW_HEAT1,1:FF%MTYP_ALLOCATE,1:MCOL_MIONS,1:3))
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_HEAT1,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FF%MTYP,q)*REAL(MCOL_MIONS,q)*3*8/1.0E6_q
            IF(ALLOCATED(HEAT_HELP2)) THEN
               DEALLOCATE(HEAT_HELP2)
            ENDIF
            ALLOCATE(HEAT_HELP2(1:MROW_HEAT2,1:FF%MTYP_ALLOCATE,1:MCOL_MIONS,1:3))
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_HEAT2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FF%MTYP,q)*REAL(MCOL_MIONS,q)*3*8/1.0E6_q

            RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST2,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST_MAX)) THEN
               DEALLOCATE(LNIONS_EST_MAX)
            ENDIF

            ALLOCATE (LNIONS_EST_MAX(1:MROW_EST_MAX,1:ABN%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            RMEM_HELP1=RMEM_HELP1+REAL(MROW_EST_MAX,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST_MAX,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST_MAX)) THEN
               DEALLOCATE(NNEIB_EST_MAX)
            ENDIF
            ALLOCATE (NNEIB_EST_MAX(1:ABN%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            RMEM_HELP1=RMEM_HELP1+REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST_MAX,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST_MAX)) THEN
               DEALLOCATE(XYZ_EST_MAX)
            ENDIF
            IF (FF%LFAST .AND. FF%IERR_COUNTER.NE.FF%IERR) THEN
               ALLOCATE (XYZ_EST_MAX(1:MROW_EST_MAX,1:3,1:ABN%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            ELSE
               ALLOCATE (XYZ_EST_MAX(1:3,1:MROW_EST_MAX,1:ABN%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            ENDIF
            RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST_MAX,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST_MAX,q)*8/1.0E+06_q
            IF(ALLOCATED(LHEAD)) THEN
               DEALLOCATE(LHEAD)
            ENDIF
            ALLOCATE(LHEAD(1:FF%MTYP_ALLOCATE))
            RMEM_HELP1=RMEM_HELP1+REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
          END SUBROUTINE ALLOCATE_MB_ARRAY_MANYBODY


          SUBROUTINE ALLOCATE_NEAREST_NEIGHBOR_MANYBODY

             IF(FFM%W1.GT.0.0_q) THEN
                MROW_EST1=MNEIB_EST1+1
                MCOL_EST1=CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                IF(FFM%LHEAT) THEN
                   IF(.NOT.FFM%LSUPERVEC) THEN
                      MROW_HEAT1=MNEIB_EST1+1
                   ELSE
                      MROW_HEAT1=MNEIB_EST_MAX+1
                   ENDIF                                               
                ELSE                                              
                   MROW_HEAT1=1
                ENDIF                                                 
             ELSE
                MROW_EST1=1
                MCOL_EST1=1                                             
                MROW_HEAT1=1                                  
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN                                   
                MROW_EST2=MNEIB_EST2+1                            
                MCOL_EST2=CEILING(REAL(ABN%MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                IF(FFM%LHEAT) THEN                                 
                   IF(.NOT.FFM%LSUPERVEC) THEN                             
                      MROW_HEAT2=MNEIB_EST2+1                    
                   ELSE                                               
                      MROW_HEAT2=MNEIB_EST_MAX+1
                   ENDIF
                ELSE                              
                   MROW_HEAT2=1
                ENDIF
             ELSE
                MROW_HEAT2=1
                MROW_EST2=1
                MCOL_EST2=1
             ENDIF

             IF(ALLOCATED(LNIONS_EST1)) THEN
                DEALLOCATE(LNIONS_EST1)
             ENDIF
             ALLOCATE (LNIONS_EST1(1:MROW_EST1,1:ABN%MTYP_ALLOCATE,1:MCOL_EST1))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_EST1,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)/1.0E+06_q
             IF(ALLOCATED(NNEIB_EST1)) THEN
                DEALLOCATE(NNEIB_EST1)
             ENDIF
             ALLOCATE (NNEIB_EST1(1:ABN%MTYP_ALLOCATE,1:MCOL_EST1))
             RMEM_HELP1=RMEM_HELP1+REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)/1.0E+06_q
             IF(ALLOCATED(XYZ_EST1)) THEN
                DEALLOCATE(XYZ_EST1)
             ENDIF
             IF (FF%LFAST .AND. FF%IERR_COUNTER.NE.FF%IERR) THEN
                ALLOCATE (XYZ_EST1(1:MROW_EST1,1:3,1:ABN%MTYP_ALLOCATE,1:MCOL_EST1))
             ELSE
                ALLOCATE (XYZ_EST1(1:3,1:MROW_EST1,1:ABN%MTYP_ALLOCATE,1:MCOL_EST1))
             ENDIF
             RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST1,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)*8/1.0E+06_q
             IF(ALLOCATED(XYZ_EST1_NORM)) THEN
                DEALLOCATE(XYZ_EST1_NORM)
             ENDIF
             ALLOCATE (XYZ_EST1_NORM(1:MROW_EST1,1:3,1:ABN%MTYP_ALLOCATE,1:MCOL_EST1))
             RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST1,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)*8/1.0E+06_q
             IF(ALLOCATED(NORMALIZATION_XYZ1)) THEN
                DEALLOCATE(NORMALIZATION_XYZ1)
             ENDIF
             ALLOCATE (NORMALIZATION_XYZ1(1:MROW_EST1,1:ABN%MTYP_ALLOCATE,1:MCOL_EST1))
             RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST1,q)*8/1.0E+06_q
             IF(ALLOCATED(LNIONS_EST2)) THEN
                DEALLOCATE(LNIONS_EST2)
             ENDIF
             ALLOCATE (LNIONS_EST2(1:MROW_EST2,1:ABN%MTYP_ALLOCATE,1:MCOL_EST2))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_EST2,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)/1.0E+06_q
             IF(ALLOCATED(NNEIB_EST2)) THEN
                DEALLOCATE(NNEIB_EST2)
             ENDIF
             ALLOCATE (NNEIB_EST2(1:ABN%MTYP_ALLOCATE,1:MCOL_EST2))
             RMEM_HELP1=RMEM_HELP1+REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)/1.0E+06_q
             IF(ALLOCATED(XYZ_EST2)) THEN
                DEALLOCATE(XYZ_EST2)
             ENDIF
             IF (FF%LFAST .AND. FF%IERR_COUNTER.NE.FF%IERR) THEN
                ALLOCATE (XYZ_EST2(1:MROW_EST2,1:3,1:ABN%MTYP_ALLOCATE,1:MCOL_EST2))
             ELSE
                ALLOCATE (XYZ_EST2(1:3,1:MROW_EST2,1:ABN%MTYP_ALLOCATE,1:MCOL_EST2))
             ENDIF
             RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST2,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)*8/1.0E+06_q
             IF(ALLOCATED(XYZ_EST2_NORM)) THEN
                DEALLOCATE(XYZ_EST2_NORM)
             ENDIF
             ALLOCATE (XYZ_EST2_NORM(1:MROW_EST2,1:3,1:ABN%MTYP_ALLOCATE,1:MCOL_EST2))
             RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST2,q)*REAL(ABN%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)*8/1.0E+06_q
             IF(ALLOCATED(NORMALIZATION_XYZ2)) THEN
                DEALLOCATE(NORMALIZATION_XYZ2)
             ENDIF
             ALLOCATE (NORMALIZATION_XYZ2(1:MROW_EST2,1:ABN%MTYP_ALLOCATE,1:MCOL_EST2))
             RMEM_HELP1=RMEM_HELP1+3*REAL(MROW_EST2,q)*8/1.0E+06_q

          END SUBROUTINE ALLOCATE_NEAREST_NEIGHBOR_MANYBODY

! Deallocate temporary arrays

          SUBROUTINE DEALLOCATE_MB_ARRAY_MANYBODY
            IMPLICIT NONE
            IF(ALLOCATED(ENERGY_COUPLE_HELP)) THEN
               DEALLOCATE(ENERGY_COUPLE_HELP)
            ENDIF
            IF(ALLOCATED(LHEAD)) THEN
               DEALLOCATE(LHEAD)
            ENDIF
            IF(ALLOCATED(EATOM_HELP)) THEN
               DEALLOCATE(EATOM_HELP)
            ENDIF
            IF(ALLOCATED(HEAT_HELP1)) THEN
               DEALLOCATE(HEAT_HELP1)
            ENDIF
            IF(ALLOCATED(HEAT_HELP2)) THEN
               DEALLOCATE(HEAT_HELP2)
            ENDIF
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            IF(ALLOCATED(LNIONS_EST_MAX)) THEN
               DEALLOCATE(LNIONS_EST_MAX)
            ENDIF
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            IF(ALLOCATED(NNEIB_EST_MAX)) THEN
               DEALLOCATE(NNEIB_EST_MAX)
            ENDIF
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            IF(ALLOCATED(XYZ_EST1_NORM)) THEN
               DEALLOCATE(XYZ_EST1_NORM)
            ENDIF
            IF(ALLOCATED(NORMALIZATION_XYZ1)) THEN
               DEALLOCATE(NORMALIZATION_XYZ1)
            ENDIF
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
            IF(ALLOCATED(XYZ_EST2_NORM)) THEN
               DEALLOCATE(XYZ_EST2_NORM)
            ENDIF
            IF(ALLOCATED(NORMALIZATION_XYZ2)) THEN
               DEALLOCATE(NORMALIZATION_XYZ2)
            ENDIF
            IF(ALLOCATED(XYZ_EST_MAX)) THEN
               DEALLOCATE(XYZ_EST_MAX)
            ENDIF
          END SUBROUTINE DEALLOCATE_MB_ARRAY_MANYBODY 

        END SUBROUTINE MANYBODY

!------------------------------------------------------------------------------------------------------------------
! Calculate design matrix and spilling factor on new configurations.
! This subroutine calculates design-matrix elements on the new configuration
! using radial and angular descriptors, FFM%C00_ALL and FFM%PS_ALL, owned by all processes.
!------------------------------------------------------------------------------------------------------------------
        SUBROUTINE FMAT_NEW_MB(AB,ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,LHEAD,LNIONS_EST1,LNIONS_EST2, &
                   LNIONS_EST_MAX,MCOL_EATOM, &
                   MNEIB_EST1,MNEIB_EST2,MNEIB_EST_MAX, &
                   MROW_C00,MROW_EATOM, &
                   MROW_EST1,MROW_EST2,MROW_EST_MAX, &
                   MROW_PS,NB_MAX,NNEIB_EST1,NNEIB_EST2,NNEIB_EST_MAX, &
                   XYZ_EST1,XYZ_EST2,XYZ_EST_MAX,C00,EATOM_HELP, &
                   ENERGY_COUPLE_HELP,ENERGY_HELP,FORCE_HELP,HEAT_HELP1,HEAT_HELP2,PS, &
                   RMEM_HELP1,RMEM_HELP2,STRESS_HELP)
        USE SOAP_KERNEL
        USE ML_FF_STRUCT, ONLY: ABINITIO, ABINITIONEW, PARALLEL_SUPER, ML_SHMEM, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input and output variables
          TYPE (ABINITIO)       :: AB
          TYPE (ABINITIONEW)    :: ABN
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: LNIONS_EST1(:,:,:) !(1:MROW_EST1,1:MTYP,1:MCOL_EST1)
          INTEGER, INTENT(IN)   :: LNIONS_EST2(:,:,:) !(1:MROW_EST2,1:MTYP,1:MCOL_EST2)
          INTEGER, INTENT(IN)   :: LNIONS_EST_MAX(:,:,:) !(1:MROW_EST_MAX,1:MTYP,1:MCOL_EST_MAX)
          INTEGER, INTENT(IN)   :: MCOL_EATOM
          INTEGER, INTENT(IN)   :: MNEIB_EST1
          INTEGER, INTENT(IN)   :: MNEIB_EST2
          INTEGER, INTENT(IN)   :: MNEIB_EST_MAX
          INTEGER, INTENT(IN)   :: MROW_C00
          INTEGER, INTENT(IN)   :: MROW_EATOM
          INTEGER, INTENT(IN)   :: MROW_EST1
          INTEGER, INTENT(IN)   :: MROW_EST2
          INTEGER, INTENT(IN)   :: MROW_EST_MAX
          INTEGER, INTENT(IN)   :: MROW_PS
          INTEGER, INTENT(IN)   :: NB_MAX  
          INTEGER, INTENT(IN)   :: NNEIB_EST1(:,:) !(1:MTYP,1:MCOL_EST1)
          INTEGER, INTENT(IN)   :: NNEIB_EST2(:,:) !(1:MTYP,1:MCOL_EST2)
          INTEGER, INTENT(IN)   :: NNEIB_EST_MAX(:,:) !(1:MTYP,1:MCOL_EST_MAX)
          REAL(q), INTENT(IN)   :: XYZ_EST1(:,:,:,:) !(1:3,1:MROW_EST1,1:MTYP,1:MCOL_EST1)
          REAL(q), INTENT(IN)   :: XYZ_EST2(:,:,:,:) !(1:3,1:MROW_EST2,1:MTYP,1:MCOL_EST2)
          REAL(q), INTENT(IN)   :: XYZ_EST_MAX(:,:,:,:) !(1:3,1:MROW_EST_MAX,1:MTYP,1:MCOL_EST_MAX)
          REAL(q), INTENT(INOUT)  :: C00(:,:,:) !(1:MROW_C00,1:MCOL_C00,1:MTYP)
          REAL(q), INTENT(INOUT)  :: EATOM_HELP(:,:,:) !(1:MROW_EATOM,1:MCOL_EATOM,1:FF%MTYP)
          REAL(q), INTENT(INOUT)  :: ENERGY_COUPLE_HELP(:,:,:) !(1:MROW_ENERGY_COUPLE_HELP,1:MCOL_ENERGY_COUPLE_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: ENERGY_HELP(:,:,:) !(1:MROW_ENERGY_HELP,1:MCOL_ENERGY_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: FORCE_HELP(:,:,:) !(1:MROW_FORCE_HELP,1:MCOL_FORCE_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: HEAT_HELP1(:,:,:,:) !(1:MROW_HEAT1,1:MCOL_HEAT1,1:FF%MTYP,1:MCOL_MIONS,1:3)
          REAL(q), INTENT(INOUT)  :: HEAT_HELP2(:,:,:,:) !(1:MROW_HEAT2,1:MCOL_HEAT2,1:FF%MTYP,1:MCOL_MIONS,1:3)
          INTEGER, INTENT(INOUT)  :: LHEAD(:) !(1:FF%MTYP)
          REAL(q), INTENT(INOUT)  :: PS(:,:,:) !(1:MROW_PS,1:MCOL_PS,1:MTYP)
          REAL(q), INTENT(INOUT)  :: RMEM_HELP1
          REAL(q), INTENT(INOUT)  :: RMEM_HELP2
          REAL(q), INTENT(INOUT)  :: STRESS_HELP(:,:,:) !(1:MROW_STRESS_HELP,1:MCOL_STRESS_HELP,1:MTYP)
! Local variables
          REAL(q), ALLOCATABLE  :: C00_COUPLE(:,:,:)                   !!(1:MROW_C00_COUPLE,1:MCOL_C00_COUPLE,1:MTYP)
          REAL(q), ALLOCATABLE  :: DC00(:,:,:,:)                       !!(1:MROW_DC00,1:MCOL_DC00,0:3,1:MTYP)
          REAL(q), ALLOCATABLE  :: DCLM1(:,:,:,:)                      !!(1:3,1:MROW_DCLM1,1:FF%MTYP,1:MCOL_DCLM1)
          REAL(q), ALLOCATABLE  :: DCLM2(:,:,:,:)                      !!(1:3,1:MROW_DCLM2,1:FF%MTYP,1:MCOL_DCLM2)
          REAL(q), ALLOCATABLE  :: DPS(:,:,:,:)                        !!(1:MROW_DPS,1:MCOL_DPS,0:3,1:MTYP)
          REAL(q), ALLOCATABLE  :: DPS_SIC(:,:,:,:)                    !!(1:MROW_DPS_SIC,1:MCOL_DPS_SIC,1:3,1:MTYP)
          REAL(q), ALLOCATABLE  :: DSOAP11(:,:)                        !!(1:MROW_DSOAP1,1:MCOL_DSOAP1)
          REAL(q), ALLOCATABLE  :: DSOAP12(:,:)                        !!(1:MROW_DSOAP2,1:MCOL_DSOAP2)
          REAL(q), ALLOCATABLE  :: DSOAP21(:,:,:)                      !!(1:MROW_DSOAP1,1:MCOL_DSOAP1,1:3)
          REAL(q), ALLOCATABLE  :: DSOAP22(:,:,:)                      !!(1:MROW_DSOAP2,1:MCOL_DSOAP2,1:3)
          REAL(q), ALLOCATABLE  :: PS_COUPLE(:,:,:)                    !!(1:MROW_PS_COUPLE,1:MCOL_PS_COUPLE,1:MTYP)
          REAL(q), ALLOCATABLE  :: RNORM_ALL(:,:)                      !!(1:MROW_RNORM_ALL,1:MCOL_RNORM_ALL)
          REAL(q), ALLOCATABLE  :: RNORM_C00(:,:)                      !!(1:MROW_RNORM_C00,1:MCOL_RNORM_C00)
          REAL(q), ALLOCATABLE  :: RNORM_PS(:,:)                       !!(1:MROW_RNORM_PS,1:MCOL_RNORM_PS)
          REAL(q), ALLOCATABLE  :: SOAP1(:,:)                          !!(1:MROW_SOAP,1:MCOL_SOAP)
          REAL(q), ALLOCATABLE  :: SOAP1_COUPLE(:,:)                   !!(1:MROW_SOAP_COUPLE,1:MCOL_SOAP_COUPLE)
          REAL(q), ALLOCATABLE  :: SOAP2(:,:)                          !!(1:MROW_SOAP,1:MCOL_SOAP)
          REAL(q), ALLOCATABLE  :: SOAP2_COUPLE(:,:)                   !!(1:MROW_SOAP_COUPLE,1:MCOL_SOAP_COUPLE)
          REAL(q), ALLOCATABLE  :: VEC_LOC_ENERGY(:,:)                 !!(1:MROW_VEC_LOC_ENERGY,1:MCOL_VEC_LOC_ENERGY)
          REAL(q), ALLOCATABLE  :: VEC_LOC_FORCE1(:,:)                 !!(1:MROW_VEC_LOC_FORCE1,1:MCOL_VEC_LOC_FORCE1)
          REAL(q), ALLOCATABLE  :: VEC_LOC_FORCE2(:,:)                 !!(1:MROW_VEC_LOC_FORCE2,1:MCOL_VEC_LOC_FORCE2)
          REAL(q), ALLOCATABLE  :: VEC_LOC_HEAT1(:,:)                  !!(1:MROW_VEC_LOC_HEAT1,1:MCOL_VEC_LOC_HEAT1)
          REAL(q), ALLOCATABLE  :: VEC_LOC_HEAT2(:,:)                  !!(1:MROW_VEC_LOC_HEAT2,1:MCOL_VEC_LOC_HEAT2)
          REAL(q), ALLOCATABLE  :: VEC_LOC_STRESS1(:,:)                !!(1:MROW_VEC_LOC_STRESS1,1:MCOL_VEC_LOC_STRESS1)
          REAL(q), ALLOCATABLE  :: VEC_LOC_STRESS2(:,:)                !!(1:MROW_VEC_LOC_STRESS2,1:MCOL_VEC_LOC_STRESS2)
          INTEGER               :: MCOL_C00_COUPLE
          INTEGER               :: MCOL_DC00
          INTEGER               :: MCOL_DCLM1
          INTEGER               :: MCOL_DCLM2
          INTEGER               :: MCOL_DPS
          INTEGER               :: MCOL_DPS_SIC
          INTEGER               :: MCOL_DSOAP1
          INTEGER               :: MCOL_DSOAP2
          INTEGER               :: MCOL_PS_COUPLE
          INTEGER               :: MCOL_RNORM_ALL
          INTEGER               :: MCOL_RNORM_C00
          INTEGER               :: MCOL_RNORM_PS
          INTEGER               :: MCOL_SOAP
          INTEGER               :: MCOL_SOAP_COUPLE
          INTEGER               :: MCOL_VEC_LOC_ENERGY
          INTEGER               :: MCOL_VEC_LOC_FORCE1
          INTEGER               :: MCOL_VEC_LOC_FORCE2
          INTEGER               :: MCOL_VEC_LOC_HEAT1
          INTEGER               :: MCOL_VEC_LOC_HEAT2
          INTEGER               :: MCOL_VEC_LOC_STRESS1
          INTEGER               :: MCOL_VEC_LOC_STRESS2
          INTEGER               :: MROW_CLM1  
          INTEGER               :: MROW_CLM2
          INTEGER               :: MROW_C00_COUPLE
          INTEGER               :: MROW_DC00
          INTEGER               :: MROW_DCLM1
          INTEGER               :: MROW_DCLM2
          INTEGER               :: MROW_DPS
          INTEGER               :: MROW_DPS_SIC
          INTEGER               :: MROW_DSOAP1
          INTEGER               :: MROW_DSOAP2
          INTEGER               :: MROW_PS_COUPLE
          INTEGER               :: MROW_RNORM_ALL
          INTEGER               :: MROW_RNORM_C00
          INTEGER               :: MROW_RNORM_PS
          INTEGER               :: MROW_SOAP
          INTEGER               :: MROW_SOAP_COUPLE
          INTEGER               :: MROW_VEC_LOC_ENERGY
          INTEGER               :: MROW_VEC_LOC_FORCE1
          INTEGER               :: MROW_VEC_LOC_FORCE2
          INTEGER               :: MROW_VEC_LOC_HEAT1
          INTEGER               :: MROW_VEC_LOC_HEAT2
          INTEGER               :: MROW_VEC_LOC_STRESS1
          INTEGER               :: MROW_VEC_LOC_STRESS2
          INTEGER               :: INITYP
          INTEGER               :: INITYP_TMP
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: KNIONS
          INTEGER               :: KNIONS_TMP
          INTEGER               :: KNTYP0
          INTEGER               :: NCOL_NITYP
          REAL(q)               :: RMEM_HELP3
          REAL(q)               :: TOTEN_ATOM_REF
!!TEST
!             INTEGER :: I1,I2,I3,I4
!!TEST
! Start profiling.
          PROFILING_START ('fmat_new_mb')
! Calculate array sizes for local arrays
          CALL CALCULATE_ARRAY_SIZES_FMAT_NEW_MB
! Allocate local arrays 
          CALL ALLOCATE_FMAT_NEW_MB
! Initialization of helping arrays.for non-fast-linear descriptors
          CALL INIT_FMAT_HELP_NEW_MB
! Initialization of expansion coefficients.
          CALL INIT_CLM_FMAT_NEW_MB
! Initialization of memory usage.
          RMEM_HELP2=0.0_q
! Make list for locations of beginings of basis sets in arrays.
! In this subroutine, this must be the same as FFM%LB(1,INTYP0)
          LHEAD=1
          DO INTYP0=2, FF%MTYP, 1
             LHEAD(INTYP0)=LHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
          ENDDO
! Initialization of SOAP matrices.
          CALL INIT_SOAP_FMAT_NEW_MB
! Calculate expansion coefficients.
          CALL D0CLM_FMAT_NEW_MB
! Calculate radial and angular descriptors.
          DO INTYP=1, ABN%NTYP ! Element loop
             INTYP0=ABN%LADD(INTYP)
! Set column size for atom index.
             NCOL_NITYP=0
             DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                   NCOL_NITYP=NCOL_NITYP+1
                ENDIF
             ENDDO
! Calculate 1-point correlation (radial) descriptor.
             CALL D0C00_FMAT_NEW_MB
! Calculate 2-points correlation (angular) descriptor.
             CALL D0PS_FMAT_NEW_MB
! Normalization.
             CALL NORMALIZATION_D0_FMAT_NEW_MB
! Calculate SOAP kernel.
             CALL SOAP_KERNEL_FMAT_NEW_MB
! Calculate energy components.
             CALL ENERGY_FMAT_NEW_MB
          ENDDO ! End of element loop.
! Calculations of force and stress tensor components.
          DO KNIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
             KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
             IF(KNIONS.LE.ABN%NIONS) THEN
                KNTYP0=ABN%LNTYP(KNIONS)
! Calculate derivatives of expansion coefficients DCLM.
                CALL D1CLM_FMAT_NEW_MB
! Calculate derivatives of radial descriptors DC00.
                CALL D1C00_FMAT_NEW_MB
! Calculate derivatives of angular descriptors DPS.
                CALL D1PS_FMAT_NEW_MB
! Normalization of derivatives.
                CALL NORMALIZATION_D1_FMAT_NEW_MB
! Calculations of design-matrix elements.
                DO INTYP=1, ABN%NTYP
                   INTYP0=ABN%LADD(INTYP)
! Calculate derivatives of SOAP similarity kernel DSOAP.
                   CALL DSOAP_KERNEL_FMAT_NEW_MB
! Calculate force and stress components in the design matrix.
                   CALL FORCE_AND_STRESS_FMAT_NEW_MB
                ENDDO ! End of element loop.
             ENDIF
          ENDDO ! End of atom loop.
! All-reduce the stress components.
          CALL ALLREDUCE_STRESS_FMAT_NEW_MB
! Deallocate local arrays
          CALL DEALLOCATE_FMAT_NEW_MB
! Stop profiling.
          PROFILING_STOP ('fmat_new_mb')

          CONTAINS

! Calculate sizes of local arrays
          SUBROUTINE CALCULATE_ARRAY_SIZES_FMAT_NEW_MB
             IMPLICIT NONE
! Sizes for structural list.
             IF(.NOT.FFM%LSUPERVEC) THEN
                MROW_RNORM_ALL=1
                MCOL_RNORM_ALL=ABN%MTYP
             ELSE
                MROW_RNORM_ALL=ABN%MITYP
                MCOL_RNORM_ALL=ABN%MTYP
             ENDIF
! Size of SOAP
             MROW_SOAP=FFM%MB
             MCOL_SOAP=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of SOAP_COUPLE
             IF(FFM%LCOUPLE) THEN
                MROW_SOAP_COUPLE=FFM%MB
                MCOL_SOAP_COUPLE=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
             ELSE
                MROW_SOAP_COUPLE=1
                MCOL_SOAP_COUPLE=1
             ENDIF
! Size of VEC_LOC_ENERGY
             MROW_VEC_LOC_ENERGY=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
             MCOL_VEC_LOC_ENERGY=1
! Radial descriptor
             IF(FFM%W1.GT.0.0_q) THEN
! Size of DC00.
                MROW_DC00=FFM%MMVAR1
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MCOL_DC00=MNEIB_EST1+1
                ELSE
                   MCOL_DC00=MNEIB_EST_MAX+1
                ENDIF
! Size of C00_COUPLE.
                IF(FFM%LCOUPLE) THEN
                   MROW_C00_COUPLE=FFM%MMVAR1
                   MCOL_C00_COUPLE=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                ELSE
                   MROW_C00_COUPLE=1
                   MCOL_C00_COUPLE=1
                ENDIF
! Size of CLM1 and DCLM1.
                MROW_CLM1=(FFM%LMAX1+1)**2*FF%MTYP_ALLOCATE*FFM%MRB1
                MROW_DCLM1=(FFM%LMAX1+1)**2*FF%MTYP_ALLOCATE*FFM%MRB1
                MCOL_DCLM1=MNEIB_EST1+1
! Size of DSOAP1.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_DSOAP1=MNEIB_EST1+1
                ELSE
                   MROW_DSOAP1=MNEIB_EST_MAX+1
                ENDIF
                MCOL_DSOAP1=FFM%MB
! Size of RNORM_C00
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_RNORM_C00=ABN%MITYP
                   MCOL_RNORM_C00=ABN%MTYP
                ELSE
                   MROW_RNORM_C00=1
                   MCOL_RNORM_C00=ABN%MTYP
                ENDIF
! Size of VEC_LOC_FORCE1.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_VEC_LOC_FORCE1=MNEIB_EST1+1
                ELSE
                   MROW_VEC_LOC_FORCE1=MNEIB_EST_MAX+1
                ENDIF
                MCOL_VEC_LOC_FORCE1=1
! Size of VEC_LOC_HEAT1.
                IF(FFM%LHEAT) THEN
                   IF(.NOT.FFM%LSUPERVEC) THEN
                      MROW_VEC_LOC_HEAT1=MNEIB_EST1+1
                   ELSE
                      MROW_VEC_LOC_HEAT1=MNEIB_EST_MAX+1
                   ENDIF
                   MCOL_VEC_LOC_HEAT1=1
                ELSE
                   MROW_VEC_LOC_HEAT1=1
                   MCOL_VEC_LOC_HEAT1=1
                ENDIF
! Size of VEC_LOC_STRESS1.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_VEC_LOC_STRESS1=MNEIB_EST1+1
                ELSE
                   MROW_VEC_LOC_STRESS1=MNEIB_EST_MAX+1
                ENDIF
                MCOL_VEC_LOC_STRESS1=1
             ELSE
                MROW_C00_COUPLE=1
                MCOL_C00_COUPLE=1
                MROW_CLM1=1
                MROW_DC00=1
                MCOL_DC00=1
                MROW_DCLM1=1
                MCOL_DCLM1=1
                MROW_DSOAP1=1
                MCOL_DSOAP1=1
                MROW_RNORM_C00=1
                MCOL_RNORM_C00=ABN%MTYP
                MROW_VEC_LOC_FORCE1=1
                MCOL_VEC_LOC_FORCE1=1
                MROW_VEC_LOC_HEAT1=1
                MCOL_VEC_LOC_HEAT1=1
                MROW_VEC_LOC_STRESS1=1
                MCOL_VEC_LOC_STRESS1=1
             ENDIF
! Angular descriptor
             IF(FFM%W2.GT.0.0_q) THEN
! Size of CLM2 and DCLM2.
                MROW_CLM2=(FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2
                MROW_DCLM2=(FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2
                MCOL_DCLM2=MNEIB_EST2+1
! Size of DPS.
                MROW_DPS=FFM%MMVAR2
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MCOL_DPS=(MNEIB_EST2+1)
                ELSE
                   MCOL_DPS=(MNEIB_EST_MAX+1)
                ENDIF
! Size of DPS_SIC.
                IF(FFM%LSIC) THEN
                   MROW_DPS_SIC=FFM%MMVAR2
                   MCOL_DPS_SIC=MNEIB_EST2+1
                ELSE
                   MROW_DPS_SIC=1
                   MCOL_DPS_SIC=1
                ENDIF
! Size of DSOAP2.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_DSOAP2=(MNEIB_EST2+1)
                ELSE
                   MROW_DSOAP2=(MNEIB_EST_MAX+1)
                ENDIF
                MCOL_DSOAP2=FFM%MB
! Size of PS_COUPLE.
                IF(FFM%LCOUPLE) THEN
                   MROW_PS_COUPLE=FFM%MMVAR2
                   MCOL_PS_COUPLE=CEILING(REAL(ABN%MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                ELSE
                   MROW_PS_COUPLE=1
                   MCOL_PS_COUPLE=1
                ENDIF
! Size of RNORM_PS
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_RNORM_PS=ABN%MITYP
                   MCOL_RNORM_PS=ABN%MTYP
                ELSE
                   MROW_RNORM_PS=1
                   MCOL_RNORM_PS=ABN%MTYP
                ENDIF
! Size of VEC_LOC_FORCE2.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_VEC_LOC_FORCE2=MNEIB_EST2+1
                ELSE
                   MROW_VEC_LOC_FORCE2=MNEIB_EST_MAX+1
                ENDIF
                MCOL_VEC_LOC_FORCE2=1
! Size of VEC_LOC_HEAT2.
                IF(FFM%LHEAT) THEN
                   IF(.NOT.FFM%LSUPERVEC) THEN
                      MROW_VEC_LOC_HEAT2=MNEIB_EST2+1
                   ELSE
                      MROW_VEC_LOC_HEAT2=MNEIB_EST_MAX+1
                   ENDIF
                   MCOL_VEC_LOC_HEAT2=1
                ELSE
                   MROW_VEC_LOC_HEAT2=1
                   MCOL_VEC_LOC_HEAT2=1
                ENDIF
! Size of VEC_LOC_STRESS2.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   MROW_VEC_LOC_STRESS2=MNEIB_EST2+1
                ELSE
                   MROW_VEC_LOC_STRESS2=MNEIB_EST_MAX+1
                ENDIF
                MCOL_VEC_LOC_STRESS2=1
             ELSE
                MROW_CLM2=1
                MROW_DCLM2=1
                MCOL_DCLM2=1
                MROW_DPS=1
                MCOL_DPS=1
                MROW_DPS_SIC=1
                MCOL_DPS_SIC=1
                MROW_DSOAP2=1
                MCOL_DSOAP2=1
                MROW_PS_COUPLE=1
                MCOL_PS_COUPLE=1
                MROW_RNORM_PS=1
                MCOL_RNORM_PS=ABN%MTYP
                MROW_VEC_LOC_FORCE2=1
                MCOL_VEC_LOC_FORCE2=1
                MROW_VEC_LOC_HEAT2=1
                MCOL_VEC_LOC_HEAT2=1
                MROW_VEC_LOC_STRESS2=1
                MCOL_VEC_LOC_STRESS2=1
             ENDIF
          END SUBROUTINE CALCULATE_ARRAY_SIZES_FMAT_NEW_MB

! Allocate arrays used locally in FMAT_NEW_MB
          SUBROUTINE ALLOCATE_FMAT_NEW_MB
             IMPLICIT NONE
             IF(ALLOCATED(C00_COUPLE)) THEN
                DEALLOCATE(C00_COUPLE)
             ENDIF
             ALLOCATE (C00_COUPLE(1:MROW_C00_COUPLE,1:MCOL_C00_COUPLE,1:ABN%MTYP_ALLOCATE)) 
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_C00_COUPLE,q)*REAL(MCOL_C00_COUPLE,q)*REAL(ABN%MTYP_ALLOCATE,q)*8/1.0E6_q
             IF(ALLOCATED(DC00)) THEN
                DEALLOCATE(DC00)
             ENDIF
             ALLOCATE (DC00(1:MROW_DC00,1:MCOL_DC00,0:3,1:ABN%MTYP_ALLOCATE))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DC00,q)*REAL(MCOL_DC00,q)*REAL(ABN%MTYP_ALLOCATE,q)*4*8/1.0E6_q
             IF(ALLOCATED(DCLM1)) THEN
                DEALLOCATE(DCLM1)
             ENDIF
             ALLOCATE(DCLM1(1:3,1:MROW_DCLM1,1:FF%MTYP_ALLOCATE,1:MCOL_DCLM1))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DCLM2,q)*REAL(MCOL_DCLM2,q)*REAL(FF%MTYP_ALLOCATE,q)*3*8/1.0E+06_q
             IF(ALLOCATED(DCLM2)) THEN
                DEALLOCATE(DCLM2)
             ENDIF
             ALLOCATE(DCLM2(1:3,1:MROW_DCLM2,1:FF%MTYP_ALLOCATE,1:MCOL_DCLM2))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DCLM2,q)*REAL(MCOL_DCLM2,q)*REAL(FF%MTYP_ALLOCATE,q)*3*8/1.0E+06_q
             IF(ALLOCATED(DPS)) THEN
                DEALLOCATE(DPS)
             ENDIF
             ALLOCATE (DPS(1:MROW_DPS,1:MCOL_DPS,0:3,1:ABN%MTYP_ALLOCATE))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DPS,q)*REAL(MCOL_DPS,q)*REAL(ABN%MTYP_ALLOCATE,q)*4*8/1.0E+06_q
             IF(ALLOCATED(DPS_SIC)) THEN
                DEALLOCATE(DPS_SIC)
             ENDIF
             ALLOCATE (DPS_SIC(1:MROW_DPS_SIC,1:MCOL_DPS_SIC,1:3,1:ABN%MTYP_ALLOCATE))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DPS_SIC,q)*REAL(MCOL_DPS_SIC,q)*REAL(ABN%MTYP_ALLOCATE,q)*3*8/1.0E+06_q
             IF(ALLOCATED(DSOAP11)) THEN
                DEALLOCATE(DSOAP11)
             ENDIF
             ALLOCATE (DSOAP11(1:MROW_DSOAP1,1:MCOL_DSOAP1))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DSOAP1,q)*REAL(MCOL_DSOAP1,q)*8/1.0E6_q
             IF(ALLOCATED(DSOAP21)) THEN
                DEALLOCATE(DSOAP21)
             ENDIF
             ALLOCATE (DSOAP21(1:MROW_DSOAP1,1:MCOL_DSOAP1,1:3))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DSOAP1,q)*REAL(MCOL_DSOAP1,q)*3*8/1.0E6_q
             IF(ALLOCATED(DSOAP12)) THEN
                DEALLOCATE(DSOAP12)
             ENDIF
             ALLOCATE (DSOAP12(1:MROW_DSOAP2,1:MCOL_DSOAP2))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DSOAP2,q)*REAL(MCOL_DSOAP2,q)*8/1.0E+06_q
             IF(ALLOCATED(DSOAP22)) THEN
                DEALLOCATE(DSOAP22)
             ENDIF
             ALLOCATE (DSOAP22(1:MROW_DSOAP2,1:MCOL_DSOAP2,1:3))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_DSOAP2,q)*REAL(MCOL_DSOAP2,q)*3*8/1.0E+06_q
             IF (ALLOCATED(PS_COUPLE)) THEN
                DEALLOCATE(PS_COUPLE)
             ENDIF
             ALLOCATE(PS_COUPLE(1:MROW_PS_COUPLE,1:MCOL_PS_COUPLE,1:ABN%MTYP_ALLOCATE))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_PS_COUPLE,q)*REAL(MCOL_PS_COUPLE,q)*REAL(ABN%MTYP_ALLOCATE,q)*4*8/1.0E6_q
             IF(ALLOCATED(RNORM_ALL)) THEN
                DEALLOCATE(RNORM_ALL)
             ENDIF
             ALLOCATE (RNORM_ALL(1:MROW_RNORM_ALL,1:MCOL_RNORM_ALL))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_RNORM_ALL,q)*REAL(MCOL_RNORM_ALL,q)*8/1.0E6_q
             IF(ALLOCATED(RNORM_C00)) THEN
                DEALLOCATE(RNORM_C00)
             ENDIF
             ALLOCATE (RNORM_C00(1:MROW_RNORM_C00,1:MCOL_RNORM_C00))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_RNORM_C00,q)*REAL(MCOL_RNORM_C00,q)*8/1.0E6_q
             IF(ALLOCATED(RNORM_PS)) THEN
                DEALLOCATE(RNORM_PS)
             ENDIF
             ALLOCATE (RNORM_PS(1:MROW_RNORM_PS,1:MCOL_RNORM_PS))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_RNORM_PS,q)*REAL(MCOL_RNORM_PS,q)*8/1.0E6_q
             IF(ALLOCATED(SOAP1)) THEN
                DEALLOCATE(SOAP1)
             ENDIF
             ALLOCATE (SOAP1(1:MROW_SOAP,1:MCOL_SOAP))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
             IF(ALLOCATED(SOAP2)) THEN
                DEALLOCATE(SOAP2)
             ENDIF
             ALLOCATE (SOAP2(1:MROW_SOAP,1:MCOL_SOAP))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
             IF(ALLOCATED(SOAP1_COUPLE)) THEN
                DEALLOCATE(SOAP1_COUPLE)
             ENDIF
             ALLOCATE (SOAP1_COUPLE(1:MROW_SOAP_COUPLE,1:MCOL_SOAP_COUPLE))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_SOAP_COUPLE,q)*REAL(MCOL_SOAP_COUPLE,q)*8/1.0E+06_q
             IF(ALLOCATED(SOAP2_COUPLE)) THEN
                DEALLOCATE(SOAP2_COUPLE)
             ENDIF
             ALLOCATE (SOAP2_COUPLE(1:MROW_SOAP_COUPLE,1:MCOL_SOAP_COUPLE))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_SOAP_COUPLE,q)*REAL(MCOL_SOAP_COUPLE,q)*8/1.0E+06_q
             IF(ALLOCATED(VEC_LOC_FORCE1)) THEN
                DEALLOCATE(VEC_LOC_FORCE1)
             ENDIF
             ALLOCATE (VEC_LOC_FORCE1(1:MROW_VEC_LOC_FORCE1,1:MCOL_VEC_LOC_FORCE1))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_FORCE1,q)*REAL(MCOL_VEC_LOC_FORCE1,q)*8/1.0E6_q
             VEC_LOC_FORCE1=0.0_q
             IF(ALLOCATED(VEC_LOC_HEAT1)) THEN
                DEALLOCATE(VEC_LOC_HEAT1)
             ENDIF
             ALLOCATE (VEC_LOC_HEAT1(1:MROW_VEC_LOC_HEAT1,1:MCOL_VEC_LOC_HEAT1))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_HEAT1,q)*REAL(MCOL_VEC_LOC_HEAT1,q)*8/1.0E6_q
             VEC_LOC_HEAT1=0.0_q
             IF(ALLOCATED(VEC_LOC_STRESS1)) THEN
                DEALLOCATE(VEC_LOC_STRESS1)
             ENDIF
             ALLOCATE (VEC_LOC_STRESS1(1:MROW_VEC_LOC_STRESS1,1:MCOL_VEC_LOC_STRESS1))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_STRESS1,q)*REAL(MCOL_VEC_LOC_STRESS1,q)*8/1.0E6_q
             VEC_LOC_STRESS1=0.0_q
             IF(ALLOCATED(VEC_LOC_FORCE2)) THEN
                DEALLOCATE(VEC_LOC_FORCE2)
             ENDIF
             ALLOCATE (VEC_LOC_FORCE2(1:MROW_VEC_LOC_FORCE2,1:MCOL_VEC_LOC_FORCE2))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_FORCE2,q)*REAL(MCOL_VEC_LOC_FORCE2,q)*8/1.0E+06_q
             VEC_LOC_FORCE2=0.0_q
             IF(ALLOCATED(VEC_LOC_HEAT2)) THEN
                DEALLOCATE(VEC_LOC_HEAT2)
             ENDIF
             ALLOCATE (VEC_LOC_HEAT2(1:MROW_VEC_LOC_HEAT2,1:MCOL_VEC_LOC_HEAT2))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_HEAT2,q)*REAL(MCOL_VEC_LOC_HEAT2,q)*8/1.0E+06_q
             VEC_LOC_HEAT2=0.0_q
             IF(ALLOCATED(VEC_LOC_STRESS2)) THEN
                DEALLOCATE(VEC_LOC_STRESS2)
             ENDIF
             ALLOCATE (VEC_LOC_STRESS2(1:MROW_VEC_LOC_STRESS2,1:MCOL_VEC_LOC_STRESS2))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_STRESS2,q)*REAL(MCOL_VEC_LOC_STRESS2,q)*8/1.0E+06_q
             VEC_LOC_STRESS2=0.0_q
             IF(ALLOCATED(VEC_LOC_ENERGY)) THEN
                DEALLOCATE(VEC_LOC_ENERGY)
             ENDIF
             ALLOCATE (VEC_LOC_ENERGY(1:MROW_VEC_LOC_ENERGY,1:MCOL_VEC_LOC_ENERGY))
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_VEC_LOC_ENERGY,q)*REAL(MCOL_VEC_LOC_ENERGY,q)*8/1.0E+06_q
             VEC_LOC_ENERGY=0.0_q
          END SUBROUTINE ALLOCATE_FMAT_NEW_MB

! Deallocate neccessary arrays for FMAT_NEW_MB
          SUBROUTINE DEALLOCATE_FMAT_NEW_MB
             IMPLICIT NONE
             IF(ALLOCATED(C00_COUPLE)) THEN
                DEALLOCATE(C00_COUPLE)
             ENDIF
             IF(ALLOCATED(DC00)) THEN
                DEALLOCATE(DC00)
             ENDIF
             IF(ALLOCATED(DCLM1)) THEN
                DEALLOCATE(DCLM1)
             ENDIF
             IF(ALLOCATED(DCLM2)) THEN
                DEALLOCATE(DCLM2)
             ENDIF
             IF(ALLOCATED(DPS)) THEN
                DEALLOCATE(DPS)
             ENDIF
             IF(ALLOCATED(DPS_SIC)) THEN
                DEALLOCATE(DPS_SIC)
             ENDIF
             IF(ALLOCATED(PS_COUPLE)) THEN
                DEALLOCATE(PS_COUPLE)
             ENDIF
             IF(ALLOCATED(RNORM_ALL)) THEN
                DEALLOCATE(RNORM_ALL)
             ENDIF
             IF(ALLOCATED(RNORM_C00)) THEN
                DEALLOCATE(RNORM_C00)
             ENDIF
             IF(ALLOCATED(RNORM_PS)) THEN
                DEALLOCATE(RNORM_PS)
             ENDIF
             IF(ALLOCATED(DSOAP11)) THEN
                DEALLOCATE(DSOAP11)
             ENDIF
             IF(ALLOCATED(DSOAP12)) THEN
                DEALLOCATE(DSOAP12)
             ENDIF
             IF(ALLOCATED(DSOAP21)) THEN
                DEALLOCATE(DSOAP21)
             ENDIF
             IF(ALLOCATED(DSOAP22)) THEN
                DEALLOCATE(DSOAP22)
             ENDIF
             IF(ALLOCATED(SOAP1)) THEN
                DEALLOCATE(SOAP1)
             ENDIF
             IF(ALLOCATED(SOAP2)) THEN
                DEALLOCATE(SOAP2)
             ENDIF
             IF(ALLOCATED(SOAP1_COUPLE)) THEN
                DEALLOCATE(SOAP1_COUPLE)
             ENDIF
             IF(ALLOCATED(SOAP2_COUPLE)) THEN
                DEALLOCATE(SOAP2_COUPLE)
             ENDIF
             IF(ALLOCATED(VEC_LOC_ENERGY)) THEN
                DEALLOCATE(VEC_LOC_ENERGY)
             ENDIF
             IF(ALLOCATED(VEC_LOC_FORCE1)) THEN
                DEALLOCATE(VEC_LOC_FORCE1)
             ENDIF
             IF(ALLOCATED(VEC_LOC_FORCE2)) THEN
                DEALLOCATE(VEC_LOC_FORCE2)
             ENDIF
             IF(ALLOCATED(VEC_LOC_HEAT1)) THEN
                DEALLOCATE(VEC_LOC_HEAT1)
             ENDIF
             IF(ALLOCATED(VEC_LOC_HEAT2)) THEN
                DEALLOCATE(VEC_LOC_HEAT2)
             ENDIF
             IF(ALLOCATED(VEC_LOC_STRESS1)) THEN
                DEALLOCATE(VEC_LOC_STRESS1)
             ENDIF
             IF(ALLOCATED(VEC_LOC_STRESS2)) THEN
                DEALLOCATE(VEC_LOC_STRESS2)
             ENDIF
          END SUBROUTINE DEALLOCATE_FMAT_NEW_MB

! Subroutine to initialize helping design-matrix arrays.
          SUBROUTINE INIT_FMAT_HELP_NEW_MB
             IMPLICIT NONE
! Initialization of energy components.
             ENERGY_HELP=0.0_q
             IF(FFM%LCOUPLE) THEN
                ENERGY_COUPLE_HELP=0.0_q
             ENDIF
! Initialization of force components.
             FORCE_HELP=0.0_q
! Initialization of heat components, if necessary.
             IF(FFM%LHEAT) THEN
                IF(FFM%W1.GT.0.0_q) THEN
                   HEAT_HELP1=0.0_q
                ENDIF
                IF(FFM%W2.GT.0.0_q) THEN
                   HEAT_HELP2=0.0_q
                ENDIF
             ENDIF
! Initialization of stress components.
             STRESS_HELP=0.0_q
          END SUBROUTINE INIT_FMAT_HELP_NEW_MB

! Subroutine to initialize the expansion coefficients CLM.
          SUBROUTINE INIT_CLM_FMAT_NEW_MB
             IMPLICIT NONE
! Local Variables
             INTEGER               :: IERR
             IF(FFM%W1.GT.0.0_q) THEN
                MLSHM%CLM1(1:MROW_CLM1,1:ABN%NIONS)=0.0_q
                IF(FFM%LCOUPLE) THEN
                   MLSHM%CLM_COUPLE_HELP1_MANYBODY(1:MROW_CLM1,1:ABN%NIONS)=0.0_q
                ENDIF
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                MLSHM%CLM2(1:MROW_CLM2,1:ABN%NIONS)=0.0_q
                IF(FFM%LCOUPLE) THEN
                   MLSHM%CLM_COUPLE_HELP2_MANYBODY(1:MROW_CLM2,1:ABN%NIONS)=0.0_q
                ENDIF
                IF(FFM%LSIC) THEN
                   MLSHM%PS_SIC(1:FFM%MMVAR2_SIC,1:ABN%NIONS)=0.0_q
                   IF(FFM%LCOUPLE) THEN
                      MLSHM%PS_SIC_COUPLE(1:FFM%MMVAR2_SIC,1:ABN%NIONS)=0.0_q
                   ENDIF
                ENDIF
             ENDIF
#ifdef use_shmem
             CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
          END SUBROUTINE INIT_CLM_FMAT_NEW_MB

! Subroutine to initialize SOAP matrices.
          SUBROUTINE INIT_SOAP_FMAT_NEW_MB
             IMPLICIT NONE
             INTEGER    :: IB
             INTEGER    :: IERR
             IF(.NOT.FFM%LSUPERVEC) THEN
                IF(FFM%W1.GT.0.0_q) THEN
                   DO IB=1, NB_MAX
                      MLSHM%SOAP_C00(1:ABN%NIONS,IB)=0.0_q
                   ENDDO
                ENDIF
                IF(FFM%W2.GT.0.0_q) THEN
                   DO IB=1, NB_MAX
                      MLSHM%SOAP_PS(1:ABN%NIONS,IB)=0.0_q
                   ENDDO
                ENDIF
             ELSE
                DO IB=1, NB_MAX
                   MLSHM%SOAP_ALL(1:ABN%NIONS,IB)=0.0_q
                ENDDO
             ENDIF
#ifdef use_shmem
             CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
          END SUBROUTINE INIT_SOAP_FMAT_NEW_MB

! Subroutine to calculate the expansion coefficients CLM.
          SUBROUTINE D0CLM_FMAT_NEW_MB
             IMPLICIT NONE
! Local variables
             INTEGER               :: IERR
             INTEGER               :: INIONS
             INTEGER               :: INIONS_TMP
             INTEGER               :: INTYP0
             INTEGER               :: LOCVAR_COL
             INTEGER               :: LOCVAR_COL_CLM1
             INTEGER               :: LOCVAR_COL_CLM1_COUPLE
             INTEGER               :: LOCVAR_COL_CLM2
             INTEGER               :: LOCVAR_COL_CLM2_COUPLE
             INTEGER               :: LOCVAR_COL_EST1
             INTEGER               :: LOCVAR_COL_EST2
             INTEGER               :: LOCVAR_COL_PS
             INTEGER               :: LOCVAR_COL_PS_SIC
             INTEGER               :: LOCVAR_COL_PS_SIC_COUPLE
! MPI-parallel
             PROFILING_START('d0clm_soap_fmat_new_mb')
             DO INIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                IF(INIONS.LE.ABN%NIONS) THEN
                   INTYP0=ABN%LNTYP(INIONS)
                   IF(FFM%W1.GT.0.0_q) THEN
                      LOCVAR_COL_CLM1=INIONS
                      LOCVAR_COL_EST1=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                      IF(FFM%LCOUPLE) THEN
                         LOCVAR_COL_CLM1_COUPLE=INIONS
                      ELSE
                         LOCVAR_COL_CLM1_COUPLE=1
                      ENDIF
                      LOCVAR_COL_PS_SIC=1
                      LOCVAR_COL_PS_SIC_COUPLE=1
                      CALL D0CLM_SOAP (MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE),FFM%DRSPL1,FFM%FNL1,FFM%FWIN1, &
                           INTYP0,ABN%LADD(1:),FFM%LCOUPLE,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1), &
                           .FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                           FF%MIONS,MROW_EST1,FFM%MRB1,FFM%MSPL1,ABN%MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                           NNEIB_EST1(1:,LOCVAR_COL_EST1),FFM%NRB1(0:),FFM%NSPL1,ABN%NTYP, &
                           MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_HELP3,XYZ_EST1(1:,1:,1:,LOCVAR_COL_EST1))
                      RMEM_HELP2=MAX(RMEM_HELP2,RMEM_HELP3)
                   ENDIF
                   IF(FFM%W2.GT.0.0_q) THEN
                      LOCVAR_COL_CLM2=INIONS
                      LOCVAR_COL_EST2=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                      IF(FFM%LCOUPLE) THEN
                         LOCVAR_COL_CLM2_COUPLE=INIONS
                      ELSE
                         LOCVAR_COL_CLM2_COUPLE=1
                      ENDIF
                      IF(FFM%LSIC) THEN
                         LOCVAR_COL_PS_SIC=INIONS
                         IF(FFM%LCOUPLE) THEN
                            LOCVAR_COL_PS_SIC_COUPLE=INIONS
                         ELSE
                            LOCVAR_COL_PS_SIC_COUPLE=1
                         ENDIF
                      ELSE
                         LOCVAR_COL_PS_SIC=1
                         LOCVAR_COL_PS_SIC_COUPLE=1
                      ENDIF
                      CALL D0CLM_SOAP (MLSHM%CLM2(:,LOCVAR_COL_CLM2),MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE),FFM%DRSPL2,FFM%FNL2,FFM%FWIN2, &
                           INTYP0,ABN%LADD(1:),FFM%LCOUPLE,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX2,LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                           FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW2, &
                           FF%MIONS,MROW_EST2,FFM%MRB2,FFM%MSPL2,ABN%MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                           NNEIB_EST2(1:,LOCVAR_COL_EST2),FFM%NRB2(0:),FFM%NSPL2,ABN%NTYP, &
                           MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_HELP3,XYZ_EST2(1:,1:,1:,LOCVAR_COL_EST2))
                      RMEM_HELP2=MAX(RMEM_HELP2,RMEM_HELP3)
                   ENDIF
                ENDIF
             ENDDO
#ifdef use_shmem
             CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
             PROFILING_STOP('d0clm_soap_fmat_new_mb')
! All reduce CLM.
             PROFILING_START ('allred_clm_fmat_new_mb')
#ifdef use_shmem
             IF(FFM%W1.GT.0.0_q) THEN
                IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM1,MLSHM%MROW_CLM1_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM, &
                        PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                ENDIF
                IF(FFM%LCOUPLE) THEN
                   IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM_COUPLE_HELP1_MANYBODY,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY*ABN%NIONS,MPI_REAL8,MPI_SUM, &
                           PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                   ENDIF
                ENDIF
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                IF(PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM2,MLSHM%MROW_CLM2_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM, &
                        PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                   IF(FFM%LSIC) THEN
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC,MLSHM%MROW_PS_SIC_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM, &
                           PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                   ENDIF
                ENDIF
                IF(FFM%LCOUPLE) THEN
                   IF(PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM_COUPLE_HELP2_MANYBODY,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY*ABN%NIONS,MPI_REAL8,MPI_SUM, &
                           PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                      IF(FFM%LSIC) THEN
                         CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC_COUPLE,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM, &
                              PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                      ENDIF
                   ENDIF
                ENDIF
             ENDIF
             CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
             IF(FFM%W1.GT.0.0_q) THEN
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM1,MLSHM%MROW_CLM1_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                IF(FFM%LCOUPLE) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM_COUPLE_HELP1_MANYBODY,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                ENDIF
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM2,MLSHM%MROW_CLM2_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                IF(FFM%LSIC) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC,MLSHM%MROW_PS_SIC_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                ENDIF
                IF(FFM%LCOUPLE) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM_COUPLE_HELP2_MANYBODY,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                   IF(FFM%LSIC) THEN
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC_COUPLE,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                   ENDIF
                ENDIF
             ENDIF
#endif
             PROFILING_STOP ('allred_clm_fmat_new_mb')
          END SUBROUTINE D0CLM_FMAT_NEW_MB

! Calculate radial descriptors within the fast version method.
          SUBROUTINE D0C00_FMAT_NEW_MB
             IMPLICIT NONE
! Local variables
             INTEGER               :: INIONS
             INTEGER               :: INITYP
             INTEGER               :: INITYP_TMP
             INTEGER               :: LOCVAR_COL
             INTEGER               :: LOCVAR_COL_C00
             INTEGER               :: LOCVAR_COL_C00_COUPLE
             INTEGER               :: LOCVAR_COL_CLM1
             INTEGER               :: LOCVAR_COL_CLM1_COUPLE
             IF(FFM%W1.GT.0.0_q) THEN
! MPI-parallel over INITYP loop.
                PROFILING_START('d0c00_soap_fmat_new_mb')
                DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                   INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                      INIONS=ABN%LNIONS(INITYP,INTYP0)
                      LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                      LOCVAR_COL_CLM1=INIONS
                      IF(FFM%LCOUPLE) THEN
                         LOCVAR_COL_C00_COUPLE=LOCVAR_COL_C00
                         LOCVAR_COL_CLM1_COUPLE=INIONS
                      ELSE
                         LOCVAR_COL_C00_COUPLE=1
                         LOCVAR_COL_CLM1_COUPLE=1
                      ENDIF
                      CALL D0C00_SOAP (C00(1:,LOCVAR_COL_C00,INTYP0),C00_COUPLE(1:,LOCVAR_COL_C00_COUPLE,INTYP0), &
                           MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE), &
                           ABN%LADD(1:),FFM%LCOUPLE,FFM%LMAX1,FFM%LNORM1, &
                           MROW_C00,MROW_C00_COUPLE,FFM%MRB1,ABN%MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY,FFM%NRB1(0:),ABN%NTYP)
                   ENDIF
                ENDDO
                PROFILING_STOP('d0c00_soap_fmat_new_mb')
             ENDIF
          END SUBROUTINE D0C00_FMAT_NEW_MB

! Calculate angular descriptor within the fast version method.
          SUBROUTINE D0PS_FMAT_NEW_MB
             IMPLICIT NONE
! Local variables
             INTEGER               :: INIONS
             INTEGER               :: INITYP
             INTEGER               :: INITYP_TMP
             INTEGER               :: LOCVAR_COL
             INTEGER               :: LOCVAR_COL_CLM2
             INTEGER               :: LOCVAR_COL_CLM2_COUPLE
             INTEGER               :: LOCVAR_COL_PS
             INTEGER               :: LOCVAR_COL_PS_COUPLE
             INTEGER               :: LOCVAR_COL_PS_SIC
             INTEGER               :: LOCVAR_COL_PS_SIC_COUPLE
             IF(FFM%W2.GT.0.0_q) THEN
                PROFILING_START('d0ps_soap_fmat_new_mb')
! MPI-parallel.
                DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                   INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                      INIONS=ABN%LNIONS(INITYP,INTYP0)
                      LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                      LOCVAR_COL_CLM2=INIONS
                      IF(FFM%LCOUPLE) THEN
                         LOCVAR_COL_CLM2_COUPLE=INIONS
                         LOCVAR_COL_PS_COUPLE=LOCVAR_COL_PS
                      ELSE
                         LOCVAR_COL_PS_COUPLE=1
                         LOCVAR_COL_CLM2_COUPLE=1
                      ENDIF
                      IF(FFM%LSIC) THEN
                         LOCVAR_COL_PS_SIC=INIONS
                         IF(FFM%LCOUPLE) THEN
                            LOCVAR_COL_PS_SIC_COUPLE=INIONS
                         ELSE
                            LOCVAR_COL_PS_SIC_COUPLE=1
                         ENDIF
                      ELSE
                         LOCVAR_COL_PS_SIC=1
                         LOCVAR_COL_PS_SIC_COUPLE=1
                      ENDIF
!                      CALL D0PS_SOAP (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                      CALL SELECTOR_D0PS (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                           MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE), &
                           FFM%DESC_TYPE,FFM%IAFILT2, &
                           INTYP0,FFM%LAFILT2,ABN%LADD(1:),FFM%LCOUPLE,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%L_LNRB2, &
                           FFM%LMAX2,FFM%LNORM2,FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                           FFM%MLNRB2,MROW_PS,MROW_PS_COUPLE,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                           FFM%MRB2,ABN%MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY, &
                           FFM%NLNRB2,FFM%NRB2(0:),FFM%NRB_LNRB2,ABN%NTYP, &
                           PS(1:,LOCVAR_COL_PS,INTYP0),PS_COUPLE(1:,LOCVAR_COL_PS_COUPLE,INTYP0), &
                           MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%WVAR)
                   ENDIF
                ENDDO
                PROFILING_STOP('d0ps_soap_fmat_new_mb')
             ENDIF
          END SUBROUTINE D0PS_FMAT_NEW_MB

! Normalization.
          SUBROUTINE NORMALIZATION_D0_FMAT_NEW_MB
             IMPLICIT NONE
! Local variables
             INTEGER               :: IERR
             INTEGER               :: INIONS
             INTEGER               :: INITYP
             INTEGER               :: INITYP_TMP
             INTEGER               :: LOCVAR_COL
             INTEGER               :: LOCVAR_COL_C00
             INTEGER               :: LOCVAR_COL_C00_COUPLE
             INTEGER               :: LOCVAR_COL_PS
             INTEGER               :: LOCVAR_COL_PS_COUPLE
             INTEGER               :: LOCVAR_COL_RNORM_ALL
             INTEGER               :: LOCVAR_COL_RNORM_C00
             INTEGER               :: LOCVAR_COL_RNORM_PS
             INTEGER               :: I1
             PROFILING_START('normalization_d0_fmat_new_mb')
! Initialization of norm.
             IF(.NOT.FFM%LSUPERVEC) THEN
                IF(FFM%W1.GT.0.0_q) THEN
                   RNORM_C00(1:ABN%NITYP(INTYP0),INTYP0)=0.0_q
                ENDIF
                IF(FFM%W2.GT.0.0_q) THEN
                   RNORM_PS(1:ABN%NITYP(INTYP0),INTYP0)=0.0_q
                ENDIF
             ELSE
                RNORM_ALL(1:ABN%NITYP(INTYP0),INTYP0)=0.0_q
             ENDIF
             DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                   LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                   INIONS=ABN%LNIONS(INITYP,INTYP0)
                   IF(.NOT.FFM%LSUPERVEC) THEN
                      IF(FFM%W1.GT.0.0_q) THEN
                         LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         LOCVAR_COL_RNORM_C00=INITYP
                         IF(FFM%LCOUPLE) THEN
                            LOCVAR_COL_C00_COUPLE=LOCVAR_COL_C00
                         ELSE
                            LOCVAR_COL_C00_COUPLE=1
                         ENDIF
                      ELSE
                         LOCVAR_COL_C00=1
                         LOCVAR_COL_C00_COUPLE=1
                         LOCVAR_COL_RNORM_C00=1
                      ENDIF
                      IF(FFM%W2.GT.0.0_q) THEN
                         LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         LOCVAR_COL_RNORM_PS=INITYP
                         IF(FFM%LCOUPLE) THEN
                            LOCVAR_COL_PS_COUPLE=LOCVAR_COL_PS
                         ELSE
                            LOCVAR_COL_PS_COUPLE=1
                         ENDIF
                      ELSE
                         LOCVAR_COL_PS=1
                         LOCVAR_COL_PS_COUPLE=1
                         LOCVAR_COL_RNORM_PS=1
                      ENDIF
                      LOCVAR_COL_RNORM_ALL=1
                   ELSE
                      IF(FFM%W1.GT.0.0_q) THEN
                         LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         IF(FFM%LCOUPLE) THEN
                            LOCVAR_COL_C00_COUPLE=LOCVAR_COL_C00
                         ELSE
                            LOCVAR_COL_C00_COUPLE=1
                         ENDIF
                      ELSE
                         LOCVAR_COL_C00=1
                         LOCVAR_COL_C00_COUPLE=1
                      ENDIF
                      IF(FFM%W2.GT.0.0_q) THEN
                         LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         IF(FFM%LCOUPLE) THEN
                            LOCVAR_COL_PS_COUPLE=LOCVAR_COL_PS
                         ELSE
                            LOCVAR_COL_PS_COUPLE=1
                         ENDIF
                      ELSE
                         LOCVAR_COL_PS=1
                         LOCVAR_COL_PS_COUPLE=1
                      ENDIF
                      LOCVAR_COL_RNORM_C00=1
                      LOCVAR_COL_RNORM_PS=1
                      LOCVAR_COL_RNORM_ALL=INITYP
                   ENDIF
                   CALL NORMALIZATION_D0 (C00(1:,LOCVAR_COL_C00,INTYP0),C00_COUPLE(1:,LOCVAR_COL_C00_COUPLE,INTYP0),FFM%LSUPERVEC,FFM%LCOUPLE,FFM%LNORM1,FFM%LNORM2, &
                        MROW_C00,MROW_C00_COUPLE,MROW_PS,MROW_PS_COUPLE,FFM%NNVAR1,FFM%NNVAR2(INTYP0),PS(1:,LOCVAR_COL_PS,INTYP0),PS_COUPLE(1:,LOCVAR_COL_PS_COUPLE,INTYP0), &
                        RNORM_ALL(LOCVAR_COL_RNORM_ALL,INTYP0),RNORM_C00(LOCVAR_COL_RNORM_C00,INTYP0),RNORM_PS(LOCVAR_COL_RNORM_PS,INTYP0),FFM%W1,FFM%W2)
                ENDIF
             ENDDO
             PROFILING_STOP('normalization_d0_fmat_new_mb')
! All-reduce the norm.
             PROFILING_START ('allred_rnorm_fmat_new_mb')
             IF(.NOT.FFM%LSUPERVEC) THEN
                IF(FFM%W1.GT.0.0_q) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_C00(1,INTYP0),ABN%NITYP(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                ENDIF
                IF(FFM%W2.GT.0.0_q) THEN
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_PS(1,INTYP0),ABN%NITYP(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                ENDIF
             ELSE
                CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_ALL(1,INTYP0),ABN%NITYP(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
             ENDIF
             PROFILING_STOP ('allred_rnorm_fmat_new_mb')
          END SUBROUTINE NORMALIZATION_D0_FMAT_NEW_MB

! Calculate SOAP kernel by using the fast version method.
          SUBROUTINE SOAP_KERNEL_FMAT_NEW_MB
             IMPLICIT NONE
! Local variables
             INTEGER               :: IB
             INTEGER               :: IERR
             INTEGER               :: IHEAD
             INTEGER               :: INIONS
             INTEGER               :: INITYP
             INTEGER               :: INITYP_TMP
             INTEGER               :: IPOLY
             INTEGER               :: LOCVAR_COL
             IPOLY=0
! Set header in the array.
             IHEAD=LHEAD(INTYP0)
! Calculate contribution from 1-point correlation function (radial descriptor)
             IF(FFM%W1.GT.0.0_q) THEN
                IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                   PROFILING_START('dgemm_soap1_fmat_new_mb')
#ifdef scaLAPACK
                   CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR1,1.0_q, &
                        FFM%C00_ALL(1,IHEAD),FFM%MMVAR1, &
                        C00(1,1,INTYP0),MROW_C00, &
                        0.0_q,SOAP1(1,1),MROW_SOAP)
                   IF(FFM%LCOUPLE) THEN
                      CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR1,1.0_q, &
                           FFM%C00_ALL(1,IHEAD),FFM%MMVAR1, &
                           C00_COUPLE(1,1,INTYP0),MROW_C00_COUPLE, &
                           0.0_q,SOAP1_COUPLE(1,1),MROW_SOAP)
                   ENDIF
#else
                   CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR1,1.0_q, &
                        FFM%C00(1,1,INTYP0),FFM%MMVAR1, &
                        C00(1,1,INTYP0),MROW_C00, &
                        0.0_q,SOAP1(1,1),MROW_SOAP)
                   IF(FFM%LCOUPLE) THEN
                      CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR1,1.0_q, &
                           FFM%C00(1,1,INTYP0),FFM%MMVAR1, &
                           C00_COUPLE(1,1,INTYP0),MROW_C00_COUPLE, &
                           0.0_q,SOAP1_COUPLE(1,1),MROW_SOAP)
                   ENDIF
#endif
                   PROFILING_STOP('dgemm_soap1_fmat_new_mb')
                   PROFILING_START('poly_soap1_fmat_new_mb')
                   CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0),NCOL_NITYP,FFM%NHYP1,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W1)
                   IF(FFM%LCOUPLE) THEN
                      CALL POLY_SOAP_COUPLE1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,MROW_SOAP_COUPLE,MCOL_SOAP_COUPLE,FFM%NB(INTYP0),NCOL_NITYP,FFM%NHYP1,SOAP1(1:,1:),SOAP1_COUPLE(1:,1:),SOAP2_COUPLE(1:,1:),FFM%W1)
                   ENDIF
                   PROFILING_STOP('poly_soap1_fmat_new_mb')
                   IPOLY=1
                ENDIF
! Store the calculated SOAP1 to SOAP_C00.
! MPI-parallel.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   PROFILING_START('gather_soap_c00_fmat_new_mb')
                   IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                      DO IB=1, FFM%NB(INTYP0)
                         DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                            INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                            IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                               INIONS=ABN%LNIONS(INITYP,INTYP0)
                               LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                               MLSHM%SOAP_C00(INIONS,IB)=FFM%W1*REAL(FFM%NHYP1,q)*(SOAP1(IB,LOCVAR_COL))**(FFM%NHYP1-1)
                            ENDIF
                         ENDDO
                      ENDDO
                   ENDIF
#   ifdef use_shmem
                   CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_C00 at the end of INTYP loop.
                   IF(INTYP.EQ.ABN%NTYP) THEN
                      PROFILING_START ('allred_soap_c00_fmat_new_mb')
#ifdef use_shmem
                      IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN 
                         CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_C00,MLSHM%MROW_SOAP_C00_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                              PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                      ENDIF
                      CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_C00,MLSHM%MROW_SOAP_C00_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
                      PROFILING_STOP ('allred_soap_c00_fmat_new_mb')
                   ENDIF
                   PROFILING_STOP('gather_soap_c00_fmat_new_mb')
                ENDIF
             ENDIF
! Calculate contribution from 2-point correlation function (angular descriptore)
             IF(FFM%W2.GT.0.0_q) THEN
                IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                   PROFILING_START('dgemm_soap2_fmat_new_mb')
#ifdef scaLAPACK
                   CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS_ALL(1,IHEAD),FFM%MMVAR2, &
                        PS(1,1,INTYP0),MROW_PS, &
                        0.0_q,SOAP1(1,1),MROW_SOAP)
                   IF(FFM%LCOUPLE) THEN
                      CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR2(INTYP0),1.0_q, &
                           FFM%PS_ALL(1,IHEAD),FFM%MMVAR2, &
                           PS_COUPLE(1,1,INTYP0),MROW_PS_COUPLE, &
                           0.0_q,SOAP1_COUPLE(1,1),MROW_SOAP)
                   ENDIF
#else
                   CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                        PS(1,1,INTYP0),MROW_PS, &
                        0.0_q,SOAP1(1,1),MROW_SOAP)
                   IF(FFM%LCOUPLE) THEN
                      CALL DGEMM ('T','N',FFM%NB(INTYP0),NCOL_NITYP,FFM%NNVAR2(INTYP0),1.0_q, &
                           FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                           PS_COUPLE(1,1,INTYP0),MROW_PS_COUPLE, &
                           0.0_q,SOAP1_COUPLE(1,1),MROW_SOAP)
                   ENDIF
#endif
                   PROFILING_STOP('dgemm_soap2_fmat_new_mb')
                   PROFILING_START('poly_soap2_fmat_new_mb')
                   CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0),NCOL_NITYP,FFM%NHYP2,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W2)
                   IF(FFM%LCOUPLE) THEN
                      CALL POLY_SOAP_COUPLE1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,MROW_SOAP_COUPLE,MCOL_SOAP_COUPLE,FFM%NB(INTYP0),NCOL_NITYP,FFM%NHYP2,SOAP1(1:,1:),SOAP1_COUPLE(1:,1:),SOAP2_COUPLE(1:,1:),FFM%W2)
                   ENDIF
                   PROFILING_STOP('poly_soap2_fmat_new_mb')
                ENDIF
! Store the calculated SOAP1 to SOAP_PS.
! MPI-parallel.
                IF(.NOT.FFM%LSUPERVEC) THEN
                   PROFILING_START('gather_soap_ps_fmat_new_mb')
                   IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                      DO IB=1, FFM%NB(INTYP0)
                         DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                            INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                            IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                               INIONS=ABN%LNIONS(INITYP,INTYP0)
                               LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                               MLSHM%SOAP_PS(INIONS,IB)=FFM%W2*REAL(FFM%NHYP2,q)*(SOAP1(IB,LOCVAR_COL))**(FFM%NHYP2-1)
                            ENDIF
                         ENDDO
                      ENDDO
                   ENDIF
#ifdef use_shmem
                   CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_PS at the end of INTYP loop.
                   IF(INTYP.EQ.ABN%NTYP) THEN
                      PROFILING_START ('allred_soap_ps_fmat_new_mb')
#ifdef use_shmem
                      IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                         CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_PS,MLSHM%MROW_SOAP_PS_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                              PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                      ENDIF
                      CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_PS,MLSHM%MROW_SOAP_PS_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
                      PROFILING_STOP ('allred_soap_ps_fmat_new_mb')
                   ENDIF
                   PROFILING_STOP('gather_soap_ps_fmat_new_mb')
                ENDIF
             ENDIF
             IF(FFM%LSUPERVEC) THEN
! Store the calculated SOAP1 to SOAP_ALL
! MPI-parallel.
                PROFILING_START('gather_soap_all_fmat_new_mb')
                IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                   DO IB=1, FFM%NB(INTYP0)
                      DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                         INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                         IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                            INIONS=ABN%LNIONS(INITYP,INTYP0)
                            LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                            MLSHM%SOAP_ALL(INIONS,IB)=REAL(FFM%NHYP2,q)*(SOAP2(IB,LOCVAR_COL))**(FFM%NHYP2-1)
                         ENDIF
                      ENDDO
                   ENDDO
                ENDIF
#ifdef use_shmem
                CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_PS at the end of INTYP loop.
                IF(INTYP.EQ.ABN%NTYP) THEN
                   PROFILING_START ('allred_soap_all_fmat_new_mb')
#ifdef use_shmem
                   IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                      CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_ALL,MLSHM%MROW_SOAP_ALL_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                           PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                   ENDIF
                   CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                   CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_ALL,MLSHM%MROW_SOAP_ALL_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
#endif
                   PROFILING_STOP ('allred_soap_all_fmat_new_mb')
                ENDIF
                PROFILING_STOP('gather_soap_all_fmat_new_mb')
! Calculate SOAP similarity kernel for super vector.
                PROFILING_START('poly_soap_all_fmat_new_mb')
                IF(FFM%LCOUPLE) THEN
                   CALL POLY_SOAP_COUPLE2 (MROW_SOAP,MCOL_SOAP,MROW_SOAP_COUPLE,MCOL_SOAP_COUPLE,FFM%NB(INTYP0),NCOL_NITYP,FFM%NHYP2,SOAP2(1:,1:),SOAP2_COUPLE(1:,1:))
                ENDIF
                CALL POLY_SOAP2 (MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0),NCOL_NITYP,FFM%NHYP2,SOAP2(1:,1:))
                PROFILING_STOP('poly_soap_all_fmat_new_mb')
             ENDIF
          END SUBROUTINE SOAP_KERNEL_FMAT_NEW_MB

! Calculate energy components.
! If FFM%LEATOM=.TRUE. or FFM%LHEAT=.TRUE. or FFM%LCOUPLE=.TRUE., atomic energy elements are also stored.
          SUBROUTINE ENERGY_FMAT_NEW_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: ICOL
            INTEGER               :: IERR
            INTEGER               :: INIONS
            INTEGER               :: INITYP
            INTEGER               :: INITYP_TMP
            INTEGER               :: IROW
            INTEGER               :: LOCVAR_COL
! Calculate energy matrix elements
            PROFILING_START('energy_fmat_new_mb')
            IF(FFM%NB(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
               VEC_LOC_ENERGY=0.0_q
               DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                     INIONS=ABN%LNIONS(INITYP,INTYP0)
                     LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     IF (FF%LTOTEN_SYSTEM) THEN
                        VEC_LOC_ENERGY(LOCVAR_COL,1)=FFM%RCOUPLE_IONS(INIONS)
                     ELSE
                        VEC_LOC_ENERGY(LOCVAR_COL,1)=FFM%RCOUPLE_IONS(INIONS)/REAL(ABN%NIONS,q)
                     ENDIF
                  ENDIF
               ENDDO
               CALL DGEMV ('N',FFM%NB(INTYP0),NCOL_NITYP,1.0_q, &
                    SOAP2,MROW_SOAP,VEC_LOC_ENERGY(1,1), &
                    1,0.0_q,ENERGY_HELP(1,1,INTYP0),1)
               IF(FFM%LCOUPLE) THEN
                  CALL DGEMV ('N',FFM%NB(INTYP0),NCOL_NITYP,1.0_q, &
                       SOAP2_COUPLE,MROW_SOAP,VEC_LOC_ENERGY(1,1), &
                       1,0.0_q,ENERGY_COUPLE_HELP(1,1,INTYP0),1)
               ENDIF
            ELSE
               ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)=0.0_q
               IF(FFM%LCOUPLE) THEN
                  ENERGY_COUPLE_HELP(1:FFM%NB(INTYP0),1,INTYP0)=0.0_q
               ENDIF
            ENDIF
! All-reduce ENERGY_HELP.
            PROFILING_START ('allred_energy_fmat_new_mb')
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,ENERGY_HELP(1,1,INTYP0),FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            IF(FFM%LCOUPLE) THEN
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,ENERGY_COUPLE_HELP(1,1,INTYP0),FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
            PROFILING_STOP ('allred_energy_fmat_new_mb')
            PROFILING_STOP('energy_fmat_new_mb')
! Store the atomic energy elements.
            IF(FFM%LEATOM.OR.FFM%LHEAT.OR.FFM%LCOUPLE) THEN
               DO ICOL=1, MCOL_EATOM
                  DO IROW=1, MROW_EATOM
                     EATOM_HELP(IROW,ICOL,INTYP0)=SOAP2(IROW,ICOL)
                  ENDDO
               ENDDO
            ENDIF
          END SUBROUTINE ENERGY_FMAT_NEW_MB

! Subroutine to calculate derivatives of expansion coefficients within the fast version method.
          SUBROUTINE D1CLM_FMAT_NEW_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: LOCVAR_COL_EST1
            INTEGER               :: LOCVAR_COL_EST2
! Calculate derivatives of expansion coefficients.
            PROFILING_START('d1clm_soap_fmat_new_mb')
            IF(FFM%W1.GT.0.0_q) THEN
               LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               CALL D1CLM_SOAP (DCLM1,FFM%DRSPL1,FFM%FNL1,FFM%FWIN1,KNIONS,KNTYP0, &
                    ABN%LADD(1:),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1), &
                    .FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                    MCOL_DCLM1,MCOL_DPS_SIC,FF%MIONS,FFM%MRB1, &
                    MROW_DCLM1,MROW_DPS_SIC,MROW_EST1,FFM%MSPL1,ABN%MTYP, &
                    NNEIB_EST1(1:,LOCVAR_COL_EST1),FFM%NRB1(0:),FFM%NSPL1,ABN%NTYP, &
                    DPS_SIC,FFM%RCOUPLE_IONS,RMEM_HELP3,XYZ_EST1(1:,1:,1:,LOCVAR_COL_EST1))
               RMEM_HELP2=MAX(RMEM_HELP2,RMEM_HELP3)
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               CALL D1CLM_SOAP (DCLM2,FFM%DRSPL2,FFM%FNL2,FFM%FWIN2,KNIONS,KNTYP0, &
                    ABN%LADD(1:),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LMAX2,LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                    FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW2, &
                    MCOL_DCLM2,MCOL_DPS_SIC,FF%MIONS,FFM%MRB2, &
                    MROW_DCLM2,MROW_DPS_SIC,MROW_EST2,FFM%MSPL2,ABN%MTYP, &
                    NNEIB_EST2(1:,LOCVAR_COL_EST2),FFM%NRB2(0:),FFM%NSPL2,ABN%NTYP, &
                    DPS_SIC,FFM%RCOUPLE_IONS,RMEM_HELP3,XYZ_EST2(1:,1:,1:,LOCVAR_COL_EST2))
               RMEM_HELP2=MAX(RMEM_HELP2,RMEM_HELP3)
            ENDIF
            PROFILING_STOP('d1clm_soap_fmat_new_mb')
          END SUBROUTINE D1CLM_FMAT_NEW_MB

! Subroutine to calculate derivatives of radial descriptor within the fast version method.
          SUBROUTINE D1C00_FMAT_NEW_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: LOCVAR_COL_EST1
            INTEGER               :: LOCVAR_COL_EST_MAX
! Calculate derivatives of radial descriptor.
            IF(FFM%W1 .GT. 0.0_q) THEN
               PROFILING_START('d1c00_soap1_fmat_new_mb')
               LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               IF(.NOT.FFM%LSUPERVEC) THEN
                  LOCVAR_COL_EST_MAX=1
               ELSE
                  LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ENDIF
               CALL D1C00_SOAP (MLSHM%CLM1,DC00,DCLM1,FFM%LSUPERVEC,KNTYP0, &
                    ABN%LADD(1:),FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1),LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX), &
                    MLSHM%MCOL_CLM1_GLOBAL,MCOL_DC00,MCOL_DCLM1,FFM%MRB1,MROW_EST1,MROW_EST_MAX,MLSHM%MROW_CLM1_GLOBAL,MROW_DC00,MROW_DCLM1, &
                    ABN%MTYP,ABN%MTYP_ALLOCATE,NNEIB_EST1(1:,LOCVAR_COL_EST1),NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NRB1(0:),ABN%NTYP)
               PROFILING_STOP('d1c00_soap1_fmat_new_mb')
            ENDIF
          END SUBROUTINE D1C00_FMAT_NEW_MB

! Subroutine to calculate derivatives of angular descriptor within the fast version method.
          SUBROUTINE D1PS_FMAT_NEW_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: LOCVAR_COL_EST2
            INTEGER               :: LOCVAR_COL_EST_MAX
            IF(FFM%W2 .GT. 0.0_q) THEN
               PROFILING_START('d1ps_soap_fmat_new_mb')
               LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               IF(.NOT.FFM%LSUPERVEC) THEN
                  LOCVAR_COL_EST_MAX=1
               ELSE
                  LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ENDIF
!               CALL D1PS_SOAP (FFM%AFILT2,MLSHM%CLM2,DCLM2,DPS,DPS_SIC,FFM%IAFILT2,FFM%LSUPERVEC,KNTYP0, &
               CALL SELECTOR_D1PS (FFM%AFILT2,MLSHM%CLM2,DCLM2,FFM%DESC_TYPE,DPS,DPS_SIC,FFM%IAFILT2,FFM%LSUPERVEC,KNTYP0, &
                    FFM%LAFILT2,ABN%LADD(1:),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%L_LNRB2,FFM%LMAX2, &
                    LNIONS_EST2(1:,1:,LOCVAR_COL_EST2),LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX),FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                    MLSHM%MCOL_CLM2_GLOBAL,MCOL_DCLM2,MCOL_DPS,MCOL_DPS_SIC,MLSHM%MCOL_PS_SIC_GLOBAL,FFM%MLNRB2,FFM%MRB2, &
                    MROW_EST2,MROW_EST_MAX,MLSHM%MROW_CLM2_GLOBAL,MROW_DCLM2, &
                    MROW_DPS,MROW_DPS_SIC,MLSHM%MROW_PS_SIC_GLOBAL,ABN%MTYP,ABN%MTYP_ALLOCATE, &
                    ABN%NIONS       ,FFM%NLNRB2,NNEIB_EST2(1:,LOCVAR_COL_EST2),NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX), &
                    FFM%NRB2(0:),FFM%NRB_LNRB2,ABN%NTYP,MLSHM%PS_SIC,FFM%WVAR)
               PROFILING_STOP('d1ps_soap_fmat_new_mb')
            ENDIF
          END SUBROUTINE D1PS_FMAT_NEW_MB

! Normalization of derivatives.
          SUBROUTINE NORMALIZATION_D1_FMAT_NEW_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: LOCVAR_COL_EST1
            INTEGER               :: LOCVAR_COL_EST2
            INTEGER               :: LOCVAR_COL_EST_MAX
            PROFILING_START('normalization_d1_fmat_new_mb')
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST1=1
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST2=1
               ENDIF
               LOCVAR_COL_EST_MAX=1
            ELSE
               IF(FFM%W1.GT.0.0_q) THEN
                  LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST1=1
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST2=1
               ENDIF
               LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ENDIF
            CALL NORMALIZATION_D1 (DC00,DPS,FFM%LSUPERVEC,KNTYP0, &
                 ABN%LADD(1:),LNIONS_EST1(1:,1:,LOCVAR_COL_EST1),LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                 LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX),ABN%LNITYP(1:),FFM%LNORM1,FFM%LNORM2, &
                 MCOL_DC00,MCOL_DPS,MCOL_RNORM_ALL,MCOL_RNORM_C00,MCOL_RNORM_PS,ABN%MIONS,ABN%MITYP, &
                 MROW_EST1,MROW_EST2,MROW_EST_MAX,MROW_DC00,MROW_DPS,MROW_RNORM_C00,MROW_RNORM_PS,ABN%MTYP_ALLOCATE, &
                 NNEIB_EST1(1:,LOCVAR_COL_EST1),NNEIB_EST2(1:,LOCVAR_COL_EST2), &
                 NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NNVAR1,FFM%NNVAR2,ABN%NTYP, &
                 FFM%RCUT1,FFM%RCUT2,RNORM_ALL(1:,1:),RNORM_C00(1:,1:),RNORM_PS(1:,1:),FFM%W1,FFM%W2)
            PROFILING_STOP('normalization_d1_fmat_new_mb')
          END SUBROUTINE NORMALIZATION_D1_FMAT_NEW_MB

! Subroutine to calculate derivatives of SOAP similarity kernels.
          SUBROUTINE DSOAP_KERNEL_FMAT_NEW_MB
            IMPLICIT NONE
! Local variables
            INTEGER               :: IHEAD
            INTEGER               :: IXYZ
            INTEGER               :: LOCVAR_COL
            INTEGER               :: NNEIB_EST_DUMMY
! Set header.
            IHEAD=LHEAD(INTYP0)
! Set LOCVAR_COL
            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Calculate 1-point correlation (radial) kernel.
            IF(FFM%W1.GT.0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
                     PROFILING_START('dgemm_dsoap1_fmat_new_mb')
#ifdef scaLAPACK
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                          DC00(1,1,IXYZ,INTYP0),MROW_DC00,FFM%C00_ALL(1,IHEAD),FFM%MMVAR1, &
                          0.0_q,DSOAP11(1,1),MROW_DSOAP1)
#else
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                          DC00(1,1,IXYZ,INTYP0),MROW_DC00,FFM%C00(1,1,INTYP0),FFM%MMVAR1, &
                          0.0_q,DSOAP11(1,1),MROW_DSOAP1)
#endif
                     PROFILING_STOP('dgemm_dsoap1_fmat_new_mb')
                     PROFILING_START('poly_dsoap1_fmat_new_mb')
                     IF(.NOT.FFM%LSUPERVEC) THEN
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST1(1:,INTYP0,LOCVAR_COL)   ,MROW_EST1   ,MROW_DSOAP1,MCOL_DSOAP1,MLSHM%MROW_SOAP_C00_GLOBAL,MLSHM%MCOL_SOAP_C00_GLOBAL, &
                             NNEIB_EST1(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP11(1:,1:),DSOAP21(1:,1:,IXYZ),MLSHM%SOAP_C00,FFM%W1)
                     ELSE
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST_MAX(1:,INTYP0,LOCVAR_COL),MROW_EST_MAX,MROW_DSOAP1,MCOL_DSOAP1,MLSHM%MROW_SOAP_ALL_GLOBAL,MLSHM%MCOL_SOAP_ALL_GLOBAL, &
                             NNEIB_EST_MAX(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP11(1:,1:),DSOAP21(1:,1:,IXYZ),MLSHM%SOAP_ALL,FFM%W1)
                     ENDIF
                     PROFILING_STOP('poly_dsoap1_fmat_new_mb')
                  ENDDO
               ENDIF
            ENDIF
! 2-points correlation (angular) kernels.
            IF(FFM%W2 .GT. 0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
                     PROFILING_START ('dgemm_dsoap2_fmat_new_mb')
#ifdef scaLAPACK
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                          DPS(1,1,IXYZ,INTYP0),MROW_DPS,FFM%PS_ALL(1,IHEAD),FFM%MMVAR2, &
                          0.0_q,DSOAP12(1,1),MROW_DSOAP2)
#else
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                          DPS(1,1,IXYZ,INTYP0),MROW_DPS,FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                          0.0_q,DSOAP12(1,1),MROW_DSOAP2)
#endif
                     PROFILING_STOP ('dgemm_dsoap2_fmat_new_mb')
                     PROFILING_START('poly_dsoap2_fmat_new_mb')
                     IF(.NOT.FFM%LSUPERVEC) THEN
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST2(1:,INTYP0,LOCVAR_COL)   ,MROW_EST2   ,MROW_DSOAP2,MCOL_DSOAP2,MLSHM%MROW_SOAP_PS_GLOBAL,MLSHM%MCOL_SOAP_PS_GLOBAL, &
                             NNEIB_EST2(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP12(1:,1:),DSOAP22(1:,1:,IXYZ),MLSHM%SOAP_PS,FFM%W2)
                     ELSE
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST_MAX(1:,INTYP0,LOCVAR_COL),MROW_EST_MAX,MROW_DSOAP2,MCOL_DSOAP2,MLSHM%MROW_SOAP_ALL_GLOBAL,MLSHM%MCOL_SOAP_ALL_GLOBAL, &
                             NNEIB_EST_MAX(INTYP0,LOCVAR_COL)+1,FFM%NB(INTYP0),DSOAP12(1:,1:),DSOAP22(1:,1:,IXYZ),MLSHM%SOAP_ALL,FFM%W2)
                     ENDIF
                     PROFILING_STOP('poly_dsoap2_fmat_new_mb')
                  ENDDO
               ENDIF
            ENDIF
          END SUBROUTINE DSOAP_KERNEL_FMAT_NEW_MB

! Subroutine to calculate force and stress design-matrix elements.
          SUBROUTINE FORCE_AND_STRESS_FMAT_NEW_MB
             IMPLICIT NONE
! Local variables
             INTEGER               :: IHEAD
             INTEGER               :: INEIB
             INTEGER               :: INIONS
             INTEGER               :: IXYZ
             INTEGER               :: JXYZ
             INTEGER               :: KXYZ
             INTEGER               :: LOCVAR_COL
             INTEGER               :: NNEIB_EST_DUMMY
! Calculate force and stress components.
! Set LOCVAR_COL.
             LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Contributions from radial descriptor.
             IF(FFM%W1.GT.0.0_q) THEN
                IF(.NOT.FFM%LSUPERVEC) THEN
                   NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
                ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
                ENDIF
                IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
! Initialize counter for stress tensor.
                   KXYZ=0
! Calculate force and stress components.
                   DO IXYZ=1, 3
! Calculate force components.
                      PROFILING_START('force_fmat_new_mb')
                      DO INEIB=1, NNEIB_EST_DUMMY+1
                         IF(.NOT.FFM%LSUPERVEC) THEN
                            INIONS=LNIONS_EST1(INEIB,INTYP0,LOCVAR_COL)
                         ELSE
                            INIONS=LNIONS_EST_MAX(INEIB,INTYP0,LOCVAR_COL)
                         ENDIF
                         IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                            VEC_LOC_FORCE1(INEIB,1)=0.0_q
                         ELSE
                            VEC_LOC_FORCE1(INEIB,1)=FFM%RCOUPLE_IONS(INIONS)
                         ENDIF
                      ENDDO
                      CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                           VEC_LOC_FORCE1(1,1),1,1.0_q,FORCE_HELP(1,3*(LOCVAR_COL-1)+IXYZ,INTYP0),1)
                      PROFILING_STOP('force_fmat_new_mb')
! Calculate stress components.
                      PROFILING_START('stress_fmat_new_mb')
                      DO JXYZ=IXYZ, 3
                         KXYZ=KXYZ+1
                         DO INEIB=1, NNEIB_EST_DUMMY+1
                            IF(.NOT.FFM%LSUPERVEC) THEN
                               INIONS=LNIONS_EST1(INEIB,INTYP0,LOCVAR_COL)
                            ELSE
                               INIONS=LNIONS_EST_MAX(INEIB,INTYP0,LOCVAR_COL)
                            ENDIF
                            IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                               VEC_LOC_STRESS1(INEIB,1)=0.0_q
                            ELSE
                               IF(.NOT.FFM%LSUPERVEC) THEN
                                  VEC_LOC_STRESS1(INEIB,1)=-FFM%RCOUPLE_IONS(INIONS)*XYZ_EST1(JXYZ,INEIB,INTYP0,LOCVAR_COL)/ABN%OMEGA(ABN%NCONF)
                               ELSE
                                  VEC_LOC_STRESS1(INEIB,1)=-FFM%RCOUPLE_IONS(INIONS)*XYZ_EST_MAX(JXYZ,INEIB,INTYP0,LOCVAR_COL)/ABN%OMEGA(ABN%NCONF)
                               ENDIF
                            ENDIF
                         ENDDO
                         CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                              VEC_LOC_STRESS1(1,1),1,1.0_q,STRESS_HELP(1,KXYZ,INTYP0),1)
                      ENDDO
                      PROFILING_STOP('stress_fmat_new_mb')
                   ENDDO
! Calculate heat flux components if necessary.
! Here, a different approach is taken because we need to renew the velocity by using the calculated forces later.
                   IF(FFM%LHEAT) THEN
                      DO IXYZ=1, 3
                         PROFILING_START('heat_fmat_new_mb')
                         IHEAD=LHEAD(INTYP0)
#ifdef scaLAPACK
                         CALL DGEMV ('N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                              FFM%WMAT_ALL(IHEAD),1,1.0_q,HEAT_HELP1(1,INTYP0,LOCVAR_COL,IXYZ),1)
#else
                         CALL DGEMV ('N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                              FFM%WMAT(1,1,INTYP0),1,1.0_q,HEAT_HELP1(1,INTYP0,LOCVAR_COL,IXYZ),1)
#endif
                         PROFILING_STOP('heat_fmat_new_mb')
                      ENDDO
                   ENDIF
                ENDIF
             ENDIF
! Contributions from angular descriptors.
             IF(FFM%W2.GT.0.0_q) THEN
                IF(.NOT.FFM%LSUPERVEC) THEN
                   NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
                ELSE
                   NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
                ENDIF
                IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB(INTYP0).GT.0) THEN
! Initialize counter for stress tensor component.
                   KXYZ=0
! Calculate force components.
                   DO IXYZ=1, 3
                      PROFILING_START('force_fmat_new_mb')
                      DO INEIB=1, NNEIB_EST_DUMMY+1
                         IF(.NOT.FFM%LSUPERVEC) THEN
                            INIONS=LNIONS_EST2(INEIB,INTYP0,LOCVAR_COL)
                         ELSE
                            INIONS=LNIONS_EST_MAX(INEIB,INTYP0,LOCVAR_COL)
                         ENDIF
                         IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                            VEC_LOC_FORCE2(INEIB,1)=0.0_q
                         ELSE
                            VEC_LOC_FORCE2(INEIB,1)=FFM%RCOUPLE_IONS(INIONS)
                         ENDIF
                      ENDDO
                      CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                           VEC_LOC_FORCE2(1,1),1,1.0_q,FORCE_HELP(1,3*(LOCVAR_COL-1)+IXYZ,INTYP0),1)
                      PROFILING_STOP('force_fmat_new_mb')
! Calculate stress components.
                      PROFILING_START('stress_fmat_new_mb')
                      DO JXYZ=IXYZ, 3
                         KXYZ=KXYZ+1
                         DO INEIB=1, NNEIB_EST_DUMMY+1
                            IF(.NOT.FFM%LSUPERVEC) THEN
                               INIONS=LNIONS_EST2(INEIB,INTYP0,LOCVAR_COL)
                            ELSE
                               INIONS=LNIONS_EST_MAX(INEIB,INTYP0,LOCVAR_COL)
                            ENDIF
                            IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                               VEC_LOC_STRESS2(INEIB,1)=0.0_q
                            ELSE
                               IF(.NOT.FFM%LSUPERVEC) THEN
                                  VEC_LOC_STRESS2(INEIB,1)=-FFM%RCOUPLE_IONS(INIONS)*XYZ_EST2(JXYZ,INEIB,INTYP0,LOCVAR_COL)/ABN%OMEGA(ABN%NCONF)
                               ELSE
                                  VEC_LOC_STRESS2(INEIB,1)=-FFM%RCOUPLE_IONS(INIONS)*XYZ_EST_MAX(JXYZ,INEIB,INTYP0,LOCVAR_COL)/ABN%OMEGA(ABN%NCONF)
                               ENDIF
                            ENDIF
                         ENDDO
                         CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                              VEC_LOC_STRESS2(1,1),1,1.0_q,STRESS_HELP(1,KXYZ,INTYP0),1)
                      ENDDO
                      PROFILING_STOP('stress_fmat_new_mb')
                   ENDDO
! Calculate heat flux components if necessary.
! Here, a different approach is taken because we need to renew the velocity by using the calculated forces later.
                   IF(FFM%LHEAT) THEN
                      DO IXYZ=1, 3
                         PROFILING_START('heat_fmat_new_mb')
                         IHEAD=LHEAD(INTYP0)
#ifdef scaLAPACK
                         CALL DGEMV ('N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                              FFM%WMAT_ALL(IHEAD),1,1.0_q,HEAT_HELP2(1,INTYP0,LOCVAR_COL,IXYZ),1)
#else
                         CALL DGEMV ('N',NNEIB_EST_DUMMY+1,FFM%NB(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                              FFM%WMAT(1,1,INTYP0),1,1.0_q,HEAT_HELP2(1,INTYP0,LOCVAR_COL,IXYZ),1)
#endif
                         PROFILING_STOP('heat_fmat_new_mb')
                      ENDDO
                   ENDIF
                ENDIF
             ENDIF
          END SUBROUTINE FORCE_AND_STRESS_FMAT_NEW_MB

! Reduction of help array containing stress tensor elements over atom types
           SUBROUTINE ALLREDUCE_STRESS_FMAT_NEW_MB
              IMPLICIT NONE
! Local variables
              INTEGER               :: IERR
              INTEGER               :: INTYP
              INTEGER               :: INTYP0
              INTEGER               :: KXYZ
              CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
              PROFILING_START ('allred_stress_fmat_new_mb')
              DO INTYP=1, ABN%NTYP
                 INTYP0=ABN%LADD(INTYP)
                 DO KXYZ=1, 6
                    CALL MPI_ALLREDUCE(MPI_IN_PLACE,STRESS_HELP(1,KXYZ,INTYP0),FFM%NB(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                 ENDDO
              ENDDO
              PROFILING_STOP ('allred_stress_fmat_new_mb')
           END SUBROUTINE ALLREDUCE_STRESS_FMAT_NEW_MB

        END SUBROUTINE FMAT_NEW_MB


!------------------------------------------------------------------------------------------------------------------
! Calculate energy, force and stress tensor within fast version method.
! In this method, regression coefficients stored in all processes are 
! used to calculate energy, force and stress tensor without using scaLAPACK.
!------------------------------------------------------------------------------------------------------------------
        SUBROUTINE ZMAT_NEW_MB(ABN,PAR_SUP_HANDLE,MLSHM,FF,FFM,LHEAD, &
                   MNEIB_EST1,MNEIB_EST2,MNEIB_EST_MAX,XYZ_EST1,XYZ_EST2,XYZ_EST_MAX,EATOM_HELP, &
                   ENERGY_COUPLE_HELP,ENERGY_HELP,FORCE_HELP,HEAT_HELP1,HEAT_HELP2,NNEIB_EST1,NNEIB_EST2, &
                   NNEIB_EST_MAX,QHEAT,RMEM,STRESS_HELP,TIFOR_MB,TOTEN_MB,TSIF_MB,VEL, &
                   LNIONS_EST1,LNIONS_EST2,LNIONS_EST_MAX)
          USE ML_FF_STRUCT, ONLY: ABINITIONEW, PARALLEL_SUPER, ML_SHMEM, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input and output variables
          TYPE (ABINITIONEW)    :: ABN
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: LHEAD(:) !(1:FF%MTYP)
          INTEGER, INTENT(IN)   :: MNEIB_EST1
          INTEGER, INTENT(IN)   :: MNEIB_EST2
          INTEGER, INTENT(IN)   :: MNEIB_EST_MAX
          REAL(q), INTENT(IN)   :: XYZ_EST1(:,:,:,:) !(1:3,1:MROW_EST1,1:MTYP,1:MCOL_EST1)
          REAL(q), INTENT(IN)   :: XYZ_EST2(:,:,:,:) !(1:3,1:MROW_EST2,1:MTYP,1:MCOL_EST2)
          REAL(q), INTENT(IN)   :: XYZ_EST_MAX(:,:,:,:) !(1:3,1:MROW_EST_MAX,1:MTYP,1:MCOL_EST_MAX)
          REAL(q), INTENT(INOUT)  :: EATOM_HELP(:,:,:) !(1:MROW_EATOM,1:MCOL_EATOM,1:FF%MTYP)
          REAL(q), INTENT(INOUT)  :: ENERGY_COUPLE_HELP(:,:,:) !(1:MROW_ENERGY_COUPLE_HELP,1:MCOL_ENERGY_COUPLE_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: ENERGY_HELP(:,:,:) !(1:MROW_ENERGY_HELP,1:MCOL_ENERGY_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: FORCE_HELP(:,:,:) !(1:MROW_FORCE_HELP,1:MCOL_FORCE_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: HEAT_HELP1(:,:,:,:) !(1:MROW_HEAT1,1:MCOL_HEAT1,1:FF%MTYP,1:MCOL_MIONS,1:3)
          REAL(q), INTENT(INOUT)  :: HEAT_HELP2(:,:,:,:) !(1:MROW_HEAT2,1:MCOL_HEAT2,1:FF%MTYP,1:MCOL_MIONS,1:3)
          INTEGER, INTENT(INOUT)  :: NNEIB_EST1(:,:) !(1:MTYP,1:MCOL_EST1)
          INTEGER, INTENT(INOUT)  :: NNEIB_EST2(:,:) !(1:MTYP,1:MCOL_EST2)
          INTEGER, INTENT(INOUT)  :: NNEIB_EST_MAX(:,:) !(1:MTYP,1:MCOL_EST_MAX)
          REAL(q), INTENT(INOUT)  :: QHEAT(:) !(1:3)
          REAL(q), INTENT(INOUT)  :: RMEM
          REAL(q), INTENT(INOUT)  :: STRESS_HELP(:,:,:) !(1:MROW_STRESS_HELP,1:MCOL_STRESS_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: TIFOR_MB(:,:) !(1:3,1:MIONS)
          REAL(q), INTENT(INOUT)  :: TOTEN_MB
          REAL(q), INTENT(INOUT)  :: TSIF_MB(:,:) !(1:3,1:3)
          REAL(q), INTENT(INOUT)  :: VEL(:,:) !(1:3,1:MIONS)
          INTEGER, INTENT(IN)   :: LNIONS_EST1(:,:,:) !(1:MROW_EST1,1:MTYP,1:MCOL_EST1)
          INTEGER, INTENT(IN)   :: LNIONS_EST2(:,:,:) !(1:MROW_EST2,1:MTYP,1:MCOL_EST2)
          INTEGER, INTENT(IN)   :: LNIONS_EST_MAX(:,:,:) !(1:MROW_EST_MAX,1:MTYP,1:MCOL_EST_MAX)
! Local variables
          REAL(q)               :: DRIFT(1:3)
          INTEGER               :: IERR
          INTEGER               :: IHEAD
          INTEGER               :: INEIB
          INTEGER               :: INIONS
          INTEGER               :: INITYP
          INTEGER               :: INITYP_TMP
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: IXYZ
          INTEGER               :: JXYZ
          INTEGER               :: KNIONS
          INTEGER               :: KNIONS_TMP
          INTEGER               :: KNTYP0
          INTEGER               :: KXYZ
          INTEGER               :: LOCVAR_COL
          INTEGER               :: MCOL_VEC_LOC_HEAT1
          INTEGER               :: MCOL_VEC_LOC_HEAT2
          INTEGER               :: MROW_VEC_LOC_HEAT1
          INTEGER               :: MROW_VEC_LOC_HEAT2
          INTEGER               :: NNEIB_EST_DUMMY
          REAL(q)               :: TOTEN_ATOM_REF
          REAL(q), ALLOCATABLE  :: VEC_LOC_HEAT1(:,:)
          REAL(q), ALLOCATABLE  :: VEC_LOC_HEAT2(:,:)
! LAPACK routine.
          REAL(q) :: DDOT
! Start profiling
          PROFILING_START ('zmat_new_mb')
          IF(FF%IFF) THEN
! Allocate necessary arrays in this subroutine
             IF(FFM%LHEAT) THEN
! Size of VEC_LOC_HEAT1.
                IF(FFM%W1.GT.0.0_q) THEN
                   IF(.NOT.FFM%LSUPERVEC) THEN
                      MROW_VEC_LOC_HEAT1=MNEIB_EST1+1
                   ELSE
                      MROW_VEC_LOC_HEAT1=MNEIB_EST_MAX+1
                   ENDIF
                   MCOL_VEC_LOC_HEAT1=1
                   IF(ALLOCATED(VEC_LOC_HEAT1)) THEN
                      DEALLOCATE(VEC_LOC_HEAT1)
                   ENDIF
                   ALLOCATE (VEC_LOC_HEAT1(1:MROW_VEC_LOC_HEAT1,1:MCOL_VEC_LOC_HEAT1))
                   RMEM=RMEM+REAL(MROW_VEC_LOC_HEAT1,q)*REAL(MCOL_VEC_LOC_HEAT1,q)*8/1.0E6_q
                ENDIF
! Size of VEC_LOC_HEAT2
                IF(FFM%W2.GT.0.0_q) THEN
                   IF(.NOT.FFM%LSUPERVEC) THEN
                      MROW_VEC_LOC_HEAT2=MNEIB_EST2+1
                   ELSE
                      MROW_VEC_LOC_HEAT2=MNEIB_EST_MAX+1
                   ENDIF
                   MCOL_VEC_LOC_HEAT2=1
                   IF(ALLOCATED(VEC_LOC_HEAT2)) THEN
                      DEALLOCATE(VEC_LOC_HEAT2)
                   ENDIF
                   ALLOCATE (VEC_LOC_HEAT2(1:MROW_VEC_LOC_HEAT2,1:MCOL_VEC_LOC_HEAT2))
                   RMEM=RMEM+REAL(MROW_VEC_LOC_HEAT2,q)*REAL(MCOL_VEC_LOC_HEAT2,q)*8/1.0E+06_q
                ENDIF
             ENDIF
                
! Initialization of energy, force and stress
             TOTEN_MB=0.0_q
             IF(FFM%LCOUPLE) THEN
                FFM%DHDRCOUPLE=0.0_q
             ENDIF
             TIFOR_MB=0.0_q
             TSIF_MB=0.0_q
! Calculate reference atomic energy.
             TOTEN_ATOM_REF=0.0_q
             DO INTYP=1, ABN%NTYP
                INTYP0=ABN%LADD(INTYP)
                DO INITYP=1, ABN%NITYP(INTYP0)
                   INIONS=ABN%LNIONS(INITYP,INTYP0)
                   TOTEN_ATOM_REF=TOTEN_ATOM_REF+FF%EATOM_REF(INTYP0)
                ENDDO
             ENDDO

! Calculate energy, force and stress tensor.
! Calculate energy.
! IF statement is necessary since the saved arrays for the fast linear
! descriptor are different from the usual descriptors.
             DO INTYP=1, ABN%NTYP
                INTYP0=ABN%LADD(INTYP)
                IHEAD=LHEAD(INTYP0)
#ifdef scaLAPACK
                IF (FF%LTOTEN_SYSTEM) THEN
                   TOTEN_MB=TOTEN_MB+DDOT(FFM%NB(INTYP0),ENERGY_HELP(1,1,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)
                ELSE
                   TOTEN_MB=TOTEN_MB+REAL(ABN%NIONS,q)*DDOT(FFM%NB(INTYP0),ENERGY_HELP(1,1,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)
                ENDIF
#else
                IF (FF%LTOTEN_SYSTEM) THEN
                   TOTEN_MB=TOTEN_MB+DDOT(FFM%NB(INTYP0),ENERGY_HELP(1,1,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)
                ELSE
                   TOTEN_MB=TOTEN_MB+REAL(ABN%NIONS,q)*DDOT(FFM%NB(INTYP0),ENERGY_HELP(1,1,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)
                ENDIF
#endif
! Calculate the derivative of the energy with respect to the coupling constant.
                IF(FFM%LCOUPLE) THEN
#ifdef scaLAPACK
                   IF (FF%LTOTEN_SYSTEM) THEN
                      FFM%DHDRCOUPLE=FFM%DHDRCOUPLE+DDOT(FFM%NB(INTYP0),ENERGY_COUPLE_HELP(1,1,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)
                   ELSE
                      FFM%DHDRCOUPLE=FFM%DHDRCOUPLE+REAL(ABN%NIONS,q)*DDOT(FFM%NB(INTYP0),ENERGY_COUPLE_HELP(1,1,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)
                   ENDIF
#else
                   IF (FF%LTOTEN_SYSTEM) THEN
                      FFM%DHDRCOUPLE=FFM%DHDRCOUPLE+DDOT(FFM%NB(INTYP0),ENERGY_COUPLE_HELP(1,1,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)
                   ELSE
                      FFM%DHDRCOUPLE=FFM%DHDRCOUPLE+REAL(ABN%NIONS,q)*DDOT(FFM%NB(INTYP0),ENERGY_COUPLE_HELP(1,1,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)
                   ENDIF
#endif
                ENDIF
             ENDDO
! If FFM%ISCALE_TOTEN=1, the energy data is scaled to the energy of isolated atoms. Thus, this should be added.
             IF(FFM%ISCALE_TOTEN.EQ.1) THEN
                TOTEN_MB=TOTEN_MB+TOTEN_ATOM_REF
! If FFM%ISCALE_TOTEN=2, the energy data is scaled to the average of training energy data. Thus, the average energy must be also added.
             ELSE IF (FFM%ISCALE_TOTEN.EQ.2) THEN
                DO INTYP=1, ABN%NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO INITYP=1, ABN%NITYP(INTYP0)
                      INIONS=ABN%LNIONS(INITYP,INTYP0)
                      TOTEN_MB=TOTEN_MB+FF%EATOM_REF(INTYP0)+FFM%RCOUPLE_IONS(INIONS)*FFM%TOTENAV
                   ENDDO
                ENDDO
             ENDIF
! Calculate forces.
! Do parallel loop over atoms for which derivates are calculated (second
! atom loop is also inside).
             DO INTYP=1, ABN%NTYP
                INTYP0=ABN%LADD(INTYP)
                IHEAD=LHEAD(INTYP0)
                DO KNIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
! Set KNIONS.
                   KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(KNIONS.LE.ABN%NIONS) THEN
                      KNTYP0=ABN%LNTYP(KNIONS)
! Set LOCVAR_COL.
                      LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                      DO IXYZ=1, 3
#ifdef scaLAPACK
                         TIFOR_MB(IXYZ,KNIONS)=TIFOR_MB(IXYZ,KNIONS)+DDOT(FFM%NB(INTYP0),FORCE_HELP(1,3*(LOCVAR_COL-1)+IXYZ,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)
#else
                         TIFOR_MB(IXYZ,KNIONS)=TIFOR_MB(IXYZ,KNIONS)+DDOT(FFM%NB(INTYP0),FORCE_HELP(1,3*(LOCVAR_COL-1)+IXYZ,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)
#endif
                      ENDDO
                   ENDIF
                ENDDO
             ENDDO
             CALL MPI_ALLREDUCE(MPI_IN_PLACE,TIFOR_MB,3*ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
! Calculate stress.
             DO INTYP=1, ABN%NTYP
                INTYP0=ABN%LADD(INTYP)
                IHEAD=LHEAD(INTYP0)
                KXYZ=0
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      KXYZ=KXYZ+1
#ifdef scaLAPACK
                      TSIF_MB(JXYZ,IXYZ)=TSIF_MB(JXYZ,IXYZ)+DDOT(FFM%NB(INTYP0),STRESS_HELP(1,KXYZ,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)
#else
                      TSIF_MB(JXYZ,IXYZ)=TSIF_MB(JXYZ,IXYZ)+DDOT(FFM%NB(INTYP0),STRESS_HELP(1,KXYZ,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)
#endif
                   ENDDO
                ENDDO 
             ENDDO
! Symmetrization of stress tensor.
             DO IXYZ=1, 2
                DO JXYZ=IXYZ+1, 3
                   TSIF_MB(IXYZ,JXYZ)=TSIF_MB(JXYZ,IXYZ)
                ENDDO
             ENDDO
! Calculate atomic energies, if necessary.
             IF(FFM%LHEAT.OR.FFM%LEATOM.OR.FFM%LCOUPLE) THEN
! Initialization.
                ABN%EATOM_POT(1:ABN%NIONS)=0.0_q
                ABN%EATOM_KIN(1:ABN%NIONS)=0.0_q
! Drift term in forces.
                DRIFT(1:3)=0.0_q
                DO INIONS=1, ABN%NIONS
                   DO IXYZ=1, 3
                      DRIFT(IXYZ)=DRIFT(IXYZ)+TIFOR_MB(IXYZ,INIONS)
                   ENDDO
                ENDDO
                DRIFT(1:3)=-DRIFT(1:3)/REAL(ABN%NIONS,q)
! Renew the velocities by using the calculated forces.
                DO INTYP=1, ABN%NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO INITYP=1, ABN%NITYP(INTYP0)
                      INIONS=ABN%LNIONS(INITYP,INTYP0)
                      DO IXYZ=1, 3
                         VEL(IXYZ,INIONS)=VEL(IXYZ,INIONS)+5E-01_q*(TIFOR_MB(IXYZ,INIONS)+DRIFT(IXYZ))/ABN%POMASS(INTYP0)*ABN%POTIM
                      ENDDO
                   ENDDO
                ENDDO
! Calculate the atomic energies.
                DO INTYP=1, ABN%NTYP
                   INTYP0=ABN%LADD(INTYP)
                   IHEAD=LHEAD(INTYP0)
                   DO INITYP_TMP=1, ABN%NITYP(INTYP0), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                      INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                      IF(INITYP.LE.ABN%NITYP(INTYP0)) THEN
                         LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         INIONS=ABN%LNIONS(INITYP,INTYP0)
                         IF(FFM%ISCALE_TOTEN.EQ.1) THEN
#ifdef scaLAPACK
                            ABN%EATOM_POT(INIONS)=DDOT(FFM%NB(INTYP0),EATOM_HELP(1,LOCVAR_COL,INTYP0),1,FFM%WMAT_ALL(IHEAD),1) +FF%EATOM_REF(INTYP0)
#else
                            ABN%EATOM_POT(INIONS)=DDOT(FFM%NB(INTYP0),EATOM_HELP(1,LOCVAR_COL,INTYP0),1,FFM%WMAT(1,1,INTYP0),1) +FF%EATOM_REF(INTYP0)
#endif
                         ELSE IF(FFM%ISCALE_TOTEN.EQ.2) THEN
#ifdef scaLAPACK
                            ABN%EATOM_POT(INIONS)=DDOT(FFM%NB(INTYP0),EATOM_HELP(1,LOCVAR_COL,INTYP0),1,FFM%WMAT_ALL(IHEAD),1)+FF%EATOM_REF(INTYP0) +FFM%TOTENAV
#else
                            ABN%EATOM_POT(INIONS)=DDOT(FFM%NB(INTYP0),EATOM_HELP(1,LOCVAR_COL,INTYP0),1,FFM%WMAT(1,1,INTYP0),1)+FF%EATOM_REF(INTYP0)+FFM%TOTENAV
#endif
                         ENDIF
                         DO IXYZ=1, 3
                            ABN%EATOM_KIN(INIONS)=ABN%EATOM_KIN(INIONS)+5E-01_q*ABN%POMASS(INTYP0)*VEL(IXYZ,INIONS)**2
                         ENDDO
                      ENDIF
                   ENDDO
                ENDDO
                CALL MPI_ALLREDUCE (MPI_IN_PLACE,ABN%EATOM_POT,ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                CALL MPI_ALLREDUCE (MPI_IN_PLACE,ABN%EATOM_KIN,ABN%NIONS,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
             ENDIF
! If FFM%LCOUPLE=.TRUE., calculate the derivative of the Hamiltonian with respect to the coupling parameter.
             IF(FFM%LCOUPLE) THEN
                DO INIONS=1, FFM%NATOM_COUPLED
                   INTYP0=ABN%LNTYP (FFM%ICOUPLE(INIONS))
                   FFM%DHDRCOUPLE=FFM%DHDRCOUPLE+ABN%EATOM_POT(FFM%ICOUPLE(INIONS))-FF%EATOM_REF(INTYP0)
                ENDDO
             ENDIF
! Calculate heat flux, if necessary.
             IF(FFM%LHEAT) THEN
! Initialization of heat flux.
                QHEAT=0.0_q
! Calculations of interaction heat flux.
                IF(FFM%W1.GT.0.0_q) THEN
                   DO IXYZ=1, 3
                      DO KNIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                         KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                         IF(KNIONS.LE.ABN%NIONS) THEN
                            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                            KNTYP0=ABN%LNTYP(KNIONS)
                            DO INTYP=1, ABN%NTYP
                               INTYP0=ABN%LADD(INTYP)
                               DO JXYZ=1, 3
                                  IF(.NOT.FFM%LSUPERVEC) THEN
                                     NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
                                  ELSE
                                     NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
                                  ENDIF
                                  DO INEIB=1, NNEIB_EST_DUMMY+1

                                     IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                                        VEC_LOC_HEAT1(INEIB,1)=0.0_q
                                     ELSE
                                        IF(.NOT.FFM%LSUPERVEC) THEN
                                           INIONS=LNIONS_EST1(INEIB,INTYP0,LOCVAR_COL) 
                                           VEC_LOC_HEAT1(INEIB,1)=-XYZ_EST1(IXYZ,INEIB,INTYP0,LOCVAR_COL)*VEL(JXYZ,KNIONS)*FFM%RCOUPLE_IONS(INIONS)
                                        ELSE
                                           INIONS=LNIONS_EST_MAX(INEIB,INTYP0,LOCVAR_COL)
                                           VEC_LOC_HEAT1(INEIB,1)=-XYZ_EST_MAX(IXYZ,INEIB,INTYP0,LOCVAR_COL)*VEL(JXYZ,KNIONS)*FFM%RCOUPLE_IONS(INIONS)
                                        ENDIF
                                     ENDIF
                                  ENDDO
                                  QHEAT(IXYZ)=QHEAT(IXYZ)+DDOT(NNEIB_EST_DUMMY+1,HEAT_HELP1(1,INTYP0,LOCVAR_COL,JXYZ),1,VEC_LOC_HEAT1(1,1),1)
                               ENDDO
                            ENDDO
                         ENDIF
                      ENDDO
                   ENDDO
                ENDIF
                IF(FFM%W2.GT.0.0_q) THEN
                   DO IXYZ=1, 3
                      DO KNIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                         KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                         IF(KNIONS.LE.ABN%NIONS) THEN
                            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                            KNTYP0=ABN%LNTYP(KNIONS)
                            DO INTYP=1, ABN%NTYP
                               INTYP0=ABN%LADD(INTYP)
                               DO JXYZ=1, 3
                                  IF(.NOT.FFM%LSUPERVEC) THEN
                                     NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
                                  ELSE
                                     NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
                                  ENDIF
                                  DO INEIB=1, NNEIB_EST_DUMMY+1
                                     IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                                        VEC_LOC_HEAT2(INEIB,1)=0.0_q
                                     ELSE
                                        IF(.NOT.FFM%LSUPERVEC) THEN
                                           INIONS=LNIONS_EST2(INEIB,INTYP0,LOCVAR_COL)
                                           VEC_LOC_HEAT2(INEIB,1)=-XYZ_EST2(IXYZ,INEIB,INTYP0,LOCVAR_COL)*VEL(JXYZ,KNIONS)*FFM%RCOUPLE_IONS(INIONS)
                                        ELSE
                                           INIONS=LNIONS_EST_MAX(INEIB,INTYP0,LOCVAR_COL)
                                           VEC_LOC_HEAT2(INEIB,1)=-XYZ_EST_MAX(IXYZ,INEIB,INTYP0,LOCVAR_COL)*VEL(JXYZ,KNIONS)*FFM%RCOUPLE_IONS(INIONS)
                                        ENDIF
                                     ENDIF
                                  ENDDO
                                  QHEAT(IXYZ)=QHEAT(IXYZ)+DDOT(NNEIB_EST_DUMMY+1,HEAT_HELP2(1,INTYP0,LOCVAR_COL,JXYZ),1,VEC_LOC_HEAT2(1,1),1)
                               ENDDO
                            ENDDO
                         ENDIF
                      ENDDO
                   ENDDO
                ENDIF
! Calculations of convection heat flux.
                DO IXYZ=1, 3
                   DO KNIONS_TMP=1, ABN%NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                      KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                      IF(KNIONS.LE.ABN%NIONS) THEN
                         QHEAT(IXYZ)=QHEAT(IXYZ) +(ABN%EATOM_KIN(KNIONS)+ABN%EATOM_POT(KNIONS))*VEL(IXYZ,KNIONS)
                      ENDIF
                   ENDDO
                ENDDO
! Then, allreduce the flux.
                CALL MPI_ALLREDUCE (MPI_IN_PLACE,QHEAT,3,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
             ENDIF
! Deallocate helping arrays for heat flux
             IF(FFM%LHEAT) THEN
                IF(FFM%W1.GT.0.0_q) THEN
                   DEALLOCATE(VEC_LOC_HEAT1)
                ENDIF
                IF(FFM%W2.GT.0.0_q) THEN
                   DEALLOCATE(VEC_LOC_HEAT2)
                ENDIF
             ENDIF
          ELSE
             TOTEN_MB=0.0_q
             TIFOR_MB=0.0_q
             TSIF_MB=0.0_q
             IF(FFM%LEATOM.OR.FFM%LHEAT.OR.FFM%LCOUPLE) THEN
                ABN%EATOM_KIN=0.0_q
                ABN%EATOM_POT=0.0_q
             ENDIF
             IF(FFM%LHEAT) THEN
                QHEAT=0.0_q
             ENDIF
          ENDIF
! Stop profiling
          PROFILING_STOP ('zmat_new_mb')
        END SUBROUTINE ZMAT_NEW_MB


!------------------------------------------------------------------------------------------------------------------
! Bayesian error estimation within fast version method.
! Bayesian error is calculated for the dimensionless energy, force and stress tensor.
! In this method, the Bayesian errors are calculated by using covariance matrix owned by all processes.
! No scaLAPACK is used.
!------------------------------------------------------------------------------------------------------------------
        SUBROUTINE BAYES_ERR(ABN,PAR_SUP_HANDLE,FF,FFM, &
                   MROW_ENERGY_HELP,MROW_FORCE_HELP,MROW_STRESS_HELP,NCONF,NCONF_SYS,NIONS,NTYP, &
                   MCOL_MIONS,ENERGY_HELP,FORCE_HELP,RMEM_HELP1,STRESS_HELP,BE)
          USE ML_FF_STRUCT, ONLY : ABINITIONEW, PARALLEL_SUPER, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input and output variables
          TYPE (ABINITIONEW)    :: ABN
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER, INTENT(IN)   :: MROW_ENERGY_HELP
          INTEGER, INTENT(IN)   :: MROW_FORCE_HELP
          INTEGER, INTENT(IN)   :: MROW_STRESS_HELP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NCONF_SYS
          INTEGER, INTENT(IN)   :: NIONS
          INTEGER, INTENT(IN)   :: NTYP
          INTEGER, INTENT(IN)   :: MCOL_MIONS
          REAL(q), INTENT(INOUT)  :: ENERGY_HELP(:,:,:) !(1:MROW_ENERGY_HELP,1:MCOL_ENERGY_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: FORCE_HELP(:,:,:) !(1:MROW_FORCE_HELP,1:MCOL_FORCE_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: STRESS_HELP(:,:,:) !(1:MROW_STRESS_HELP,1:MCOL_STRESS_HELP,1:MTYP)
          REAL(q), INTENT(INOUT)  :: RMEM_HELP1
          REAL(q), INTENT(INOUT)  :: BE(:) !(3*MIONS+7)
! Local variables
          REAL(q), ALLOCATABLE  :: BE_ENERGY(:,:)
          REAL(q), ALLOCATABLE  :: BE_FORCE(:,:)
          REAL(q), ALLOCATABLE  :: BE_STRESS(:,:)
          REAL(q)               :: EPS
          INTEGER               :: IERR
          INTEGER               :: INIONS
          INTEGER               :: INTYP
          INTEGER               :: INTYP0
          INTEGER               :: IXYZ
          INTEGER               :: IXYZ_TMP
          INTEGER               :: KNIONS
          INTEGER               :: KNIONS_TMP
          INTEGER               :: KXYZ
          INTEGER               :: LOCVAR_COL
          INTEGER               :: MCOL_BE_ENERGY
          INTEGER               :: MCOL_BE_FORCE
          INTEGER               :: MCOL_BE_STRESS
          INTEGER               :: MROW_BE_ENERGY
          INTEGER               :: MROW_BE_FORCE
          INTEGER               :: MROW_BE_STRESS
          INTEGER               :: MCOL_MIONS_LOC
          INTEGER               :: MCOL_MIONS_ENERGY
          INTEGER               :: COUNTER
          INTEGER               :: NODE_ME_LOC
          REAL(q)               :: SIGMA(1:10)
! LAPACK routine.
          REAL(q) :: DDOT

          PROFILING_START('bayes_err')
! Calculate sizes of helping arrays for energy, forces and stress
          CALL SET_SIZE_HELPING_ARRAYS_BAYES_ERR
! Allocate helping arrays for energy, forces and stress
          CALL ALLOCATE_ARRAYS_BAYES_ERR
! If FF%LMLONLY=.TRUE. and FF%IERR.LT.1, the error estimation is skipped to accerelate the ML-MD
          IF((FF%LMLONLY).AND.(FF%IERR.LT.1)) THEN
             BE=0E0_q
! Otherwise, calculate the errors.
          ELSE
! Constant
             EPS=1E-10_q
! Determine the scaling parameter for energy.
! If FF%IWEIGHT=1, set SIGMA as constant, FF%WTOTEN, read from INCAR file.
             IF(FF%IWEIGHT.EQ.1) THEN
                SIGMA(1)=FF%WTOTEN
! If FF%IWEIGHT=2, set SIGMA as variance in TOTEN in ab initio data for all systems.
             ELSE IF(FF%IWEIGHT.EQ.2) THEN
                IF(FFM%SIG(1).GT.EPS) THEN
                   SIGMA(1)=FFM%SIG(1)/FF%WTOTEN
                ELSE
                   SIGMA(1)=5.0E-3_q
                ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in TOTEN in ab initio data for individual system.
             ELSE IF(FF%IWEIGHT.EQ.3) THEN
                IF(FFM%SIG(1).GT.EPS) THEN
                   SIGMA(1)=FFM%SIG(1)/FF%WTOTEN
                ELSE
                   SIGMA(1)=5.0E-3_q
                ENDIF
! If FF%IWEIGHT=4, set SIGMA as variance in TOTEN in ab initio data for all systems.
! The number of structure datasets are taken into account.
             ELSE IF(FF%IWEIGHT.EQ.4) THEN
                IF(FFM%SIG(1).GT.EPS) THEN
                   IF(NCONF_SYS.GT.0) THEN
                      SIGMA(1)=FFM%SIG(1)/FF%WTOTEN*SQRT(REAL(NCONF_SYS,q)/REAL(NCONF,q))
                   ELSE
                      SIGMA(1)=FFM%SIG(1)/FF%WTOTEN
                   ENDIF
                ELSE
                   SIGMA(1)=5.0E-3_q
                ENDIF
! If FF%IWEIGHT=5, set SIGMA as variance in TOTEN in ab initio data for individual system.
! The number of structure datasets are taken into account.
             ELSE IF(FF%IWEIGHT.EQ.5) THEN
                IF(FFM%SIG(1).GT.EPS) THEN
                   IF(NCONF_SYS.GT.0) THEN
                      SIGMA(1)=FFM%SIG(1)/FF%WTOTEN*SQRT(REAL(NCONF_SYS,q)/REAL(NCONF,q))
                   ELSE
                      SIGMA(1)=FFM%SIG(1)/FF%WTOTEN
                   ENDIF
                ELSE
                   SIGMA(1)=5.0E-3_q
                ENDIF
             ENDIF
! Determine the scaling parameter for forces.
             DO IXYZ=1, 3
! If FF%IWEIGHT=1, set SIGMA as constant, FF%WTIFOR, read from INCAR file.
                IF(FF%IWEIGHT.EQ.1) THEN
                   SIGMA(IXYZ+1)=FF%WTIFOR
! If FF%IWEIGHT=2, set SIGMA as variance in TIFOR in ab initio data for all systems.
                ELSE IF(FF%IWEIGHT.EQ.2) THEN
                   IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                      SIGMA(IXYZ+1)=FFM%SIG(IXYZ+1)/FF%WTIFOR
                   ELSE
                      SIGMA(IXYZ+1)=5.0E-2_q
                   ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in TIFOR in ab initio data for individual system.
                ELSE IF(FF%IWEIGHT.EQ.3) THEN
                   IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                      SIGMA(IXYZ+1)=FFM%SIG(IXYZ+1)/FF%WTIFOR
                   ELSE
                      SIGMA(IXYZ+1)=5.0E-2_q
                   ENDIF
! If FF%IWEIGHT=4, set SIGMA as variance in TIFOR in ab initio data for all systems.
! The number of structure datasets is taken into account.
                ELSE IF(FF%IWEIGHT.EQ.4) THEN
                   IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                      IF(NCONF_SYS.GT.0) THEN
                         SIGMA(IXYZ+1)=FFM%SIG(IXYZ+1)/FF%WTIFOR*SQRT(REAL(NCONF_SYS,q)/REAL(NCONF,q))
                      ELSE
                         SIGMA(IXYZ+1)=FFM%SIG(IXYZ+1)/FF%WTIFOR
                      ENDIF
                   ELSE
                      SIGMA(IXYZ+1)=5.0E-2_q
                   ENDIF
! If FF%IWEIGHT=5, set SIGMA as variance in TIFOR in ab initio data for individual system.
! The number of structure datasets is taken into accouint.
                ELSE IF(FF%IWEIGHT.EQ.5) THEN
                   IF(FFM%SIG(IXYZ+1).GT.EPS) THEN
                      IF(NCONF_SYS.GT.0) THEN
                         SIGMA(IXYZ+1)=FFM%SIG(IXYZ+1)/FF%WTIFOR*SQRT(REAL(NCONF_SYS,q)/REAL(NCONF,q))
                      ELSE
                         SIGMA(IXYZ+1)=FFM%SIG(IXYZ+1)/FF%WTIFOR
                      ENDIF
                   ELSE
                      SIGMA(IXYZ+1)=5.0E-2_q
                   ENDIF
                ENDIF
             ENDDO
! Determine the scaling factor for stress tensor.
             DO IXYZ=1, 6
! If FF%IWEIGHT=1, set SIGMA as constant, FF%WTSIF, read from INCAR file.
                IF(FF%IWEIGHT.EQ.1) THEN
                   SIGMA(IXYZ+4)=FF%WTSIF
! If FF%IWEIGHT=2, set SIGMA as variance in TSIF in ab initio data for all systems.
                ELSE IF(FF%IWEIGHT.EQ.2) THEN
                   IF(FFM%SIG(IXYZ+4) .GT. EPS) THEN
                      SIGMA(IXYZ+4)=FFM%SIG(IXYZ+4)/FF%WTSIF
                   ELSE
                      SIGMA(IXYZ+4)=5.0E0_q
                   ENDIF
! If FF%IWEIGHT=3, set SIGMA as variance in TSIF in ab initio data for individual system.
                ELSE IF(FF%IWEIGHT.EQ.3) THEN
                   IF(FFM%SIG(IXYZ+4).GT.EPS) THEN
                      SIGMA(IXYZ+4)=FFM%SIG(IXYZ+4)/FF%WTSIF
                   ELSE
                      SIGMA(IXYZ+4)=5.0E0_q
                   ENDIF
! If FF%IWEIGHT=4, set SIGMA as variance in TSIF in ab initio data for all systems.
! The number of structure datasets is taken into account.
                ELSE IF(FF%IWEIGHT.EQ.4) THEN
                   IF(FFM%SIG(IXYZ+4).GT.EPS) THEN
                      IF(NCONF_SYS.GT.0) THEN
                         SIGMA(IXYZ+4)=FFM%SIG(IXYZ+4)/FF%WTSIF*SQRT(REAL(NCONF_SYS,q)/REAL(NCONF,q))
                      ELSE
                         SIGMA(IXYZ+4)=FFM%SIG(IXYZ+4)/FF%WTSIF
                      ENDIF
                   ELSE
                      SIGMA(IXYZ+4)=5.0E0_q
                   ENDIF
! If FF%IWEIGHT=5, set SIGMA as variance in TSIF in ab initio data for individual system.
! The number of structure datasets is taken into account.
                ELSE IF(FF%IWEIGHT.EQ.5) THEN
                   IF(FFM%SIG(IXYZ+4).GT.EPS) THEN
                      IF(NCONF_SYS.GT.0) THEN
                         SIGMA(IXYZ+4)=FFM%SIG(IXYZ+4)/FF%WTSIF*SQRT(REAL(NCONF_SYS,q)/REAL(NCONF,q))
                      ELSE
                         SIGMA(IXYZ+4)=FFM%SIG(IXYZ+4)/FF%WTSIF
                      ENDIF
                   ELSE
                      SIGMA(IXYZ+4)=5.0E0_q
                   ENDIF
                ENDIF
             ENDDO
! If FF%IFF=.TRUE., calculate the errors using the existing force field.
             IF(FF%IFF) THEN
! Scale the design matrix
! Scale energy components.
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   IF (FF%LTOTEN_SYSTEM) THEN
                      ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)=ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)/SIGMA(1)
                   ELSE
                      ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)=ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)/SIGMA(1)/REAL(NIONS,q)
                   ENDIF
                ENDDO
! Scale force components.
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO KNIONS_TMP=1, NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
! Set KNIONS.
                      KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                      IF(KNIONS.LE.NIONS) THEN
! Set LOCVAR_COL.
                         LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         DO IXYZ=1, 3
                            FORCE_HELP(1:FFM%NB(INTYP0),3*(LOCVAR_COL-1)+IXYZ,INTYP0)=&
                                       FORCE_HELP(1:FFM%NB(INTYP0),3*(LOCVAR_COL-1)+IXYZ,INTYP0)/SIGMA(IXYZ+1)
                         ENDDO
                      ENDIF
                   ENDDO
                ENDDO
! Scale stress components.
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO KXYZ=1, 6
                      STRESS_HELP(1:FFM%NB(INTYP0),KXYZ,INTYP0)=STRESS_HELP(1:FFM%NB(INTYP0),KXYZ,INTYP0)/SIGMA(KXYZ+4)
                   ENDDO
                ENDDO
! Calculate errors by Bayesian error estimation method
! Energy component.
                BE_ENERGY(1:FFM%NBTOT,1)=0.0_q

                ! Force components.
                DO KNIONS_TMP=1, NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                   KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                   IF(KNIONS.LE.NIONS) THEN
                      LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                      DO IXYZ=1, 3
                         BE_FORCE(1:FFM%NBTOT,3*(LOCVAR_COL-1)+IXYZ)=0.0_q
                      ENDDO
                   ENDIF
                ENDDO

                MCOL_MIONS_LOC = 3 * MCOL_MIONS
                IF ( PAR_SUP_HANDLE%COMM_WORLD%NODE_ME .EQ. 0 ) then
                   MCOL_MIONS_LOC  =  MCOL_MIONS_LOC + 1
                END IF
                MCOL_MIONS_ENERGY = MCOL_MIONS_LOC


                NODE_ME_LOC = PAR_SUP_HANDLE%COMM_WORLD%NODE_ME - 1
                IF ( PAR_SUP_HANDLE%COMM_WORLD%NODE_ME .EQ. 0 ) THEN
                   NODE_ME_LOC = PAR_SUP_HANDLE%COMM_WORLD%NCPU - 1
                   DO INTYP=1, NTYP
                       !FORCE_HELP( 1:, MCOL_MIONS_LOC, : ) = 0.0_q
                      INTYP0=ABN%LADD(INTYP)
                      FORCE_HELP( 1:FFM%NB(INTYP0), MCOL_MIONS_LOC, INTYP0 ) = &
                                               ENERGY_HELP( 1:FFM%NB(INTYP0), 1, INTYP0 )
                   END DO
                   BE_FORCE( 1:FFM%NBTOT, MCOL_MIONS_LOC ) = 0.0_q
                END IF

                !! fill the stress help to force help 
                DO INTYP=1, NTYP
                   FORCE_HELP( : , MCOL_MIONS_LOC+1 : , INTYP )  =  0.0_q
                   INTYP0=ABN%LADD(INTYP)
                   COUNTER = 0
                   DO IXYZ_TMP = 1, 6, PAR_SUP_HANDLE%COMM_WORLD%NCPU 
                      IXYZ = IXYZ_TMP + NODE_ME_LOC
                      IF ( IXYZ .LE. 6 ) THEN
                         COUNTER  =  COUNTER + 1
                         FORCE_HELP( 1:FFM%NB(INTYP0), MCOL_MIONS_LOC+COUNTER, INTYP0 ) = &
                                              STRESS_HELP( 1:FFM%NB(INTYP0), IXYZ , INTYP0 )
                      END IF
                   ENDDO
                ENDDO
                MCOL_MIONS_LOC = MCOL_MIONS_LOC + COUNTER
                BE_FORCE( :, MCOL_MIONS_ENERGY : MCOL_MIONS_LOC ) = 0.0_q

                DO INTYP = 1, NTYP
                   INTYP0 = ABN%LADD( INTYP )
#ifdef scaLAPACK
                   CALL DGEMM( 'N','N', FFM%NBTOT, MCOL_MIONS_LOC, FFM%NB(INTYP0), 1.0_q,&
                                FFM%CMAT_ALL( 1, 1+FFM%LBHEAD( INTYP0 )), FFM%MBTOT, &
                                FORCE_HELP(1,1,INTYP0), MROW_FORCE_HELP, 1.0_q,&
                                BE_FORCE(1,1), FFM%MBTOT )
#else
                   CALL DGEMM( 'N','N', FFM%NBTOT, MCOL_MIONS_LOC, FFM%NB(INTYP0),1.0_q,&
                                FFM%CMAT(1,1+FFM%LBHEAD(INTYP0)), FFM%MBTOT, &
                                FORCE_HELP(1,1,INTYP0), MROW_FORCE_HELP, 1.0_q,&
                                BE_FORCE(1,1), FFM%MBTOT )
#endif
                ENDDO
                BE(2:3*NIONS+1)=0.0_q
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO KNIONS_TMP=1, NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                      KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                      IF(KNIONS.LE.NIONS) THEN
                         LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         DO IXYZ=1, 3
                            BE(3*(KNIONS-1)+IXYZ+1)=BE(3*(KNIONS-1)+IXYZ+1)+ &
                            DDOT( FFM%NB(INTYP0),FORCE_HELP(1,3*(LOCVAR_COL-1)+IXYZ,INTYP0),&
                                  1,BE_FORCE(1+FFM%LBHEAD(INTYP0),3*(LOCVAR_COL-1)+IXYZ),1 )
                         ENDDO
                      ENDIF
                   ENDDO
                ENDDO
                
                CALL MPI_ALLREDUCE( MPI_IN_PLACE,BE(2),&
                                    3*NIONS,MPI_REAL8,MPI_SUM,&
                                    PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR )

                ! energy Bayes error
                BE(1)=0.0_q
                IF ( PAR_SUP_HANDLE%COMM_WORLD%NODE_ME .EQ. 0 ) THEN
                   DO INTYP=1, NTYP
                      INTYP0=ABN%LADD(INTYP)
                      BE(1)=BE(1)+DDOT( FFM%NB(INTYP0), &
                                        FORCE_HELP( 1, MCOL_MIONS_ENERGY , INTYP0),&
                                        1,BE_FORCE(1+FFM%LBHEAD(INTYP0), MCOL_MIONS_ENERGY ), 1 )
                   ENDDO
                END IF
                
                IF (FF%LTOTEN_SYSTEM) THEN
                   BE(1)=BE(1)*(SIGMA(1))**2
                ELSE
                   BE(1)=BE(1)*(SIGMA(1)*REAL(NIONS,q))**2
                ENDIF

                DO KNIONS=1, NIONS
                   DO IXYZ=1, 3
                      BE(3*(KNIONS-1)+IXYZ+1)=BE(3*(KNIONS-1)+IXYZ+1)*(SIGMA(IXYZ+1))**2
                   ENDDO
                ENDDO
! Stress components.
                DO IXYZ=1, 6
                   BE_STRESS(1:FFM%NBTOT,IXYZ)=0.0_q
                ENDDO


                ! stress Bayes error
                BE(3*NIONS+2:3*NIONS+7)=0.0_q
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   COUNTER = 0
                   DO IXYZ_TMP = 1, 6, PAR_SUP_HANDLE%COMM_WORLD%NCPU 
                      IXYZ = IXYZ_TMP + NODE_ME_LOC
                      IF ( IXYZ .LE. 6 ) THEN
                         COUNTER  =  COUNTER + 1
                         BE(3*NIONS+IXYZ+1) = BE(3*NIONS+IXYZ+1) + &
                                DDOT( FFM%NB( INTYP0 ), &
                                      FORCE_HELP( 1,MCOL_MIONS_ENERGY + COUNTER, INTYP0 ), 1, &
                                      BE_FORCE( 1+FFM%LBHEAD(INTYP0), &
                                      MCOL_MIONS_ENERGY + COUNTER ), 1 )
                      END IF
                   ENDDO
                ENDDO
                CALL MPI_ALLREDUCE( MPI_IN_PLACE,BE(3*NIONS+2),&
                                    6,MPI_REAL8,MPI_SUM,&
                                    PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR )
                DO KXYZ=1, 6
                   BE(3*NIONS+KXYZ+1)=BE(3*NIONS+KXYZ+1)*(SIGMA(KXYZ+4))**2
                ENDDO
! Restore the original design matrix
! Restore energy components.
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)=ENERGY_HELP(1:FFM%NB(INTYP0),1,INTYP0)*SIGMA(1)*REAL(NIONS,q)
                ENDDO
! Restore force components.
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO KNIONS_TMP=1, NIONS, PAR_SUP_HANDLE%COMM_WORLD%NCPU
                      KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                      IF(KNIONS.LE.NIONS) THEN
                         LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                         DO IXYZ=1, 3
                            FORCE_HELP(1:FFM%NB(INTYP0),3*(LOCVAR_COL-1)+IXYZ,INTYP0)=FORCE_HELP(1:FFM%NB(INTYP0),3*(LOCVAR_COL-1)+IXYZ,INTYP0)*SIGMA(IXYZ+1)
                         ENDDO
                      ENDIF
                   ENDDO
                ENDDO
! Restore stress components.
                DO INTYP=1, NTYP
                   INTYP0=ABN%LADD(INTYP)
                   DO KXYZ=1, 6
                      STRESS_HELP(1:FFM%NB(INTYP0),KXYZ,INTYP0)=STRESS_HELP(1:FFM%NB(INTYP0),KXYZ,INTYP0)*SIGMA(KXYZ+4)
                   ENDDO
                ENDDO
! Otherwise, set the errors to be larger then the threshold.
             ELSE
                BE(1)=0.0_q
                DO INIONS=1, NIONS
                   DO IXYZ=1, 3
                      BE(3*(INIONS-1)+IXYZ+1)=1D2*(FF%CTIFOR)**2
                   ENDDO
                ENDDO
                DO IXYZ=1, 6
                   BE(3*NIONS+IXYZ+1)=0.0_q
                ENDDO
             ENDIF
          ENDIF
! Deallocate helping arrays for energy, forces and stress
          CALL DEALLOCATE_ARRAYS_BAYES_ERR
          PROFILING_STOP('bayes_err')

          CONTAINS

! Set sizes of helping arrays for energy, forces and stress
          SUBROUTINE SET_SIZE_HELPING_ARRAYS_BAYES_ERR
             IMPLICIT NONE
! Size of Bayesian error in energy.
             MROW_BE_ENERGY=FFM%MBTOT
             MCOL_BE_ENERGY=1
! Size of Bayesian error in force.
             MROW_BE_FORCE=FFM%MBTOT
             ! + 6 for stress tensor
             MCOL_BE_FORCE=3*MCOL_MIONS+6
! Size of Bayesian error in energy.
             MROW_BE_STRESS=FFM%MBTOT
             MCOL_BE_STRESS=6
          END SUBROUTINE SET_SIZE_HELPING_ARRAYS_BAYES_ERR

! Allocate necessary arrays for energy, forces and stress 
          SUBROUTINE ALLOCATE_ARRAYS_BAYES_ERR
             IMPLICIT NONE
             IF(ALLOCATED(BE_ENERGY)) THEN
                DEALLOCATE(BE_ENERGY)
             ENDIF
             ALLOCATE (BE_ENERGY(1:MROW_BE_ENERGY,1:MCOL_BE_ENERGY))
             BE_ENERGY = 0.0_q
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_BE_ENERGY,q)*REAL(MCOL_BE_ENERGY,q)*8/1.0E+06_q
             IF(ALLOCATED(BE_FORCE)) THEN
                DEALLOCATE(BE_FORCE)
             ENDIF
             ! + 1 for energy
             IF ( PAR_SUP_HANDLE%COMM_WORLD%NODE_ME .EQ. 0 ) then
                ALLOCATE( BE_FORCE( 1:MROW_BE_FORCE, 1:MCOL_BE_FORCE + 1 ) )
             ELSE
                ALLOCATE( BE_FORCE( 1:MROW_BE_FORCE, 1:MCOL_BE_FORCE ) )
             END IF
             BE_FORCE = 0.0_q
             RMEM_HELP1=RMEM_HELP1+REAL(MROW_BE_FORCE,q)*REAL(MCOL_BE_FORCE,q)*8/1.0E+06_q
             IF(ALLOCATED(BE_STRESS)) THEN
                DEALLOCATE(BE_STRESS)
             ENDIF
             ALLOCATE (BE_STRESS(1:MROW_BE_STRESS,1:MCOL_BE_STRESS))
             BE_STRESS = 0.0_q
          END SUBROUTINE ALLOCATE_ARRAYS_BAYES_ERR

! Deallocate necessary arrays for energy, forces and stress
          SUBROUTINE DEALLOCATE_ARRAYS_BAYES_ERR
             IMPLICIT NONE
             IF(ALLOCATED(BE_ENERGY)) THEN
                DEALLOCATE(BE_ENERGY)
             ENDIF
             IF(ALLOCATED(BE_FORCE)) THEN
                DEALLOCATE(BE_FORCE)
             ENDIF
             IF(ALLOCATED(BE_STRESS)) THEN
                DEALLOCATE(BE_STRESS)
             ENDIF 
          END SUBROUTINE DEALLOCATE_ARRAYS_BAYES_ERR
        
        END SUBROUTINE BAYES_ERR


!****************************************************************************************************
! Give energetic information from force field to VASP
!****************************************************************************************************
        SUBROUTINE GIVE_FROM_FF_TO_VASP (MIONS_ABN,OMEGA,TOTEN_ABN,TIFOR_ABN,TSIF_ABN,TOTEN,TIFOR,TSIF)
          IMPLICIT NONE
! Input variables
          INTEGER, INTENT(IN) :: MIONS_ABN
          REAL(q), INTENT(IN) :: OMEGA
          REAL(q), INTENT(IN) :: TIFOR_ABN(:,:) !(1:3,1:MIONS_ABN) ! Forces predicted by machine-learning force field
          REAL(q), INTENT(IN) :: TOTEN_ABN ! Energy predicted by machine-learning force field
          REAL(q), INTENT(IN) :: TSIF_ABN(:,:) !(1:3,1:3) ! Stress tensor predicted by machine-learning force field
! Output variables
          REAL(q), INTENT(OUT) :: TIFOR(:,:) !(1:3,1:MIONS_ABN) ! Forces predicted by machine-learning force field
          REAL(q), INTENT(OUT) :: TOTEN ! Energy predicted by machine-learning force field
          REAL(q), INTENT(OUT) :: TSIF(:,:) !(1:3,1:3) ! Stress tensor predicted by machine-learning force field
! Local variables
          REAL(q) FAKT
! Start profiling
          PROFILING_START('give_from_ff_to_vasp')
! Copy the data
!unit
          FAKT=EVTOJ*1D22/OMEGA/AUTOA**3
          TIFOR(1:3,1:MIONS_ABN)=TIFOR_ABN(1:3,1:MIONS_ABN)*FUNIT
          TOTEN=TOTEN_ABN*EUNIT
          TSIF(1:3,1:3)=TSIF_ABN(1:3,1:3)*SUNIT/FAKT
!unit
!          FAKT=EVTOJ*1D22/OMEGA/AUTOA**3
!          TIFOR(1:3,1:MIONS_ABN)=TIFOR_ABN(1:3,1:MIONS_ABN)
!          TOTEN=TOTEN_ABN
!          TSIF(1:3,1:3)=TSIF_ABN(1:3,1:3)
! Stop profiling
          PROFILING_STOP('give_from_ff_to_vasp')
        END SUBROUTINE GIVE_FROM_FF_TO_VASP

!****************************************************************************************************
! Store the maximum Bayesian error and change the criteria for it if
! necessary. This process is executed to resolve the problem written
! below.
! The accuracy of the generated force field is limitted by the quality
! of the descriptor. If the user specified criteria is set below the
! limitation, the machine continue to collect the ab initio data, but
! this does not improve the accuracy at all. To prevent this 
! operation, the limitation should be detected, and the criteria should
! be replaced by the limitation. 
! In the current algorithm, the Bayesian errors just after the force
! field generation are stored.  In the limit situation, the Bayesian
! error should converge to certain value. This convergence is detected
! by checking the variance in the collected Bayesian errors. If the
! variance is smaller than the user specified threshold, the machine
! judges that the limitation appears and replaces the criteria with the
! average of the stored Bayesian errors if the criteria is smaller than
! the average.
!****************************************************************************************************

        SUBROUTINE CHANGE_CRITERIA (COMM_WORLD,LOGF,FF,BEMAX,NIONS)
          USE ML_FF_STRUCT, ONLY: ML_MPI_PAR, LOG_PAR, FF_PAR
          IMPLICIT NONE
! Input variables
          TYPE (ML_MPI_PAR)      :: COMM_WORLD
          TYPE (LOG_PAR)      :: LOGF
          TYPE (FF_PAR)       :: FF
          REAL(q), INTENT(IN) :: BEMAX(:) !(1:3)
          INTEGER, INTENT(IN) :: NIONS
! Local variables
          REAL(q) :: A(1:2,1:2)
          REAL(q) :: B(1:2)
          REAL(q) :: C(1:2,1:2)
          REAL(q) :: BEAV
          REAL(q) :: BESIG
          REAL(q) :: BESL
          REAL(q) :: DET
          REAL(q) :: ERRSL
          REAL(q) :: ERRAV
          REAL(q) :: ERRSIG
          REAL(q) :: EPS
          INTEGER :: IHIS
          LOGICAL :: LCHANGE
          REAL(q) :: SAV
          REAL(q) :: SIGMA
          INTEGER :: NSTEP_TARGET
!gK quick hack
          INTEGER,SAVE :: ICALL = 0
          INTEGER, PARAMETER :: BE_HIST=400 ! do not believe playing with this changes things a lot
          REAL(q),SAVE :: BEMAX_LAST(BE_HIST)
          REAL(q),SAVE :: BEMAX_SLOPE=0
          REAL(q),SAVE :: BEMAX_AVERAGE=0
!end gK
          
          PROFILING_START('change_criteria')
! Update of Bayesian force theshold will be only done if FF%ICRITERIA>0
          IF(FF%ICRITERIA.GT.0) THEN
             EPS=1E-10_q
! Store the STIFOR in FF%ERRHIS if NSTEP_FROM_GENFF=1 and FF%IFF=.TRUE.
             IF (FF%IUPDATE_CRITERIA.EQ.1) THEN
                NSTEP_TARGET=0
             ELSE
                NSTEP_TARGET=1
             ENDIF
             IF((FF%NSTEP_FROM_GENFF .EQ. NSTEP_TARGET) .AND. (FF%IFF)) THEN
                IF(FF%NHIS .NE. FF%MHIS) THEN
                   FF%NHIS=FF%NHIS+1
                ENDIF
                DO IHIS=FF%NHIS-1, 1, -1
                   FF%BEHIS(IHIS+1)=FF%BEHIS(IHIS)
                   FF%ERRHIS(IHIS+1)=FF%ERRHIS(IHIS)
                ENDDO
                FF%BEHIS(1)=BEMAX(2)
                FF%ERRHIS(1)=FF%STIFOR_LAST
! Calculate the slope and variance of recent Bayesian errors to judge the convergence.
                IF(FF%NHIS .EQ. FF%MHIS) THEN
! Calculate the slope of the collected errors.
                   A(1:2,1:2)=0.0_q
                   DO IHIS=1, FF%NHIS
                      A(1,1)=A(1,1)+REAL((IHIS**2),q)
                      A(2,1)=A(2,1)+REAL(IHIS,q)
                      A(1,2)=A(1,2)+REAL(IHIS,q)
                      A(2,2)=A(2,2)+1.0_q
                   ENDDO
                   DET=A(1,1)*A(2,2)-A(1,2)*A(2,1)
                   IF(ABS(DET) .GT. EPS) THEN
                      C(1,1)= A(2,2)/DET
                      C(2,1)=-A(2,1)/DET
                      C(1,2)=-A(1,2)/DET
                      C(2,2)= A(1,1)/DET

! Calculate the variance of the collected errors
                      B(1:2)=0.0_q
                      DO IHIS=1, FF%NHIS
                         B(1)=B(1)+REAL(IHIS,q)*FF%ERRHIS(IHIS)
                         B(2)=B(2)+FF%ERRHIS(IHIS)
                      ENDDO
                      ERRSL=C(1,1)*B(1)+C(2,1)*B(2)
! Mean value of real error and variance of real error
                      ERRAV=SUM(FF%ERRHIS(1:FF%NHIS))/FF%NHIS
                      ERRSIG=0.0_q
                      DO IHIS=1, FF%NHIS
                         ERRSIG=ERRSIG+(FF%ERRHIS(IHIS)-ERRAV)**2/REAL(FF%NHIS,q)
                      ENDDO

                      B(1:2)=0.0_q
                      BEAV=0.0_q
                      DO IHIS=1, FF%NHIS
                         BEAV=BEAV+FF%BEHIS(IHIS)/REAL(FF%NHIS,q)
                         B(1)=B(1)+REAL(IHIS,q)*FF%BEHIS(IHIS)
                         B(2)=B(2)+FF%BEHIS(IHIS)
                      ENDDO
                      BESL=C(1,1)*B(1)+C(2,1)*B(2)
! Calculate the variance of the collected errors
                      BESIG=0.0_q
                      DO IHIS=1, FF%NHIS
                         BESIG=BESIG+(FF%BEHIS(IHIS)-BEAV)**2/REAL(FF%NHIS,q)
                      ENDDO
! If the slope and the variance are smaller than the criteria, change the criteria
                      FF%CTIFOR_PREV = FF%CTIFOR
                      LCHANGE=.FALSE.
                      IF (FF%ICRITERIA.EQ.1) THEN
                         IF((ABS(BESL)/ABS(BEAV) .LT. FF%CSLOPE) .AND. (SQRT(BESIG)/ABS(BEAV) .LT. FF%CSIG)) THEN
                            LCHANGE=.TRUE.
!gk
!                            FF%CTIFOR=(1.0_q-FF%CX)*FF%CTIFOR+FF%CX*BEAV
                            FF%CTIFOR=BEAV*(1.0+FF%CX)
                            ! Save sigma and slope for logging.
                            FF%CSIG_LOG = SQRT(BESIG) / ABS(BEAV)
                            ! BE history is ordered newest to oldest, so the
                            ! correct slope is -BESL!
                            FF%CSLOPE_LOG = -BESL / ABS(BEAV)
                            ! Log file output is activated here and is done later.
                            FF%LLOG_THRESHOLD_HISTORY = .TRUE.
                            FF%LLOG_THRESHOLD_UPDATE = .TRUE.
                         ENDIF
                      ENDIF
                   ENDIF
                ENDIF
             ENDIF
             IF (FF%ICRITERIA.EQ.2) THEN
! gK new criteria that is just based on the gliding average of the
! predicted Bayesian error, this is much more robust, since it sees
! many more data (currently it does not avoid "oversampling" though could be obtained by checking out slope
! store data, but only after at least NHIS learning steps have been performed
                IF (ICALL<BE_HIST .AND. FF%NHIS==FF%MHIS) THEN
                  ICALL=ICALL+1
                ENDIF
! move data in history
                DO IHIS=ICALL-1,1,-1
                  BEMAX_LAST(IHIS+1)=BEMAX_LAST(IHIS)
                ENDDO
                BEMAX_LAST(1)=BEMAX(2)
                IF (ICALL>2) THEN
                   CALL simple_lin_reg(BEMAX_LAST(1:ICALL), BEAV, BESL, BESIG)
                   IF (ICALL>=BE_HIST) THEN
                      ! use linear regression value 1/4 back into the history
                      ! this is similar to using the mean value of the BE_HIST/2 last values (but smoother)
                      FF%CTIFOR=(BEAV+BESL*ICALL/4)*(1.0+FF%CX)
                   ELSE IF (ICALL>=BE_HIST/2) THEN
                      ! mean value of yet stored history
                      FF%CTIFOR=(BEAV+BESL*ICALL/2)*(1.0+FF%CX)
                   ENDIF
                ENDIF
             ENDIF
          ENDIF
          PROFILING_STOP('change_criteria')
        END SUBROUTINE CHANGE_CRITERIA

        SUBROUTINE simple_lin_reg( data, b, m, r)
          REAL(q) :: data(:)
          REAL(q) :: b   !  y-intercept
          REAL(q) :: m   !  slope
          REAL(q) :: r   ! correlation coefficient
          REAL(q) :: sumx, sumx2, sumxy, sumy, sumy2, x, y
          INTEGER :: i, n

          sumx=0;  sumx2=0; sumxy=0; sumy=0; sumy2=0
          n=SIZE(data)
          
          DO i=1,n
            x=REAL(i,q)-1
            y=data(i)
            sumx  = sumx + x ! compute sum of x
            sumx2 = sumx2 + x * x ! compute sum of x**2
            sumxy = sumxy + x * y ! compute sum of x * y
            sumy  = sumy + y ! compute sum of y
            sumy2 = sumy2 + y * y
          ENDDO

          m = (n * sumxy  -  sumx * sumy) / (n * sumx2 - sumx**2) ! slope
          b = (sumy * sumx2  -  sumx * sumxy) / (n * sumx2  -  sumx**2) ! compute y-intercept
          r = (sumxy - sumx * sumy / n) / sqrt((sumx2 - sumx**2/n) * (sumy2 - sumy**2/n)) ! compute correlation coefficient
        END SUBROUTINE

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Calculate angular descriptors for new data
! Only copies of FFM%PS and FFM%C00 are parallelized by scaLAPACK
!****************************************************************************************************

        SUBROUTINE PUT_PS (TIM,PAR_SUP_HANDLE,LOGF,FF,FFM,BE,LADD,LB,LNIONS,LNTYP,MCONF,MCONF_NEW,MITYP,MIONS,MIONS_NEW,MTYP, &
                   NCONF,NCONF_NEW,NITYP,NIONS,NIONS_NEW,NSTEP_NEW,NTYP)
          USE ML_FF_STRUCT, ONLY: TIME, PARALLEL_SUPER, LOG_PAR, FF_PAR, FFM_PAR
          USE ml_ff_tutor, ONLY: ml_tutor, isError, STORAGE_LRC
          IMPLICIT NONE
! Input variables
          TYPE (TIME)            :: TIM
          TYPE (PARALLEL_SUPER)  :: PAR_SUP_HANDLE
          TYPE (LOG_PAR)         :: LOGF
          TYPE (FF_PAR)          :: FF
          TYPE (FFM_PAR)         :: FFM
          REAL(q), INTENT(IN)    :: BE(:,:) !(1:(3*MIONS_NEW+7),1:NCONF_NEW)
          INTEGER, INTENT(IN)    :: LADD(:,(NCONF+1):) !(1:MTYP,(NCONF+1):(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)    :: LNIONS(:,:,(NCONF+1):) !(1:MITYP,1:MTYP,(NCONF+1):(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)    :: LNTYP(:,(NCONF+1):) !(1:MIONS,(NCONF+1):(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)    :: MCONF
          INTEGER, INTENT(IN)    :: MCONF_NEW
          INTEGER, INTENT(IN)    :: MITYP
          INTEGER, INTENT(IN)    :: MIONS
          INTEGER, INTENT(IN)    :: MIONS_NEW
          INTEGER, INTENT(IN)    :: MTYP
          INTEGER, INTENT(IN)    :: NCONF
          INTEGER, INTENT(IN)    :: NCONF_NEW
          INTEGER, INTENT(IN)    :: NIONS
          INTEGER, INTENT(IN)    :: NIONS_NEW
          INTEGER, INTENT(IN)    :: NITYP(:,(NCONF+1):) !(1:MTYP,(NCONF+1):(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)    :: NSTEP_NEW(:) !(1:NCONF_NEW)
          INTEGER, INTENT(IN)    :: NTYP((NCONF+1):) !((NCONF+1):(NCONF+NCONF_NEW))
! Input/output data
          INTEGER, INTENT(INOUT) :: LB(:,(NCONF+1):) !(1:MIONS,(NCONF+1):(NCONF+NCONF_NEW))
! Local variables
          REAL(q)                :: CPUTIM0
          REAL(q)                :: CPUTIM1
          REAL(q)                :: EPS
          REAL(q)                :: ERR(1:MIONS_NEW,1:NCONF_NEW)
          INTEGER                :: IB
          INTEGER                :: ICONF
          INTEGER                :: IERR
          INTEGER                :: INIONS
          INTEGER                :: INTYP
          INTEGER                :: INTYP0
          INTEGER                :: INITYP
          INTEGER                :: IVAR
          INTEGER                :: IXYZ
          LOGICAL                :: LEXIT
          INTEGER                :: LFLAG_LOC
          INTEGER                :: NCONF_LOC
          INTEGER                :: NERR
          REAL(q)                :: VPUTIM0
          REAL(q)                :: VPUTIM1
#ifdef ML_DEBUG
          INTEGER                :: LFLAG_LOC_HELP
#endif
! Constant
          EPS=1E-10_q
! Start profiling
          PROFILING_START('put_ps')
! Measure the initial times
          CALL VTIME (VPUTIM0,CPUTIM0)
! Define the error.
          DO ICONF=1, NCONF_NEW
             DO INIONS=1, NIONS_NEW
                ERR(INIONS,ICONF)=SQRT(BE(3*(INIONS-1)+2,ICONF)+BE(3*(INIONS-1)+3,ICONF)+BE(3*(INIONS-1)+4,ICONF))
             ENDDO
          ENDDO
          IF(FF%LMLMB) THEN
             NCONF_LOC=NCONF
             FFM%NB_NEW=0
             DO ICONF=1, NCONF_NEW
                NCONF_LOC=NCONF_LOC+1
                DO INTYP=1, NTYP(NCONF_LOC)
                   INTYP0=LADD(INTYP,NCONF_LOC)
                   DO INITYP=1, NITYP(INTYP0,NCONF_LOC)
                      INIONS=LNIONS(INITYP,INTYP0,NCONF_LOC)
                      LFLAG_LOC=0
                      ! Here we introduce a variable FF%SCALE_CTIFOR which
                      ! controls the extent of selected local referenc configurations.
                      ! In the interval 0.0<FF%SCALE_CTIFOR<1.0 this variable leads
                      ! to a larger number of local reference configurations.
                      IF (ERR(INIONS,ICONF) .GT. FF%SCALE_CTIFOR*FF%CTIFOR) THEN
                         LFLAG_LOC=1
                      ENDIF
#ifdef ML_DEBUG
                      ! This is just a debugging option if everything goes south
                      LFLAG_LOC_HELP=0
                      CALL MPI_ALLREDUCE(LFLAG_LOC_HELP,LFLAG_LOC,1,MPI_INTEGER,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                      IF ((LFLAG_LOC*PAR_SUP_HANDLE%COMM_WORLD%NCPU).NE.LFLAG_LOC_HELP) THEN
                         CALL ml_tutor%bug("LFLAG_LOC is not identical on all MPI tasks in PUT_PS", __FILE__, __LINE__) 
                      ENDIF
#endif
                      ! We need to broadcast here to ensure LFLAG_LOC is the same on each core otherwise possible deadlocks can occur
                       CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,LFLAG_LOC,0)
                      IF(LFLAG_LOC .EQ. 1) THEN
                         FFM%NB_NEW(INTYP0)=FFM%NB_NEW(INTYP0)+1
                         FFM%LNCONF(FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0),INTYP0)=NCONF_LOC
                         FFM%LNIONS(FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0),INTYP0)=INIONS
                         LB(INIONS,NCONF_LOC)=FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0)
                         IF ((FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0)).GT.FFM%MB) THEN
                             CALL ml_tutor%write(isError, STORAGE_LRC)
                         ENDIF
                         IF(FFM%W1 .GT. 0.0_q) THEN
! Because column-dimension of FFM%C00_NEW is differently distributed from that of FFM%C00,
! PDCOPY is necessary even for the case of 1-dimensional scaLAPACK grid.
#ifdef scaLAPACK
                            CALL PDCOPY(FFM%NNVAR1,FFM%C00_NEW(1,1,INTYP0,ICONF),1,INITYP,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%DESC,1, &
                                 FFM%C00(1,1,INTYP0),1,FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0),PAR_SUP_HANDLE%DESC_C00_FFM%DESC,1)
! In the case of no-scaLAPACK version, just call DCOPY.
#else
                            CALL DCOPY (FFM%NNVAR1,FFM%C00_NEW(1,INITYP,INTYP0,ICONF),1,FFM%C00(1,FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0),INTYP0),1)
#endif
                         ENDIF
                         IF(FFM%W2 .GT. 0.0_q) THEN
! Because column-dimension of FFM%PS_NEW is differently distributed from that of FFM%C00,
! PDCOPY is necessary even for the case of 1-dimensional scaLAPACK grid.
#ifdef scaLAPACK
                            CALL PDCOPY(FFM%NNVAR2(INTYP0),FFM%PS_NEW(1,1,INTYP0,ICONF),1,INITYP,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%DESC,1, &
                                 FFM%PS(1,1,INTYP0),1,FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0),PAR_SUP_HANDLE%DESC_PS_FFM%DESC,1)
#else
! In the case of no-scaLAPACK version, just call DCOPY
                            CALL DCOPY (FFM%NNVAR2(INTYP0),FFM%PS_NEW(1,INITYP,INTYP0,ICONF),1,FFM%PS(1,FFM%NB_NEW(INTYP0)+FFM%NB(INTYP0),INTYP0),1)
#endif
                         ENDIF
                      ENDIF
                   ENDDO
                ENDDO
             ENDDO
          ENDIF
          CALL LOGLINE_LCONF(FF, FFM, LOGF)
! Measure the final time
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(4)=TIM%CPUTIM(4)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(4)=TIM%VPUTIM(4)+VPUTIM1-VPUTIM0
! Stop profiling
          PROFILING_STOP('put_ps')
        END SUBROUTINE PUT_PS
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Add list
! Not parallelized since all data is shared, and the operations are fast.
!****************************************************************************************************

        SUBROUTINE PUT_LIST (TIM,FF,FFM,LNTYP,MCONF,MCONF_NEW,MIONS,NCONF,NCONF_NEW,NIONS)
          USE ML_FF_STRUCT, ONLY: TIME, FF_PAR, FFM_PAR
          USE ml_ff_tutor, ONLY: ml_tutor
          IMPLICIT NONE
! Input variables
          TYPE (TIME)         :: TIM
          TYPE (FF_PAR)       :: FF
          TYPE (FFM_PAR)      :: FFM
          INTEGER, INTENT(IN) :: LNTYP(:,(NCONF+1):) !(1:MIONS,(NCONF+1):(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN) :: MCONF
          INTEGER, INTENT(IN) :: MCONF_NEW
          INTEGER, INTENT(IN) :: MIONS
          INTEGER, INTENT(IN) :: NCONF
          INTEGER, INTENT(IN) :: NCONF_NEW
          INTEGER, INTENT(IN) :: NIONS((NCONF+1):) !((NCONF+1):(NCONF+NCONF_NEW))
! Local variables
          REAL(q)             :: CPUTIM0
          REAL(q)             :: CPUTIM1
          INTEGER             :: ICONF
          INTEGER             :: INIONS
          INTEGER             :: INTYP
          INTEGER             :: INTYP0
          INTEGER             :: IXYZ
          INTEGER             :: JXYZ
          INTEGER             :: NCONF_LOC
          REAL(q)             :: VPUTIM0
          REAL(q)             :: VPUTIM1
! Start profiling
          PROFILING_START('put_list')
! Put list
! Record the initial time
          CALL VTIME (VPUTIM0,CPUTIM0)
          NCONF_LOC=NCONF
          DO ICONF=1, NCONF_NEW
             NCONF_LOC=NCONF_LOC+1
             FF%NTOTEN=FF%NTOTEN+1
             DO INIONS=1, NIONS(NCONF_LOC)
                DO IXYZ=1, 3
                   FF%NTIFOR=FF%NTIFOR+1
                ENDDO
             ENDDO
             DO IXYZ=1, 3
                DO JXYZ=IXYZ, 3
                   FF%NTSIF=FF%NTSIF+1
                ENDDO
             ENDDO
          ENDDO
          ! Check here if number of training structures exceeds FF%MCONF
          IF ((NCONF_LOC).GT.FF%MCONF) THEN
             CALL ml_tutor%error("Not enough storage reserved for &
                &reference structures, please increase ML_MCONF.")
          ENDIF
! Record the final time
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(1)=TIM%CPUTIM(1)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(1)=TIM%VPUTIM(1)+VPUTIM1-VPUTIM0
          IF(FF%LMLMB) THEN
             CALL VTIME (VPUTIM0,CPUTIM0)
             NCONF_LOC=NCONF
             DO ICONF=1, NCONF_NEW
                NCONF_LOC=NCONF_LOC+1
                FFM%NDATA=FFM%NDATA+1
                FFM%NTOTEN=FFM%NTOTEN+1
                FFM%LTOTEN(NCONF_LOC)=FFM%NDATA
                DO INIONS=1, NIONS(NCONF_LOC)
                   DO IXYZ=1, 3
                      FFM%NDATA=FFM%NDATA+1
                      FFM%NTIFOR=FFM%NTIFOR+1
                      FFM%LTIFOR(IXYZ,INIONS,NCONF_LOC)=FFM%NDATA
                   ENDDO
                ENDDO
                DO IXYZ=1, 3
                   DO JXYZ=IXYZ, 3
                      FFM%NDATA=FFM%NDATA+1
                      FFM%NTSIF=FFM%NTSIF+1
                      FFM%LTSIF(JXYZ,IXYZ,NCONF_LOC)=FFM%NDATA
                   ENDDO
                ENDDO
             ENDDO
! Record the final time
             CALL VTIME (VPUTIM1,CPUTIM1)
             TIM%CPUTIM(4)=TIM%CPUTIM(4)+CPUTIM1-CPUTIM0
             TIM%VPUTIM(4)=TIM%VPUTIM(4)+VPUTIM1-VPUTIM0
          ENDIF
! Stop profiling
          PROFILING_STOP('put_list')
        END SUBROUTINE PUT_LIST
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Add or calculate new SOAP matrix elements
! scaLAPACK-parallel
!****************************************************************************************************

        SUBROUTINE PUT_SOAP(TIM,PAR_SUP_HANDLE,MEM1,FF,FFM)
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: TIME, PARALLEL_SUPER, MEMORY, FF_PAR, FFM_PAR, ML_IO_WRITE
          IMPLICIT NONE
! Input variables
          TYPE (TIME)           :: TIM
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (MEMORY)         :: MEM1
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
! Local variables
          REAL(q)               :: CPUTIM0
          REAL(q)               :: CPUTIM1
          INTEGER               :: IB
          INTEGER               :: IERR
          INTEGER               :: INTYP0
          INTEGER               :: IPOLY
          INTEGER               :: IVAR
          INTEGER               :: JB
          INTEGER               :: JNTYP0
          INTEGER               :: KNTYP0
          INTEGER               :: LOCVAR_COL
          INTEGER               :: MCOL_SOAP
          INTEGER               :: MCOL_SOAP_TRANSPOSED
          INTEGER               :: MROW_SOAP
          INTEGER               :: MROW_SOAP_TRANSPOSED
          REAL(q)               :: RMEM_HELP
          REAL(q), ALLOCATABLE  :: SOAP1(:,:)
          REAL(q), ALLOCATABLE  :: SOAP2(:,:)
          REAL(q), ALLOCATABLE  :: SOAP3(:,:)
          REAL(q), ALLOCATABLE  :: SOAP4(:,:)
          INTEGER               :: TEST_COL
          REAL(q)               :: VPUTIM0
          REAL(q)               :: VPUTIM1
! Start profiling
          PROFILING_START('put_soap')
! Record the initial time
          CALL VTIME (VPUTIM0,CPUTIM0)
! Initialize the memory usage
! Allocate
          CALL ALLOCATE_SOAP_ARRAY
          DO INTYP0=1, FF%MTYP
             IF(FFM%NB_NEW(INTYP0).GT.0) THEN
! Calculate new SOAP matrix elements.
                IPOLY=0
                IF(FFM%W1 .GT. 0.0_q) THEN
#ifdef scaLAPACK
                   PROFILING_START('pdgemm_put_soap1')
                   CALL PDGEMM('T','N',FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0),FFM%NNVAR1,1.0_q, &
                        FFM%C00(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_C00_FFM%DESC, &
                        FFM%C00(1,1,INTYP0),1,FFM%NB(INTYP0)+1,PAR_SUP_HANDLE%DESC_C00_FFM%DESC, &
                        0.0_q,SOAP1(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_NEW%DESC)
                   CALL PDGEMM('T','N',FFM%NB_NEW(INTYP0),FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                        FFM%C00(1,1,INTYP0),1,FFM%NB(INTYP0)+1,PAR_SUP_HANDLE%DESC_C00_FFM%DESC, &
                        FFM%C00(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_C00_FFM%DESC, &
                        0.0_q,SOAP3(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%DESC)
                   PROFILING_STOP('pdgemm_put_soap1')
#else
                   PROFILING_START('dgemm_put_soap1')
                   CALL DGEMM ('T','N',FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0),FFM%NNVAR1,1.0_q, &
                        FFM%C00(1,1,INTYP0),FFM%MMVAR1,FFM%C00(1,FFM%NB(INTYP0)+1,INTYP0),FFM%MMVAR1,0.0_q,SOAP1(1,1),FFM%MB)
                   CALL DGEMM ('T','N',FFM%NB_NEW(INTYP0),FFM%NB(INTYP0),FFM%NNVAR1,1.0_q, &
                        FFM%C00(1,FFM%NB(INTYP0)+1,INTYP0),FFM%MMVAR1,FFM%C00(1,1,INTYP0),FFM%MMVAR1,0.0_q,SOAP3(1,1),FFM%MB_NEW)
                   PROFILING_STOP('dgemm_put_soap1')
#endif
                   PROFILING_START('poly_put_soap1')
                   CALL POLY_SOAP_INIT1 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_NEW,IPOLY,FFM%LSUPERVEC, &
                        MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0), &
                        FFM%NHYP1,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W1)
                   CALL POLY_SOAP_INIT1 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED,IPOLY, &
                        FFM%LSUPERVEC,MROW_SOAP_TRANSPOSED,MCOL_SOAP_TRANSPOSED,1,FFM%NB_NEW(INTYP0),FFM%NB(INTYP0), &
                        FFM%NHYP1,SOAP3(1:,1:),SOAP4(1:,1:),FFM%W1)
                   PROFILING_STOP('poly_put_soap1')
                   IPOLY=1
                ENDIF
                IF(FFM%W2 .GT. 0.0_q) THEN
#ifdef scaLAPACK
                   PROFILING_START('pdgemm_put_soap2')
                   CALL PDGEMM('T','N',FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        FFM%PS(1,1,INTYP0),1,FFM%NB(INTYP0)+1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        0.0_q,SOAP1(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_NEW%DESC)
                   CALL PDGEMM('T','N',FFM%NB_NEW(INTYP0),FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),1,FFM%NB(INTYP0)+1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        FFM%PS(1,1,INTYP0),1,1,PAR_SUP_HANDLE%DESC_PS_FFM%DESC, &
                        0.0_q,SOAP3(1,1),1,1,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%DESC)
                   PROFILING_STOP('pdgemm_put_soap2')
#else
                   PROFILING_START('dgemm_put_soap2')
                   CALL DGEMM ('T','N',FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS(1,1,INTYP0),FFM%MMVAR2,FFM%PS(1,FFM%NB(INTYP0)+1,INTYP0),FFM%MMVAR2, &
                        0.0_q,SOAP1(1,1),FFM%MB)
                   CALL DGEMM ('T','N',FFM%NB_NEW(INTYP0),FFM%NB(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                        FFM%PS(1,FFM%NB(INTYP0)+1,INTYP0),FFM%MMVAR2,FFM%PS(1,1,INTYP0),FFM%MMVAR2, &
                        0.0_q,SOAP3(1,1),FFM%MB_NEW)
                   PROFILING_STOP('dgemm_put_soap2')
#endif
                   PROFILING_START('poly_put_soap2')
                   CALL POLY_SOAP_INIT1 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_NEW,IPOLY,FFM%LSUPERVEC, &
                        MROW_SOAP,MCOL_SOAP,1,FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0), &
                        FFM%NHYP2,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W2)
                   CALL POLY_SOAP_INIT1 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED,IPOLY,FFM%LSUPERVEC,MROW_SOAP_TRANSPOSED, &
                        MCOL_SOAP_TRANSPOSED,1,FFM%NB_NEW(INTYP0),FFM%NB(INTYP0), &
                        FFM%NHYP2,SOAP3(1:,1:),SOAP4(1:,1:),FFM%W2)
                   PROFILING_STOP('poly_put_soap2')
                ENDIF
                IF(FFM%LSUPERVEC) THEN
                   PROFILING_START('pdgemm_soap_all_put_soap')
                   CALL POLY_SOAP_INIT2 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_NEW,MROW_SOAP,MCOL_SOAP, &
                        1,FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),FFM%NB_NEW(INTYP0),FFM%NHYP2,SOAP2(1:,1:))
                   CALL POLY_SOAP_INIT2 (PAR_SUP_HANDLE%CONTEXT_WORLD,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED, &
                        MROW_SOAP_TRANSPOSED,MCOL_SOAP_TRANSPOSED,1,FFM%NB_NEW(INTYP0),FFM%NB(INTYP0),FFM%NHYP2,SOAP4(1:,1:))
                   PROFILING_STOP('pdgemm_soap_all_put_soap')
                ENDIF
! Then, copy the new matrix elements into FFM%SOAP matrix.
#ifdef scaLAPACK
! Because the column dimension of SOAP2 is distributed in a manner different from that for FFM%SOAP,
! PDCOPY is necessary even for the case of 1-dimensional scaLAPACK grid.
                DO IB=1, FFM%NB_NEW(INTYP0)
                   PROFILING_START('pdcopy_put_soap')
                   CALL PDCOPY(FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),SOAP2(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_NEW%DESC,1, &
                        FFM%SOAP(1,1,INTYP0),1,IB+FFM%NB(INTYP0),PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
                   PROFILING_STOP('pdcopy_put_soap')
                ENDDO
! Because the column dimension of SOAP4 is distributed in an exactly same manner as that for FFM%SOAP,
! we can use DCOPY for 1-dimensional scaLAPACK grid.
                DO IB=1, FFM%NB(INTYP0)
                   IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.1) THEN
                      TEST_COL=MOD((IB-1)/PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                      IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.NE.TEST_COL) THEN
                         CYCLE
                      ENDIF
                      LOCVAR_COL=GLOBAL2LOCAL(IB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB)
                      PROFILING_START('dcopy_put_soap')
                      CALL DCOPY (FFM%NB_NEW(INTYP0),SOAP4(1,LOCVAR_COL),1,FFM%SOAP(FFM%NB(INTYP0)+1,LOCVAR_COL,INTYP0),1)
                      PROFILING_STOP('dcopy_put_soap')
                   ELSE IF(PAR_SUP_HANDLE%CONTEXT_WORLD%NDIM.EQ.2) THEN
                      PROFILING_START('pdcopy_put_soap')
                      CALL PDCOPY(FFM%NB_NEW(INTYP0),SOAP4(1,1),1,IB,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%DESC,1, &
                           FFM%SOAP(1,1,INTYP0),FFM%NB(INTYP0)+1,IB,PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,1)
                      PROFILING_STOP('pdcopy_put_soap')
                   ENDIF
                ENDDO
#else
                PROFILING_START('dcopy_put_soap')
                DO IB=1, FFM%NB_NEW(INTYP0)
                   CALL DCOPY (FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0),SOAP2(1,IB),1, &
                        FFM%SOAP(1,IB+FFM%NB(INTYP0),INTYP0),1)
                ENDDO
                DO IB=1, FFM%NB(INTYP0)
                   CALL DCOPY (FFM%NB_NEW(INTYP0),SOAP4(1,IB),1,FFM%SOAP(FFM%NB(INTYP0)+1,IB,INTYP0),1)
                ENDDO
                PROFILING_STOP('dcopy_put_soap')
#endif
             ENDIF
          ENDDO
! Deallocate
          CALL DEALLOCATE_SOAP_ARRAY
! Calculate the memory usage
          MEM1%RMEM(5)=MAX(MEM1%RMEM(5),RMEM_HELP)
! Record the final time
          CALL VTIME (VPUTIM1,CPUTIM1) 
          TIM%CPUTIM(5)=TIM%CPUTIM(5)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(5)=TIM%VPUTIM(5)+VPUTIM1-VPUTIM0
! Stop profiling
          PROFILING_STOP('put_soap')

          CONTAINS

          SUBROUTINE ALLOCATE_SOAP_ARRAY
            IMPLICIT NONE
            RMEM_HELP=0.0_q
! Declare size of arrays.
! Size of SOAP1 and SOAP2.
#ifdef scaLAPACK
            PAR_SUP_HANDLE%DESC_SOAP_NEW%M=FFM%MB
            PAR_SUP_HANDLE%DESC_SOAP_NEW%N=FFM%MB_NEW
            PAR_SUP_HANDLE%DESC_SOAP_NEW%MB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_SOAP_NEW%NB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_SOAP_NEW%IRSRC=0
            PAR_SUP_HANDLE%DESC_SOAP_NEW%ICSRC=0
            CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_SOAP_NEW%DESC,PAR_SUP_HANDLE%DESC_SOAP_NEW%M,PAR_SUP_HANDLE%DESC_SOAP_NEW%N, &
                 PAR_SUP_HANDLE%DESC_SOAP_NEW%MB,PAR_SUP_HANDLE%DESC_SOAP_NEW%NB,PAR_SUP_HANDLE%DESC_SOAP_NEW%IRSRC,PAR_SUP_HANDLE%DESC_SOAP_NEW%ICSRC, &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_NEW%LLD, &
                 PAR_SUP_HANDLE%DESC_SOAP_NEW%LOC_M,PAR_SUP_HANDLE%DESC_SOAP_NEW%LOC_N)
            MROW_SOAP=PAR_SUP_HANDLE%DESC_SOAP_NEW%LOC_M
            MCOL_SOAP=PAR_SUP_HANDLE%DESC_SOAP_NEW%LOC_N
#else
            MROW_SOAP=FFM%MB
            MCOL_SOAP=FFM%MB_NEW
#endif
! Size of SOAP3 and SOAP4.
#ifdef scaLAPACK
            PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%M=FFM%MB_NEW
            PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%N=FFM%MB
            PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%MB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%NB=NBLOCK_SCALAPACK
            PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%IRSRC=0
            PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%ICSRC=0
            CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%DESC,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%M,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%N, &
                 PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%MB,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%NB,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%IRSRC,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%ICSRC, &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                 PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%LLD, &
                 PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%LOC_M,PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%LOC_N)
            MROW_SOAP_TRANSPOSED=PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%LOC_M
            MCOL_SOAP_TRANSPOSED=PAR_SUP_HANDLE%DESC_SOAP_NEW_TRANSPOSED%LOC_N
#else
            MROW_SOAP_TRANSPOSED=FFM%MB_NEW
            MCOL_SOAP_TRANSPOSED=FFM%MB
#endif
! Then, allocate arrays.
            IF(ALLOCATED(SOAP1)) THEN
               DEALLOCATE(SOAP1)
            ENDIF
            ALLOCATE(SOAP1(1:MROW_SOAP,1:MCOL_SOAP))
            RMEM_HELP=RMEM_HELP+(REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8)/1.0E+06_q
            IF(ALLOCATED(SOAP2)) THEN
               DEALLOCATE(SOAP2)
            ENDIF
            ALLOCATE(SOAP2(1:MROW_SOAP,1:MCOL_SOAP))
            RMEM_HELP=RMEM_HELP+(REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8)/1.0E+06_q
            IF(ALLOCATED(SOAP3)) THEN
               DEALLOCATE(SOAP3)
            ENDIF
            ALLOCATE(SOAP3(1:MROW_SOAP_TRANSPOSED,1:MCOL_SOAP_TRANSPOSED))
            RMEM_HELP=RMEM_HELP+(REAL(MROW_SOAP_TRANSPOSED,q)*REAL(MCOL_SOAP_TRANSPOSED,q)*8)/1.0E+06_q
            IF(ALLOCATED(SOAP4)) THEN
               DEALLOCATE(SOAP4)
            ENDIF
            ALLOCATE(SOAP4(1:MROW_SOAP_TRANSPOSED,1:MCOL_SOAP_TRANSPOSED))
            RMEM_HELP=RMEM_HELP+(REAL(MROW_SOAP_TRANSPOSED,q)*REAL(MCOL_SOAP_TRANSPOSED,q)*8)/1.0E+06_q
          END SUBROUTINE ALLOCATE_SOAP_ARRAY

          SUBROUTINE DEALLOCATE_SOAP_ARRAY
            IMPLICIT NONE
            IF(ALLOCATED(SOAP1)) THEN
               DEALLOCATE(SOAP1)
            ENDIF
            IF(ALLOCATED(SOAP2)) THEN
               DEALLOCATE(SOAP2)
            ENDIF
            IF(ALLOCATED(SOAP3)) THEN
               DEALLOCATE(SOAP3)
            ENDIF
            IF(ALLOCATED(SOAP4)) THEN
               DEALLOCATE(SOAP4)
            ENDIF
          END SUBROUTINE DEALLOCATE_SOAP_ARRAY

        END SUBROUTINE PUT_SOAP
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Add or calculate new design matrix elements
!****************************************************************************************************

        SUBROUTINE PUT_FMAT (AB,TIM,PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM,A,B,LADD,LNIONS,LNITYP,LNTYP,MCONF, &
                   MCONF_NEW,MIONS,MITYP,MTYP,NCONF,NCONF_NEW,NIONS,NITYP,NTYP,OMEGA,POSION)
          USE NEIGHBOUR
          USE SOAP_KERNEL
          USE ML_FF_STRUCT, ONLY: ABINITIO, TIME, PARALLEL_SUPER, ML_SHMEM, MEMORY, FF_PAR, FFM_PAR 
          IMPLICIT NONE
! Input variables
          TYPE (ABINITIO)       :: AB
          TYPE (TIME)           :: TIM
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (MEMORY)         :: MEM1
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          REAL(q), INTENT(IN)   :: A(:,:,:) !(1:3,1:3,1:(NCONF+NCONF_NEW))
          REAL(q), INTENT(IN)   :: B(:,:,:) !(1:3,1:3,1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: LADD(:,:) !(1:AB%MTYP,1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: LNIONS(:,:,:) !(1:MITYP,1:AB%MTYP,1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: LNITYP(:,:) !(1:MIONS,1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: LNTYP(:,:) !(1:MIONS,1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: MCONF
          INTEGER, INTENT(IN)   :: MCONF_NEW
          INTEGER, INTENT(IN)   :: MIONS
          INTEGER, INTENT(IN)   :: MITYP
          INTEGER, INTENT(IN)   :: MTYP
          INTEGER, INTENT(IN)   :: NCONF
          INTEGER, INTENT(IN)   :: NCONF_NEW
          INTEGER, INTENT(IN)   :: NIONS(:) !(1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: NITYP(:,:) !(1:AB%MTYP,1:(NCONF+NCONF_NEW))
          INTEGER, INTENT(IN)   :: NTYP(:) !(1:(NCONF+NCONF_NEW))
          REAL(q), INTENT(IN)   :: OMEGA(:) !(1:(NCONF+NCONF_NEW))
          REAL(q), INTENT(IN)   :: POSION(:,:,:) !(1:3,1:MIONS,1:(NCONF+NCONF_NEW))
! Local variables
          REAL(q), ALLOCATABLE :: C00(:,:,:)
          REAL(q), ALLOCATABLE :: C00_COUPLE(:)
          REAL(q)              :: CPUTIM0
          REAL(q)              :: CPUTIM1
          REAL(q), ALLOCATABLE :: DC00(:,:,:,:)
          REAL(q), ALLOCATABLE :: DCLM1(:,:,:,:)
          REAL(q), ALLOCATABLE :: DCLM2(:,:,:,:)
          REAL(q), ALLOCATABLE :: DPS(:,:,:,:)
          REAL(q), ALLOCATABLE :: DPS_SIC(:,:,:,:)
          REAL(q), ALLOCATABLE :: DSOAP11(:,:)
          REAL(q), ALLOCATABLE :: DSOAP21(:,:,:)
          REAL(q), ALLOCATABLE :: DSOAP12(:,:)
          REAL(q), ALLOCATABLE :: DSOAP22(:,:,:)
          REAL(q), ALLOCATABLE :: ENERGY_HELP(:)
          REAL(q), ALLOCATABLE :: FORCE_HELP1(:,:,:,:)
          REAL(q), ALLOCATABLE :: FORCE_HELP2(:)
          INTEGER, ALLOCATABLE :: LHEAD(:)
          INTEGER, ALLOCATABLE :: LNIONS_EST1(:,:,:)
          INTEGER, ALLOCATABLE :: LNIONS_EST2(:,:,:)
          INTEGER, ALLOCATABLE :: LNIONS_EST_MAX(:,:,:)
          INTEGER              :: MCOL_C00
          INTEGER              :: MCOL_C00_COUPLE
          INTEGER              :: MCOL_CLM1
          INTEGER              :: MCOL_CLM2
          INTEGER              :: MCOL_DC00
          INTEGER              :: MCOL_DCLM1
          INTEGER              :: MCOL_DCLM2
          INTEGER              :: MCOL_DPS
          INTEGER              :: MCOL_DPS_SIC
          INTEGER              :: MCOL_DSOAP1
          INTEGER              :: MCOL_DSOAP2
          INTEGER              :: MCOL_EST1
          INTEGER              :: MCOL_EST2
          INTEGER              :: MCOL_EST_MAX
          INTEGER              :: MCOL_MIONS
          INTEGER              :: MCOL_MITYP
          INTEGER              :: MCOL_PS
          INTEGER              :: MCOL_PS_COUPLE
          INTEGER              :: MCOL_RNORM_C00
          INTEGER              :: MCOL_RNORM_PS
          INTEGER              :: MCOL_RNORM_ALL
          INTEGER              :: MCOL_SOAP
          INTEGER              :: MCOL_VEC_LOC_ENERGY
          INTEGER              :: MCOL_VEC_LOC_FORCE1
          INTEGER              :: MCOL_VEC_LOC_FORCE2
          INTEGER              :: MCOL_VEC_LOC_STRESS1
          INTEGER              :: MCOL_VEC_LOC_STRESS2
          INTEGER              :: MNEIB_EST1
          INTEGER              :: MNEIB_EST2
          INTEGER              :: MNEIB_EST_MAX
          INTEGER              :: MNEIB_TMP
          INTEGER              :: MROW_C00
          INTEGER              :: MROW_C00_COUPLE
          INTEGER              :: MROW_CLM1
          INTEGER              :: MROW_CLM2
          INTEGER              :: MROW_DC00
          INTEGER              :: MROW_DCLM1
          INTEGER              :: MROW_DCLM2
          INTEGER              :: MROW_DPS
          INTEGER              :: MROW_DPS_SIC
          INTEGER              :: MROW_DSOAP1
          INTEGER              :: MROW_DSOAP2
          INTEGER              :: MROW_EST1
          INTEGER              :: MROW_EST2
          INTEGER              :: MROW_EST_MAX
          INTEGER              :: MROW_PS
          INTEGER              :: MROW_PS_COUPLE
          INTEGER              :: MROW_RNORM_C00
          INTEGER              :: MROW_RNORM_PS
          INTEGER              :: MROW_RNORM_ALL
          INTEGER              :: MROW_SOAP
          INTEGER              :: MROW_VEC_LOC_ENERGY
          INTEGER              :: MROW_VEC_LOC_FORCE1
          INTEGER              :: MROW_VEC_LOC_FORCE2
          INTEGER              :: MROW_VEC_LOC_STRESS1
          INTEGER              :: MROW_VEC_LOC_STRESS2
          INTEGER              :: NB_MAX
          INTEGER, ALLOCATABLE :: NNEIB_EST1(:,:)
          INTEGER, ALLOCATABLE :: NNEIB_EST2(:,:)
          INTEGER, ALLOCATABLE :: NNEIB_EST_MAX(:,:)
          REAL(q), ALLOCATABLE :: PS(:,:,:)
          REAL(q), ALLOCATABLE :: PS_COUPLE(:)
          REAL(q)              :: RMEM_HELP1
          REAL(q)              :: RMEM_HELP2
          REAL(q)              :: RMEM_MB
          REAL(q), ALLOCATABLE :: RNORM_ALL(:,:)
          REAL(q), ALLOCATABLE :: RNORM_C00(:,:)
          REAL(q), ALLOCATABLE :: RNORM_PS(:,:)
          REAL(q), ALLOCATABLE :: SOAP1(:,:)
          REAL(q), ALLOCATABLE :: SOAP2(:,:)
          REAL(q), ALLOCATABLE :: STRESS_HELP(:,:,:,:)
          REAL(q), ALLOCATABLE :: VEC_LOC_ENERGY(:,:)
          REAL(q), ALLOCATABLE :: VEC_LOC_FORCE1(:,:)
          REAL(q), ALLOCATABLE :: VEC_LOC_FORCE2(:,:)
          REAL(q), ALLOCATABLE :: VEC_LOC_STRESS1(:,:)
          REAL(q), ALLOCATABLE :: VEC_LOC_STRESS2(:,:)
          REAL(q)              :: VPUTIM0
          REAL(q)              :: VPUTIM1
          REAL(q), ALLOCATABLE :: XYZ_EST1(:,:,:,:)
          REAL(q), ALLOCATABLE :: XYZ_EST2(:,:,:,:)
          REAL(q), ALLOCATABLE :: XYZ_EST_MAX(:,:,:,:)
! Start profiling on PUT_FMAT
          PROFILING_START('put_fmat')

! Record the initial time
          CALL VTIME(VPUTIM0,CPUTIM0)
! Calculate or copy the new matrix elements
          IF(FF%LMLMB) THEN
! Copy the previously calculated new matrix elements
             CALL DCOPY_PUT_FMAT_MB
! Configure the maximum number of neghbouring atoms
!!!!             CALL DCOPY_PUT_FMAT_MB
             CALL EST_PUT_FMAT_MB
! Allocate
             CALL ALLOCATE_MB_ARRAY_PUT_FMAT
! Calculate remaining design matrix element
             CALL REMAINING_PUT_FMAT_MB
! Deallocate
             CALL DEALLOCATE_MB_ARRAY_PUT_FMAT
          ENDIF
! Calculate memory usage
          MEM1%RMEM(7)=MAX(MEM1%RMEM(7),RMEM_MB+RMEM_HELP1)
! Record the final time
          CALL VTIME (VPUTIM1,CPUTIM1)
          TIM%CPUTIM(4)=TIM%CPUTIM(4)+CPUTIM1-CPUTIM0
          TIM%VPUTIM(4)=TIM%VPUTIM(4)+VPUTIM1-VPUTIM0
! Stop profiling
          PROFILING_STOP('put_fmat')

          CONTAINS

          SUBROUTINE DCOPY_PUT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER              :: ICONF
            INTEGER              :: INIONS
            INTEGER              :: INTYP0
            INTEGER              :: IXYZ
            INTEGER              :: JXYZ
            INTEGER              :: NCONF_LOC
! Start profiling on DCOPY_PUT_FMAT_MB.
            PROFILING_START('dcopy_put_fmat_mb')
! Copy the already calculated design matrix elements.
! PDCOPY is necessary even for the case of 1-dimensional scaLAPACK grid.
            NCONF_LOC=NCONF
            DO ICONF=1, NCONF_NEW
               NCONF_LOC=NCONF_LOC+1
               DO INTYP0=1, FF%MTYP
#ifdef scaLAPACK
                  CALL PDCOPY(FFM%MB,FFM%FMAT_NEW(1,1,INTYP0),1,FFM%LTOTEN_NEW(ICONF),PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%DESC,1, &
                       FFM%FMAT(1,1,INTYP0),1,FFM%LTOTEN(NCONF_LOC),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1)
#else
                  CALL DCOPY (FFM%MB,FFM%FMAT_NEW(1,FFM%LTOTEN_NEW(ICONF),INTYP0),1, &
                       FFM%FMAT(1,FFM%LTOTEN(NCONF_LOC),INTYP0),1)
#endif
                  DO INIONS=1, NIONS(NCONF_LOC)
                     DO IXYZ=1, 3
#ifdef scaLAPACK
                        CALL PDCOPY(FFM%MB,FFM%FMAT_NEW(1,1,INTYP0),1,FFM%LTIFOR_NEW(IXYZ,INIONS,ICONF),PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%DESC,1, &
                             FFM%FMAT(1,1,INTYP0),1,FFM%LTIFOR(IXYZ,INIONS,NCONF_LOC),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1)
#else
                        CALL DCOPY (FFM%MB,FFM%FMAT_NEW(1,FFM%LTIFOR_NEW(IXYZ,INIONS,ICONF),INTYP0),1, &
                             FFM%FMAT(1,FFM%LTIFOR(IXYZ,INIONS,NCONF_LOC),INTYP0),1)
#endif
                     ENDDO
                  ENDDO
                  DO IXYZ=1, 3
                     DO JXYZ=IXYZ, 3
#ifdef scaLAPACK
                        CALL PDCOPY(FFM%MB,FFM%FMAT_NEW(1,1,INTYP0),1,FFM%LTSIF_NEW(JXYZ,IXYZ,ICONF),PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%DESC,1, &
                             FFM%FMAT(1,1,INTYP0),1,FFM%LTSIF(JXYZ,IXYZ,NCONF_LOC),PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,1)
#else
                        CALL DCOPY (FFM%MB,FFM%FMAT_NEW(1,FFM%LTSIF_NEW(JXYZ,IXYZ,ICONF),INTYP0),1, &
                             FFM%FMAT(1,FFM%LTSIF(JXYZ,IXYZ,NCONF_LOC),INTYP0),1)
#endif
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
! Stop profiling on DCOPY_PUT_FMAT_MB.
            PROFILING_STOP('dcopy_put_fmat_mb')
          END SUBROUTINE DCOPY_PUT_FMAT_MB

          SUBROUTINE EST_PUT_FMAT_MB
            IMPLICIT NONE
! Local varaibles
            INTEGER              :: ICONF
            INTEGER              :: MNEIB_TMP
! Start profiling on EST_PUT_FMAT_MB.
            PROFILING_START('est_put_fmat_mb')
! Configure the structural data.
! Even if FFM%W1(2)=1, some subroutines uses the array with these sizes.
! Therefore, those arrays need to be allocated even in this situation.
! To minimize the memory usage, I set the sizes to 1
! MPI-parallel.
            IF(FFM%W1.GT.0.0_q) THEN
               MNEIB_EST1=0
               DO ICONF=1, NCONF+NCONF_NEW, 1
                  CALL SET_SIZE_EST (PAR_SUP_HANDLE%COMM_WORLD,A(1:,1:,ICONF),B(1:,1:,ICONF),LADD(1:,ICONF),LNIONS(1:,1:,ICONF), &
                       MIONS,MITYP,MNEIB_TMP,MTYP,NIONS(ICONF),NITYP(1:,ICONF),NTYP(ICONF), &
                       FFM%RCUT1,POSION(1:,1:,ICONF))
                  MNEIB_EST1=MAX(MNEIB_EST1,MNEIB_TMP)
               ENDDO
            ELSE
               MNEIB_EST1=1
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               MNEIB_EST2=0
               DO ICONF=1, NCONF+NCONF_NEW, 1
                  CALL SET_SIZE_EST (PAR_SUP_HANDLE%COMM_WORLD,A(1:,1:,ICONF),B(1:,1:,ICONF),LADD(1:,ICONF),LNIONS(1:,1:,ICONF), &
                       MIONS,MITYP,MNEIB_TMP,MTYP,NIONS(ICONF),NITYP(1:,ICONF),NTYP(ICONF), &
                       FFM%RCUT2,POSION(1:,1:,ICONF))
                  MNEIB_EST2=MAX(MNEIB_EST2,MNEIB_TMP)
               ENDDO
            ELSE
               MNEIB_EST2=1
            ENDIF
! Set maximum size. If FFM%LSUPERVEC=1, this information is unnecessary. Therefore, this set to 1.
            IF(.NOT.FFM%LSUPERVEC) THEN
               MNEIB_EST_MAX=1
            ELSE
               MNEIB_EST_MAX=MAX(MNEIB_EST1,MNEIB_EST2)
            ENDIF
! Start profiling on EST_PUT_FMAT_MB.
            PROFILING_STOP('est_put_fmat_mb')
          END SUBROUTINE EST_PUT_FMAT_MB

! This subroutine calculates new design matrix elements using 
! FFM%C00_ALL and FFM%PS_ALL.
          SUBROUTINE REMAINING_PUT_FMAT_MB
            IMPLICIT NONE
! Local Vraibles
            INTEGER              :: ICONF
            INTEGER              :: INITYP
            INTEGER              :: INITYP_TMP
            INTEGER              :: INTYP
            INTEGER              :: INTYP0
            INTEGER              :: KNIONS
            INTEGER              :: KNIONS_TMP
            INTEGER              :: KNTYP0
            INTEGER              :: NCOL_NITYP
! Start profiling on REMAINING_PUT_FMAT_MB.
            PROFILING_START('remaining_put_fmat_mb')
! Initialization of countor of memory usage.
            RMEM_HELP1=0.0_q
! Make list for locations of the begining of basis sets.
!            LHEAD(1)=1
            LHEAD=1
            DO INTYP0=2, FF%MTYP, 1
               LHEAD(INTYP0)=LHEAD(INTYP0-1)+FFM%NB(INTYP0-1)+FFM%NB_NEW(INTYP0-1)
            ENDDO
! Calculate design matrix.
            DO ICONF=1, NCONF+NCONF_NEW, 1 ! Configuration loop.
! Initialization of the design matrix elements.
               CALL INIT_FMAT_HELP_PUT_MB
! Initialization of expansion coefficients
               CALL INIT_CLM_PUT_FMAT_MB(ICONF)
! Initialization of SOAP matrix.
               CALL INIT_SOAP_KERNEL_PUT_FMAT_MB
! Configure structural data.
               CALL SET_EST_DATA_PUT_FMAT_MB(ICONF)
! Calculate expansion coefficients
               CALL D0CLM_PUT_FMAT_MB(ICONF)
! Calculate angular descriptor
               DO INTYP=1, NTYP(ICONF)
                  INTYP0=LADD(INTYP,ICONF)
! Set column size for atom index.
                  NCOL_NITYP=0
                  DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                     INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                     IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                        NCOL_NITYP=NCOL_NITYP+1
                     ENDIF
                  ENDDO ! Atom loop.
! Calculate 1-point correlation (radial) descriptor
                  CALL D0C00_PUT_FMAT_MB(ICONF,INTYP0)
! Calculate 2-point correlation (angular) descriptor
                  CALL D0PS_PUT_FMAT_MB(ICONF,INTYP0)
! Normalization
                  CALL NORMALIZATION_D0_PUT_FMAT_MB(ICONF,INTYP0)
! Calculate SOAP kernel.
                  CALL SOAP_KERNEL_PUT_FMAT_MB(ICONF,INTYP,INTYP0,KNTYP0,NCOL_NITYP)
! Calculate and copy energy matrix elements.
                  CALL ENERGY_PUT_FMAT_MB(ICONF,INTYP0,KNTYP0,NCOL_NITYP)
               ENDDO ! End of element loop.
! Calculate derivatives of SOAP kernel
! MPI-parallel over KNIONS loop.
               DO KNIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  KNIONS=KNIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(KNIONS.LE.NIONS(ICONF)) THEN
                     KNTYP0=LNTYP(KNIONS,ICONF)
! Calculate derivatives of expansion coefficients.
                     CALL D1CLM_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
! Calculate derivatives of 1-point correlation (radial) descriptor.
                     CALL D1C00_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
! Calculate derivatives of 2-points correlation (angular) descriptor.
                     CALL D1PS_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
! Normalization of derivatives.
                     CALL NORMALIZATION_D1_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
! Element loop.
                     DO INTYP=1, NTYP(ICONF)
                        INTYP0=LADD(INTYP,ICONF)
! Calculate derivatives of SOAP similarity kernel.
                        CALL DSOAP_KERNEL_PUT_FMAT_MB(INTYP0,KNIONS,KNTYP0)
! Calculate force and stress components.
                        CALL FORCE_AND_STRESS_PUT_FMAT_MB(ICONF,INTYP0,KNIONS,KNTYP0)
                     ENDDO ! End loop for element.
                  ENDIF ! End if for atom.
               ENDDO ! End of atom loop.
! Transfer and copy the calculated force components in design matrix into the distributed FFM%FMAT array.
               DO INTYP=1, NTYP(ICONF)
                  INTYP0=LADD(INTYP,ICONF)
                  CALL COPY_FORCE_AND_STRESS_PUT_FMAT_MB(ICONF,INTYP0)
               ENDDO ! Element loop.
            ENDDO ! End of configuration loop.
!!! Debug
            PROFILING_STOP('remaining_put_fmat_mb')
          END SUBROUTINE REMAINING_PUT_FMAT_MB

! Subroutine to initialize helping arrays that store the design matrix elements.

          SUBROUTINE INIT_FMAT_HELP_PUT_MB
            IMPLICIT NONE
! Initialization of force components in design-matrix.
            FORCE_HELP1=0.0_q
! Initialization of stress components in design-matrix.
            STRESS_HELP=0.0_q
          END SUBROUTINE INIT_FMAT_HELP_PUT_MB

! Subroutine to initialize soap matrices.

          SUBROUTINE INIT_SOAP_KERNEL_PUT_FMAT_MB
            IMPLICIT NONE
! Local variables
            INTEGER              :: IB
            INTEGER              :: IERR
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  DO IB=1, NB_MAX
                     MLSHM%SOAP_C00(1:FF%MIONS,IB)=0.0_q
                  ENDDO
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  DO IB=1, NB_MAX
                     MLSHM%SOAP_PS(1:FF%MIONS,IB)=0.0_q
                  ENDDO
               ENDIF
            ELSE
               DO IB=1, NB_MAX
                  MLSHM%SOAP_ALL(1:FF%MIONS,IB)=0.0_q
               ENDDO
            ENDIF
#ifdef use_shmem
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
          END SUBROUTINE INIT_SOAP_KERNEL_PUT_FMAT_MB

! Subroutine to calculate radial descriptor.

          SUBROUTINE D0C00_PUT_FMAT_MB(ICONF,INTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
            INTEGER, INTENT(IN)  :: INTYP0
! Local variables
            INTEGER              :: INIONS
            INTEGER              :: INITYP
            INTEGER              :: INITYP_TMP
            INTEGER              :: LOCVAR_COL_C00
            INTEGER              :: LOCVAR_COL_CLM1
            INTEGER              :: LOCVAR_COL_CLM1_COUPLE
            IF(FFM%W1.GT.0.0_q) THEN
! Calculate C00.
! MPI-parallel over INITYP loop.
               PROFILING_START('d0c00_soap_put_fmat_mb')
               DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                     INIONS=LNIONS(INITYP,INTYP0,ICONF)
                     LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM1=INIONS
                     LOCVAR_COL_CLM1_COUPLE=1
                     CALL D0C00_SOAP (C00(1:,LOCVAR_COL_C00,INTYP0),C00_COUPLE(1:),MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE), &
                          LADD(1:,ICONF),.FALSE.,FFM%LMAX1,FFM%LNORM1, &
                          MROW_C00,MROW_C00_COUPLE,FFM%MRB1,MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY,FFM%NRB1(0:),NTYP(ICONF))
                  ENDIF
               ENDDO ! Atom loop.
               PROFILING_STOP('d0c00_soap_put_fmat_mb')
            ENDIF
          END SUBROUTINE D0C00_PUT_FMAT_MB

! Subroutine to calculate angular descriptor.

          SUBROUTINE D0PS_PUT_FMAT_MB(ICONF,INTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
            INTEGER, INTENT(IN)  :: INTYP0
! Local variables
            INTEGER              :: INIONS
            INTEGER              :: INITYP
            INTEGER              :: INITYP_TMP
            INTEGER              :: LOCVAR_COL_CLM2
            INTEGER              :: LOCVAR_COL_CLM2_COUPLE
            INTEGER              :: LOCVAR_COL_PS
            INTEGER              :: LOCVAR_COL_PS_SIC
            INTEGER              :: LOCVAR_COL_PS_SIC_COUPLE
            IF(FFM%W2.GT.0.0_q) THEN
! Calculate PS.
! MPI-parallel.
               PROFILING_START('d0ps_soap_put_fmat_mb')
               DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                  INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                  IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                     INIONS=LNIONS(INITYP,INTYP0,ICONF)
                     LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM2=INIONS
                     LOCVAR_COL_CLM2_COUPLE=1
                     IF(FFM%LSIC) THEN
                        LOCVAR_COL_PS_SIC=INIONS
                     ELSE
                        LOCVAR_COL_PS_SIC=1
                     ENDIF
                     LOCVAR_COL_PS_SIC_COUPLE=1
!                     CALL D0PS_SOAP (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                     CALL SELECTOR_D0PS (FFM%AFILT2,MLSHM%CLM2(:,LOCVAR_COL_CLM2), &
                          MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE), &
                          FFM%DESC_TYPE,FFM%IAFILT2, &
                          INTYP0,FFM%LAFILT2,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC, &
                          FFM%L_LNRB2,FFM%LMAX2,FFM%LNORM2,FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                          FFM%MLNRB2,MROW_PS,MROW_PS_COUPLE,MLSHM%MROW_PS_SIC_GLOBAL, &
                          MLSHM%MROW_PS_SIC_COUPLE_GLOBAL,FFM%MRB2,MTYP, &
                          MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY, &
                          FFM%NLNRB2,FFM%NRB2(0:),FFM%NRB_LNRB2,NTYP(ICONF), &
                          PS(1:,LOCVAR_COL_PS,INTYP0),PS_COUPLE(1:),MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC), &
                          MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%WVAR)
                  ENDIF
               ENDDO
               PROFILING_STOP('d0ps_soap_put_fmat_mb')
            ENDIF
          END SUBROUTINE D0PS_PUT_FMAT_MB

! Normalization.

          SUBROUTINE NORMALIZATION_D0_PUT_FMAT_MB(ICONF,INTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
            INTEGER, INTENT(IN)  :: INTYP0
! Local variables
            INTEGER              :: IERR
            INTEGER              :: INIONS
            INTEGER              :: INITYP
            INTEGER              :: INITYP_TMP
            INTEGER              :: LOCVAR_COL_C00
            INTEGER              :: LOCVAR_COL_PS
            INTEGER              :: LOCVAR_COL_RNORM_ALL
            INTEGER              :: LOCVAR_COL_RNORM_C00
            INTEGER              :: LOCVAR_COL_RNORM_PS
! Initialization of norm.
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  RNORM_C00(1:NITYP(INTYP0,ICONF),INTYP0)=0.0_q
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  RNORM_PS(1:NITYP(INTYP0,ICONF),INTYP0)=0.0_q
               ENDIF
            ELSE
               RNORM_ALL(1:NITYP(INTYP0,ICONF),INTYP0)=0.0_q
            ENDIF
! Normalization.
! MPI-parallel.
            PROFILING_START('normalization_d0_put_fmat_mb')
            DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
               INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
               IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                  INIONS=LNIONS(INITYP,INTYP0,ICONF)
                  IF(.NOT.FFM%LSUPERVEC) THEN
                     IF(FFM%W1.GT.0.0_q) THEN
                        LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        LOCVAR_COL_RNORM_C00=INITYP
                     ELSE
                        LOCVAR_COL_C00=1
                        LOCVAR_COL_RNORM_C00=1
                     ENDIF
                     IF(FFM%W2.GT.0.0_q) THEN
                        LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        LOCVAR_COL_RNORM_PS=INITYP
                     ELSE
                        LOCVAR_COL_PS=1
                        LOCVAR_COL_RNORM_PS=1
                     ENDIF
                     LOCVAR_COL_RNORM_ALL=1
                  ELSE
                     IF(FFM%W1.GT.0.0_q) THEN
                        LOCVAR_COL_C00=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     ELSE
                        LOCVAR_COL_C00=1
                     ENDIF
                     IF(FFM%W2.GT.0.0_q) THEN
                        LOCVAR_COL_PS=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     ELSE
                        LOCVAR_COL_PS=1
                     ENDIF
                     LOCVAR_COL_RNORM_C00=1
                     LOCVAR_COL_RNORM_PS=1
                     LOCVAR_COL_RNORM_ALL=INITYP
                  ENDIF
                  CALL NORMALIZATION_D0 (C00(1:,LOCVAR_COL_C00,INTYP0),C00_COUPLE(1:),FFM%LSUPERVEC,.FALSE.,FFM%LNORM1,FFM%LNORM2, &
                       MROW_C00,MROW_C00_COUPLE,MROW_PS,MROW_PS_COUPLE,FFM%NNVAR1,FFM%NNVAR2(INTYP0),PS(1:,LOCVAR_COL_PS,INTYP0),PS_COUPLE(1:), &
                       RNORM_ALL(LOCVAR_COL_RNORM_ALL,INTYP0),RNORM_C00(LOCVAR_COL_RNORM_C00,INTYP0),RNORM_PS(LOCVAR_COL_RNORM_PS,INTYP0),FFM%W1,FFM%W2)
               ENDIF
            ENDDO
            PROFILING_STOP('normalization_d0_put_fmat_mb')
! All-reduce the norm.
            PROFILING_START('allred_rnorm_put_fmat_mb')
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_C00(1,INTYP0),NITYP(INTYP0,ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_PS(1,INTYP0),NITYP(INTYP0,ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDIF
            ELSE
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,RNORM_ALL(1,INTYP0),NITYP(INTYP0,ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
            PROFILING_STOP('allred_rnorm_put_fmat_mb')
          END SUBROUTINE NORMALIZATION_D0_PUT_FMAT_MB

! Subroutine to calculate derivatives of SOAP similarity kernel.

          SUBROUTINE SOAP_KERNEL_PUT_FMAT_MB(ICONF,INTYP,INTYP0,KNTYP0,NCOL_NITYP)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)       :: ICONF
            INTEGER, INTENT(IN)       :: INTYP
            INTEGER, INTENT(IN)       :: INTYP0
            INTEGER, INTENT(IN)       :: KNTYP0
            INTEGER, INTENT(IN)       :: NCOL_NITYP
! Localc variables
            INTEGER              :: IB
            INTEGER              :: IERR
            INTEGER              :: IHEAD
            INTEGER              :: INIONS
            INTEGER              :: INITYP
            INTEGER              :: INITYP_TMP
            INTEGER              :: IPOLY
            INTEGER              :: LOCVAR_COL
            IPOLY=0
! Set header in the array.
#ifdef scaLAPACK
            IHEAD=FFM%NB(INTYP0)+LHEAD(INTYP0)
#else
            IHEAD=FFM%NB(INTYP0)+1
#endif
! Calculate contribution from 1-point correlation function
            IF(FFM%W1.GT.0.0_q) THEN
               IF(FFM%NB_NEW(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                  PROFILING_START('dgemm_soap1_put_fmat_mb')
#ifdef scaLAPACK
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NNVAR1,1.0_q,C00(1,1,INTYP0), &
                       MROW_C00,FFM%C00_ALL(1,IHEAD),FFM%MMVAR1,0.0_q,SOAP1(1,1),MROW_SOAP)
#else
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NNVAR1,1.0_q,C00(1,1,INTYP0), &
                       MROW_C00,FFM%C00(1,IHEAD,INTYP0),FFM%MMVAR1,0.0_q,SOAP1(1,1),MROW_SOAP)
#endif
                  PROFILING_STOP('dgemm_soap1_put_fmat_mb')
                  PROFILING_START('poly_soap1_put_fmat_mb')
                  CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,NIONS(ICONF),NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NHYP1,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W1)
                  PROFILING_STOP('poly_soap1_put_fmat_mb')
                  IPOLY=1
               ENDIF
               IF(.NOT.FFM%LSUPERVEC) THEN
! Store the calculated SOAP1 to SOAP_C00.
! MPI-parallel.
                  PROFILING_START('gather_soap_c00_put_fmat_mb')
                  IF(FFM%NB_NEW(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                     DO IB=1, FFM%NB_NEW(INTYP0)
                        DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                           INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                           IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                              INIONS=LNIONS(INITYP,INTYP0,ICONF)
                              LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                              MLSHM%SOAP_C00(INIONS,IB)=FFM%W1*REAL(FFM%NHYP1,q)*(SOAP1(LOCVAR_COL,IB))**(FFM%NHYP1-1)
                           ENDIF
                        ENDDO
                     ENDDO
                  ENDIF
#ifdef use_shmem
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_C00 at the end of INTYP loop.
                  IF(INTYP.EQ.NTYP(ICONF)) THEN
                     PROFILING_START ('allred_soap_c00_put_fmat_mb')
#ifdef use_shmem
                     IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                        CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_C00,MLSHM%MROW_SOAP_C00_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                             PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                     ENDIF
!!!                     CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                     CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                     CALL MPI_ALLREDUCE(   MPI_IN_PLACE,MLSHM%SOAP_C00,MLSHM%MROW_SOAP_C00_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR           )
#endif
                     PROFILING_STOP ('allred_soap_c00_put_fmat_mb')
                  ENDIF
                  PROFILING_STOP('gather_soap_c00_put_fmat_mb')
               ENDIF
            ENDIF ! End if for 1-point correlation descriptor.
! Calculate contribution from 2-point correlation function
            IF(FFM%W2.GT.0.0_q) THEN
               IF(FFM%NB_NEW(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                  PROFILING_START('dgemm_soap2_put_fmat_mb')
#ifdef scaLAPACK
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NNVAR2(INTYP0),1.0_q,PS(1,1,INTYP0),MROW_PS, &
                       FFM%PS_ALL(1,IHEAD),FFM%MMVAR2,0.0_q,SOAP1(1,1),MROW_SOAP)
#else
                  CALL DGEMM ('T','N',NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NNVAR2(INTYP0),1.0_q,PS(1,1,INTYP0),MROW_PS, &
                       FFM%PS(1,IHEAD,INTYP0),FFM%MMVAR2,0.0_q,SOAP1(1,1),MROW_SOAP)
#endif
                  PROFILING_STOP('dgemm_soap2_put_fmat_mb')
                  PROFILING_START('poly_soap2_put_fmat_mb')
                  CALL POLY_SOAP1 (IPOLY,FFM%LSUPERVEC,MROW_SOAP,MCOL_SOAP,NIONS(ICONF),NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NHYP2,SOAP1(1:,1:),SOAP2(1:,1:),FFM%W2)
                  PROFILING_STOP('poly_soap2_put_fmat_mb')
               ENDIF
               IF(.NOT.FFM%LSUPERVEC) THEN
! Store the calculated SOAP1 to SOAP_PS.
! MPI-parallel.
                  PROFILING_START('gather_soap_ps_put_fmat_mb')
                  IF(FFM%NB_NEW(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                     DO IB=1, FFM%NB_NEW(INTYP0)
                        DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                           INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                           IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                              INIONS=LNIONS(INITYP,INTYP0,ICONF)
                              LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                              MLSHM%SOAP_PS(INIONS,IB)=FFM%W2*REAL(FFM%NHYP2,q)*(SOAP1(LOCVAR_COL,IB))**(FFM%NHYP2-1)
                           ENDIF
                        ENDDO
                     ENDDO
                  ENDIF
#ifdef use_shmem
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_PS at the end of INTYP loop.
                  IF(INTYP.EQ.NTYP(ICONF)) THEN
                     PROFILING_START ('allred_soap_ps_put_fmat_mb')
#ifdef use_shmem
                     IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                        CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_PS,MLSHM%MROW_SOAP_PS_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                             PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                     ENDIF
!!!                     CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                     CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                     CALL MPI_ALLREDUCE(   MPI_IN_PLACE,MLSHM%SOAP_PS,MLSHM%MROW_SOAP_PS_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR           )
#endif
                     PROFILING_STOP ('allred_soap_ps_put_fmat_mb')
                  ENDIF
                  PROFILING_STOP('gather_soap_ps_put_fmat_mb')
               ENDIF
            ENDIF ! End if for 2-points correlation descriptor
            IF(FFM%LSUPERVEC) THEN
! Store the calculated SOAP1 to SOAP_ALL
! MPI-parallel.
               PROFILING_START('gather_soap_all_put_fmat_mb')
               IF(FFM%NB_NEW(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
                  DO IB=1, FFM%NB_NEW(INTYP0)
                     DO INITYP_TMP=1, NITYP(INTYP0,ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
                        INITYP=INITYP_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
                        IF(INITYP.LE.NITYP(INTYP0,ICONF)) THEN
                           INIONS=LNIONS(INITYP,INTYP0,ICONF)
                           LOCVAR_COL=CEILING(REAL(INITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                           MLSHM%SOAP_ALL(INIONS,IB)=REAL(FFM%NHYP2,q)*(SOAP2(LOCVAR_COL,IB))**(FFM%NHYP2-1)
                        ENDIF
                     ENDDO
                  ENDDO
               ENDIF
#ifdef use_shmem
               CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
! Then, all-reduce SOAP_ALL at the end of INTYP loop.
               IF(INTYP.EQ.NTYP(ICONF)) THEN
                  PROFILING_START ('allred_soap_all_put_fmat_mb')
#ifdef use_shmem
                  IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%SOAP_ALL,MLSHM%MROW_SOAP_ALL_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM, &
                          PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                  ENDIF
                  CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
                  CALL MPI_ALLREDUCE(   MPI_IN_PLACE,MLSHM%SOAP_ALL,MLSHM%MROW_SOAP_ALL_GLOBAL*NB_MAX,MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR           )
#endif
                  PROFILING_STOP ('allred_soap_all_put_fmat_mb')
               ENDIF
               PROFILING_STOP('gather_soap_all_put_fmat_mb')
! Calculate SOAP similarity kernel for super vector.
               PROFILING_START('poly_soap_all_fmat_new_mb')
               CALL POLY_SOAP2 (MROW_SOAP,MCOL_SOAP,NIONS(ICONF),NCOL_NITYP,FFM%NB_NEW(INTYP0),FFM%NHYP2,SOAP2(1:,1:))
               PROFILING_STOP('poly_soap_all_fmat_new_mb')
            ENDIF
          END SUBROUTINE SOAP_KERNEL_PUT_FMAT_MB

! Subroutine to calculate and copy energy component in design-matrix.

          SUBROUTINE ENERGY_PUT_FMAT_MB(ICONF,INTYP0,KNTYP0,NCOL_NITYP)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
            INTEGER, INTENT(IN)  :: INTYP0
            INTEGER, INTENT(IN)  :: KNTYP0
            INTEGER, INTENT(IN)  :: NCOL_NITYP
! Local variables
            INTEGER              :: IB
            INTEGER              :: IERR
            INTEGER              :: LOCVAR_COL
            INTEGER              :: LOCVAR_ROW
            INTEGER              :: TEST_COL
            INTEGER              :: TEST_ROW
            PROFILING_START('energy_put_fmat_mb')
            IF(FFM%NB_NEW(INTYP0).GT.0.AND.NCOL_NITYP.GT.0) THEN
               VEC_LOC_ENERGY=1.0_q
               CALL DGEMV ('T',NCOL_NITYP,FFM%NB_NEW(INTYP0),1.0_q, &
                    SOAP2,MROW_SOAP,VEC_LOC_ENERGY(1,1), &
                    1,0.0_q,ENERGY_HELP(1),1)
            ELSE
               ENERGY_HELP=0.0_q
            ENDIF
! All-reduce ENERGY_HELP.
            PROFILING_START ('allred_energy_put_fmat_mb')
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,ENERGY_HELP,FFM%NB_NEW(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            PROFILING_STOP ('allred_energy_put_fmat_mb')
            PROFILING_STOP('energy_put_fmat_mb')
! Store the design matrix elements
            IF(FFM%NB_NEW(INTYP0).GT.0) THEN
#ifdef scaLAPACK
               TEST_COL=MOD((FFM%LTOTEN(ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
               IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                  LOCVAR_COL=GLOBAL2LOCAL(FFM%LTOTEN(ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                  LOCVAR_COL=FFM%LTOTEN(ICONF)
#endif
                  DO IB=1, FFM%NB_NEW(INTYP0)
#ifdef scaLAPACK
                     TEST_ROW=MOD((IB+FFM%NB(INTYP0)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                        CYCLE
                     ENDIF
                     LOCVAR_ROW=GLOBAL2LOCAL(IB+FFM%NB(INTYP0),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
#else
                     LOCVAR_ROW=IB+FFM%NB(INTYP0)
#endif
                     FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=ENERGY_HELP(IB)
                  ENDDO
#ifdef scaLAPACK
               ENDIF
#endif
            ENDIF
          END SUBROUTINE ENERGY_PUT_FMAT_MB

! Subroutine to calculate derivatives of expansion coefficients.

          SUBROUTINE D1CLM_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)       :: ICONF
            INTEGER, INTENT(IN)       :: KNIONS
            INTEGER, INTENT(IN)       :: KNTYP0
! Local variables
            INTEGER                   :: LOCVAR_COL_EST1
            INTEGER                   :: LOCVAR_COL_EST2
            PROFILING_START('d1clm_soap_put_fmat_mb')
            IF(FFM%W1.GT.0.0_q) THEN
               LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               CALL D1CLM_SOAP (DCLM1,FFM%DRSPL1,FFM%FNL1,FFM%FWIN1,KNIONS,KNTYP0, &
                    LADD(1:,ICONF),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1), &
                    .FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                    MCOL_DCLM1,MCOL_DPS_SIC,FF%MIONS,FFM%MRB1, &
                    MROW_DCLM1,MROW_DPS_SIC,MROW_EST1,FFM%MSPL1,MTYP, &
                    NNEIB_EST1(1:,LOCVAR_COL_EST1),FFM%NRB1(0:),FFM%NSPL1,NTYP(ICONF), &
                    DPS_SIC,FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST1(1:,1:,1:,LOCVAR_COL_EST1))
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               CALL D1CLM_SOAP (DCLM2,FFM%DRSPL2,FFM%FNL2,FFM%FWIN2,KNIONS,KNTYP0, &
                    LADD(1:,ICONF),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LMAX2,LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                    FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW2, &
                    MCOL_DCLM2,MCOL_DPS_SIC,FF%MIONS,FFM%MRB2, &
                    MROW_DCLM2,MROW_DPS_SIC,MROW_EST2,FFM%MSPL2,MTYP, &
                    NNEIB_EST2(1:,LOCVAR_COL_EST2),FFM%NRB2(0:),FFM%NSPL2,NTYP(ICONF), &
                    DPS_SIC,FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST2(1:,1:,1:,LOCVAR_COL_EST2))
            ENDIF
            PROFILING_STOP('d1clm_soap_put_fmat_mb')
            RMEM_HELP1=MAX(RMEM_HELP1,RMEM_HELP2)
          END SUBROUTINE D1CLM_PUT_FMAT_MB

! Subroutine to calculate derivatives of radial descriptor.

          SUBROUTINE D1C00_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)       :: ICONF
            INTEGER, INTENT(IN)       :: KNIONS
            INTEGER, INTENT(IN)       :: KNTYP0
! Localc variables
            INTEGER              :: LOCVAR_COL_EST1
            INTEGER              :: LOCVAR_COL_EST_MAX 
            IF(FFM%W1 .GT. 0.0_q) THEN
               PROFILING_START('d1c00_soap1_put_fmat_mb')
               LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               IF(.NOT.FFM%LSUPERVEC) THEN
                  LOCVAR_COL_EST_MAX=1
               ELSE
                  LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ENDIF
               CALL D1C00_SOAP (MLSHM%CLM1,DC00,DCLM1,FFM%LSUPERVEC,KNTYP0, &
                    LADD(1:,ICONF),FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1),LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX), &
                    MLSHM%MCOL_CLM1_GLOBAL,MCOL_DC00,MCOL_DCLM1,FFM%MRB1,MROW_EST1,MROW_EST_MAX,MLSHM%MROW_CLM1_GLOBAL,MROW_DC00,MROW_DCLM1, &
                    AB%MTYP,AB%MTYP_ALLOCATE,NNEIB_EST1(1:,LOCVAR_COL_EST1),NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NRB1(0:),NTYP(ICONF))
               PROFILING_STOP('d1c00_soap1_put_fmat_mb')
            ENDIF
          END SUBROUTINE D1C00_PUT_FMAT_MB

! Subroutine to calculate derivatives of angular descriptor.

          SUBROUTINE D1PS_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)       :: ICONF
            INTEGER, INTENT(IN)       :: KNIONS
            INTEGER, INTENT(IN)       :: KNTYP0
! Local variables
            INTEGER                   :: LOCVAR_COL_EST2
            INTEGER                   :: LOCVAR_COL_EST_MAX
            IF(FFM%W2 .GT. 0.0_q) THEN
               PROFILING_START('d1ps_soap_put_fmat_mb')
               LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               IF(.NOT.FFM%LSUPERVEC) THEN
                  LOCVAR_COL_EST_MAX=1
               ELSE
                  LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ENDIF
!               CALL D1PS_SOAP (FFM%AFILT2,MLSHM%CLM2,DCLM2,DPS,DPS_SIC,FFM%IAFILT2,FFM%LSUPERVEC,KNTYP0, &
               CALL SELECTOR_D1PS (FFM%AFILT2,MLSHM%CLM2,DCLM2,FFM%DESC_TYPE,DPS,DPS_SIC,FFM%IAFILT2,FFM%LSUPERVEC,KNTYP0, &
                    FFM%LAFILT2,LADD(1:,ICONF),FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%L_LNRB2,FFM%LMAX2, &
                    LNIONS_EST2(1:,1:,LOCVAR_COL_EST2),LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX),FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC, &
                    MLSHM%MCOL_CLM2_GLOBAL,MCOL_DCLM2,MCOL_DPS,MCOL_DPS_SIC,MLSHM%MCOL_PS_SIC_GLOBAL,FFM%MLNRB2,FFM%MRB2, &
                    MROW_EST2,MROW_EST_MAX,MLSHM%MROW_CLM2_GLOBAL,MROW_DCLM2,MROW_DPS, &
                    MROW_DPS_SIC,MLSHM%MROW_PS_SIC_GLOBAL,MTYP,AB%MTYP_ALLOCATE, &
                    NIONS(ICONF),FFM%NLNRB2,NNEIB_EST2(1:,LOCVAR_COL_EST2), &
                    NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NRB2(0:),FFM%NRB_LNRB2,NTYP(ICONF),MLSHM%PS_SIC,FFM%WVAR)
               PROFILING_STOP('d1ps_soap_put_fmat_mb')
            ENDIF
          END SUBROUTINE D1PS_PUT_FMAT_MB

! Normalization of derivatives.

          SUBROUTINE NORMALIZATION_D1_PUT_FMAT_MB(ICONF,KNIONS,KNTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)       :: ICONF
            INTEGER, INTENT(IN)       :: KNIONS
            INTEGER, INTENT(IN)       :: KNTYP0
! Local variables
            INTEGER              :: LOCVAR_COL_EST1
            INTEGER              :: LOCVAR_COL_EST2
            INTEGER              :: LOCVAR_COL_EST_MAX
            PROFILING_START('normalization_d1_put_fmat_mb')
            IF(.NOT.FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q) THEN
                  LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST1=1
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST2=1
               ENDIF
               LOCVAR_COL_EST_MAX=1
            ELSE
               IF(FFM%W1.GT.0.0_q) THEN
                  LOCVAR_COL_EST1=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST1=1
               ENDIF
               IF(FFM%W2.GT.0.0_q) THEN
                  LOCVAR_COL_EST2=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  LOCVAR_COL_EST2=1
               ENDIF
               LOCVAR_COL_EST_MAX=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ENDIF
            CALL NORMALIZATION_D1 (DC00,DPS,FFM%LSUPERVEC,KNTYP0, &
                 LADD(1:,ICONF),LNIONS_EST1(1:,1:,LOCVAR_COL_EST1),LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                 LNIONS_EST_MAX(1:,1:,LOCVAR_COL_EST_MAX),LNITYP(1:,ICONF),FFM%LNORM1,FFM%LNORM2, &
                 MCOL_DC00,MCOL_DPS,MCOL_RNORM_ALL,MCOL_RNORM_C00,MCOL_RNORM_PS,MIONS,MITYP,MROW_EST1, &
                 MROW_EST2,MROW_EST_MAX,MROW_DC00,MROW_DPS,MROW_RNORM_C00,MROW_RNORM_PS,FF%MTYP_ALLOCATE, &
                 NNEIB_EST1(1:,LOCVAR_COL_EST1),NNEIB_EST2(1:,LOCVAR_COL_EST2),NNEIB_EST_MAX(1:,LOCVAR_COL_EST_MAX),FFM%NNVAR1,FFM%NNVAR2,NTYP(ICONF), &
                 FFM%RCUT1,FFM%RCUT2,RNORM_ALL(1:,1:),RNORM_C00(1:,1:),RNORM_PS(1:,1:),FFM%W1,FFM%W2)
            PROFILING_STOP('normalization_d1_put_fmat_mb')
          END SUBROUTINE NORMALIZATION_D1_PUT_FMAT_MB

! Subroutine to calculate derivatives of SOAP similarity kernel.

          SUBROUTINE DSOAP_KERNEL_PUT_FMAT_MB(INTYP0,KNIONS,KNTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: INTYP0
            INTEGER, INTENT(IN)  :: KNIONS
            INTEGER, INTENT(IN)  :: KNTYP0
! Local variables
            INTEGER              :: IHEAD
            INTEGER              :: IXYZ
            INTEGER              :: LOCVAR_COL
            INTEGER              :: NNEIB_EST_DUMMY
            
! Calculate header.
#ifdef scaLAPACK
            IHEAD=LHEAD(INTYP0)+FFM%NB(INTYP0)
#else
            IHEAD=FFM%NB(INTYP0)+1
#endif
! Set LOCVAR_COL.
            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Calculate derivatives of 1-point correlation kernel
            IF(FFM%W1 .GT. 0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB_NEW(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
                     PROFILING_START('dgemm_dsoap1_put_fmat_mb')
#ifdef scaLAPACK
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),FFM%NNVAR1,1.0_q, &
                          DC00(1,1,IXYZ,INTYP0),MROW_DC00,FFM%C00_ALL(1,IHEAD),FFM%MMVAR1, &
                          0.0_q,DSOAP11(1,1),MROW_DSOAP1)
#else
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),FFM%NNVAR1,1.0_q, &
                          DC00(1,1,IXYZ,INTYP0),MROW_DC00,FFM%C00(1,IHEAD,INTYP0),FFM%MMVAR1, &
                          0.0_q,DSOAP11(1,1),MROW_DSOAP1)
#endif
                     PROFILING_STOP('dgemm_dsoap1_put_fmat_mb')
                     PROFILING_START('poly_dsoap1_put_fmat_mb')
                     IF(.NOT.FFM%LSUPERVEC) THEN
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST1(1:,INTYP0,LOCVAR_COL)   ,MROW_EST1   ,MROW_DSOAP1,MCOL_DSOAP1,MLSHM%MROW_SOAP_C00_GLOBAL,MLSHM%MCOL_SOAP_C00_GLOBAL, &
                             NNEIB_EST1(INTYP0,LOCVAR_COL)+1   ,FFM%NB_NEW(INTYP0),DSOAP11(1:,1:),DSOAP21(1:,1:,IXYZ),MLSHM%SOAP_C00,FFM%W1)
                     ELSE
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST_MAX(1:,INTYP0,LOCVAR_COL),MROW_EST_MAX,MROW_DSOAP1,MCOL_DSOAP1,MLSHM%MROW_SOAP_ALL_GLOBAL,MLSHM%MCOL_SOAP_ALL_GLOBAL, &
                             NNEIB_EST_MAX(INTYP0,LOCVAR_COL)+1,FFM%NB_NEW(INTYP0),DSOAP11(1:,1:),DSOAP21(1:,1:,IXYZ),MLSHM%SOAP_ALL,FFM%W1)
                     ENDIF
                     PROFILING_STOP('poly_dsoap1_put_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF ! End if for 1-point correlation descriptor.
! Calculate derivatives of 2-point correlation kernel
            IF(FFM%W2.GT.0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB_NEW(INTYP0).GT.0) THEN
                  DO IXYZ=1, 3
                     PROFILING_START('dgemm_dsoap2_put_fmat_mb')
#ifdef scaLAPACK
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                          DPS(1,1,IXYZ,INTYP0),MROW_DPS,FFM%PS_ALL(1,IHEAD),FFM%MMVAR2, &
                          0.0_q,DSOAP12(1,1),MROW_DSOAP2)
#else
                     CALL DGEMM ('T','N',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),FFM%NNVAR2(INTYP0),1.0_q, &
                          DPS(1,1,IXYZ,INTYP0),MROW_DPS,FFM%PS(1,IHEAD,INTYP0),FFM%MMVAR2, &
                          0.0_q,DSOAP12(1,1),MROW_DSOAP2)
#endif
                     PROFILING_STOP('dgemm_dsoap2_put_fmat_mb')
                     PROFILING_START('poly_dsoap2_put_fmat_mb')
                     IF(.NOT.FFM%LSUPERVEC) THEN
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST2(1:,INTYP0,LOCVAR_COL)   ,MROW_EST2   ,MROW_DSOAP2,MCOL_DSOAP2,MLSHM%MROW_SOAP_PS_GLOBAL,MLSHM%MCOL_SOAP_PS_GLOBAL, &
                             NNEIB_EST2(INTYP0,LOCVAR_COL)+1   ,FFM%NB_NEW(INTYP0),DSOAP12(1:,1:),DSOAP22(1:,1:,IXYZ),MLSHM%SOAP_PS,FFM%W2)
                     ELSE
                        CALL POLY_DSOAP (INTYP0,KNIONS,KNTYP0,LNIONS_EST_MAX(1:,INTYP0,LOCVAR_COL),MROW_EST_MAX,MROW_DSOAP2,MCOL_DSOAP2,MLSHM%MROW_SOAP_ALL_GLOBAL,MLSHM%MCOL_SOAP_ALL_GLOBAL, &
                             NNEIB_EST_MAX(INTYP0,LOCVAR_COL)+1,FFM%NB_NEW(INTYP0),DSOAP12(1:,1:),DSOAP22(1:,1:,IXYZ),MLSHM%SOAP_ALL,FFM%W2)
                     ENDIF
                     PROFILING_STOP('poly_dsoap2_put_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF ! End if for 2-points correlation descriptor.
          END SUBROUTINE DSOAP_KERNEL_PUT_FMAT_MB

! Subroutine to calculate force and stress components in design matrix.

          SUBROUTINE FORCE_AND_STRESS_PUT_FMAT_MB(ICONF,INTYP0,KNIONS,KNTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
            INTEGER, INTENT(IN)  :: INTYP0
            INTEGER, INTENT(IN)  :: KNIONS
            INTEGER, INTENT(IN)  :: KNTYP0
! Local variables
            INTEGER              :: INEIB
            INTEGER              :: IXYZ
            INTEGER              :: JXYZ
            INTEGER              :: LOCVAR_COL
            INTEGER              :: NNEIB_EST_DUMMY
! Set LOCVAR_COL
            LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Contributions from radial descriptors.
            IF(FFM%W1.GT.0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST1(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB_NEW(INTYP0).GT.0) THEN
! Calculate force components.
                  DO IXYZ=1, 3
                     PROFILING_START('force_put_fmat_mb')
                     DO INEIB=1, NNEIB_EST_DUMMY+1
                        IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                           VEC_LOC_FORCE1(INEIB,1)=0.0_q
                        ELSE
                           VEC_LOC_FORCE1(INEIB,1)=1.0_q
                        ENDIF
                     ENDDO
                     CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                          VEC_LOC_FORCE1(1,1),1,1.0_q,FORCE_HELP1(1,IXYZ,LOCVAR_COL,INTYP0),1)
                     PROFILING_STOP('force_put_fmat_mb')
! Calculate stress components.
                     PROFILING_START('stress_put_fmat_mb')
                     DO JXYZ=IXYZ, 3
                        DO INEIB=1, NNEIB_EST_DUMMY+1
                           IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                              VEC_LOC_STRESS1(INEIB,1)=0.0_q
                           ELSE
                              IF(.NOT.FFM%LSUPERVEC) THEN
                                 VEC_LOC_STRESS1(INEIB,1)=-XYZ_EST1(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ELSE
                                 VEC_LOC_STRESS1(INEIB,1)=-XYZ_EST_MAX(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ENDIF
                           ENDIF
                        ENDDO
                        CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),1.0_q,DSOAP21(1,1,IXYZ),MROW_DSOAP1, &
                             VEC_LOC_STRESS1(1,1),1,1.0_q,STRESS_HELP(1,JXYZ,IXYZ,INTYP0),1)
                     ENDDO
                     PROFILING_STOP('stress_put_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF
! Contributions from angular descriptors.
            IF(FFM%W2.GT.0.0_q) THEN
               IF(.NOT.FFM%LSUPERVEC) THEN
                  NNEIB_EST_DUMMY=NNEIB_EST2(INTYP0,LOCVAR_COL)
               ELSE
                  NNEIB_EST_DUMMY=NNEIB_EST_MAX(INTYP0,LOCVAR_COL)
               ENDIF
               IF(NNEIB_EST_DUMMY+1.GT.0.AND.FFM%NB_NEW(INTYP0).GT.0) THEN
! Calculate force components.
                  DO IXYZ=1, 3
                     PROFILING_START('force_put_fmat_mb')
                     DO INEIB=1, NNEIB_EST_DUMMY+1
                        IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                           VEC_LOC_FORCE2(INEIB,1)=0.0_q
                        ELSE
                           VEC_LOC_FORCE2(INEIB,1)=1.0_q
                        ENDIF
                     ENDDO
                     CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                          VEC_LOC_FORCE2(1,1),1,1.0_q,FORCE_HELP1(1,IXYZ,LOCVAR_COL,INTYP0),1)
                     PROFILING_STOP('force_put_fmat_mb')
! Calculate stress components.
                     PROFILING_START('stress_put_fmat_mb')
                     DO JXYZ=IXYZ, 3
                        DO INEIB=1, NNEIB_EST_DUMMY+1
                           IF((INEIB.EQ.1).AND.(INTYP0.NE.KNTYP0)) THEN
                              VEC_LOC_STRESS2(INEIB,1)=0.0_q
                           ELSE
                              IF(.NOT.FFM%LSUPERVEC) THEN
                                 VEC_LOC_STRESS2(INEIB,1)=-XYZ_EST2(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ELSE
                                 VEC_LOC_STRESS2(INEIB,1)=-XYZ_EST_MAX(JXYZ,INEIB,INTYP0,LOCVAR_COL)/OMEGA(ICONF)
                              ENDIF
                           ENDIF
                        ENDDO
                        CALL DGEMV ('T',NNEIB_EST_DUMMY+1,FFM%NB_NEW(INTYP0),1.0_q,DSOAP22(1,1,IXYZ),MROW_DSOAP2, &
                             VEC_LOC_STRESS2(1,1),1,1.0_q,STRESS_HELP(1,JXYZ,IXYZ,INTYP0),1)
                     ENDDO
                     PROFILING_STOP('stress_put_fmat_mb')
                  ENDDO
               ENDIF
            ENDIF
          END SUBROUTINE FORCE_AND_STRESS_PUT_FMAT_MB

! Copy force and stress components in design matrix to global array.

          SUBROUTINE COPY_FORCE_AND_STRESS_PUT_FMAT_MB(ICONF,INTYP0)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
            INTEGER, INTENT(IN)  :: INTYP0
! Local variables
            INTEGER              :: IB
            INTEGER              :: IERR
            INTEGER              :: IPROCESS
            INTEGER              :: IXYZ
            INTEGER              :: JXYZ
            INTEGER              :: KNIONS
            INTEGER              :: LOCVAR_COL
            INTEGER              :: LOCVAR_ROW
            INTEGER              :: TEST_COL
            INTEGER              :: TEST_ROW
            IF(FFM%NB_NEW(INTYP0).GT.0) THEN
               PROFILING_START('copy_force_put_fmat_mb')
               DO KNIONS=1, NIONS(ICONF), 1
                  IPROCESS=MOD(KNIONS-1,PAR_SUP_HANDLE%COMM_WORLD%NCPU)
                  DO IXYZ=1, 3
! Transfer the force elements to all processes.
                     IF(PAR_SUP_HANDLE%COMM_WORLD%NODE_ME.EQ.IPROCESS) THEN
                        LOCVAR_COL=CEILING(REAL(KNIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                        FORCE_HELP2(1:FFM%NB_NEW(INTYP0))=FORCE_HELP1(1:FFM%NB_NEW(INTYP0),IXYZ,LOCVAR_COL,INTYP0)
                     ENDIF
                      CALL M_BCAST (PAR_SUP_HANDLE%COMM_WORLD,FORCE_HELP2(1:),FFM%NB_NEW(INTYP0),IPROCESS)
! Store the design matrix elements
#ifdef scaLAPACK
                     TEST_COL=MOD((FFM%LTIFOR(IXYZ,KNIONS,ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                        LOCVAR_COL=GLOBAL2LOCAL(FFM%LTIFOR(IXYZ,KNIONS,ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                        LOCVAR_COL=FFM%LTIFOR(IXYZ,KNIONS,ICONF)
#endif
                        DO IB=1, FFM%NB_NEW(INTYP0)
#ifdef scaLAPACK
                           TEST_ROW=MOD((IB+FFM%NB(INTYP0)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                           IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_ROW=GLOBAL2LOCAL(IB+FFM%NB(INTYP0),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
#else
                           LOCVAR_ROW=IB+FFM%NB(INTYP0)
#endif
                           FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=FORCE_HELP2(IB)
                        ENDDO
#ifdef scaLAPACK
                     ENDIF
#endif
                  ENDDO
               ENDDO
               PROFILING_STOP('copy_force_put_fmat_mb')
! Transfer and copy the calculated stress components in design matrix into the distributed FFM%FMAT array.
               PROFILING_START('copy_stress_put_fmat_mb')
               DO IXYZ=1, 3
                  DO JXYZ=IXYZ, 3
! All-reduce STRESS_HELP.
                     PROFILING_START ('allred_stress_put_fmat_mb')
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,STRESS_HELP(1,JXYZ,IXYZ,INTYP0),FFM%NB_NEW(INTYP0),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
                     PROFILING_STOP ('allred_stress_put_fmat_mb')
! Store the design matrix elements
#ifdef scaLAPACK
                     TEST_COL=MOD((FFM%LTSIF(JXYZ,IXYZ,ICONF)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL)
                     IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL.EQ.TEST_COL) THEN
                        LOCVAR_COL=GLOBAL2LOCAL(FFM%LTSIF(JXYZ,IXYZ,ICONF),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB)
#else
                        LOCVAR_COL=FFM%LTSIF(JXYZ,IXYZ,ICONF)
#endif
                        DO IB=1, FFM%NB_NEW(INTYP0)
#ifdef scaLAPACK
                           TEST_ROW=MOD((IB+FFM%NB(INTYP0)-1)/PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW)
                           IF(PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW.NE.TEST_ROW) THEN
                              CYCLE
                           ENDIF
                           LOCVAR_ROW=GLOBAL2LOCAL(IB+FFM%NB(INTYP0),PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%DESC_FMAT_FFM%MB)
#else
                           LOCVAR_ROW=IB+FFM%NB(INTYP0)
#endif
                           FFM%FMAT(LOCVAR_ROW,LOCVAR_COL,INTYP0)=STRESS_HELP(IB,JXYZ,IXYZ,INTYP0)
                        ENDDO
#ifdef scaLAPACK
                     ENDIF
#endif
                  ENDDO
               ENDDO
               PROFILING_STOP('copy_stress_put_fmat_mb')
            ENDIF
          END SUBROUTINE COPY_FORCE_AND_STRESS_PUT_FMAT_MB

! Subroutine to determine the maximum number of neighbouring atoms.

          SUBROUTINE SET_EST_DATA_PUT_FMAT_MB(ICONF)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
! Local variables
            INTEGER              :: INIONS
            INTEGER              :: INIONS_TMP
            INTEGER              :: LOCVAR_COL
! MPI-parallel.
            PROFILING_START('st_put_fmat_mb')
            DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
               INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
               IF(INIONS.LE.NIONS(ICONF)) THEN
                  LOCVAR_COL=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                  IF(FFM%W1.GT.0.0_q) THEN
                     CALL SET_EST_DATA_POINT (1,A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LNTYP(1:,ICONF),LNIONS_EST1(1:,1:,LOCVAR_COL),MIONS,MROW_EST1,MTYP, &
                          NIONS(ICONF),NNEIB_EST1(1:,LOCVAR_COL),NTYP(ICONF),FFM%RCUT1,FFM%RCUT1,FFM%RCUT2,POSION(1:,1:,ICONF), &
                          XYZ_EST1(1:,1:,1:,LOCVAR_COL))
                  ENDIF
                  IF(FFM%W2.GT.0.0_q) THEN
                     CALL SET_EST_DATA_POINT (1,A(1:,1:,ICONF),B(1:,1:,ICONF),INIONS,LNTYP(1:,ICONF),LNIONS_EST2(1:,1:,LOCVAR_COL),MIONS,MROW_EST2,MTYP, &
                          NIONS(ICONF),NNEIB_EST2(1:,LOCVAR_COL),NTYP(ICONF),FFM%RCUT2,FFM%RCUT1,FFM%RCUT2,POSION(1:,1:,ICONF), &
                          XYZ_EST2(1:,1:,1:,LOCVAR_COL))
                  ENDIF
               ENDIF
            ENDDO
            IF(FFM%LSUPERVEC) THEN
               IF(FFM%W1.GT.0.0_q.AND.FFM%W2.GT.0.0_q) THEN
                  IF(MNEIB_EST1.GE.MNEIB_EST2) THEN
                      LNIONS_EST_MAX=LNIONS_EST1
                      NNEIB_EST_MAX=NNEIB_EST1
                      XYZ_EST_MAX=XYZ_EST1
                  ELSE
                      LNIONS_EST_MAX=LNIONS_EST2
                      NNEIB_EST_MAX=NNEIB_EST2
                      XYZ_EST_MAX=XYZ_EST2
                  ENDIF
               ELSE
                  IF(FFM%W1.NE.0.0_q) THEN
                      LNIONS_EST_MAX=LNIONS_EST1
                      NNEIB_EST_MAX=NNEIB_EST1
                      XYZ_EST_MAX=XYZ_EST1
                  ELSE IF(FFM%W2.NE.0.0_q) THEN
                      LNIONS_EST_MAX=LNIONS_EST2
                      NNEIB_EST_MAX=NNEIB_EST2
                      XYZ_EST_MAX=XYZ_EST2
                  ENDIF
               ENDIF
            ENDIF
            PROFILING_STOP('st_put_fmat_mb')
          END SUBROUTINE SET_EST_DATA_PUT_FMAT_MB

! Subroutine to initialize the expansion coefficients.

          SUBROUTINE INIT_CLM_PUT_FMAT_MB(ICONF)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)       :: ICONF
! Local variables
            INTEGER                   :: IERR          
            IF(FFM%W1.GT.0.0_q) THEN
               MLSHM%CLM1(1:MROW_CLM1,1:NIONS(ICONF))=0.0_q
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               MLSHM%CLM2(1:MROW_CLM2,1:NIONS(ICONF))=0.0_q
               IF(FFM%LSIC) THEN
                  MLSHM%PS_SIC(1:FFM%MMVAR2_SIC,1:NIONS(ICONF))=0.0_q
               ENDIF
            ENDIF
#ifdef use_shmem
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
          END SUBROUTINE INIT_CLM_PUT_FMAT_MB

! Subroutine to calculate the expansion coefficients.

          SUBROUTINE D0CLM_PUT_FMAT_MB(ICONF)
            IMPLICIT NONE
! Input variables
            INTEGER, INTENT(IN)  :: ICONF
! Local variables
            INTEGER              :: IERR
            INTEGER              :: INIONS
            INTEGER              :: INIONS_TMP
            INTEGER              :: INTYP0
            INTEGER              :: LOCVAR_COL_CLM1
            INTEGER              :: LOCVAR_COL_CLM1_COUPLE
            INTEGER              :: LOCVAR_COL_CLM2
            INTEGER              :: LOCVAR_COL_CLM2_COUPLE
            INTEGER              :: LOCVAR_COL_EST1
            INTEGER              :: LOCVAR_COL_EST2
            INTEGER              :: LOCVAR_COL_PS_SIC
            INTEGER              :: LOCVAR_COL_PS_SIC_COUPLE
! MPI-parallel.
            PROFILING_START('d0clm_soap_put_fmat_mb')
            DO INIONS_TMP=1, NIONS(ICONF), PAR_SUP_HANDLE%COMM_WORLD%NCPU
               INIONS=INIONS_TMP+PAR_SUP_HANDLE%COMM_WORLD%NODE_ME
               IF(INIONS.LE.NIONS(ICONF)) THEN
                  INTYP0=LNTYP(INIONS,ICONF)
                  IF(FFM%W1.GT.0.0_q) THEN
                     LOCVAR_COL_CLM1=INIONS
                     LOCVAR_COL_EST1=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM1_COUPLE=1
                     LOCVAR_COL_PS_SIC=1
                     LOCVAR_COL_PS_SIC_COUPLE=1
                     CALL D0CLM_SOAP (MLSHM%CLM1(:,LOCVAR_COL_CLM1),MLSHM%CLM_COUPLE_HELP1_MANYBODY(:,LOCVAR_COL_CLM1_COUPLE),FFM%DRSPL1,FFM%FNL1,FFM%FWIN1, &
                          INTYP0,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX1,LNIONS_EST1(1:,1:,LOCVAR_COL_EST1), &
                          .FALSE.,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW1, &
                          FF%MIONS,MROW_EST1,FFM%MRB1,FFM%MSPL1,MTYP,MLSHM%MROW_CLM1_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                          NNEIB_EST1(1:,LOCVAR_COL_EST1),FFM%NRB1(0:),FFM%NSPL1,NTYP(ICONF), &
                          MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST1(1:,1:,1:,LOCVAR_COL_EST1))
                  ENDIF
                  IF(FFM%W2.GT.0.0_q) THEN
                     LOCVAR_COL_CLM2=INIONS
                     LOCVAR_COL_EST2=CEILING(REAL(INIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
                     LOCVAR_COL_CLM2_COUPLE=1
                     IF(FFM%LSIC) THEN
                        LOCVAR_COL_PS_SIC=INIONS
                     ELSE
                        LOCVAR_COL_PS_SIC=1
                     ENDIF
                     LOCVAR_COL_PS_SIC_COUPLE=1
                     CALL D0CLM_SOAP (MLSHM%CLM2(:,LOCVAR_COL_CLM2),MLSHM%CLM_COUPLE_HELP2_MANYBODY(:,LOCVAR_COL_CLM2_COUPLE),FFM%DRSPL2,FFM%FNL2,FFM%FWIN2, &
                          INTYP0,LADD(1:,ICONF),.FALSE.,FFM%LFLAG_VAR,FFM%LFLAG_VAR_SIC,FFM%LIONS_COUPLE,FFM%LMAX2,LNIONS_EST2(1:,1:,LOCVAR_COL_EST2), &
                          FFM%LSIC,FFM%LVAR,FFM%LVAR_SIC,FFM%LWINDOW2, &
                          FF%MIONS,MROW_EST2,FFM%MRB2,FFM%MSPL2,MTYP,MLSHM%MROW_CLM2_GLOBAL,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY,MLSHM%MROW_PS_SIC_GLOBAL,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL, &
                          NNEIB_EST2(1:,LOCVAR_COL_EST2),FFM%NRB2(0:),FFM%NSPL2,NTYP(ICONF), &
                          MLSHM%PS_SIC(:,LOCVAR_COL_PS_SIC),MLSHM%PS_SIC_COUPLE(:,LOCVAR_COL_PS_SIC_COUPLE),FFM%RCOUPLE_IONS,RMEM_HELP2,XYZ_EST2(1:,1:,1:,LOCVAR_COL_EST2))
                  ENDIF
               ENDIF
               RMEM_HELP1=MAX(RMEM_HELP1,RMEM_HELP2)
            ENDDO
#ifdef use_shmem
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#endif
            PROFILING_STOP('d0clm_soap_put_fmat_mb')
! Reduction of expansion coefficients so that each process possesses the whole array CLM1 and CLM2.
            PROFILING_START ('allred_clm_put_fmat_mb')
#ifdef use_shmem
            IF(FFM%W1.GT.0.0_q) THEN
               IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM1,MLSHM%MROW_CLM1_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM, &
                       PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
               ENDIF
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM2,MLSHM%MROW_CLM2_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM, &
                       PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                  IF(FFM%LSIC) THEN
                     CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC,MLSHM%MROW_PS_SIC_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM, &
                          PAR_SUP_HANDLE%COMM_inter_node_world%MPI_COMM,IERR)
                  ENDIF
               ENDIF
            ENDIF
!!!            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,IERR)
#else
            IF(FFM%W1.GT.0.0_q) THEN
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM1,MLSHM%MROW_CLM1_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
               CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%CLM2,MLSHM%MROW_CLM2_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               IF(FFM%LSIC) THEN
                  CALL MPI_ALLREDUCE(MPI_IN_PLACE,MLSHM%PS_SIC,MLSHM%MROW_PS_SIC_GLOBAL*NIONS(ICONF),MPI_REAL8,MPI_SUM,PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,IERR)
               ENDIF
            ENDIF
#endif
            PROFILING_STOP ('allred_clm_put_fmat_mb')
          END SUBROUTINE D0CLM_PUT_FMAT_MB

! Allocate

          SUBROUTINE ALLOCATE_MB_ARRAY_PUT_FMAT
            IMPLICIT NONE
! Local variables
            INTEGER              :: INTYP0
            RMEM_MB=0.0_q
! Define sizes of arrays.
! Set maximum number of basis set.
            NB_MAX=FFM%NB_NEW(1)
            DO INTYP0=2, FF%MTYP, 1
               NB_MAX=MAX(NB_MAX,FFM%NB_NEW(INTYP0))
            ENDDO
! Sizes for FORCE_HELP.
            MCOL_MIONS=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_MITYP=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of SOAP.
            MROW_SOAP=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_SOAP=FFM%MB_NEW
! Size of VEC_LOC_ENERGY.
            MROW_VEC_LOC_ENERGY=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            MCOL_VEC_LOC_ENERGY=1
! Sizes for structural list.
            IF(.NOT.FFM%LSUPERVEC) THEN
               MROW_EST_MAX=1
               MCOL_EST_MAX=1
            ELSE
               MROW_EST_MAX=MNEIB_EST_MAX+1
               MCOL_EST_MAX=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
            ENDIF
! Sizes for norms.
            IF(.NOT.FFM%LSUPERVEC) THEN
               MROW_RNORM_ALL=1
               MCOL_RNORM_ALL=AB%MTYP
            ELSE
               MROW_RNORM_ALL=MITYP
               MCOL_RNORM_ALL=AB%MTYP
            ENDIF
            IF(FFM%W1.GT.0.0_q) THEN
! Size of C00.
               MROW_C00=FFM%MMVAR1
               MCOL_C00=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of C00_COUPLE.
               IF(FFM%LCOUPLE) THEN
                  MROW_C00_COUPLE=FFM%MMVAR1
                  MCOL_C00_COUPLE=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  MROW_C00_COUPLE=1
                  MCOL_C00_COUPLE=1
               ENDIF
! Set size of CLM1.
               MROW_CLM1=(FFM%LMAX1+1)**2*FF%MTYP_ALLOCATE*FFM%MRB1
               MCOL_CLM1=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of DC00.
               MROW_DC00=FFM%MMVAR1
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MCOL_DC00=MNEIB_EST1+1 
               ELSE
                  MCOL_DC00=MNEIB_EST_MAX+1
               ENDIF
! Size of DCLM1.
               MROW_DCLM1=(FFM%LMAX1+1)**2*FF%MTYP_ALLOCATE*FFM%MRB1
               MCOL_DCLM1=MNEIB_EST1+1
! Size of DSOAP1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_DSOAP1=MNEIB_EST1+1
               ELSE
                  MROW_DSOAP1=MNEIB_EST_MAX+1
               ENDIF
               MCOL_DSOAP1=FFM%MB_NEW
! Size of structural lists.
               MROW_EST1=MNEIB_EST1+1
               MCOL_EST1=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of RNORM_C00 
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_RNORM_C00=MITYP
                  MCOL_RNORM_C00=AB%MTYP
               ELSE
                  MROW_RNORM_C00=1
                  MCOL_RNORM_C00=AB%MTYP
               ENDIF
! Size of VEC_LOC_FORCE1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_FORCE1=MNEIB_EST1+1
               ELSE
                  MROW_VEC_LOC_FORCE1=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_FORCE1=1
! Size of VEC_LOC_STRESS1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_STRESS1=MNEIB_EST1+1
               ELSE
                  MROW_VEC_LOC_STRESS1=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_STRESS1=1
            ELSE
               MCOL_C00=1
               MROW_C00=1
               MROW_C00_COUPLE=1
               MCOL_C00_COUPLE=1
               MROW_CLM1=1
               MCOL_CLM1=1
               MCOL_DC00=1
               MROW_DC00=1
               MROW_DCLM1=1
               MCOL_DCLM1=1
               MROW_DSOAP1=1
               MCOL_DSOAP1=1
               MROW_EST1=1
               MCOL_EST1=1
               MROW_RNORM_C00=1
               MCOL_RNORM_C00=AB%MTYP
               MROW_VEC_LOC_FORCE1=1
               MCOL_VEC_LOC_FORCE1=1
               MROW_VEC_LOC_STRESS1=1
               MCOL_VEC_LOC_STRESS1=1
            ENDIF
            IF(FFM%W2.GT.0.0_q) THEN
! Set size of CLM2.
               MROW_CLM2=(FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2
               MCOL_CLM2=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of DCLM2.
               MROW_DCLM2=(FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2
               MCOL_DCLM2=MNEIB_EST2+1
! Size of DPS.
               MROW_DPS=FFM%MMVAR2
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MCOL_DPS=MNEIB_EST2+1
               ELSE
                  MCOL_DPS=MNEIB_EST_MAX+1
               ENDIF
! Size of DPS_SIC.
               IF(FFM%LSIC) THEN
                  MROW_DPS_SIC=FFM%MMVAR2
                  MCOL_DPS_SIC=MNEIB_EST2+1
               ELSE
                  MROW_DPS_SIC=1
                  MCOL_DPS_SIC=1
               ENDIF
! Size of DSOAP1.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_DSOAP2=MNEIB_EST2+1
               ELSE
                  MROW_DSOAP2=MNEIB_EST_MAX+1
               ENDIF
               MCOL_DSOAP2=FFM%MB_NEW
! Size of structural lists.
               MROW_EST2=MNEIB_EST2+1
               MCOL_EST2=CEILING(REAL(MIONS,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of PS.
               MROW_PS=FFM%MMVAR2
               MCOL_PS=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
! Size of PS_COUPLE.
               IF(FFM%LCOUPLE) THEN
                  MROW_PS_COUPLE=FFM%MMVAR2
                  MCOL_PS_COUPLE=CEILING(REAL(MITYP,q)/REAL(PAR_SUP_HANDLE%COMM_WORLD%NCPU,q))
               ELSE
                  MROW_PS_COUPLE=1
                  MCOL_PS_COUPLE=1
               ENDIF
! Size of RNORM_PS
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_RNORM_PS=MITYP
                  MCOL_RNORM_PS=AB%MTYP
               ELSE
                  MROW_RNORM_PS=1
                  MCOL_RNORM_PS=AB%MTYP
               ENDIF
! Size of VEC_LOC_FORCE2.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_FORCE2=MNEIB_EST2+1
               ELSE
                  MROW_VEC_LOC_FORCE2=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_FORCE2=1
! Size of VEC_LOC_STRESS2.
               IF(.NOT.FFM%LSUPERVEC) THEN
                  MROW_VEC_LOC_STRESS2=MNEIB_EST2+1
               ELSE
                  MROW_VEC_LOC_STRESS2=MNEIB_EST_MAX+1
               ENDIF
               MCOL_VEC_LOC_STRESS2=1
            ELSE
               MROW_CLM2=1
               MCOL_CLM2=1
               MROW_DCLM2=1
               MCOL_DCLM2=1
               MCOL_DPS=1
               MROW_DPS=1
               MROW_DPS_SIC=1
               MCOL_DPS_SIC=1
               MROW_DSOAP2=1
               MCOL_DSOAP2=1
               MROW_EST2=1
               MCOL_EST2=1
               MCOL_PS=1
               MROW_PS=1
               MROW_PS_COUPLE=1
               MCOL_PS_COUPLE=1
               MROW_RNORM_PS=1
               MCOL_RNORM_PS=AB%MTYP
               MROW_VEC_LOC_FORCE2=1
               MCOL_VEC_LOC_FORCE2=1
               MROW_VEC_LOC_STRESS2=1
               MCOL_VEC_LOC_STRESS2=1
            ENDIF
! Then, allocate arrays.
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            ALLOCATE (C00(1:MROW_C00,1:MCOL_C00,1:AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MROW_C00,q)*REAL(MCOL_C00,q)*REAL(AB%MTYP_ALLOCATE,q)*8/1.0E+06_q
            IF(ALLOCATED(C00_COUPLE)) THEN
               DEALLOCATE(C00_COUPLE)
            ENDIF
            ALLOCATE (C00_COUPLE(1:MROW_C00_COUPLE))
            RMEM_MB=RMEM_MB+REAL(MROW_C00_COUPLE,q)*8/1.0E+06_q
            IF(ALLOCATED(DC00)) THEN
               DEALLOCATE(DC00)
            ENDIF
            ALLOCATE (DC00(1:MROW_DC00,1:MCOL_DC00,0:3,1:AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MROW_DC00,q)*REAL(MCOL_DC00,q)*REAL(AB%MTYP_ALLOCATE,q)*4*8/1.0E+06_q
            IF(ALLOCATED(DCLM1)) THEN
               DEALLOCATE(DCLM1)
            ENDIF
            ALLOCATE (DCLM1(1:3,1:MROW_DCLM1,1:FF%MTYP_ALLOCATE,1:MCOL_DCLM1))
            RMEM_MB=RMEM_MB+3*REAL(MROW_DCLM1,q)*REAL(MCOL_DCLM1,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
            DCLM1=0.0_q 
            IF(ALLOCATED(DCLM2)) THEN
               DEALLOCATE(DCLM2)
            ENDIF
            ALLOCATE (DCLM2(1:3,1:MROW_DCLM2,1:FF%MTYP_ALLOCATE,1:MCOL_DCLM2))
            RMEM_MB=RMEM_MB+3*REAL(MROW_DCLM2,q)*REAL(MCOL_DCLM2,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
            DCLM2=0.0_q
            IF(ALLOCATED(DPS)) THEN
               DEALLOCATE(DPS)
            ENDIF
            ALLOCATE (DPS(1:MROW_DPS,1:MCOL_DPS,0:3,1:AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MROW_DPS,q)*REAL(MCOL_DPS,q)*REAL(AB%MTYP_ALLOCATE,q)*4*8/1.0E+06_q
            IF(ALLOCATED(DPS_SIC)) THEN
               DEALLOCATE(DPS_SIC)
            ENDIF
            ALLOCATE (DPS_SIC(1:MROW_DPS_SIC,1:MCOL_DPS_SIC,1:3,1:AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MROW_DPS_SIC,q)*REAL(MCOL_DPS_SIC,q)*REAL(AB%MTYP_ALLOCATE,q)*3*8/1.0E+06_q
            IF(ALLOCATED(DSOAP11)) THEN
               DEALLOCATE(DSOAP11)
            ENDIF
            ALLOCATE (DSOAP11(1:MROW_DSOAP1,1:MCOL_DSOAP1))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP1,q)*REAL(MCOL_DSOAP1,q)*8/1.0E+06_q
            IF(ALLOCATED(DSOAP21)) THEN
               DEALLOCATE(DSOAP21)
            ENDIF
            ALLOCATE (DSOAP21(1:MROW_DSOAP1,1:MCOL_DSOAP1,1:3))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP1,q)*REAL(MCOL_DSOAP1,q)*3*8/1.0E+06_q
            IF(ALLOCATED(DSOAP12)) THEN
               DEALLOCATE(DSOAP12)
            ENDIF
            ALLOCATE (DSOAP12(1:MROW_DSOAP2,1:MCOL_DSOAP2))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP2,q)*REAL(MCOL_DSOAP2,q)*8/1.0E+06_q
            IF(ALLOCATED(DSOAP22)) THEN
               DEALLOCATE(DSOAP22)
            ENDIF
            ALLOCATE (DSOAP22(1:MROW_DSOAP2,1:MCOL_DSOAP2,1:3))
            RMEM_MB=RMEM_MB+REAL(MROW_DSOAP2,q)*REAL(MCOL_DSOAP2,q)*3*8/1.0E+06_q
            IF(ALLOCATED(ENERGY_HELP)) THEN
               DEALLOCATE(ENERGY_HELP)
            ENDIF
            ALLOCATE(ENERGY_HELP(1:FFM%MB_NEW))
            RMEM_MB=RMEM_MB+REAL(FFM%MB_NEW,q)*8/1.0E+06_q
            ENERGY_HELP=0.0_q
            IF(ALLOCATED(FORCE_HELP1)) THEN
               DEALLOCATE(FORCE_HELP1)
            ENDIF
            ALLOCATE(FORCE_HELP1(1:FFM%MB_NEW,1:3,1:MCOL_MIONS,1:FF%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(FFM%MB_NEW,q)*REAL(MCOL_MIONS,q)*REAL(FF%MTYP_ALLOCATE,q)*3*8/1.0E+06_q
            FORCE_HELP1=0.0_q
            IF(ALLOCATED(FORCE_HELP2)) THEN
               DEALLOCATE(FORCE_HELP2)
            ENDIF
            ALLOCATE(FORCE_HELP2(1:FFM%MB_NEW))
            RMEM_MB=RMEM_MB+REAL(FFM%MB_NEW,q)*8/1.0E+06_q
            FORCE_HELP2=0.0_q
            IF(ALLOCATED(LHEAD)) THEN
               DEALLOCATE(LHEAD)
            ENDIF
            ALLOCATE(LHEAD(1:FF%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            ALLOCATE (PS(1:MROW_PS,1:MCOL_PS,1:AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MROW_PS,q)*REAL(MCOL_PS,q)*REAL(AB%MTYP_ALLOCATE,q)*8/1.0E+06_q
            IF(ALLOCATED(PS_COUPLE)) THEN
               DEALLOCATE(PS_COUPLE)
            ENDIF
            ALLOCATE (PS_COUPLE(1:MROW_PS_COUPLE))
            RMEM_MB=RMEM_MB+REAL(MROW_PS_COUPLE,q)*8/1.0E+06_q
            IF(ALLOCATED(RNORM_ALL)) THEN
               DEALLOCATE(RNORM_ALL)
            ENDIF
            ALLOCATE (RNORM_ALL(1:MITYP,AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MITYP,q)*REAL(AB%MTYP_ALLOCATE,q)*8/1.0E+06_q
            IF(ALLOCATED(RNORM_C00)) THEN
               DEALLOCATE(RNORM_C00)
            ENDIF
            ALLOCATE (RNORM_C00(1:MITYP,AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MITYP,q)*REAL(AB%MTYP_ALLOCATE,q)*8/1.0E+06_q
            IF(ALLOCATED(RNORM_PS)) THEN
               DEALLOCATE(RNORM_PS)
            ENDIF
            ALLOCATE (RNORM_PS(1:MITYP,1:AB%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(MITYP,q)*REAL(AB%MTYP_ALLOCATE,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            ALLOCATE (LNIONS_EST1(1:MROW_EST1,1:AB%MTYP_ALLOCATE,1:MCOL_EST1))
            RMEM_MB=RMEM_MB+REAL(MROW_EST1,q)*REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            ALLOCATE (NNEIB_EST1(1:AB%MTYP_ALLOCATE,1:MCOL_EST1))
            RMEM_MB=RMEM_MB+REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            ALLOCATE (XYZ_EST1(1:3,1:MROW_EST1,1:AB%MTYP_ALLOCATE,1:MCOL_EST1))
            RMEM_MB=RMEM_MB+3*REAL(MROW_EST1,q)*REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST1,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            ALLOCATE (LNIONS_EST2(1:MROW_EST2,1:AB%MTYP_ALLOCATE,1:MCOL_EST2))
            RMEM_MB=RMEM_MB+REAL(MROW_EST2,q)*REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            ALLOCATE (NNEIB_EST2(1:AB%MTYP_ALLOCATE,1:MCOL_EST2))
            RMEM_MB=RMEM_MB+REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
            ALLOCATE (XYZ_EST2(1:3,1:MROW_EST2,1:AB%MTYP_ALLOCATE,1:MCOL_EST2))
            RMEM_MB=RMEM_MB+3*REAL(MROW_EST2,q)*REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST2,q)*8/1.0E+06_q
            IF(ALLOCATED(LNIONS_EST_MAX)) THEN
               DEALLOCATE(LNIONS_EST_MAX)
            ENDIF
            ALLOCATE (LNIONS_EST_MAX(1:MROW_EST_MAX,1:AB%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            RMEM_MB=RMEM_MB+REAL(MROW_EST_MAX,q)*REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST_MAX,q)/1.0E+06_q
            IF(ALLOCATED(NNEIB_EST_MAX)) THEN
               DEALLOCATE(NNEIB_EST_MAX)
            ENDIF
            ALLOCATE (NNEIB_EST_MAX(1:AB%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            RMEM_MB=RMEM_MB+REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST_MAX,q)/1.0E+06_q
            IF(ALLOCATED(XYZ_EST_MAX)) THEN
               DEALLOCATE(XYZ_EST_MAX)
            ENDIF
            ALLOCATE (XYZ_EST_MAX(1:3,1:MROW_EST_MAX,1:AB%MTYP_ALLOCATE,1:MCOL_EST_MAX))
            RMEM_MB=RMEM_MB+3*REAL(MROW_EST_MAX,q)*REAL(AB%MTYP_ALLOCATE,q)*REAL(MCOL_EST_MAX,q)*8/1.0E+06_q
            IF(ALLOCATED(STRESS_HELP)) THEN
               DEALLOCATE(STRESS_HELP)
            ENDIF
            ALLOCATE(STRESS_HELP(1:FFM%MB_NEW,1:3,1:3,1:FF%MTYP_ALLOCATE))
            RMEM_MB=RMEM_MB+REAL(FFM%MB_NEW,q)*REAL(FF%MTYP_ALLOCATE,q)*9*8/1.0E+06_q
            STRESS_HELP=0.0_q
            IF(ALLOCATED(SOAP1)) THEN
               DEALLOCATE(SOAP1)
            ENDIF
            ALLOCATE (SOAP1(1:MROW_SOAP,1:MCOL_SOAP))
            RMEM_MB=RMEM_MB+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
            IF(ALLOCATED(SOAP2)) THEN
               DEALLOCATE(SOAP2)
            ENDIF
            ALLOCATE (SOAP2(1:MROW_SOAP,1:MCOL_SOAP))
            RMEM_MB=RMEM_MB+REAL(MROW_SOAP,q)*REAL(MCOL_SOAP,q)*8/1.0E+06_q
            IF(ALLOCATED(VEC_LOC_ENERGY)) THEN
               DEALLOCATE(VEC_LOC_ENERGY)
            ENDIF
            ALLOCATE (VEC_LOC_ENERGY(1:MROW_VEC_LOC_ENERGY,1:MCOL_VEC_LOC_ENERGY))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_ENERGY,q)*REAL(MCOL_VEC_LOC_ENERGY,q)*8/1.0E+06_q
            VEC_LOC_ENERGY=0.0_q
            IF(ALLOCATED(VEC_LOC_FORCE1)) THEN
               DEALLOCATE(VEC_LOC_FORCE1)
            ENDIF
            ALLOCATE (VEC_LOC_FORCE1(1:MROW_VEC_LOC_FORCE1,1:MCOL_VEC_LOC_FORCE1))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_FORCE1,q)*REAL(MCOL_VEC_LOC_FORCE1,q)*8/1.0E+06_q
            VEC_LOC_FORCE1=0.0_q
            IF(ALLOCATED(VEC_LOC_FORCE2)) THEN
               DEALLOCATE(VEC_LOC_FORCE2)
            ENDIF
            ALLOCATE (VEC_LOC_FORCE2(1:MROW_VEC_LOC_FORCE2,1:MCOL_VEC_LOC_FORCE2))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_FORCE2,q)*REAL(MCOL_VEC_LOC_FORCE2,q)*8/1.0E+06_q
            VEC_LOC_FORCE2=0.0_q
            IF(ALLOCATED(VEC_LOC_STRESS1)) THEN
               DEALLOCATE(VEC_LOC_STRESS1)
            ENDIF
            ALLOCATE (VEC_LOC_STRESS1(1:MROW_VEC_LOC_STRESS1,1:MCOL_VEC_LOC_STRESS1))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_STRESS1,q)*REAL(MCOL_VEC_LOC_STRESS1,q)*8/1.0E+06_q
            VEC_LOC_STRESS1=0.0_q
            IF(ALLOCATED(VEC_LOC_STRESS2)) THEN
               DEALLOCATE(VEC_LOC_STRESS2)
            ENDIF
            ALLOCATE (VEC_LOC_STRESS2(1:MROW_VEC_LOC_STRESS2,1:MCOL_VEC_LOC_STRESS2))
            RMEM_MB=RMEM_MB+REAL(MROW_VEC_LOC_STRESS2,q)*REAL(MCOL_VEC_LOC_STRESS2,q)*8/1.0E+06_q
            VEC_LOC_STRESS2=0.0_q
          END SUBROUTINE ALLOCATE_MB_ARRAY_PUT_FMAT

! Deallocate

          SUBROUTINE DEALLOCATE_MB_ARRAY_PUT_FMAT
            IMPLICIT NONE
            IF(ALLOCATED(C00)) THEN
               DEALLOCATE(C00)
            ENDIF
            IF(ALLOCATED(C00_COUPLE)) THEN
               DEALLOCATE(C00_COUPLE)
            ENDIF
            IF(ALLOCATED(DC00)) THEN
               DEALLOCATE(DC00)
            ENDIF
            IF(ALLOCATED(DCLM1)) THEN
               DEALLOCATE(DCLM1)
            ENDIF
            IF(ALLOCATED(DCLM2)) THEN
               DEALLOCATE(DCLM2)
            ENDIF
            IF(ALLOCATED(DPS)) THEN
               DEALLOCATE(DPS)
            ENDIF
            IF(ALLOCATED(DPS_SIC)) THEN
               DEALLOCATE(DPS_SIC)
            ENDIF
            IF(ALLOCATED(DSOAP11)) THEN
               DEALLOCATE(DSOAP11)
            ENDIF
            IF(ALLOCATED(DSOAP21)) THEN
               DEALLOCATE(DSOAP21)
            ENDIF
            IF(ALLOCATED(DSOAP12)) THEN
               DEALLOCATE(DSOAP12)
            ENDIF
            IF(ALLOCATED(DSOAP22)) THEN
               DEALLOCATE(DSOAP22)
            ENDIF
            IF(ALLOCATED(ENERGY_HELP)) THEN
               DEALLOCATE(ENERGY_HELP)
            ENDIF
            IF(ALLOCATED(FORCE_HELP1)) THEN
               DEALLOCATE(FORCE_HELP1)
            ENDIF
            IF(ALLOCATED(FORCE_HELP2)) THEN
               DEALLOCATE(FORCE_HELP2)
            ENDIF
            IF(ALLOCATED(LHEAD)) THEN
               DEALLOCATE(LHEAD)
            ENDIF
            IF(ALLOCATED(PS)) THEN
               DEALLOCATE(PS)
            ENDIF
            IF(ALLOCATED(PS_COUPLE)) THEN
               DEALLOCATE(PS_COUPLE)
            ENDIF
            IF(ALLOCATED(RNORM_ALL)) THEN
               DEALLOCATE(RNORM_ALL)
            ENDIF
            IF(ALLOCATED(RNORM_C00)) THEN
               DEALLOCATE(RNORM_C00)
            ENDIF
            IF(ALLOCATED(RNORM_PS)) THEN
               DEALLOCATE(RNORM_PS)
            ENDIF
            IF(ALLOCATED(LNIONS_EST1)) THEN
               DEALLOCATE(LNIONS_EST1)
            ENDIF
            IF(ALLOCATED(LNIONS_EST2)) THEN
               DEALLOCATE(LNIONS_EST2)
            ENDIF
            IF(ALLOCATED(LNIONS_EST_MAX)) THEN
               DEALLOCATE(LNIONS_EST_MAX)
            ENDIF
            IF(ALLOCATED(NNEIB_EST1)) THEN
               DEALLOCATE(NNEIB_EST1)
            ENDIF
            IF(ALLOCATED(NNEIB_EST2)) THEN
               DEALLOCATE(NNEIB_EST2)
            ENDIF
            IF(ALLOCATED(NNEIB_EST_MAX)) THEN
               DEALLOCATE(NNEIB_EST_MAX)
            ENDIF
            IF(ALLOCATED(SOAP1)) THEN
               DEALLOCATE(SOAP1)
            ENDIF
            IF(ALLOCATED(SOAP2)) THEN
               DEALLOCATE(SOAP2)
            ENDIF
            IF(ALLOCATED(STRESS_HELP)) THEN
               DEALLOCATE(STRESS_HELP)
            ENDIF
            IF(ALLOCATED(VEC_LOC_ENERGY)) THEN
               DEALLOCATE(VEC_LOC_ENERGY)
            ENDIF
            IF(ALLOCATED(VEC_LOC_FORCE1)) THEN
               DEALLOCATE(VEC_LOC_FORCE1)
            ENDIF
            IF(ALLOCATED(VEC_LOC_FORCE2)) THEN
               DEALLOCATE(VEC_LOC_FORCE2)
            ENDIF
            IF(ALLOCATED(VEC_LOC_STRESS1)) THEN
               DEALLOCATE(VEC_LOC_STRESS1)
            ENDIF
            IF(ALLOCATED(VEC_LOC_STRESS2)) THEN
               DEALLOCATE(VEC_LOC_STRESS2)
            ENDIF
            IF(ALLOCATED(XYZ_EST1)) THEN
               DEALLOCATE(XYZ_EST1)
            ENDIF
            IF(ALLOCATED(XYZ_EST2)) THEN
               DEALLOCATE(XYZ_EST2)
            ENDIF
            IF(ALLOCATED(XYZ_EST_MAX)) THEN
               DEALLOCATE(XYZ_EST_MAX)
            ENDIF
          END SUBROUTINE DEALLOCATE_MB_ARRAY_PUT_FMAT

        END SUBROUTINE PUT_FMAT
#endif

#ifndef ML_LEARNING_NOT_ACTIVE
!****************************************************************************************************
! Renew the size data
! Not parallelized since all arrays are shared, and the operations should be fast
!****************************************************************************************************

        SUBROUTINE PUT_SIZE (FF,FFM,ISYS_NEW,LABORT,MCONF_NEW,NCONF,NCONF_NEW,NCONF_SYS,NSTEP,NSYS)
          USE ML_FF_STRUCT, ONLY: FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (FF_PAR)      :: FF
          TYPE (FFM_PAR)     :: FFM
          INTEGER, INTENT(IN)    :: ISYS_NEW
          LOGICAL, INTENT(IN)    :: LABORT
          INTEGER, INTENT(IN)    :: MCONF_NEW
          INTEGER, INTENT(IN)    :: NCONF_NEW
          INTEGER, INTENT(IN)    :: NSTEP
          INTEGER, INTENT(IN)    :: NSYS
! Input and output variables
          INTEGER, INTENT(INOUT) :: NCONF
          INTEGER, INTENT(INOUT) :: NCONF_SYS(:) !(1:NSYS)
! Local variables
          INTEGER                :: IB
          INTEGER                :: ICONF
          INTEGER                :: INTYP0
! Start profiling
          PROFILING_START('put_size')
          NCONF=NCONF+NCONF_NEW
          NCONF_SYS(ISYS_NEW)=NCONF_SYS(ISYS_NEW)+NCONF_NEW
          DO INTYP0=1, FF%MTYP
             FFM%NB(INTYP0)=FFM%NB(INTYP0)+FFM%NB_NEW(INTYP0)
             FFM%NB_NEW(INTYP0)=0
          ENDDO
          FFM%LBHEAD(1)=0
          DO INTYP0=2, FF%MTYP
             FFM%LBHEAD(INTYP0)=FFM%LBHEAD(INTYP0-1)+FFM%NB(INTYP0-1)
          ENDDO
          FFM%NBTOT=0
          DO INTYP0=1, FF%MTYP
             DO IB=1, FFM%NB(INTYP0)
                FFM%NBTOT=FFM%NBTOT+1
                FFM%LB(IB,INTYP0)=FFM%NBTOT
             ENDDO
          ENDDO
! Stop profiling
          PROFILING_STOP('put_size')
        END SUBROUTINE PUT_SIZE
#endif

!****************************************************************************************************
! Subroutine to allocate the arrays storing the element order
!****************************************************************************************************

        SUBROUTINE ALLOCATE_FFARRAY1(FF,FFM)
          USE ML_FF_STRUCT, ONLY: FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (FF_PAR)      :: FF
          TYPE (FFM_PAR)     :: FFM
          IF(ALLOCATED(FF%EATOM_REF)) THEN
             DEALLOCATE(FF%EATOM_REF)
          ENDIF
          ALLOCATE(FF%EATOM_REF(1:FF%MTYP_ALLOCATE))
          IF(ALLOCATED(FF%LADD)) THEN
             DEALLOCATE(FF%LADD)
          ENDIF
          ALLOCATE (FF%LADD(1:FF%MTYP_ALLOCATE))
          IF(ALLOCATED(FFM%NNVAR2)) THEN
             DEALLOCATE(FFM%NNVAR2)
          ENDIF
          ALLOCATE (FFM%NNVAR2(1:FF%MTYP_ALLOCATE))
          IF(ALLOCATED(FFM%NNVAR2_SIC)) THEN
             DEALLOCATE(FFM%NNVAR2_SIC)
          ENDIF
          ALLOCATE (FFM%NNVAR2_SIC(1:FF%MTYP_ALLOCATE))
          IF(ALLOCATED(FF%POMASS)) THEN
             DEALLOCATE(FF%POMASS)
          ENDIF
          ALLOCATE(FF%POMASS(1:FF%MTYP_ALLOCATE))
          IF(ALLOCATED(FF%TYPE)) THEN
             DEALLOCATE(FF%TYPE)
          ENDIF
          ALLOCATE(FF%TYPE(1:FF%MTYP_ALLOCATE))
          IF(FF%LMLMB) THEN
             IF(ALLOCATED(FFM%WION1)) THEN
                DEALLOCATE(FFM%WION1)
             ENDIF
             ALLOCATE(FFM%WION1(1:FF%MTYP_ALLOCATE))
             IF(ALLOCATED(FFM%WION2)) THEN
                DEALLOCATE(FFM%WION2)
             ENDIF
             ALLOCATE(FFM%WION2(1:FF%MTYP_ALLOCATE))
          ENDIF
          FF%EATOM_REF=0.0_q
          FF%LADD=0
          FF%TYPE=''
          IF(FF%LMLMB) THEN
             FFM%WION1=0.0_q
             FFM%WION2=0.0_q
          ENDIF
        END SUBROUTINE ALLOCATE_FFARRAY1

!****************************************************************************************************
! Subroutine to allocate the arrays storing the system order
!****************************************************************************************************

        SUBROUTINE ALLOCATE_FFARRAY2(FF,FFM)
          USE ML_FF_STRUCT, ONLY: FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (FF_PAR)      :: FF
          TYPE (FFM_PAR)     :: FFM
          IF(ALLOCATED(FF%SZNAM2)) THEN
             DEALLOCATE(FF%SZNAM2)
          ENDIF
          ALLOCATE(FF%SZNAM2(1:FF%NSYS_ALLOCATE))
          IF(ALLOCATED(FF%SZNAM2_INPUT)) THEN
             DEALLOCATE(FF%SZNAM2_INPUT)
          ENDIF
          ALLOCATE(FF%SZNAM2_INPUT(1:FF%NSYS_ALLOCATE))
          IF(ALLOCATED(FF%SIG_SYS)) THEN
             DEALLOCATE(FF%SIG_SYS)
          ENDIF
          ALLOCATE(FF%SIG_SYS(1:10,1:FF%NSYS_ALLOCATE))
          IF(ALLOCATED(FFM%SIG_SYS)) THEN
             DEALLOCATE(FFM%SIG_SYS)
          ENDIF
          ALLOCATE(FFM%SIG_SYS(1:10,1:FF%NSYS_ALLOCATE))
        END SUBROUTINE ALLOCATE_FFARRAY2

!****************************************************************************************************
! Subroutine to allocate arrays storing force field parameters
!****************************************************************************************************

        SUBROUTINE ALLOCATE_FFARRAY3_SET_VARIABLES(PAR_SUP_HANDLE,MLSHM,FF,FFM)
          USE ML_FF_STRUCT, ONLY: PARALLEL_SUPER, ML_SHMEM, MEMORY, FF_PAR, FFM_PAR
          IMPLICIT NONE
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
          INTEGER               :: IERR
#ifdef scaLAPACK
! Local 1-point correlation (radial) descriptor
          IF(FFM%W1.GT.0.0_q) THEN
             PAR_SUP_HANDLE%DESC_C00_FFM%M=FFM%MMVAR1
             PAR_SUP_HANDLE%DESC_C00_FFM%N=FFM%MB
             PAR_SUP_HANDLE%DESC_C00_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_C00_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_C00_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_C00_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_C00_FFM%DESC,PAR_SUP_HANDLE%DESC_C00_FFM%M,PAR_SUP_HANDLE%DESC_C00_FFM%N, &
                  PAR_SUP_HANDLE%DESC_C00_FFM%MB,PAR_SUP_HANDLE%DESC_C00_FFM%NB,PAR_SUP_HANDLE%DESC_C00_FFM%IRSRC,PAR_SUP_HANDLE%DESC_C00_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_C00_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M,PAR_SUP_HANDLE%DESC_C00_FFM%LOC_N)
! New local 1-point correlation (radial) descriptor
             PAR_SUP_HANDLE%DESC_C00_NEW_FFM%M=FFM%MMVAR1
             PAR_SUP_HANDLE%DESC_C00_NEW_FFM%N=FF%MITYP
             PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_C00_NEW_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_C00_NEW_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_C00_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%M,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%N, &
                  PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_N)
          ENDIF
! Local 2-point correlation (angular) descriptor
          IF(FFM%W2.GT.0.0_q) THEN
             PAR_SUP_HANDLE%DESC_PS_FFM%M=FFM%MMVAR2
             PAR_SUP_HANDLE%DESC_PS_FFM%N=FFM%MB
             PAR_SUP_HANDLE%DESC_PS_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_PS_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_PS_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_PS_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_PS_FFM%DESC,PAR_SUP_HANDLE%DESC_PS_FFM%M,PAR_SUP_HANDLE%DESC_PS_FFM%N, &
                  PAR_SUP_HANDLE%DESC_PS_FFM%MB,PAR_SUP_HANDLE%DESC_PS_FFM%NB,PAR_SUP_HANDLE%DESC_PS_FFM%IRSRC,PAR_SUP_HANDLE%DESC_PS_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_PS_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N)
! New local 2-point correlation (radial and angular) descriptor
             PAR_SUP_HANDLE%DESC_PS_NEW_FFM%M=FFM%MMVAR2
             PAR_SUP_HANDLE%DESC_PS_NEW_FFM%N=FF%MITYP
             PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_PS_NEW_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_PS_NEW_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_PS_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%M,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%N, &
                  PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_N)
          ENDIF
! Covariance matrix
          PAR_SUP_HANDLE%DESC_CMAT_FFM%M=FFM%MBTOT
          PAR_SUP_HANDLE%DESC_CMAT_FFM%N=FFM%MBTOT
          PAR_SUP_HANDLE%DESC_CMAT_FFM%MB=NBLOCK_SCALAPACK
          PAR_SUP_HANDLE%DESC_CMAT_FFM%NB=NBLOCK_SCALAPACK
          PAR_SUP_HANDLE%DESC_CMAT_FFM%IRSRC=0
          PAR_SUP_HANDLE%DESC_CMAT_FFM%ICSRC=0
          CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_CMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_CMAT_FFM%M,PAR_SUP_HANDLE%DESC_CMAT_FFM%N, &
               PAR_SUP_HANDLE%DESC_CMAT_FFM%MB,PAR_SUP_HANDLE%DESC_CMAT_FFM%NB,PAR_SUP_HANDLE%DESC_CMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_CMAT_FFM%ICSRC, &
               PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
               PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_CMAT_FFM%LLD, &
               PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N)
! Allocate local design matrix if FF%LMLONLY=.FALSE. or FF%ISTART/=2.
! FF%LMLONLY=.TRUE. and FF%ISTART=2, the design matrix is not necessary.
          IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
             PAR_SUP_HANDLE%DESC_FMAT_FFM%M=FFM%MB
             PAR_SUP_HANDLE%DESC_FMAT_FFM%N=FFM%MDATA
             PAR_SUP_HANDLE%DESC_FMAT_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_FMAT_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_FMAT_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_FMAT_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_FMAT_FFM%M,PAR_SUP_HANDLE%DESC_FMAT_FFM%N, &
                  PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%DESC_FMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N)
! Allocate local new design matrix
             PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%M=FFM%MB
             PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%N=FFM%MDATA_NEW
             PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB=1
             PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%M,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%N, &
                  PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_N)
          ENDIF
! Allocate local SOAP matrix and its inverse
          PAR_SUP_HANDLE%DESC_SOAP_FFM%M=FFM%MB
          PAR_SUP_HANDLE%DESC_SOAP_FFM%N=FFM%MB
          PAR_SUP_HANDLE%DESC_SOAP_FFM%MB=NBLOCK_SCALAPACK
          PAR_SUP_HANDLE%DESC_SOAP_FFM%NB=NBLOCK_SCALAPACK
          PAR_SUP_HANDLE%DESC_SOAP_FFM%IRSRC=0
          PAR_SUP_HANDLE%DESC_SOAP_FFM%ICSRC=0
          CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,PAR_SUP_HANDLE%DESC_SOAP_FFM%M,PAR_SUP_HANDLE%DESC_SOAP_FFM%N, &
               PAR_SUP_HANDLE%DESC_SOAP_FFM%MB,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%DESC_SOAP_FFM%IRSRC,PAR_SUP_HANDLE%DESC_SOAP_FFM%ICSRC, &
               PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
               PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_SOAP_FFM%LLD, &
               PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N)
! Allocate regression coefficients.
          PAR_SUP_HANDLE%DESC_WMAT_FFM%M=FFM%MB
          PAR_SUP_HANDLE%DESC_WMAT_FFM%N=1
          PAR_SUP_HANDLE%DESC_WMAT_FFM%MB=NBLOCK_SCALAPACK
          PAR_SUP_HANDLE%DESC_WMAT_FFM%NB=1
          PAR_SUP_HANDLE%DESC_WMAT_FFM%IRSRC=0
          PAR_SUP_HANDLE%DESC_WMAT_FFM%ICSRC=0
          CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_WMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_WMAT_FFM%M,PAR_SUP_HANDLE%DESC_WMAT_FFM%N, &
               PAR_SUP_HANDLE%DESC_WMAT_FFM%MB,PAR_SUP_HANDLE%DESC_WMAT_FFM%NB,PAR_SUP_HANDLE%DESC_WMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_WMAT_FFM%ICSRC, &
               PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
               PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_WMAT_FFM%LLD, &
               PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N)
! Allocate training data if FF%LMLONLY=.FALSE. or FF%ISTART/=2.
! If FF%LMLONLY=.TRUE. and FF%ISTART=2, training is not executed, and
! therefore, these arrays are not necessary.
          IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
             PAR_SUP_HANDLE%DESC_YMAT_FFM%M=FFM%MDATA
             PAR_SUP_HANDLE%DESC_YMAT_FFM%N=1
             PAR_SUP_HANDLE%DESC_YMAT_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_YMAT_FFM%NB=1
             PAR_SUP_HANDLE%DESC_YMAT_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_YMAT_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_YMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_YMAT_FFM%M,PAR_SUP_HANDLE%DESC_YMAT_FFM%N, &
                  PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB,PAR_SUP_HANDLE%DESC_YMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_YMAT_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_YMAT_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N)
          ENDIF
#endif
! Shared memory arrays.
! Shared memory arrays need to be defined regardless the use of the scaLAPACK.
! Sizes of the shared memory arrays.
! CLM1
          IF(FFM%W1.GT.0.0_q) THEN
             MLSHM%MROW_CLM1_GLOBAL=(FFM%LMAX1+1)**2*FF%MTYP*FFM%MRB1
             MLSHM%MCOL_CLM1_GLOBAL=MAX(FF%MIONS,FFM%MB)
             MLSHM%MROW_CLM1_GLOBAL_ALLOCATE=(FFM%LMAX1+1)**2*FF%MTYP_ALLOCATE*FFM%MRB1
             MLSHM%MCOL_CLM1_GLOBAL_ALLOCATE=MAX(FF%MIONS_ALLOCATE,FFM%MB_ALLOCATE)
             IF(FFM%LCOUPLE) THEN
                MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY=(FFM%LMAX1+1)**2*FF%MTYP*FFM%MRB1
                MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY=FF%MIONS
                MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE=(FFM%LMAX1+1)**2*FF%MTYP_ALLOCATE*FFM%MRB1
                MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE=FF%MIONS_ALLOCATE
             ELSE
                MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY=1
                MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY=1
                MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE=1
                MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE=1
             ENDIF
          ELSE
             MLSHM%MROW_CLM1_GLOBAL=1
             MLSHM%MCOL_CLM1_GLOBAL=1
             MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY=1
             MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY=1
             MLSHM%MROW_CLM1_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_CLM1_GLOBAL_ALLOCATE=1
             MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE=1
             MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE=1
          ENDIF
          IF(FFM%W2.GT.0.0_q) THEN
             MLSHM%MROW_CLM2_GLOBAL=(FFM%LMAX2+1)**2*FF%MTYP*FFM%MRB2
             MLSHM%MCOL_CLM2_GLOBAL=MAX(FF%MIONS,FFM%MB)
             MLSHM%MROW_CLM2_GLOBAL_ALLOCATE=(FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2
             MLSHM%MCOL_CLM2_GLOBAL_ALLOCATE=MAX(FF%MIONS_ALLOCATE,FFM%MB_ALLOCATE)
             IF(FFM%LCOUPLE) THEN
                MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY=(FFM%LMAX2+1)**2*FF%MTYP*FFM%MRB2
                MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY=FF%MIONS
                MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE=(FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2
                MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE=FF%MIONS_ALLOCATE
             ELSE
                MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY=1
                MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY=1
                MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE=1
                MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE=1
             ENDIF
             IF(FFM%LSIC) THEN
                MLSHM%MROW_PS_SIC_GLOBAL=FFM%MMVAR2_SIC
                MLSHM%MCOL_PS_SIC_GLOBAL=MAX(FF%MIONS,FFM%MB)
                MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE=FFM%MMVAR2_SIC_ALLOCATE
                MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE=MAX(FF%MIONS_ALLOCATE,FFM%MB_ALLOCATE)
                IF(FFM%LCOUPLE) THEN
                   MLSHM%MROW_PS_SIC_COUPLE_GLOBAL=FFM%MMVAR2_SIC
                   MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL=MAX(FF%MIONS,FFM%MB)
                   MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE=FFM%MMVAR2_SIC_ALLOCATE
                   MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE=MAX(FF%MIONS_ALLOCATE,FFM%MB_ALLOCATE)
                ELSE
                   MLSHM%MROW_PS_SIC_COUPLE_GLOBAL=1
                   MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL=1
                   MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE=1
                   MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE=1
                ENDIF
             ELSE
                MLSHM%MROW_PS_SIC_GLOBAL=1
                MLSHM%MCOL_PS_SIC_GLOBAL=1
                MLSHM%MROW_PS_SIC_COUPLE_GLOBAL=1
                MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL=1
                MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE=1
                MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE=1
                MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE=1
                MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE=1
             ENDIF
          ELSE
             MLSHM%MROW_CLM2_GLOBAL=1
             MLSHM%MCOL_CLM2_GLOBAL=1
             MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY=1
             MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY=1
             MLSHM%MROW_PS_SIC_GLOBAL=1
             MLSHM%MCOL_PS_SIC_GLOBAL=1
             MLSHM%MROW_CLM2_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_CLM2_GLOBAL_ALLOCATE=1
             MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE=1
             MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE=1
             MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE=1
             MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE=1
          ENDIF
          IF(.NOT.FFM%LSUPERVEC) THEN
             MLSHM%MROW_SOAP_ALL_GLOBAL=1
             MLSHM%MCOL_SOAP_ALL_GLOBAL=1
             MLSHM%MROW_SOAP_ALL_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_SOAP_ALL_GLOBAL_ALLOCATE=1
             IF(FFM%W1.GT.0.0_q) THEN
                MLSHM%MROW_SOAP_C00_GLOBAL=FF%MIONS
                MLSHM%MCOL_SOAP_C00_GLOBAL=FFM%MB
                MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE=FF%MIONS_ALLOCATE
                MLSHM%MCOL_SOAP_C00_GLOBAL_ALLOCATE=FFM%MB_ALLOCATE
             ELSE
                MLSHM%MROW_SOAP_C00_GLOBAL=1
                MLSHM%MCOL_SOAP_C00_GLOBAL=1
                MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE=1
                MLSHM%MCOL_SOAP_C00_GLOBAL_ALLOCATE=1
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                MLSHM%MROW_SOAP_PS_GLOBAL=FF%MIONS
                MLSHM%MCOL_SOAP_PS_GLOBAL=FFM%MB
                MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE=FF%MIONS_ALLOCATE
                MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE=FFM%MB_ALLOCATE
             ELSE
                MLSHM%MROW_SOAP_PS_GLOBAL=1
                MLSHM%MCOL_SOAP_PS_GLOBAL=1
                MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE=1
                MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE=1
             ENDIF
          ELSE
             MLSHM%MROW_SOAP_ALL_GLOBAL=FF%MIONS
             MLSHM%MCOL_SOAP_ALL_GLOBAL=FFM%MB
             MLSHM%MROW_SOAP_C00_GLOBAL=1
             MLSHM%MCOL_SOAP_C00_GLOBAL=1
             MLSHM%MROW_SOAP_PS_GLOBAL=1
             MLSHM%MCOL_SOAP_PS_GLOBAL=1
             MLSHM%MROW_SOAP_ALL_GLOBAL_ALLOCATE=FF%MIONS_ALLOCATE
             MLSHM%MCOL_SOAP_ALL_GLOBAL_ALLOCATE=FFM%MB_ALLOCATE
             MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_SOAP_C00_GLOBAL_ALLOCATE=1
             MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE=1
             MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE=1
          ENDIF
        END SUBROUTINE ALLOCATE_FFARRAY3_SET_VARIABLES

        SUBROUTINE ALLOCATE_FFARRAY3_DO_ALLOCATIONS(PAR_SUP_HANDLE,MLSHM,MEM1,FF,FFM)
          USE ML_FF_STRUCT, ONLY: PARALLEL_SUPER, ML_SHMEM, MEMORY, FF_PAR, FFM_PAR, ML_IO_WRITE
          USE ml_ff_tutor, ONLY: ml_tutor
          IMPLICIT NONE
! Input and output variables
          TYPE (PARALLEL_SUPER) :: PAR_SUP_HANDLE
          TYPE (ML_SHMEM)       :: MLSHM
          TYPE (MEMORY)         :: MEM1
          TYPE (FF_PAR)         :: FF
          TYPE (FFM_PAR)        :: FFM
! Help
          INTEGER               :: IERR 
! Allocate
          IF(ALLOCATED(FF%BEHIS)) THEN
             DEALLOCATE(FF%BEHIS)
          ENDIF
          ALLOCATE (FF%BEHIS(1:FF%MHIS))
          IF(ALLOCATED(FF%ERRHIS)) THEN
             DEALLOCATE(FF%ERRHIS)
          ENDIF
          ALLOCATE(FF%ERRHIS(1:FF%MHIS))
          IF(FF%LMLMB) THEN
#ifdef scaLAPACK
! Allocate local 1-point correlation (radial) descriptor
! After allocation Descriptor needs to be set to the actual size
             IF(FFM%W1.GT.0.0_q) THEN
                PAR_SUP_HANDLE%DESC_C00_FFM%M=FFM%MMVAR1_ALLOCATE
                PAR_SUP_HANDLE%DESC_C00_FFM%N=FFM%MB_ALLOCATE
                PAR_SUP_HANDLE%DESC_C00_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_C00_FFM%NB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_C00_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_C00_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_C00_FFM%DESC,PAR_SUP_HANDLE%DESC_C00_FFM%M,PAR_SUP_HANDLE%DESC_C00_FFM%N, &
                     PAR_SUP_HANDLE%DESC_C00_FFM%MB,PAR_SUP_HANDLE%DESC_C00_FFM%NB,PAR_SUP_HANDLE%DESC_C00_FFM%IRSRC,PAR_SUP_HANDLE%DESC_C00_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_C00_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M,PAR_SUP_HANDLE%DESC_C00_FFM%LOC_N)
                IF(ALLOCATED(FFM%C00)) THEN
                   DEALLOCATE(FFM%C00)
                ENDIF
                ALLOCATE (FFM%C00(1:PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_C00_FFM%LOC_N,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_C00_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                PAR_SUP_HANDLE%DESC_C00_FFM%M=FFM%MMVAR1
                PAR_SUP_HANDLE%DESC_C00_FFM%N=FFM%MB
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_C00_FFM%DESC,PAR_SUP_HANDLE%DESC_C00_FFM%M,PAR_SUP_HANDLE%DESC_C00_FFM%N, &
                     PAR_SUP_HANDLE%DESC_C00_FFM%MB,PAR_SUP_HANDLE%DESC_C00_FFM%NB,PAR_SUP_HANDLE%DESC_C00_FFM%IRSRC,PAR_SUP_HANDLE%DESC_C00_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_C00_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M,PAR_SUP_HANDLE%DESC_C00_FFM%LOC_N)
! Allocate new local 1-point correlation (radial) descriptor
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%M=FFM%MMVAR1_ALLOCATE
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%N=FF%MITYP_ALLOCATE
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_C00_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%M,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%N, &
                     PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_N)
                IF(ALLOCATED(FFM%C00_NEW)) THEN
                   DEALLOCATE(FFM%C00_NEW)
                ENDIF
                ALLOCATE (FFM%C00_NEW(1:PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_N,1:FF%MTYP_ALLOCATE,1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FF%MCONF_NEW,q)*8/1.0E+06_q
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%M=FFM%MMVAR1
                PAR_SUP_HANDLE%DESC_C00_NEW_FFM%N=FF%MITYP
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_C00_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%M,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%N, &
                     PAR_SUP_HANDLE%DESC_C00_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_C00_NEW_FFM%LOC_N)
             ELSE
                ALLOCATE (FFM%C00(1:1,1:1,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             ENDIF
! Allocate local 2-point correlation (angular) descriptor
             IF(FFM%W2.GT.0.0_q) THEN
                PAR_SUP_HANDLE%DESC_PS_FFM%M=FFM%MMVAR2_ALLOCATE
                PAR_SUP_HANDLE%DESC_PS_FFM%N=FFM%MB_ALLOCATE
                PAR_SUP_HANDLE%DESC_PS_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_PS_FFM%NB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_PS_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_PS_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_PS_FFM%DESC,PAR_SUP_HANDLE%DESC_PS_FFM%M,PAR_SUP_HANDLE%DESC_PS_FFM%N, &
                     PAR_SUP_HANDLE%DESC_PS_FFM%MB,PAR_SUP_HANDLE%DESC_PS_FFM%NB,PAR_SUP_HANDLE%DESC_PS_FFM%IRSRC,PAR_SUP_HANDLE%DESC_PS_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_PS_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N)
                IF(ALLOCATED(FFM%PS)) THEN
                   DEALLOCATE(FFM%PS)
                ENDIF
                ALLOCATE (FFM%PS(1:PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                MEM1%RMEM_PS=MEM1%RMEM_PS+REAL(PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                PAR_SUP_HANDLE%DESC_PS_FFM%M=FFM%MMVAR2
                PAR_SUP_HANDLE%DESC_PS_FFM%N=FFM%MB
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_PS_FFM%DESC,PAR_SUP_HANDLE%DESC_PS_FFM%M,PAR_SUP_HANDLE%DESC_PS_FFM%N, &
                     PAR_SUP_HANDLE%DESC_PS_FFM%MB,PAR_SUP_HANDLE%DESC_PS_FFM%NB,PAR_SUP_HANDLE%DESC_PS_FFM%IRSRC,PAR_SUP_HANDLE%DESC_PS_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_PS_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M,PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N)
! Allocate new local 2-point correlation (radial and angular) descriptor
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%M=FFM%MMVAR2_ALLOCATE
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%N=FF%MITYP_ALLOCATE
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_PS_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%M,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%N, &
                     PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_N)
                IF(ALLOCATED(FFM%PS_NEW)) THEN
                   DEALLOCATE(FFM%PS_NEW)
                ENDIF
                ALLOCATE (FFM%PS_NEW(1:PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_N,1:FF%MTYP_ALLOCATE,1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FF%MCONF_NEW,q)*8/1.0E+06_q
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%M=FFM%MMVAR2
                PAR_SUP_HANDLE%DESC_PS_NEW_FFM%N=FF%MITYP
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_PS_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%M,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%N, &
                     PAR_SUP_HANDLE%DESC_PS_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_PS_NEW_FFM%LOC_N)
             ELSE
                ALLOCATE (FFM%PS(1:1,1:1,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                MEM1%RMEM_PS=MEM1%RMEM_PS+REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             ENDIF
! Allocate local 2-point correlation (angular) descriptor
! Allocate covariance matrix
             PAR_SUP_HANDLE%DESC_CMAT_FFM%M=FFM%MBTOT_ALLOCATE
             PAR_SUP_HANDLE%DESC_CMAT_FFM%N=FFM%MBTOT_ALLOCATE
             PAR_SUP_HANDLE%DESC_CMAT_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_CMAT_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_CMAT_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_CMAT_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_CMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_CMAT_FFM%M,PAR_SUP_HANDLE%DESC_CMAT_FFM%N, &
                  PAR_SUP_HANDLE%DESC_CMAT_FFM%MB,PAR_SUP_HANDLE%DESC_CMAT_FFM%NB,PAR_SUP_HANDLE%DESC_CMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_CMAT_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_CMAT_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N)
             IF(ALLOCATED(FFM%CMAT)) THEN
                DEALLOCATE(FFM%CMAT)
             ENDIF
             ALLOCATE (FFM%CMAT(1:PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N),STAT=IERR)
             IF (IERR.NE.0) THEN
                CALL ml_tutor%error("ERROR: First inilialization of  & 
                &covariance matrix (FFM%CMAT) failed. Exiting...")
             ENDIF
             IF (FF%ISTART.NE.2) THEN
                MEM1%RMEM(2)  =MEM1%RMEM(2)  +3.0_q*REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N,q)*8/1.0E+06_q
                MEM1%RMEM_CMAT=MEM1%RMEM_CMAT+3.0_q*REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N,q)*8/1.0E+06_q
             ELSE
                MEM1%RMEM(2)  =MEM1%RMEM(2)  +REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N,q)*8/1.0E+06_q
                MEM1%RMEM_CMAT=MEM1%RMEM_CMAT+REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N,q)*8/1.0E+06_q
             ENDIF
             PAR_SUP_HANDLE%DESC_CMAT_FFM%M=FFM%MBTOT
             PAR_SUP_HANDLE%DESC_CMAT_FFM%N=FFM%MBTOT
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_CMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_CMAT_FFM%M,PAR_SUP_HANDLE%DESC_CMAT_FFM%N, &
                  PAR_SUP_HANDLE%DESC_CMAT_FFM%MB,PAR_SUP_HANDLE%DESC_CMAT_FFM%NB,PAR_SUP_HANDLE%DESC_CMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_CMAT_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_CMAT_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N)
! Allocate local design matrix if FF%LMLONLY=.FALSE. or FF%ISTART/=2.
! FF%LMLONLY=.TRUE. and FF%ISTART=2, the design matrix is not necessary.
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                PAR_SUP_HANDLE%DESC_FMAT_FFM%M=FFM%MB_ALLOCATE
                PAR_SUP_HANDLE%DESC_FMAT_FFM%N=FFM%MDATA_ALLOCATE
                PAR_SUP_HANDLE%DESC_FMAT_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_FMAT_FFM%NB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_FMAT_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_FMAT_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_FMAT_FFM%M,PAR_SUP_HANDLE%DESC_FMAT_FFM%N, &
                     PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%DESC_FMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N)
                IF(ALLOCATED(FFM%DMAT_FMAT)) THEN
                   DEALLOCATE(FFM%DMAT_FMAT)
                ENDIF
                ALLOCATE (FFM%DMAT_FMAT(1:PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N))
                MEM1%RMEM(2)=MEM1%RMEM(2)+2.0_q*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%FMAT)) THEN
                   DEALLOCATE(FFM%FMAT)
                ENDIF
                ALLOCATE (FFM%FMAT(1:PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N,1:FF%MTYP_ALLOCATE),STAT=IERR)
                IF (IERR.NE.0) THEN
                   CALL ml_tutor%error("ERROR: First inilialization of  & 
                   &design matrix (FFM%FMAT) failed. Game over...")
                ENDIF
                IF (FF%IALGO_LINREG.GT.1) THEN
                   MEM1%RMEM(2)  =MEM1%RMEM(2)  +2.0_q*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                   MEM1%RMEM_FMAT=MEM1%RMEM_FMAT+2.0_q*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                ELSE
                   MEM1%RMEM(2)  =MEM1%RMEM(2)  +REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                   MEM1%RMEM_FMAT=MEM1%RMEM_FMAT+REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                ENDIF
                PAR_SUP_HANDLE%DESC_FMAT_FFM%M=FFM%MB
                PAR_SUP_HANDLE%DESC_FMAT_FFM%N=FFM%MDATA
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_FMAT_FFM%M,PAR_SUP_HANDLE%DESC_FMAT_FFM%N, &
                     PAR_SUP_HANDLE%DESC_FMAT_FFM%MB,PAR_SUP_HANDLE%DESC_FMAT_FFM%NB,PAR_SUP_HANDLE%DESC_FMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_FFM%LOC_N)
! Allocate local new design matrix
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%M=FFM%MB_ALLOCATE
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%N=FFM%MDATA_NEW_ALLOCATE
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB=1
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%M,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%N, &
                     PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_N)
                IF(ALLOCATED(FFM%FMAT_NEW)) THEN
                   DEALLOCATE(FFM%FMAT_NEW)
                ENDIF
                ALLOCATE (FFM%FMAT_NEW(1:PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_N,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)  =MEM1%RMEM(2)  +REAL(PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%M=FFM%MB
                PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%N=FFM%MDATA_NEW
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%DESC,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%M,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%N, &
                     PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%MB,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%NB,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%IRSRC,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_M,PAR_SUP_HANDLE%DESC_FMAT_NEW_FFM%LOC_N)
             ENDIF
! Allocate local SOAP matrix and its inverse
             PAR_SUP_HANDLE%DESC_SOAP_FFM%M=FFM%MB_ALLOCATE
             PAR_SUP_HANDLE%DESC_SOAP_FFM%N=FFM%MB_ALLOCATE
             PAR_SUP_HANDLE%DESC_SOAP_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_SOAP_FFM%NB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_SOAP_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_SOAP_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_SOAP_FFM%DESC,PAR_SUP_HANDLE%DESC_SOAP_FFM%M,PAR_SUP_HANDLE%DESC_SOAP_FFM%N, &
                  PAR_SUP_HANDLE%DESC_SOAP_FFM%MB,PAR_SUP_HANDLE%DESC_SOAP_FFM%NB,PAR_SUP_HANDLE%DESC_SOAP_FFM%IRSRC,PAR_SUP_HANDLE%DESC_SOAP_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_SOAP_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N)
             IF(ALLOCATED(FFM%SOAP)) THEN
                DEALLOCATE(FFM%SOAP)
             ENDIF
             ALLOCATE (FFM%SOAP(1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)  =MEM1%RMEM(2)  +REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             MEM1%RMEM_SOAP=MEM1%RMEM_SOAP+REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
! Allocate regression coefficients.
             PAR_SUP_HANDLE%DESC_WMAT_FFM%M=FFM%MB_ALLOCATE
             PAR_SUP_HANDLE%DESC_WMAT_FFM%N=1
             PAR_SUP_HANDLE%DESC_WMAT_FFM%MB=NBLOCK_SCALAPACK
             PAR_SUP_HANDLE%DESC_WMAT_FFM%NB=1
             PAR_SUP_HANDLE%DESC_WMAT_FFM%IRSRC=0
             PAR_SUP_HANDLE%DESC_WMAT_FFM%ICSRC=0
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_WMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_WMAT_FFM%M,PAR_SUP_HANDLE%DESC_WMAT_FFM%N, &
                  PAR_SUP_HANDLE%DESC_WMAT_FFM%MB,PAR_SUP_HANDLE%DESC_WMAT_FFM%NB,PAR_SUP_HANDLE%DESC_WMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_WMAT_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_WMAT_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N)
             IF(ALLOCATED(FFM%WMAT)) THEN
                DEALLOCATE(FFM%WMAT)
             ENDIF
             ALLOCATE (FFM%WMAT(1:PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N,1:FF%MTYP_ALLOCATE))
             IF (FF%ISTART.NE.2) THEN
                ! We need several helping arrays with the size of the weights, so just gave a rough estimate by 12
                MEM1%RMEM(2)=MEM1%RMEM(2)+12.0_q*REAL(PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             ELSE
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             ENDIF
             PAR_SUP_HANDLE%DESC_WMAT_FFM%M=FFM%MB
             CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_WMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_WMAT_FFM%M,PAR_SUP_HANDLE%DESC_WMAT_FFM%N, &
                  PAR_SUP_HANDLE%DESC_WMAT_FFM%MB,PAR_SUP_HANDLE%DESC_WMAT_FFM%NB,PAR_SUP_HANDLE%DESC_WMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_WMAT_FFM%ICSRC, &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                  PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_WMAT_FFM%LLD, &
                  PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N)
! Allocate training data if FF%LMLONLY=.FALSE. or FF%ISTART/=2.
! If FF%LMLONLY=.TRUE. and FF%ISTART=2, training is not executed, and
! therefore, these arrays are not necessary.
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                PAR_SUP_HANDLE%DESC_YMAT_FFM%M=FFM%MDATA_ALLOCATE
                PAR_SUP_HANDLE%DESC_YMAT_FFM%N=1
                PAR_SUP_HANDLE%DESC_YMAT_FFM%MB=NBLOCK_SCALAPACK
                PAR_SUP_HANDLE%DESC_YMAT_FFM%NB=1
                PAR_SUP_HANDLE%DESC_YMAT_FFM%IRSRC=0
                PAR_SUP_HANDLE%DESC_YMAT_FFM%ICSRC=0
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_YMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_YMAT_FFM%M,PAR_SUP_HANDLE%DESC_YMAT_FFM%N, &
                     PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB,PAR_SUP_HANDLE%DESC_YMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_YMAT_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_YMAT_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N)
                IF(ALLOCATED(FFM%YMAT)) THEN
                   DEALLOCATE(FFM%YMAT)
                ENDIF
                ALLOCATE (FFM%YMAT(1:PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,1:PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,q)*REAL(PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%DMAT_YMAT)) THEN
                   DEALLOCATE(FFM%DMAT_YMAT)
                ENDIF
                ALLOCATE (FFM%DMAT_YMAT(1:PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,q)*8/1.0E+06_q
! Set descriptor back to actual size
                PAR_SUP_HANDLE%DESC_YMAT_FFM%M=FFM%MDATA
                CALL SCALAPACK_SET_DESCRIPTOR(PAR_SUP_HANDLE%DESC_YMAT_FFM%DESC,PAR_SUP_HANDLE%DESC_YMAT_FFM%M,PAR_SUP_HANDLE%DESC_YMAT_FFM%N, &
                     PAR_SUP_HANDLE%DESC_YMAT_FFM%MB,PAR_SUP_HANDLE%DESC_YMAT_FFM%NB,PAR_SUP_HANDLE%DESC_YMAT_FFM%IRSRC,PAR_SUP_HANDLE%DESC_YMAT_FFM%ICSRC, &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%ICTXT,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%ME_COL,  &
                     PAR_SUP_HANDLE%CONTEXT_WORLD%NP_ROW,PAR_SUP_HANDLE%CONTEXT_WORLD%NP_COL, PAR_SUP_HANDLE%DESC_YMAT_FFM%LLD, &
                     PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_M,PAR_SUP_HANDLE%DESC_YMAT_FFM%LOC_N)
             ENDIF
#else
             IF(FFM%W1.GT.0.0_q) THEN
                IF(ALLOCATED(FFM%C00)) THEN
                   DEALLOCATE(FFM%C00)
                ENDIF
                ALLOCATE (FFM%C00(1:FFM%MMVAR1_ALLOCATE,1:FFM%MB_ALLOCATE,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR1_ALLOCATE,q)*REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%C00_NEW)) THEN
                   DEALLOCATE(FFM%C00_NEW)
                ENDIF
                ALLOCATE (FFM%C00_NEW(1:FFM%MMVAR1_ALLOCATE,1:FF%MITYP_ALLOCATE,1:FF%MTYP_ALLOCATE,1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR1_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FF%MCONF_NEW,q)*8/1.0E+06_q
             ELSE
                ALLOCATE (FFM%C00(1:1,1:1,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                IF(ALLOCATED(FFM%PS)) THEN
                   DEALLOCATE(FFM%PS)
                ENDIF
                ALLOCATE (FFM%PS(1:FFM%MMVAR2_ALLOCATE,1:FFM%MB_ALLOCATE,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                MEM1%RMEM_PS=MEM1%RMEM_PS+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%PS_NEW)) THEN
                   DEALLOCATE(FFM%PS_NEW)
                ENDIF
                ALLOCATE (FFM%PS_NEW(1:FFM%MMVAR2_ALLOCATE,1:FF%MITYP_ALLOCATE,1:FF%MTYP_ALLOCATE,1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FF%MITYP_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FF%MCONF_NEW,q)*8/1.0E+06_q
             ELSE
                ALLOCATE (FFM%PS(1:1,1:1,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                MEM1%RMEM_PS=MEM1%RMEM_PS+REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             ENDIF
             IF(ALLOCATED(FFM%CMAT)) THEN
                DEALLOCATE(FFM%CMAT)
             ENDIF
             ALLOCATE (FFM%CMAT(1:FFM%MBTOT_ALLOCATE,1:FFM%MBTOT_ALLOCATE),STAT=IERR)
             IF (IERR.NE.0) THEN
                CALL ml_tutor%error("ERROR: First inilialization of  & 
                &covariance matrix (FFM%CMAT) failed. Exiting...")
             ENDIF
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MBTOT_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1.0E+06_q
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                IF(ALLOCATED(FFM%DMAT_FMAT)) THEN
                   DEALLOCATE(FFM%DMAT_FMAT)
                ENDIF
                ALLOCATE (FFM%DMAT_FMAT(1:FFM%MDATA_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MDATA_ALLOCATE,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%DMAT_YMAT)) THEN
                   DEALLOCATE(FFM%DMAT_YMAT)
                ENDIF
                ALLOCATE (FFM%DMAT_YMAT(1:FFM%MDATA_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MDATA_ALLOCATE,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%FMAT)) THEN
                   DEALLOCATE(FFM%FMAT)
                ENDIF
                ALLOCATE (FFM%FMAT(1:FFM%MB_ALLOCATE,1:FFM%MDATA_ALLOCATE,1:FF%MTYP_ALLOCATE),STAT=IERR)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FFM%MDATA_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                IF (IERR.NE.0) THEN
                   CALL ml_tutor%error("ERROR: First inilialization of  & 
                   &covariance matrix (FFM%FMAT) failed. Exiting...")
                ENDIF
                ! do initialization here because of Peitaos case
!                FFM%FMAT=0.0_q
                IF(ALLOCATED(FFM%FMAT_NEW)) THEN
                   DEALLOCATE(FFM%FMAT_NEW)
                ENDIF
                IF (FFM%MDATA_NEW.GT.FFM%MDATA_ALLOCATE) THEN
                   ALLOCATE (FFM%FMAT_NEW(1:FFM%MB_ALLOCATE,1:FFM%MDATA_NEW_ALLOCATE,1:FF%MTYP_ALLOCATE))
                   MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FFM%MDATA_NEW_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                ELSE
                   ALLOCATE (FFM%FMAT_NEW(1:FFM%MB_ALLOCATE,1:FFM%MDATA_ALLOCATE,1:FF%MTYP_ALLOCATE))
                   MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FFM%MDATA_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                ENDIF
             ENDIF
             IF(ALLOCATED(FFM%SOAP)) THEN
                DEALLOCATE(FFM%SOAP)
             ENDIF
             ALLOCATE (FFM%SOAP(1:FFM%MB_ALLOCATE,1:FFM%MB_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             IF(ALLOCATED(FFM%WMAT)) THEN
                DEALLOCATE(FFM%WMAT)
             ENDIF
             ALLOCATE (FFM%WMAT(1:FFM%MB_ALLOCATE,1:1,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                IF(ALLOCATED(FFM%YMAT)) THEN
                   DEALLOCATE(FFM%YMAT)
                ENDIF
                ALLOCATE (FFM%YMAT(1:FFM%MDATA_ALLOCATE,1:1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MDATA_ALLOCATE,q)*8/1.0E+06_q
             ENDIF
! Some definitions that are needed only for priniting out
             PAR_SUP_HANDLE%DESC_C00_FFM%LOC_M=FFM%MMVAR1
             PAR_SUP_HANDLE%DESC_C00_FFM%LOC_N=FFM%MB        
             PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_M=FFM%MBTOT          
             PAR_SUP_HANDLE%DESC_CMAT_FFM%LOC_N=FFM%MBTOT          
             PAR_SUP_HANDLE%DESC_PS_FFM%LOC_M=FFM%MMVAR2            
             PAR_SUP_HANDLE%DESC_PS_FFM%LOC_N=FFM%MB            
             PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_M=FFM%MB          
             PAR_SUP_HANDLE%DESC_SOAP_FFM%LOC_N=FFM%MB          
             PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_M=FFM%MB          
             PAR_SUP_HANDLE%DESC_WMAT_FFM%LOC_N=1
#endif
! Label for the self-interaction terms in the angular descriptor.
! This needs to be allocated even when FFM%LSIC is set to .FALSE.
! Because the subroutine D0CLM_SOAP and D1CLM_SOAP pass this array 
! regardless the FFM%LSIC. I allow this because the size for this is 
! negligibly small.
             IF(ALLOCATED(FFM%LFLAG_VAR)) THEN
                DEALLOCATE(FFM%LFLAG_VAR)
             ENDIF
             ALLOCATE (FFM%LFLAG_VAR(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)**2*REAL((FFM%LMAX2+1),q)*REAL(FF%MTYP_ALLOCATE,q)**3/1.0E+06_q
             IF(ALLOCATED(FFM%LFLAG_VAR_SIC)) THEN
                DEALLOCATE(FFM%LFLAG_VAR_SIC)
             ENDIF
             ALLOCATE (FFM%LFLAG_VAR_SIC(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)**2*REAL((FFM%LMAX2+1),q)*REAL(FF%MTYP_ALLOCATE,q)**2/1.0E+06_q
             IF(ALLOCATED(FFM%LVAR)) THEN
                DEALLOCATE(FFM%LVAR)
             ENDIF
             ALLOCATE (FFM%LVAR(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)**2*REAL((FFM%LMAX2+1),q)*REAL(FF%MTYP_ALLOCATE,q)**3/1.0E+06_q
             IF(ALLOCATED(FFM%LVAR_SIC)) THEN
                DEALLOCATE(FFM%LVAR_SIC)
             ENDIF
             ALLOCATE (FFM%LVAR_SIC(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)**2*REAL((FFM%LMAX2+1),q)*REAL(FF%MTYP_ALLOCATE,q)**2/1.0E+06_q
! FFM%NRB2 needs to be allocated even if FFM%W2 is set to 0.
             IF(ALLOCATED(FFM%NRB2)) THEN
                DEALLOCATE(FFM%NRB2)
             ENDIF
             ALLOCATE (FFM%NRB2(0:FFM%LMAX2))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL((FFM%LMAX2+1),q)/1.0E+06_q
! Weight for each descriptor. This also needs to be allocated even when W2_FFM is set to 0.
             IF(ALLOCATED(FFM%WVAR)) THEN
                DEALLOCATE(FFM%WVAR)
             ENDIF
             ALLOCATE (FFM%WVAR(1:FFM%MRB2,1:FFM%MRB2,0:FFM%LMAX2,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)**2*REAL((FFM%LMAX2+1),q)*REAL(FF%MTYP_ALLOCATE,q)**3*8/1.0E+06_q
             IF(FFM%W1.GT.0.0_q) THEN
                IF(ALLOCATED(FFM%FNL1)) THEN
                   DEALLOCATE(FFM%FNL1)
                ENDIF
                ALLOCATE (FFM%FNL1(1:FFM%MSPL1,1:5,0:FFM%LMAX1,1:FFM%MRB1,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MSPL1,q)*5*REAL(FFM%MRB1,q)*REAL((FFM%LMAX1+1),q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%INDEX_PAIR_HELP1)) THEN
                   DEALLOCATE(FFM%INDEX_PAIR_HELP1)
                ENDIF
                ALLOCATE(FFM%INDEX_PAIR_HELP1(1:FFM%MMVAR1,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR1,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                IF(ALLOCATED(FFM%PREFACTOR_HELP1)) THEN
                   DEALLOCATE(FFM%PREFACTOR_HELP1)
                ENDIF
                ALLOCATE(FFM%PREFACTOR_HELP1(1:FFM%MMVAR1,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR1,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                IF(ALLOCATED(FFM%FWIN1)) THEN
                   DEALLOCATE(FFM%FWIN1)
                ENDIF
                ALLOCATE (FFM%FWIN1(0:FFM%LMAX1,1:FFM%MRB1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL((FFM%LMAX1+1),q)*REAL(FFM%MRB1,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%L_LNRB1)) THEN
                   DEALLOCATE(FFM%L_LNRB1)
                ENDIF
                ALLOCATE (FFM%L_LNRB1(1:FFM%MLNRB1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB1,q)*REAL((FFM%LMAX1+1),q)/1.0E+06_q
                IF(ALLOCATED(FFM%NRB1)) THEN
                   DEALLOCATE(FFM%NRB1)
                ENDIF
                ALLOCATE (FFM%NRB1(0:FFM%LMAX1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL((FFM%LMAX1+1),q)/1.0E+06_q
                IF(ALLOCATED(FFM%NRB_LNRB1)) THEN
                   DEALLOCATE(FFM%NRB_LNRB1)
                ENDIF
                ALLOCATE (FFM%NRB_LNRB1(1:FFM%MLNRB1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB1,q)*REAL((FFM%LMAX1+1),q)/1.0E+06_q
                IF(ALLOCATED(FFM%RB1)) THEN
                   DEALLOCATE(FFM%RB1)
                ENDIF
                ALLOCATE (FFM%RB1(1:FFM%NR1,1:FFM%MRB1,0:FFM%LMAX1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%NR1,q)*REAL(FFM%MRB1,q)*REAL((FFM%LMAX1+1),q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%QGRID1)) THEN
                   DEALLOCATE(FFM%QGRID1)
                ENDIF
                ALLOCATE (FFM%QGRID1(1:FFM%MRB1,0:FFM%LMAX1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB1,q)*REAL((FFM%LMAX1+1),q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%RC1)) THEN
                   DEALLOCATE(FFM%RC1)
                ENDIF
                ALLOCATE (FFM%RC1(1:FFM%MRB1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB1,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%RG1)) THEN
                   DEALLOCATE(FFM%RG1)
                ENDIF
                ALLOCATE (FFM%RG1(1:FFM%NR1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%NR1,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%RNORM1)) THEN
                   DEALLOCATE(FFM%RNORM1)
                ENDIF
                ALLOCATE (FFM%RNORM1(0:FFM%LMAX1,1:FFM%MRB1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL((FFM%LMAX1+1),q)**2*REAL(FFM%MRB1,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%USQ1)) THEN
                   DEALLOCATE(FFM%USQ1)
                ENDIF
                ALLOCATE (FFM%USQ1(1:FFM%MRB1,1:FFM%MRB1))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB1,q)**2*8/1.0E+06_q
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                IF(ALLOCATED(FFM%FNL2)) THEN
                   DEALLOCATE(FFM%FNL2)
                ENDIF
                ALLOCATE (FFM%FNL2(1:FFM%MSPL2,1:5,0:FFM%LMAX2,1:FFM%MRB2,1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MSPL2,q)*5*REAL(FFM%MRB2,q)*REAL((FFM%LMAX2+1),q)*8/1.0E+06_q*REAL(FF%MTYP_ALLOCATE,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%FWIN2)) THEN
                   DEALLOCATE(FFM%FWIN2)
                ENDIF
                ALLOCATE (FFM%FWIN2(0:FFM%LMAX2,1:FFM%MRB2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL((FFM%LMAX2+1),q)*REAL(FFM%MRB2,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%INDEX_MAP_TO_PS)) THEN
                   DEALLOCATE(FFM%INDEX_MAP_TO_PS)
                ENDIF
                ALLOCATE(FFM%INDEX_MAP_TO_PS(1:FFM%MMVAR2,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                IF (FFM%DESC_TYPE.EQ.1) THEN
                   IF(ALLOCATED(FFM%INDEX_MAP_TO_PS_B)) THEN
                      DEALLOCATE(FFM%INDEX_MAP_TO_PS_B)
                   ENDIF
                   ALLOCATE(FFM%INDEX_MAP_TO_PS_B(1:FFM%MMVAR2,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                   MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                ENDIF
                IF(ALLOCATED(FFM%INDEX_NUM2)) THEN
                   DEALLOCATE(FFM%INDEX_NUM2)
                ENDIF
                ALLOCATE(FFM%INDEX_NUM2(1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                IF (FFM%DESC_TYPE.EQ.1) THEN
                   IF(ALLOCATED(FFM%INDEX_NUM2_B)) THEN
                      DEALLOCATE(FFM%INDEX_NUM2_B)
                   ENDIF
                   ALLOCATE(FFM%INDEX_NUM2_B(1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                   MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                ENDIF
                IF(ALLOCATED(FFM%INDEX_PAIR_HELP2)) THEN
                   DEALLOCATE(FFM%INDEX_PAIR_HELP2)
                ENDIF
                ALLOCATE(FFM%INDEX_PAIR_HELP2(1:FFM%MMVAR2,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                IF (FFM%DESC_TYPE.EQ.1) THEN
                   IF(ALLOCATED(FFM%INDEX_PAIR_HELP2_B)) THEN
                      DEALLOCATE(FFM%INDEX_PAIR_HELP2_B)
                   ENDIF
                   ALLOCATE(FFM%INDEX_PAIR_HELP2_B(FF%MTYP_ALLOCATE,1:FFM%MMVAR2,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                   MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR2,q)*REAL(FF%MTYP_ALLOCATE**2,q)/1.0E+06_q
                ENDIF
                IF(ALLOCATED(FFM%L_LNRB2)) THEN
                   DEALLOCATE(FFM%L_LNRB2)
                ENDIF
                ALLOCATE (FFM%L_LNRB2(1:FFM%MLNRB2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)*REAL((FFM%LMAX2+1),q)/1.0E+06_q
                IF(ALLOCATED(FFM%NRB_LNRB2)) THEN
                   DEALLOCATE(FFM%NRB_LNRB2)
                ENDIF
                ALLOCATE (FFM%NRB_LNRB2(1:FFM%MLNRB2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)*REAL((FFM%LMAX2+1),q)/1.0E+06_q
                IF(ALLOCATED(FFM%PREFACTOR_HELP2)) THEN
                   DEALLOCATE(FFM%PREFACTOR_HELP2)
                ENDIF
                ALLOCATE(FFM%PREFACTOR_HELP2(1:FFM%MMVAR2,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                IF (FFM%DESC_TYPE.EQ.1) THEN
                   IF(ALLOCATED(FFM%PREFACTOR_HELP2_B)) THEN
                      DEALLOCATE(FFM%PREFACTOR_HELP2_B)
                   ENDIF
                   ALLOCATE(FFM%PREFACTOR_HELP2_B(1:FFM%MMVAR2,1:((FFM%LMAX2+1)**2*FF%MTYP_ALLOCATE*FFM%MRB2),1:FF%MTYP_ALLOCATE))
                   MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL((FFM%LMAX2+1)**2,q)*REAL(FF%MTYP_ALLOCATE,q)*REAL(FFM%MRB2,q)*REAL(FFM%MMVAR2,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
                ENDIF
                IF(ALLOCATED(FFM%RB2)) THEN
                   DEALLOCATE(FFM%RB2)
                ENDIF
                ALLOCATE (FFM%RB2(1:FFM%NR2,1:FFM%MRB2,0:FFM%LMAX2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%NR2,q)*REAL(FFM%MRB2,q)*REAL((FFM%LMAX2+1),q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%QGRID2)) THEN
                   DEALLOCATE(FFM%QGRID2)
                ENDIF
                ALLOCATE (FFM%QGRID2(1:FFM%MRB2,0:FFM%LMAX2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)*REAL((FFM%LMAX2+1),q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%RC2)) THEN
                   DEALLOCATE(FFM%RC2)
                ENDIF
                ALLOCATE (FFM%RC2(1:FFM%MRB2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%RG2)) THEN
                   DEALLOCATE(FFM%RG2)
                ENDIF
                ALLOCATE (FFM%RG2(1:FFM%NR2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%NR2,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%RNORM2)) THEN
                   DEALLOCATE(FFM%RNORM2)
                ENDIF
                ALLOCATE (FFM%RNORM2(0:FFM%LMAX2,1:FFM%MRB2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL((FFM%LMAX2+1),q)**2*REAL(FFM%MRB2,q)*8/1.0E+06_q
                IF(ALLOCATED(FFM%USQ2)) THEN
                   DEALLOCATE(FFM%USQ2)
                ENDIF
                ALLOCATE (FFM%USQ2(1:FFM%MRB2,1:FFM%MRB2))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MRB2,q)**2*8/1.0E+06_q
             ENDIF
             IF(ALLOCATED(FFM%LB)) THEN
                DEALLOCATE(FFM%LB)
             ENDIF
             ALLOCATE (FFM%LB(1:FFM%MB_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
             IF(ALLOCATED(FFM%LBHEAD)) THEN
                DEALLOCATE(FFM%LBHEAD)
             ENDIF
             ALLOCATE (FFM%LBHEAD(1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
             IF(ALLOCATED(FFM%LIONS_COUPLE)) THEN
                DEALLOCATE(FFM%LIONS_COUPLE)
             ENDIF
             ALLOCATE(FFM%LIONS_COUPLE(1:FF%MIONS_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MIONS_ALLOCATE,q)/1.0E+06_q
             IF(ALLOCATED(FFM%LNCONF)) THEN
                DEALLOCATE(FFM%LNCONF)
             ENDIF
             ALLOCATE (FFM%LNCONF(1:FFM%MB_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
             IF(ALLOCATED(FFM%LNIONS)) THEN
                DEALLOCATE(FFM%LNIONS)
             ENDIF
             ALLOCATE (FFM%LNIONS(1:FFM%MB_ALLOCATE,1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MB_ALLOCATE,q)*REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                IF(ALLOCATED(FFM%LTIFOR)) THEN
                   DEALLOCATE(FFM%LTIFOR)
                ENDIF
                ALLOCATE (FFM%LTIFOR(1:3,1:FF%MIONS_ALLOCATE,1:FF%MCONF))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MIONS_ALLOCATE,q)*3*REAL(FF%MCONF,q)/1.0E+06_q
                IF(ALLOCATED(FFM%LTIFOR_NEW)) THEN
                   DEALLOCATE(FFM%LTIFOR_NEW)
                ENDIF
                ALLOCATE (FFM%LTIFOR_NEW(1:3,1:FF%MIONS_ALLOCATE,1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MIONS_ALLOCATE,q)*3*REAL(FF%MCONF_NEW,q)/1.0E+06_q
                IF(ALLOCATED(FFM%LTOTEN)) THEN
                   DEALLOCATE(FFM%LTOTEN)
                ENDIF
                ALLOCATE (FFM%LTOTEN(1:FF%MCONF))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MCONF,q)/1.0E+06_q
                IF(ALLOCATED(FFM%LTOTEN_NEW)) THEN
                   DEALLOCATE(FFM%LTOTEN_NEW)
                ENDIF
                ALLOCATE (FFM%LTOTEN_NEW(1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MCONF_NEW,q)/1.0E+06_q
                IF(ALLOCATED(FFM%LTSIF)) THEN
                   DEALLOCATE(FFM%LTSIF)
                ENDIF
                ALLOCATE (FFM%LTSIF(1:3,1:3,1:FF%MCONF))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MCONF,q)*9/1.0E+06_q
                IF(ALLOCATED(FFM%LTSIF_NEW)) THEN
                   DEALLOCATE(FFM%LTSIF_NEW)
                ENDIF
                ALLOCATE (FFM%LTSIF_NEW(1:3,1:3,1:FF%MCONF_NEW))
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MCONF_NEW,q)*9/1.0E+06_q
             ENDIF
             IF(ALLOCATED(FFM%NB)) THEN
                DEALLOCATE(FFM%NB)
             ENDIF
             ALLOCATE (FFM%NB(1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
             IF(ALLOCATED(FFM%NB_NEW)) THEN
                DEALLOCATE(FFM%NB_NEW)
             ENDIF
             ALLOCATE (FFM%NB_NEW(1:FF%MTYP_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FF%MTYP_ALLOCATE,q)/1.0E+06_q
             IF(ALLOCATED(FFM%RCOUPLE_IONS)) THEN
                DEALLOCATE(FFM%RCOUPLE_IONS)
             ENDIF
             ALLOCATE(FFM%RCOUPLE_IONS(1:FF%MIONS_ALLOCATE))
             MEM1%RMEM(2)=MEM1%RMEM(2)+8.0_q*REAL(FF%MIONS_ALLOCATE,q)/1.0E+06_q
#ifdef use_shmem
!We have to deallocate arrays before allocation if they are already allocated
!CLM1
             IF (MLSHM%MLFF_SHMEM_ALLOC_CLM1) THEN
                NULLIFY(MLSHM%CLM1)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM1)
                MLSHM%MLFF_SHMEM_ALLOC_CLM1=.FALSE.
             ENDIF
!CLM2
             IF (MLSHM%MLFF_SHMEM_ALLOC_CLM2) THEN
                NULLIFY(MLSHM%CLM2)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM2)
                MLSHM%MLFF_SHMEM_ALLOC_CLM2=.FALSE.
             ENDIF
!CLM_COUPLE_HELP1_MANYBODY
             IF (MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP1_MANYBODY) THEN
                NULLIFY(MLSHM%CLM_COUPLE_HELP1_MANYBODY)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM_COUPLE_HELP1_MANYBODY)
                MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP1_MANYBODY=.FALSE.
             ENDIF
!CLM_COUPLE_HELP2_MANYBODY
             IF (MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP2_MANYBODY) THEN
                NULLIFY(MLSHM%CLM_COUPLE_HELP2_MANYBODY)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM_COUPLE_HELP2_MANYBODY)
                MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP2_MANYBODY=.FALSE.
             ENDIF
!C00_ALL 
             IF(FFM%W1.GT.0.0_q) THEN
                IF(MLSHM%MLFF_SHMEM_ALLOC_C00_ALL) THEN
                   NULLIFY(FFM%C00_ALL)
                   CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_C00_ALL)
                   MLSHM%MLFF_SHMEM_ALLOC_C00_ALL=.FALSE.
                ENDIF
             ENDIF
!C00_W_ALL 
             IF(FFM%W1.GT.0.0_q) THEN
                IF(MLSHM%MLFF_SHMEM_ALLOC_C00_W_ALL) THEN
                   NULLIFY(FFM%C00_W_ALL)
                   CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_C00_W_ALL)
                   MLSHM%MLFF_SHMEM_ALLOC_C00_W_ALL=.FALSE.
                ENDIF
             ENDIF
!PS_ALL
             IF(FFM%W2.GT.0.0_q) THEN
                IF(MLSHM%MLFF_SHMEM_ALLOC_PS_ALL) THEN
                   NULLIFY(FFM%PS_ALL)
                   CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_ALL)
                   MLSHM%MLFF_SHMEM_ALLOC_PS_ALL=.FALSE.
                ENDIF
             ENDIF
!PS_W_ALL
             IF(FFM%W2.GT.0.0_q) THEN
                IF(MLSHM%MLFF_SHMEM_ALLOC_PS_W_ALL) THEN
                   NULLIFY(FFM%PS_W_ALL)
                   CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_W_ALL)
                   MLSHM%MLFF_SHMEM_ALLOC_PS_W_ALL=.FALSE.
                ENDIF
             ENDIF
!PS_SIC
             IF(MLSHM%MLFF_SHMEM_ALLOC_PS_SIC) THEN
                NULLIFY(MLSHM%PS_SIC)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_SIC)
                MLSHM%MLFF_SHMEM_ALLOC_PS_SIC=.FALSE.
             ENDIF
!PS_SIC
             IF(MLSHM%MLFF_SHMEM_ALLOC_PS_SIC_COUPLE) THEN
                NULLIFY(MLSHM%PS_SIC_COUPLE)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_SIC_COUPLE)
                MLSHM%MLFF_SHMEM_ALLOC_PS_SIC_COUPLE=.FALSE.
             ENDIF
!SOAP_C00
             IF(MLSHM%MLFF_SHMEM_ALLOC_SOAP_C00) THEN
                NULLIFY(MLSHM%SOAP_C00)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_SOAP_C00)
                MLSHM%MLFF_SHMEM_ALLOC_SOAP_C00=.FALSE.
             ENDIF
!SOAP_PS
             IF(MLSHM%MLFF_SHMEM_ALLOC_SOAP_PS) THEN
                NULLIFY(MLSHM%SOAP_PS)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_SOAP_PS)
                MLSHM%MLFF_SHMEM_ALLOC_SOAP_PS=.FALSE.
             ENDIF
! SOAP_ALL
             IF(MLSHM%MLFF_SHMEM_ALLOC_SOAP_ALL) THEN
                NULLIFY(MLSHM%SOAP_ALL)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_SOAP_ALL)
                MLSHM%MLFF_SHMEM_ALLOC_SOAP_ALL=.FALSE.
             ENDIF
!CMAT_ALL
             IF(MLSHM%MLFF_SHMEM_ALLOC_CMAT_ALL) THEN
                NULLIFY(FFM%CMAT_ALL)
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CMAT_ALL)
                MLSHM%MLFF_SHMEM_ALLOC_CMAT_ALL=.FALSE.
             ENDIF
!ALLOCATE ARRAYS
!CMAT_ALL
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_CMAT_ALL) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,FFM%MBTOT_ALLOCATE,FFM%MBTOT_ALLOCATE, &
                     MLSHM%MLFF_SHM_2D_CMAT_ALL,FFM%CMAT_ALL,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MBTOT_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MEM1%RMEM_CMAT_ALL=MEM1%RMEM_CMAT_ALL+REAL(FFM%MBTOT_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_CMAT_ALL=.TRUE.
             ENDIF
!CLM1
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_CLM1) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_CLM1_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_CLM1_GLOBAL_ALLOCATE,MLSHM%MLFF_SHM_2D_CLM1,MLSHM%CLM1,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MCOL_CLM1_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MROW_CLM1_GLOBAL_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_CLM1=.TRUE.
             ENDIF
!CLM2
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_CLM2) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_CLM2_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_CLM2_GLOBAL_ALLOCATE,MLSHM%MLFF_SHM_2D_CLM2,MLSHM%CLM2,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MCOL_CLM2_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MROW_CLM2_GLOBAL_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_CLM2=.TRUE.
             ENDIF
!CLM_COUPLE_HELP1_MANYBODY
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP1_MANYBODY) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE, &
                     MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE,MLSHM%MLFF_SHM_2D_CLM_COUPLE_HELP1_MANYBODY,MLSHM%CLM_COUPLE_HELP1_MANYBODY,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE,q)*REAL(MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP1_MANYBODY=.TRUE.
             ENDIF
!CLM_COUPLE_HELP2_MANYBODY
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP2_MANYBODY) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE, &
                     MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE,MLSHM%MLFF_SHM_2D_CLM_COUPLE_HELP2_MANYBODY,MLSHM%CLM_COUPLE_HELP2_MANYBODY,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE,q)*REAL(MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP2_MANYBODY=.TRUE.
             ENDIF
!C00_ALL
             IF(FFM%W1.GT.0.0_q) THEN
                IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_C00_ALL) THEN
                   CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,FFM%MMVAR1_ALLOCATE, &
                        FFM%MBTOT_ALLOCATE, MLSHM%MLFF_SHM_2D_C00_ALL,FFM%C00_ALL,ISTAT=MLSHM%ISTATUS_SHMEM)
                   MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR1_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                   MLSHM%MLFF_SHMEM_ALLOC_C00_ALL=.TRUE.
                ENDIF
             ENDIF
!C00_W_ALL
             IF(FFM%W1.GT.0.0_q) THEN
                IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_C00_W_ALL) THEN
                   CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,FFM%MMVAR1_ALLOCATE, &
                        FFM%MBTOT_ALLOCATE, MLSHM%MLFF_SHM_2D_C00_W_ALL,FFM%C00_W_ALL,ISTAT=MLSHM%ISTATUS_SHMEM)
                   MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR1_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                   MLSHM%MLFF_SHMEM_ALLOC_C00_W_ALL=.TRUE.
                ENDIF
             ENDIF
!PS_ALL
             IF(FFM%W2.GT.0.0_q) THEN
                IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_PS_ALL) THEN
                   CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,FFM%MMVAR2_ALLOCATE, &
                        FFM%MBTOT_ALLOCATE, MLSHM%MLFF_SHM_2D_PS_ALL,FFM%PS_ALL,ISTAT=MLSHM%ISTATUS_SHMEM)
                   MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                   MEM1%RMEM_PS_ALL=MEM1%RMEM_PS_ALL+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                ENDIF
                MLSHM%MLFF_SHMEM_ALLOC_PS_ALL=.TRUE.
             ENDIF
!PS_W_ALL
             IF(FFM%W2.GT.0.0_q) THEN
                IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_PS_W_ALL) THEN
                   CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,FFM%MMVAR2_ALLOCATE, &
                        FFM%MBTOT_ALLOCATE, MLSHM%MLFF_SHM_2D_PS_W_ALL,FFM%PS_W_ALL,ISTAT=MLSHM%ISTATUS_SHMEM)
                   MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                   MEM1%RMEM_PS_ALL=MEM1%RMEM_PS_ALL+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                ENDIF
                MLSHM%MLFF_SHMEM_ALLOC_PS_W_ALL=.TRUE.
             ENDIF
!PS_SIC
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_PS_SIC) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE, MLSHM%MLFF_SHM_2D_PS_SIC,MLSHM%PS_SIC,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_PS_SIC=.TRUE.
             ENDIF
!PS_SIC_COUPLE
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_PS_SIC_COUPLE) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE, MLSHM%MLFF_SHM_2D_PS_SIC_COUPLE,MLSHM%PS_SIC_COUPLE,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_PS_SIC_COUPLE=.TRUE.
             ENDIF
!SOAP_C00
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_SOAP_C00) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_SOAP_C00_GLOBAL_ALLOCATE, MLSHM%MLFF_SHM_2D_SOAP_C00,MLSHM%SOAP_C00,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_SOAP_C00_GLOBAL,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_SOAP_C00=.TRUE.
             ENDIF
!SOAP_PS
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_SOAP_PS) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE, MLSHM%MLFF_SHM_2D_SOAP_PS,MLSHM%SOAP_PS,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_SOAP_PS=.TRUE.
             ENDIF
! SOAP_ALL
             IF(.NOT.MLSHM%MLFF_SHMEM_ALLOC_SOAP_ALL) THEN
                CALL M_shmem_alloc(PAR_SUP_HANDLE%COMM_intra_node_world,MLSHM%MROW_SOAP_ALL_GLOBAL_ALLOCATE, &
                     MLSHM%MCOL_SOAP_ALL_GLOBAL_ALLOCATE, MLSHM%MLFF_SHM_2D_SOAP_ALL,MLSHM%SOAP_ALL,ISTAT=MLSHM%ISTATUS_SHMEM)
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_SOAP_ALL_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_SOAP_ALL_GLOBAL_ALLOCATE,q)*8/1000000_q/REAL(PAR_SUP_HANDLE%COMM_intra_node_world%NCPU,q)
                MLSHM%MLFF_SHMEM_ALLOC_SOAP_ALL=.TRUE.
             ENDIF
!call MPI_BARRIER so that all processess are guaranteed to see allocated alllocated arrays
!!!             CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM,MLSHM%ISTATUS_SHMEM)
             CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,MLSHM%ISTATUS_SHMEM)
#else
!CLM1
             IF(ASSOCIATED(MLSHM%CLM1_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%CLM1_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%CLM1_NOSHMEM(MLSHM%MROW_CLM1_GLOBAL_ALLOCATE,MLSHM%MCOL_CLM1_GLOBAL_ALLOCATE))
             MLSHM%CLM1 => MLSHM%CLM1_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_CLM1_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_CLM1_GLOBAL_ALLOCATE,q)*8/1000000_q
!CLM2
             IF(ASSOCIATED(MLSHM%CLM2_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%CLM2_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%CLM2_NOSHMEM(MLSHM%MROW_CLM2_GLOBAL_ALLOCATE,MLSHM%MCOL_CLM2_GLOBAL_ALLOCATE))
             MLSHM%CLM2 => MLSHM%CLM2_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_CLM2_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_CLM2_GLOBAL_ALLOCATE,q)*8/1000000_q
!CLM_COUPLE_HELP1_MANYBODY
             IF(ASSOCIATED(MLSHM%CLM_COUPLE_HELP1_MANYBODY_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%CLM_COUPLE_HELP1_MANYBODY_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%CLM_COUPLE_HELP1_MANYBODY_NOSHMEM(MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE,MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE))
             MLSHM%CLM_COUPLE_HELP1_MANYBODY => MLSHM%CLM_COUPLE_HELP1_MANYBODY_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE,q)*REAL(MLSHM%MCOL_CLM_COUPLE_HELP1_MANYBODY_ALLOCATE,q)*8/1000000_q
!CLM_COUPLE_HELP2_MANYBODY
             IF(ASSOCIATED(MLSHM%CLM_COUPLE_HELP2_MANYBODY_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%CLM_COUPLE_HELP2_MANYBODY_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%CLM_COUPLE_HELP2_MANYBODY_NOSHMEM(MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE,MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE))
             MLSHM%CLM_COUPLE_HELP2_MANYBODY => MLSHM%CLM_COUPLE_HELP2_MANYBODY_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE,q)*REAL(MLSHM%MCOL_CLM_COUPLE_HELP2_MANYBODY_ALLOCATE,q)*8/1000000_q
!C00_ALL
             IF(FFM%W1.GT.0.0_q) THEN
                IF(ASSOCIATED(MLSHM%C00_ALL_NOSHMEM)) THEN
                   DEALLOCATE(MLSHM%C00_ALL_NOSHMEM)
                ENDIF
                ALLOCATE(MLSHM%C00_ALL_NOSHMEM(1:FFM%MMVAR1_ALLOCATE,1:FFM%MBTOT_ALLOCATE))
                FFM%C00_ALL => MLSHM%C00_ALL_NOSHMEM
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR1_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
             ENDIF
!C00_W_ALL
             IF(FFM%W1.GT.0.0_q) THEN
                IF(ASSOCIATED(MLSHM%C00_W_ALL_NOSHMEM)) THEN
                   DEALLOCATE(MLSHM%C00_W_ALL_NOSHMEM)
                ENDIF
                ALLOCATE(MLSHM%C00_W_ALL_NOSHMEM(1:FFM%MMVAR1_ALLOCATE,1:FFM%MBTOT_ALLOCATE))
                FFM%C00_W_ALL => MLSHM%C00_W_ALL_NOSHMEM
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR1_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
             ENDIF
!PS_ALL
             IF(FFM%W2.GT.0.0_q) THEN
                IF(ASSOCIATED(MLSHM%PS_ALL_NOSHMEM)) THEN
                   DEALLOCATE(MLSHM%PS_ALL_NOSHMEM)
                ENDIF
                ALLOCATE(MLSHM%PS_ALL_NOSHMEM(1:FFM%MMVAR2_ALLOCATE,1:FFM%MBTOT_ALLOCATE))
                FFM%PS_ALL  => MLSHM%PS_ALL_NOSHMEM
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
                MEM1%RMEM_PS_ALL=MEM1%RMEM_PS_ALL+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
             ENDIF
!PS_W_ALL
             IF(FFM%W2.GT.0.0_q) THEN
                IF(ASSOCIATED(MLSHM%PS_W_ALL_NOSHMEM)) THEN
                   DEALLOCATE(MLSHM%PS_W_ALL_NOSHMEM)
                ENDIF
                ALLOCATE(MLSHM%PS_W_ALL_NOSHMEM(1:FFM%MMVAR2_ALLOCATE,1:FFM%MBTOT_ALLOCATE))
                FFM%PS_W_ALL  => MLSHM%PS_W_ALL_NOSHMEM
                MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
                MEM1%RMEM_PS_ALL=MEM1%RMEM_PS_ALL+REAL(FFM%MMVAR2_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
             ENDIF
!PS_SIC
             IF(ASSOCIATED(MLSHM%PS_SIC_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%PS_SIC_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%PS_SIC_NOSHMEM(1:MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE,1:MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE))
             MLSHM%PS_SIC => MLSHM%PS_SIC_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_PS_SIC_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_PS_SIC_GLOBAL_ALLOCATE,q)*8/1000000_q
!PS_SIC_COUPLE
             IF(ASSOCIATED(MLSHM%PS_SIC_COUPLE_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%PS_SIC_COUPLE_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%PS_SIC_COUPLE_NOSHMEM(1:MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE,1:MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE))
             MLSHM%PS_SIC_COUPLE => MLSHM%PS_SIC_COUPLE_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_PS_SIC_COUPLE_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_PS_SIC_COUPLE_GLOBAL_ALLOCATE,q)*8/1000000_q
!SOAP_C00
             IF(ASSOCIATED(MLSHM%SOAP_C00_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%SOAP_C00_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%SOAP_C00_NOSHMEM(1:MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE,1:MLSHM%MCOL_SOAP_C00_GLOBAL_ALLOCATE))
             MLSHM%SOAP_C00 => MLSHM%SOAP_C00_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_SOAP_C00_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_SOAP_C00_GLOBAL_ALLOCATE,q)*8/1000000_q
!SOAP_PS
             IF(ASSOCIATED(MLSHM%SOAP_PS_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%SOAP_PS_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%SOAP_PS_NOSHMEM(1:MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE,1:MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE))
             MLSHM%SOAP_PS => MLSHM%SOAP_PS_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_SOAP_PS_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_SOAP_PS_GLOBAL_ALLOCATE,q)*8/1000000_q
! SOAP_ALL
             IF(ASSOCIATED(MLSHM%SOAP_ALL_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%SOAP_ALL_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%SOAP_ALL_NOSHMEM(1:MLSHM%MROW_SOAP_ALL_GLOBAL_ALLOCATE,1:MLSHM%MCOL_SOAP_ALL_GLOBAL_ALLOCATE))
             MLSHM%SOAP_ALL => MLSHM%SOAP_ALL_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(MLSHM%MROW_SOAP_ALL_GLOBAL_ALLOCATE,q)*REAL(MLSHM%MCOL_SOAP_ALL_GLOBAL_ALLOCATE,q)*8/1000000_q
!CMAT_ALL
             IF(ASSOCIATED(MLSHM%CMAT_ALL_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%CMAT_ALL_NOSHMEM)
             ENDIF
             ALLOCATE(MLSHM%CMAT_ALL_NOSHMEM(1:FFM%MBTOT_ALLOCATE,1:FFM%MBTOT_ALLOCATE))
             FFM%CMAT_ALL => MLSHM%CMAT_ALL_NOSHMEM
             MEM1%RMEM(2)=MEM1%RMEM(2)+REAL(FFM%MBTOT_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
             MEM1%RMEM_CMAT_ALL=MEM1%RMEM_CMAT_ALL+REAL(FFM%MBTOT_ALLOCATE,q)*REAL(FFM%MBTOT_ALLOCATE,q)*8/1000000_q
#endif
          ELSE
             MEM1%RMEM(2)  =0.0_q
             MEM1%RMEM_CMAT=0.0_q
             MEM1%RMEM_FMAT=0.0_q
             MEM1%RMEM_PS  =0.0_q
             MEM1%RMEM_SOAP=0.0_q
          ENDIF
! Initialization of variable
          FF%BEHIS(1:FF%MHIS)=0.0_q
          FF%ERRHIS(1:FF%MHIS)=0.0_q
          IF(FF%LMLMB) THEN
             IF(FFM%W1.GT.0.0_q) THEN
                FFM%C00=0.0_q
                FFM%C00_NEW=0.0_q
                FFM%FNL1=0.0_q
                FFM%L_LNRB1=0
                FFM%NRB_LNRB1=0
                FFM%QGRID1=0.0_q
                FFM%RB1=0.0_q
                FFM%RG1=0.0_q
                FFM%RNORM1=0.0_q
                FFM%USQ1=0.0_q
             ENDIF
             IF(FFM%W2.GT.0.0_q) THEN
                FFM%FNL2=0.0_q
                FFM%L_LNRB2=0
                FFM%LVAR=0
                FFM%LVAR_SIC=0
                FFM%LFLAG_VAR=.FALSE.
                FFM%LFLAG_VAR_SIC=.FALSE.
                FFM%NRB_LNRB2=0
                FFM%PS=0.0_q
                FFM%PS_NEW=0.0_q
                FFM%QGRID2=0.0_q
                FFM%RB2=0.0_q
                FFM%RG2=0.0_q
                FFM%RNORM2=0.0_q
                FFM%USQ2=0.0_q
             ENDIF
             FFM%CMAT=0.0_q
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                FFM%DMAT_FMAT=0.0_q
                FFM%DMAT_YMAT=0.0_q
                FFM%FMAT=0.0_q
                FFM%FMAT_NEW=0.0_q
             ENDIF
             FFM%LB=0
             FFM%LBHEAD=0
             FFM%LNCONF=0
             FFM%LNIONS=0
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                FFM%LTIFOR=0
                FFM%LTIFOR_NEW=0
                FFM%LTOTEN=0
                FFM%LTOTEN_NEW=0
                FFM%LTSIF=0
                FFM%LTSIF_NEW=0
             ENDIF
             FFM%NB=0
             FFM%NB_NEW=0
             FFM%WMAT=0.0_q
             IF(.NOT.FF%LMLONLY.OR.FF%ISTART.NE.2) THEN
                FFM%YMAT=0.0_q
             ENDIF
          ENDIF
! Initialization of non-scalapack (shared) memory objects
#ifdef use_shmem
          IF (PAR_SUP_HANDLE%COMM_intra_node_world%NODE_ME.EQ.0) THEN
#endif
             FFM%CMAT_ALL=0.0_q
             MLSHM%CLM1=0.0_q
             MLSHM%CLM2=0.0_q
             MLSHM%CLM_COUPLE_HELP1_MANYBODY=0.0_q
             MLSHM%CLM_COUPLE_HELP2_MANYBODY=0.0_q
             MLSHM%PS_SIC=0.0_q
             MLSHM%PS_SIC_COUPLE=0.0_q
             MLSHM%SOAP_ALL=0.0_q
             IF (FFM%W1.GT.0.0_q) THEN
                FFM%C00_ALL=0.0_q
                FFM%C00_W_ALL=0.0_q
                MLSHM%SOAP_C00=0.0_q
             ENDIF
             IF (FFM%W2.GT.0.0_q) THEN
                FFM%PS_ALL=0.0_q
                FFM%PS_W_ALL=0.0_q
                MLSHM%SOAP_PS=0.0_q
             ENDIF
#ifdef use_shmem
          ENDIF
          CALL MPI_BARRIER(PAR_SUP_HANDLE%COMM_intra_node_world%MPI_COMM,MLSHM%ISTATUS_SHMEM)
#endif
        END SUBROUTINE ALLOCATE_FFARRAY3_DO_ALLOCATIONS

!****************************************************************************************************
! Subroutine to deallocate arrays storing force field parameters
!****************************************************************************************************

        SUBROUTINE DEALLOCATE_FFARRAY(MLSHM,FF,FFM)
          USE ML_FF_STRUCT, ONLY: ML_SHMEM, FF_PAR, FFM_PAR
          IMPLICIT NONE
! Input variables
          TYPE (ML_SHMEM)    :: MLSHM
          TYPE (FF_PAR)      :: FF
          TYPE (FFM_PAR)     :: FFM
! Deallocate
          IF(ALLOCATED(FF%BEHIS)) THEN
             DEALLOCATE(FF%BEHIS)
          ENDIF
          IF(ALLOCATED(FF%EATOM_REF)) THEN
             DEALLOCATE(FF%EATOM_REF)
          ENDIF
          IF(ALLOCATED(FF%ERRHIS)) THEN
             DEALLOCATE(FF%ERRHIS)
          ENDIF
          IF(ALLOCATED(FF%LADD)) THEN
             DEALLOCATE(FF%LADD)
          ENDIF
          IF(ALLOCATED(FF%POMASS)) THEN
             DEALLOCATE(FF%POMASS)
          ENDIF
          IF(ALLOCATED(FF%SZNAM2)) THEN
             DEALLOCATE(FF%SZNAM2)
          ENDIF
          IF(ALLOCATED(FF%SZNAM2_INPUT)) THEN
             DEALLOCATE(FF%SZNAM2_INPUT)
          ENDIF
          IF(ALLOCATED(FF%TYPE)) THEN
             DEALLOCATE(FF%TYPE)
          ENDIF
          IF(ALLOCATED(FFM%WION1)) THEN
             DEALLOCATE(FFM%WION1)
          ENDIF
          IF(ALLOCATED(FFM%WION2)) THEN
             DEALLOCATE(FFM%WION2)
          ENDIF
          IF(ALLOCATED(FFM%C00)) THEN
             DEALLOCATE (FFM%C00)
          ENDIF
          IF(ALLOCATED(FFM%C00_NEW)) THEN
             DEALLOCATE(FFM%C00_NEW)
          ENDIF
          IF(ALLOCATED(FFM%CMAT)) THEN
             DEALLOCATE(FFM%CMAT)
          ENDIF
          IF(ALLOCATED(FFM%DMAT_FMAT)) THEN
             DEALLOCATE(FFM%DMAT_FMAT)
          ENDIF
          IF(ALLOCATED(FFM%DMAT_YMAT)) THEN
             DEALLOCATE(FFM%DMAT_YMAT)
          ENDIF
          IF(ALLOCATED(FFM%FMAT)) THEN
             DEALLOCATE(FFM%FMAT)
          ENDIF
          IF(ALLOCATED(FFM%FMAT_NEW)) THEN
             DEALLOCATE(FFM%FMAT_NEW)
          ENDIF
          IF(ALLOCATED(FFM%FNL1)) THEN
             DEALLOCATE(FFM%FNL1)
          ENDIF
          IF(ALLOCATED(FFM%FNL2)) THEN
             DEALLOCATE(FFM%FNL2)
          ENDIF
          IF(ALLOCATED(FFM%INDEX_PAIR_HELP1)) THEN
             DEALLOCATE(FFM%INDEX_PAIR_HELP1)
          ENDIF
          IF(ALLOCATED(FFM%INDEX_MAP_TO_PS)) THEN
             DEALLOCATE(FFM%INDEX_MAP_TO_PS)
          ENDIF
          IF (FFM%DESC_TYPE.EQ.1) THEN
             IF(ALLOCATED(FFM%INDEX_MAP_TO_PS_B)) THEN
                DEALLOCATE(FFM%INDEX_MAP_TO_PS_B)
             ENDIF
          ENDIF
          IF(ALLOCATED(FFM%INDEX_NUM2)) THEN
             DEALLOCATE(FFM%INDEX_NUM2)
          ENDIF
          IF (FFM%DESC_TYPE.EQ.1) THEN
             IF(ALLOCATED(FFM%INDEX_NUM2_B)) THEN
                DEALLOCATE(FFM%INDEX_NUM2_B)
             ENDIF
          ENDIF
          IF(ALLOCATED(FFM%INDEX_PAIR_HELP2)) THEN
             DEALLOCATE(FFM%INDEX_PAIR_HELP2)
          ENDIF
          IF (FFM%DESC_TYPE.EQ.1) THEN
             IF(ALLOCATED(FFM%INDEX_PAIR_HELP2_B)) THEN
                DEALLOCATE(FFM%INDEX_PAIR_HELP2_B)
             ENDIF
          ENDIF
          IF(ALLOCATED(FFM%LB)) THEN
             DEALLOCATE(FFM%LB)
          ENDIF
          IF(ALLOCATED(FFM%LIONS_COUPLE)) THEN
             DEALLOCATE(FFM%LIONS_COUPLE)
          ENDIF
          IF(ALLOCATED(FFM%LNCONF)) THEN
             DEALLOCATE(FFM%LNCONF)
          ENDIF
          IF(ALLOCATED(FFM%LNIONS)) THEN
             DEALLOCATE(FFM%LNIONS)
          ENDIF
          IF(ALLOCATED(FFM%LTIFOR)) THEN
             DEALLOCATE(FFM%LTIFOR)
          ENDIF
          IF(ALLOCATED(FFM%LTIFOR_NEW)) THEN
             DEALLOCATE(FFM%LTIFOR_NEW)
          ENDIF
          IF(ALLOCATED(FFM%LTOTEN)) THEN
             DEALLOCATE(FFM%LTOTEN)
          ENDIF
          IF(ALLOCATED(FFM%LTOTEN_NEW)) THEN
             DEALLOCATE(FFM%LTOTEN_NEW)
          ENDIF
          IF(ALLOCATED(FFM%LTSIF)) THEN
             DEALLOCATE(FFM%LTSIF)
          ENDIF
          IF(ALLOCATED(FFM%LTSIF_NEW)) THEN
             DEALLOCATE(FFM%LTSIF_NEW)
          ENDIF
          IF(ALLOCATED(FFM%LFLAG_VAR)) THEN
             DEALLOCATE(FFM%LFLAG_VAR)
          ENDIF
          IF(ALLOCATED(FFM%LFLAG_VAR_SIC)) THEN
             DEALLOCATE(FFM%LFLAG_VAR_SIC)
          ENDIF
          IF(ALLOCATED(FFM%LVAR)) THEN
             DEALLOCATE(FFM%LVAR)
          ENDIF
          IF(ALLOCATED(FFM%LVAR_SIC)) THEN
             DEALLOCATE(FFM%LVAR_SIC)
          ENDIF
          IF(ALLOCATED(FFM%NB)) THEN
             DEALLOCATE(FFM%NB)
          ENDIF
          IF(ALLOCATED(FFM%NB_NEW)) THEN
             DEALLOCATE(FFM%NB_NEW)
          ENDIF
          IF(ALLOCATED(FFM%NNVAR2)) THEN
             DEALLOCATE(FFM%NNVAR2)
          ENDIF
          IF(ALLOCATED(FFM%NNVAR2_SIC)) THEN
             DEALLOCATE(FFM%NNVAR2_SIC)
          ENDIF
          IF(ALLOCATED(FFM%PREFACTOR_HELP1)) THEN
             DEALLOCATE(FFM%PREFACTOR_HELP1)
          ENDIF
          IF(ALLOCATED(FFM%PREFACTOR_HELP2)) THEN
             DEALLOCATE(FFM%PREFACTOR_HELP2)
          ENDIF
          IF (FFM%DESC_TYPE.EQ.1) THEN
             IF(ALLOCATED(FFM%PREFACTOR_HELP2_B)) THEN
                DEALLOCATE(FFM%PREFACTOR_HELP2_B)
             ENDIF
          ENDIF
          IF(ALLOCATED(FFM%PS)) THEN
             DEALLOCATE(FFM%PS)
          ENDIF
          IF(ALLOCATED(FFM%PS_NEW)) THEN
             DEALLOCATE(FFM%PS_NEW)
          ENDIF
          IF(ALLOCATED(FFM%RB1)) THEN
             DEALLOCATE(FFM%RB1)
          ENDIF
          IF(ALLOCATED(FFM%RB2)) THEN
             DEALLOCATE(FFM%RB2)
          ENDIF
          IF(ALLOCATED(FFM%RCOUPLE_IONS)) THEN
             DEALLOCATE(FFM%RCOUPLE_IONS)
          ENDIF
          IF(ALLOCATED(FFM%RNORM1)) THEN
             DEALLOCATE(FFM%RNORM1)
          ENDIF
          IF(ALLOCATED(FFM%RNORM2)) THEN
             DEALLOCATE(FFM%RNORM2)
          ENDIF
          IF(ALLOCATED(FFM%QGRID1)) THEN
             DEALLOCATE(FFM%QGRID1)
          ENDIF
          IF(ALLOCATED(FFM%QGRID2)) THEN
             DEALLOCATE(FFM%QGRID2)
          ENDIF
          IF(ALLOCATED(FFM%RC1)) THEN
             DEALLOCATE(FFM%RC1)
          ENDIF
          IF(ALLOCATED(FFM%RC2)) THEN
             DEALLOCATE(FFM%RC2)
          ENDIF
          IF(ALLOCATED(FFM%RG1)) THEN
             DEALLOCATE(FFM%RG1)
          ENDIF
          IF(ALLOCATED(FFM%RG2)) THEN
             DEALLOCATE(FFM%RG2)
          ENDIF
          IF(ALLOCATED(FF%SIG_SYS)) THEN
             DEALLOCATE(FF%SIG_SYS)
          ENDIF
          IF(ALLOCATED(FFM%SIG_SYS)) THEN
             DEALLOCATE(FFM%SIG_SYS)
          ENDIF
          IF(ALLOCATED(FFM%SOAP)) THEN
             DEALLOCATE(FFM%SOAP)
          ENDIF
          IF(ALLOCATED(FFM%USQ1)) THEN
             DEALLOCATE(FFM%USQ1)
          ENDIF
          IF(ALLOCATED(FFM%USQ2)) THEN
             DEALLOCATE(FFM%USQ2)
          ENDIF
          IF(ALLOCATED(FFM%WMAT)) THEN
             DEALLOCATE(FFM%WMAT)
          ENDIF
          IF(ALLOCATED(FFM%WMAT_ALL)) THEN
             DEALLOCATE(FFM%WMAT_ALL)
          ENDIF
          IF(ALLOCATED(FFM%WVAR)) THEN
             DEALLOCATE(FFM%WVAR)
          ENDIF
          IF(ALLOCATED(FFM%YMAT)) THEN
             DEALLOCATE(FFM%YMAT)
          ENDIF
! Shared memory stuffs.
#ifdef use_shmem
!CLM1
          IF(MLSHM%MLFF_SHMEM_ALLOC_CLM1) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM1)
             MLSHM%MLFF_SHMEM_ALLOC_CLM1=.FALSE.
          ENDIF
!CLM2
          IF(MLSHM%MLFF_SHMEM_ALLOC_CLM2) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM2)
             MLSHM%MLFF_SHMEM_ALLOC_CLM2=.FALSE.
          ENDIF
!CLM_COUPLE_HELP1_MANYBODY
          IF(MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP1_MANYBODY) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM_COUPLE_HELP1_MANYBODY)
             MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP1_MANYBODY=.FALSE.
          ENDIF
!CLM_COUPLE_HELP2_MANYBODY
          IF(MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP2_MANYBODY) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CLM_COUPLE_HELP2_MANYBODY)
             MLSHM%MLFF_SHMEM_ALLOC_CLM_COUPLE_HELP2_MANYBODY=.FALSE.
          ENDIF
!C00_ALL
          IF(FFM%W1.GT.0.0_q) THEN
             IF(MLSHM%MLFF_SHMEM_ALLOC_C00_ALL) THEN
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_C00_ALL)
                MLSHM%MLFF_SHMEM_ALLOC_C00_ALL=.FALSE.
             ENDIF
          ENDIF
!C00_W_ALL
          IF(FFM%W1.GT.0.0_q) THEN
             IF(MLSHM%MLFF_SHMEM_ALLOC_C00_W_ALL) THEN
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_C00_W_ALL)
                MLSHM%MLFF_SHMEM_ALLOC_C00_W_ALL=.FALSE.
             ENDIF
          ENDIF
!PS_ALL
          IF(FFM%W2.GT.0.0_q) THEN
             IF(MLSHM%MLFF_SHMEM_ALLOC_PS_ALL) THEN
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_ALL)
                MLSHM%MLFF_SHMEM_ALLOC_PS_ALL=.FALSE.
             ENDIF
          ENDIF
!PS_W_ALL
          IF(FFM%W2.GT.0.0_q) THEN
             IF(MLSHM%MLFF_SHMEM_ALLOC_PS_W_ALL) THEN
                CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_W_ALL)
                MLSHM%MLFF_SHMEM_ALLOC_PS_W_ALL=.FALSE.
             ENDIF
          ENDIF
!PS_SIC
          IF(MLSHM%MLFF_SHMEM_ALLOC_PS_SIC) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_SIC)
             MLSHM%MLFF_SHMEM_ALLOC_PS_SIC=.FALSE.
          ENDIF
!PS_SIC_COUPLE
          IF(MLSHM%MLFF_SHMEM_ALLOC_PS_SIC_COUPLE) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_PS_SIC_COUPLE)
             MLSHM%MLFF_SHMEM_ALLOC_PS_SIC_COUPLE=.FALSE.
          ENDIF
!CMAT_ALL
          IF(MLSHM%MLFF_SHMEM_ALLOC_CMAT_ALL) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_CMAT_ALL)
             MLSHM%MLFF_SHMEM_ALLOC_CMAT_ALL=.FALSE.
          ENDIF
! SOAP_C00
          IF(MLSHM%MLFF_SHMEM_ALLOC_SOAP_C00) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_SOAP_C00)
             MLSHM%MLFF_SHMEM_ALLOC_SOAP_C00=.FALSE.
          ENDIF
! SOAP_PS
          IF(MLSHM%MLFF_SHMEM_ALLOC_SOAP_PS) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_SOAP_PS)
             MLSHM%MLFF_SHMEM_ALLOC_SOAP_PS=.FALSE.
          ENDIF
! SOAP_ALL
          IF(MLSHM%MLFF_SHMEM_ALLOC_SOAP_ALL) THEN
             CALL M_shmem_dealloc(MLSHM%MLFF_SHM_2D_SOAP_ALL)
             MLSHM%MLFF_SHMEM_ALLOC_SOAP_ALL=.FALSE.
          ENDIF
#else
!CLM1
          IF(ASSOCIATED(MLSHM%CLM1_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%CLM1_NOSHMEM)
          ENDIF
!CLM2
          IF(ASSOCIATED(MLSHM%CLM2_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%CLM2_NOSHMEM)
          ENDIF
!CLM_COUPLE_HELP1_MANYBODY
          IF(ASSOCIATED(MLSHM%CLM_COUPLE_HELP1_MANYBODY_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%CLM_COUPLE_HELP1_MANYBODY_NOSHMEM)
          ENDIF
!CLM_COUPLE_HELP2_MANYBODY
          IF(ASSOCIATED(MLSHM%CLM_COUPLE_HELP2_MANYBODY_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%CLM_COUPLE_HELP2_MANYBODY_NOSHMEM)
          ENDIF
!C00_ALL
          IF(FFM%W1.GT.0.0_q) THEN
             IF(ASSOCIATED(MLSHM%C00_ALL_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%C00_ALL_NOSHMEM)
             ENDIF
          ENDIF
!C00_W_ALL
          IF(FFM%W1.GT.0.0_q) THEN
             IF(ASSOCIATED(MLSHM%C00_W_ALL_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%C00_W_ALL_NOSHMEM)
             ENDIF
          ENDIF
!PS_ALL
          IF(FFM%W2.GT.0.0_q) THEN
             IF(ASSOCIATED(MLSHM%PS_ALL_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%PS_ALL_NOSHMEM)
             ENDIF
          ENDIF
!PS_W_ALL
          IF(FFM%W2.GT.0.0_q) THEN
             IF(ASSOCIATED(MLSHM%PS_W_ALL_NOSHMEM)) THEN
                DEALLOCATE(MLSHM%PS_W_ALL_NOSHMEM)
             ENDIF
          ENDIF
!PS_SIC
          IF(ASSOCIATED(MLSHM%PS_SIC_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%PS_SIC_NOSHMEM)
          ENDIF
!PS_SIC_COUPLE
          IF(ASSOCIATED(MLSHM%PS_SIC_COUPLE_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%PS_SIC_COUPLE_NOSHMEM)
          ENDIF
!CMAT_ALL
          IF(ASSOCIATED(MLSHM%CMAT_ALL_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%CMAT_ALL_NOSHMEM)
          ENDIF
!SOAP_C00
          IF(ASSOCIATED(MLSHM%SOAP_C00_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%SOAP_C00_NOSHMEM)
          ENDIF
!SOAP_PS
          IF(ASSOCIATED(MLSHM%SOAP_PS_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%SOAP_PS_NOSHMEM)
          ENDIF
!SOAP_ALL
          IF(ASSOCIATED(MLSHM%SOAP_ALL_NOSHMEM)) THEN
             DEALLOCATE(MLSHM%SOAP_ALL_NOSHMEM)
          ENDIF
#endif
        END SUBROUTINE DEALLOCATE_FFARRAY


        SUBROUTINE COMPUTE_NEAREST_NEIGHBOR_ARRAYS( NEAREST_NEIGHBOR_RADIAL, &
                                                    NEAREST_NEIGHBOR_ANGULAR, &
                                                    A, &
                                                    B, &
                                                    LNTYP, &
                                                    MTYP, &
                                                    NIONS, &
                                                    MIONS, &
                                                    POSION, &
                                                    PAR_SUP_HANDLE,&
                                                    ! radial variables
                                                    MNEIB_EST1, &
                                                    W1, &
                                                    RCUT1, &
                                                    ! angular variables
                                                    MNEIB_EST2, &
                                                    W2, &
                                                    RCUT2 &
                                                )


           USE VERLET_CELL_LIST_MOD, ONLY : VERLET_CELL_LIST_TYPE
           USE ML_FF_STRUCT, ONLY : PARALLEL_SUPER
           IMPLICIT NONE
           !> nearest neighbor object for radial descriptor
           TYPE( VERLET_CELL_LIST_TYPE ), INTENT( INOUT ) :: NEAREST_NEIGHBOR_RADIAL
           !> nearest neighbor object for angular descriptor
           TYPE( VERLET_CELL_LIST_TYPE ), INTENT( INOUT ) :: NEAREST_NEIGHBOR_ANGULAR
           !> bravais matrix
           REAL( q ), INTENT( IN ) :: A( : , : )
           !> inverse bravais matrix factor 2pi included
           REAL( q ), INTENT( IN ) :: B( : , : )
           !> ion type as a integer
           INTEGER, INTENT( IN ) :: LNTYP( : )
           !> maximal number of types
           INTEGER, INTENT( IN ) :: MTYP
           !> number of ions
           INTEGER, INTENT( IN ) :: NIONS
           ! maximum number of ions
           INTEGER, INTENT( IN ) :: MIONS
           !> positions of ions in (xyz,NIONS) format
           REAL( q ), INTENT( IN ) :: POSION( :, : )
           !> mpi communicator of machine learning force field
           TYPE (PARALLEL_SUPER), INTENT( IN ) :: PAR_SUP_HANDLE
           
           !> radial descriptor variables
           !> maximal neighbor size radial
           INTEGER, INTENT( INOUT ) :: MNEIB_EST1
           !> radial weight factor
           Real( q ), INTENT( IN ) ::W1
           !> radial cutoff distance
           Real( q ), INTENT( IN ) ::RCUT1
           
           !> angular descriptor variables
           !> maximal neighbor size angular
           INTEGER, INTENT( INOUT ) :: MNEIB_EST2
           !> angular weight factor
           Real( q ), INTENT( IN ) ::W2
           !> angular cutoff distance
           Real( q ), INTENT( IN ) ::RCUT2

           ! definitions of local variables
           INTEGER :: INIONS_TMP
           INTEGER :: INIONS

           INTEGER :: RADIAL_MAX
           INTEGER :: ANGULAR_MAX



           IF ( RCUT1 .ge. RCUT2 .and. W1 .gt. 0.0_q ) then 
              CALL NEAREST_NEIGHBOR_RADIAL%compute_nn_list( POSION, LNTYP,&
                                                            A, B,&
                                                            PAR_SUP_HANDLE%COMM_WORLD%NODE_ME, &
                                                            PAR_SUP_HANDLE%COMM_WORLD%NCPU,&
                                                            PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM )
              MNEIB_EST1  =  NEAREST_NEIGHBOR_RADIAL%GET_MAX_NUMBER_NEIGHBORS()
              IF ( W2 .gt. 0.0_q ) then
                 CALL NEAREST_NEIGHBOR_ANGULAR%compute_nn_list( NEAREST_NEIGHBOR_RADIAL,&
                                                         PAR_SUP_HANDLE%COMM_WORLD%NODE_ME, &
                                                         PAR_SUP_HANDLE%COMM_WORLD%NCPU )
                 MNEIB_EST2  =  NEAREST_NEIGHBOR_ANGULAR%GET_MAX_NUMBER_NEIGHBORS()
              ELSE
                 ! set default value if angular descriptor is not used
                 MNEIB_EST2  =  1
              END IF
           ELSE IF ( RCUT2 .ge. RCUT1 .and. W2 .gt. 0.0_q ) THEN
              CALL NEAREST_NEIGHBOR_ANGULAR%compute_nn_list( POSION, LNTYP, &
                                                             A, B,&
                                                             PAR_SUP_HANDLE%COMM_WORLD%NODE_ME,&
                                                             PAR_SUP_HANDLE%COMM_WORLD%NCPU,&
                                                             PAR_SUP_HANDLE%COMM_WORLD%MPI_COMM )
              MNEIB_EST2  =  NEAREST_NEIGHBOR_ANGULAR%GET_MAX_NUMBER_NEIGHBORS()
              IF ( W1 .gt. 0.0_q ) then
                 CALL NEAREST_NEIGHBOR_RADIAL%compute_nn_list( NEAREST_NEIGHBOR_ANGULAR,&
                                                               PAR_SUP_HANDLE%COMM_WORLD%NODE_ME, &
                                                               PAR_SUP_HANDLE%COMM_WORLD%NCPU )
                 MNEIB_EST1  =  NEAREST_NEIGHBOR_RADIAL%GET_MAX_NUMBER_NEIGHBORS()
              ELSE
                 ! set default value if radial descriptor is not used
                 MNEIB_EST1  =  1
              END IF
           END IF 


        END SUBROUTINE COMPUTE_NEAREST_NEIGHBOR_ARRAYS


        SUBROUTINE UPDATE_NEAREST_NEIGHBOR_ARRAYS( NEAREST_NEIGHBOR_RADIAL, &
                                                   NEAREST_NEIGHBOR_ANGULAR, &
                                                   A, &
                                                   B, &
                                                   LNTYP, &
                                                   MTYP, &
                                                   NIONS, &
                                                   MIONS, &
                                                   POSION, &
                                                   NCPU, &
                                                   NODE_ME, &
                                                   ! radial variables
                                                   LNIONS_EST1,&
                                                   NNEIB_EST1,&
                                                   NORMALIZATION_XYZ1,&
                                                   XYZ_EST1,&
                                                   XYZ_EST1_NORM,&
                                                   W1, &
                                                   ! angular variables
                                                   LNIONS_EST2, &
                                                   NNEIB_EST2, &
                                                   NORMALIZATION_XYZ2, &
                                                   XYZ_EST2, &
                                                   XYZ_EST2_NORM, &
                                                   W2 &
                                                )


           USE VERLET_CELL_LIST_MOD, ONLY : VERLET_CELL_LIST_TYPE
           IMPLICIT NONE
           !> nearest neighbor object for radial descriptor
           TYPE( VERLET_CELL_LIST_TYPE ),INTENT( INOUT ) :: NEAREST_NEIGHBOR_RADIAL
           !> nearest neighbor object for angular descriptor
           TYPE( VERLET_CELL_LIST_TYPE ),INTENT( INOUT ) :: NEAREST_NEIGHBOR_ANGULAR
           !> bravais matrix
           REAL( q ), INTENT( IN ) :: A( : , : )
           !> inverse bravais matrix factor 2pi included
           REAL( q ), INTENT( IN ) :: B( : , : )
           !> ion type coded as integer
           INTEGER, INTENT( IN ) :: LNTYP( : )
           !> maximal number of types
           INTEGER, INTENT( IN ) :: MTYP
           !> number of ions
           INTEGER, INTENT( IN ) :: NIONS
           ! maximum number of ions
           INTEGER, INTENT( IN ) :: MIONS
           !> positions of ions in (xyz,NIONS) format
           REAL( q ), INTENT( IN ) :: POSION( :, : )
           !> total number of cpus for mpi parallelization
           INTEGER, INTENT( IN ) :: NCPU
           !> number of current processor
           INTEGER, INTENT( IN ) :: NODE_ME
           
           !> radial descriptor variables
           !> (index pointing to POSION, type index, INIONS )
           INTEGER, INTENT( INOUT ) :: LNIONS_EST1( :, :, : )
           !> number nearest neighbours , type index, INIONS )
           INTEGER, INTENT( INOUT ) :: NNEIB_EST1( :, : )
           !> norm of connection vector  ( neighbor number , type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: NORMALIZATION_XYZ1( :, : , : )
           !> connection vector  ( neighbor number , xyz, type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: XYZ_EST1( :, : , :, : )
           !> normalized connection vector  ( neighbor number , xyz, type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: XYZ_EST1_NORM( :, : , :, : )
           Real( q ), INTENT( IN ) ::W1
           
           !> angular descriptor variables
           !> (index pointing to POSION, type index, INIONS )
           INTEGER, INTENT( INOUT ) :: LNIONS_EST2( :, :, : )
           !> number nearest neighbours , type index, INIONS )
           INTEGER, INTENT( INOUT ) :: NNEIB_EST2( :, : )
           !> norm of connection vector  ( neighbor number , type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: NORMALIZATION_XYZ2( :, : , : )
           !> connection vector  ( neighbor number , xyz, type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: XYZ_EST2( :, : , :, : )
           !> normalized connection vector  ( neighbor number , xyz, type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: XYZ_EST2_NORM( :, : , :, : )
           Real( q ), INTENT( IN ) ::W2

           ! definitions of local variables
           INTEGER :: INIONS_TMP
           INTEGER :: INIONS
           INTEGER :: LOCVAR_COL



           DO INIONS_TMP = 1, NIONS, NCPU
              INIONS = INIONS_TMP + NODE_ME
              IF ( INIONS .LE. NIONS ) THEN
                 LOCVAR_COL = CEILING( REAL( INIONS , q ) / REAL( NCPU, q ) )
                 IF ( W1 .gt. 0.0_q ) then
                    CALL UPDATE_SINGLE_NEAREST_NEIGHBOR_ARRAY( NEAREST_NEIGHBOR_RADIAL%NN_LIST( INIONS ), &
                                                               LNIONS_EST1( :, :, LOCVAR_COL ), &
                                                               NNEIB_EST1( :, LOCVAR_COL ), &
                                                               NORMALIZATION_XYZ1( :, :, LOCVAR_COL ), &
                                                               XYZ_EST1( :, :, :, LOCVAR_COL ), &
                                                               XYZ_EST1_NORM( :, :, :, LOCVAR_COL ),&
                                                               LNTYP( INIONS ),&
                                                               INIONS )
                 END IF
                 IF ( W2 .gt. 0.0_q ) then
                    CALL UPDATE_SINGLE_NEAREST_NEIGHBOR_ARRAY( NEAREST_NEIGHBOR_ANGULAR%NN_LIST( INIONS ), &
                                                               LNIONS_EST2( :, :, LOCVAR_COL ), &
                                                               NNEIB_EST2( :, LOCVAR_COL ), &
                                                               NORMALIZATION_XYZ2( :, :, LOCVAR_COL ), &
                                                               XYZ_EST2( :, :, :, LOCVAR_COL ), &
                                                               XYZ_EST2_NORM( :, :, :, LOCVAR_COL ),&
                                                               LNTYP( INIONS ),&
                                                               INIONS )
                 END IF 
              END IF
           END DO

        END SUBROUTINE UPDATE_NEAREST_NEIGHBOR_ARRAYS



        SUBROUTINE UPDATE_SINGLE_NEAREST_NEIGHBOR_ARRAY( NEAREST_NEIGHBOR_LIST, &
                                                         LNIONS_EST, &        
                                                         NNEIB_EST, &         
                                                         NORMALIZATION_XYZ, & 
                                                         XYZ_EST, & 
                                                         XYZ_EST_NORM,&
                                                         INTYP0,&
                                                         INIONS )
           USE NEIGHBOR_LIST_MOD, ONLY : NEIGHBOR_LIST_TYPE
           IMPLICIT NONE
           !> nearest neighbor object for descriptor
           TYPE( NEIGHBOR_LIST_TYPE ), INTENT( INOUT ) :: NEAREST_NEIGHBOR_LIST
           !> (index pointing to POSION, type index, INIONS )
           INTEGER, INTENT( INOUT ) :: LNIONS_EST( :, : )
           !> number nearest neighbours , type index, INIONS )
           INTEGER, INTENT( INOUT ) :: NNEIB_EST( : )
           !> norm of connection vector  ( neighbor number , type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: NORMALIZATION_XYZ( :, : )
           !> connection vector  ( neighbor number , xyz, type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: XYZ_EST( :, : , : )
           !> normalized connection vector  ( neighbor number , xyz, type index, INIONS )
           REAL( q ), INTENT( INOUT ) :: XYZ_EST_NORM( :, : , : )
           !> ion type of central ion
           INTEGER, INTENT( IN ) :: INTYP0
           !> ion number in POSION array
           INTEGER, INTENT( IN ) :: INIONS


           ! index of nearest neighbor
           INTEGER :: INN
           INTEGER :: JNIONS
           INTEGER :: JNTYP0


           LNIONS_EST      = 0
           NNEIB_EST       = 0
           XYZ_EST         = 0.0_q
           XYZ_EST_NORM    = 0.0_q


           LNIONS_EST( 1, INTYP0 )        =  INIONS
           XYZ_EST( 1, 1:3, INTYP0 )      =  0.0_q
           XYZ_EST_NORM( 1, 1:3, INTYP0 ) =  0.0_q

           DO INN =1 , SIZE( NEAREST_NEIGHBOR_LIST%NEIGHBORS )
              JNIONS = NEAREST_NEIGHBOR_LIST%NEIGHBORS( INN )
              JNTYP0 = NEAREST_NEIGHBOR_LIST%NEIGHBORS_TYPES( INN )
              ! update nearest neighbor list 
              NNEIB_EST( JNTYP0 ) = NNEIB_EST( JNTYP0 ) + 1
              LNIONS_EST( NNEIB_EST( JNTYP0 ) + 1, JNTYP0 ) = JNIONS
              ! update norm of connection vector
              NORMALIZATION_XYZ( NNEIB_EST( JNTYP0 ) + 1, JNTYP0 ) = &
                       NEAREST_NEIGHBOR_LIST%NEIGHBOR_DIST( INN )
              
              ! update normed connection vector
              XYZ_EST_NORM(NNEIB_EST( JNTYP0 ) + 1, 1, JNTYP0 )= &
                           -NEAREST_NEIGHBOR_LIST%NEIGHBOR_CONNECT( 1 , INN )
              XYZ_EST_NORM(NNEIB_EST( JNTYP0 ) + 1, 2, JNTYP0 )= &
                           -NEAREST_NEIGHBOR_LIST%NEIGHBOR_CONNECT( 2 , INN )
              XYZ_EST_NORM(NNEIB_EST( JNTYP0 ) + 1, 3, JNTYP0 )= &
                           -NEAREST_NEIGHBOR_LIST%NEIGHBOR_CONNECT( 3 , INN )
              
              ! update connection vector
              XYZ_EST( NNEIB_EST( JNTYP0 ) + 1, 1, JNTYP0) = &
                        -NEAREST_NEIGHBOR_LIST%NEIGHBOR_CONNECT( 1 , INN ) * &
                               NEAREST_NEIGHBOR_LIST%NEIGHBOR_DIST( INN )
              XYZ_EST( NNEIB_EST( JNTYP0 ) + 1, 2, JNTYP0) = &
                        -NEAREST_NEIGHBOR_LIST%NEIGHBOR_CONNECT( 2 , INN ) * &
                               NEAREST_NEIGHBOR_LIST%NEIGHBOR_DIST( INN )
              XYZ_EST( NNEIB_EST( JNTYP0 ) + 1, 3, JNTYP0) = &
                        -NEAREST_NEIGHBOR_LIST%NEIGHBOR_CONNECT( 3 , INN ) * &
                               NEAREST_NEIGHBOR_LIST%NEIGHBOR_DIST( INN )
           END DO

        END SUBROUTINE UPDATE_SINGLE_NEAREST_NEIGHBOR_ARRAY

      END MODULE FORCE_FIELD
#endif
