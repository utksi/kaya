#define Zmethod3
#include "symbol.inc"
!***********************************************************************
!***********************************************************************
!
!***********************************************************************
!***********************************************************************

  MODULE setxcmeta
    USE prec

    INTEGER, SAVE :: ID_METAGGA=-1

    LOGICAL, SAVE :: LDOMETAGGA=.FALSE.

    LOGICAL, SAVE :: LMETA_NEEDS_POT=.FALSE.
    LOGICAL, SAVE :: LMETA_NEEDS_MU=.FALSE.
    LOGICAL, SAVE :: LMETA_NEEDS_LAP=.FALSE.

    INTEGER, SAVE :: LMAXTAU=6

    LOGICAL, SAVE :: LMIXTAU=.FALSE.

    ! MBJ related constants and variables
    LOGICAL, SAVE :: LMETA_SC_CMBJ=.FALSE.
    REAL(q), SAVE :: CMBJ=-1,CMBJA,CMBJB,CMBJE
    REAL(q),ALLOCATABLE, SAVE :: CMBJ_TYP(:)
    RGRID, ALLOCATABLE, SAVE  :: CMBJ_AUX(:)      ! grid quantity, usually stores C values for MBJ
    REAL(q),ALLOCATABLE, SAVE :: CMBJ_AUG(:)         ! TR: CMBJ averaged in each atomic sphere
    REAL(q),ALLOCATABLE, SAVE :: WEIGHT_AUG_AUG(:,:) ! TR: weights for averaging over aug. spheres
    REAL(q),ALLOCATABLE, SAVE :: WEIGHT_AUG_PW(:,:)  ! TR: weights for averaging over grid points
    REAL(q),ALLOCATABLE, SAVE :: NORM_AUG_PW(:)  ! TR: norm of weights
    REAL(q),ALLOCATABLE, SAVE :: NORM_PW_AUG(:)  ! TR: norm of weights
    REAL(q),ALLOCATABLE, SAVE :: NORM_AUG_AUG(:) ! TR: norm of weights
    REAL(q),ALLOCATABLE, SAVE :: SCA_VAC(:)      ! TR: scaling factor for vacuum
    REAL(q), SAVE :: VACRAT = 0.0_q  ! TR: ratio of the vacuum over the whole volume, calculated selfconsistently
    REAL(q), SAVE :: GRHO_OVER_RHO_PW         = 0.0_q
    REAL(q), SAVE :: GRHO_OVER_RHO_ONE_CENTER = 0.0_q
    REAL(q),ALLOCATABLE, SAVE :: GRHO_OVER_RHO_AUG(:)   ! TR: for averages in each atomic sphere
    REAL(q), SAVE :: SMBJ = 2.0_q  ! spread of the Gaussian in Angstrom
    REAL(q), SAVE :: RSMBJ = 7.0_q ! density threshold for PAW contribution against vacuum in bohr
    REAL(q), SAVE :: MBJ_SMALL = 1.E-8_q    ! "SMALL" value where to cut RHO

    ! MSx related variables
    REAL(q), SAVE :: MSX_RKAPPA,MSX_CFC,MSX_CFE

    ! SCAN, rSCAN (and rSCANZT) related variables
    REAL(q), SAVE :: SCAN_TAUREG_X = 0.0_q
    REAL(q), SAVE :: SCAN_TAUREG_C = 0.0_q
    REAL(q), SAVE :: SCAN_ALPREG   = 0.0_q

    ! internal index of the LL-SCAN family of functionals
    INTEGER, SAVE :: IDSCAN

    !fraction of meta-GGA exchange and correlation
    REAL(q), SAVE :: AMGGAX = 1._q
    REAL(q), SAVE :: AMGGAC = 1._q

!$ACC DECLARE CREATE(CMBJ,CMBJ_TYP,CMBJ_AUX,ID_METAGGA,LMETA_SC_CMBJ,GRHO_OVER_RHO_PW,MSX_RKAPPA, &
!$ACC MSX_CFE,MSX_CFC,SCAN_TAUREG_X,SCAN_TAUREG_C,SCAN_ALPREG,IDSCAN,MBJ_SMALL,AMGGAX,AMGGAC)

    CONTAINS

      SUBROUTINE XC_META_READER(IO,NTYP,ICHARG,LASPH)
      USE prec
      USE base
      USE setexm
      USE vaspxml
      USE reader_tags
      USE tutor, ONLY: vtutor
      USE fock_glb, ONLY : AEXX,LHFCALC

      IMPLICIT NONE
      TYPE (in_struct) IO
      INTEGER NTYP
      INTEGER ICHARG
      INTEGER IFUNC
      LOGICAL LASPH
      ! local variables
      INTEGER N, IERR
      LOGICAL LOPEN
      CHARACTER (1) CHARAC
      CHARACTER (40) SZNAM

      CALL OPEN_INCAR_IF_FOUND(IO%IU5,LOPEN)

      SZNAM='--'
      CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'METAGGA', SZNAM, 40, IERR, WRITEXMLINCAR)

      CALL STRIP(SZNAM,N,'L'); CALL UPPER(SZNAM)
      SZNAM=TRIM(ADJUSTL(SZNAM))

      IF (SZNAM=='--') THEN
         ID_METAGGA=-1
      ELSEIF (SZNAM=='PKZB') THEN
         ID_METAGGA=10
      ELSEIF (SZNAM=='RTPSS') THEN
         ID_METAGGA=20
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
      ELSEIF (SZNAM=='TPSS') THEN
         ID_METAGGA=25
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
      ELSEIF (SZNAM=='MBJ') THEN
         ID_METAGGA=30
         LMETA_NEEDS_POT=.TRUE.
      ELSEIF (SZNAM=='LMBJ') THEN
         ID_METAGGA=31
         LMETA_NEEDS_POT=.TRUE.
      ELSEIF (SZNAM=='M06L') THEN
         ID_METAGGA=35
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
      ELSEIF (SZNAM=='MS0') THEN
         ID_METAGGA=40
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
         MSX_RKAPPA=0.29_q
         MSX_CFC=0.28771_q
         MSX_CFE=1.0_q
      ELSEIF (SZNAM=='MS1') THEN
         ID_METAGGA=41
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
         MSX_RKAPPA=0.404_q
         MSX_CFC=0.18150_q
         MSX_CFE=1.0_q
      ELSEIF (SZNAM=='MS2') THEN
         ID_METAGGA=42
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
         MSX_RKAPPA=0.504_q
         MSX_CFC=0.14601_q
         MSX_CFE=4.0_q
      ELSEIF (SZNAM=='RSCANZT') THEN
         ID_METAGGA=51
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
!!       SCAN_TAUREG_X=0.0001_q**(2._q**(5._q/3._q))
         SCAN_TAUREG_X=1.998902376E-13_q
         SCAN_TAUREG_C=0.0001_q
         SCAN_ALPREG=0.001_q
      ELSEIF (SZNAM=='RSCAN') THEN
         ID_METAGGA=51
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
         SCAN_TAUREG_X=0.0001_q
         SCAN_TAUREG_C=0.0001_q
         SCAN_ALPREG=0.001_q
      ELSEIF (SZNAM=='R2SCAN') THEN
         ID_METAGGA=52
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
      ELSEIF (SZNAM=='SCAN') THEN
         ID_METAGGA=50
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
      ELSEIF (SZNAM=='SCANL') THEN
         ID_METAGGA=61
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_LAP=.TRUE.
         IDSCAN=0
      ELSEIF (SZNAM=='RSCANL') THEN
         ID_METAGGA=62
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_LAP=.TRUE.
         IDSCAN=1
      ELSEIF (SZNAM=='R2SCANL') THEN
         ID_METAGGA=63
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_LAP=.TRUE.
         IDSCAN=3
      ELSEIF (SZNAM=='OFR2') THEN
         ID_METAGGA=64
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_LAP=.TRUE.
         IDSCAN=3
#ifdef USELIBXC
      ELSEIF (SZNAM=='LIBXC') THEN
         ID_METAGGA=99
         LMETA_NEEDS_POT=.TRUE.
         LMETA_NEEDS_MU=.TRUE.
         DO IFUNC=1, 2
            IF (LIBXC_MASK(IFUNC)>0) THEN
               IF (IAND(XC_F03_FUNC_INFO_GET_FLAGS(LIBXC_INFO_NSP(IFUNC)),XC_FLAGS_NEEDS_LAPLACIAN)==XC_FLAGS_NEEDS_LAPLACIAN) LMETA_NEEDS_LAP=.TRUE.
            ENDIF
         ENDDO
#endif
      ELSEIF (SZNAM=='PBE') THEN
         ID_METAGGA=999
         LMETA_NEEDS_POT=.TRUE.
      ELSEIF (SZNAM/='--') THEN
         CALL vtutor%error("Error: This functional is not implemented.")
      ENDIF

      IF (ID_METAGGA/=-1) LDOMETAGGA=.TRUE.

      ! additional tags for MBJ
      IF ((ID_METAGGA==30).OR.(ID_METAGGA==31)) THEN
         CMBJ=-1
         ALLOCATE(CMBJ_TYP(NTYP))
         CMBJ_TYP=-1
         ! read array of constants, if one value is provided array is initialized as constant
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'CMBJ', CMBJ_TYP, NTYP, IERR, &
            WRITEXMLINCAR, FOUNDNUMBER=N, LCONTINUE = .TRUE. )
         CMBJ=CMBJ_TYP(1)
         IF (N<NTYP .OR. N==1 ) THEN
            CMBJ_TYP=-1
         ENDIF
         ! If CMBJ is not set then it will be calculated (default)
         IF (CMBJ < 0._q) THEN
            LMETA_SC_CMBJ=.TRUE.
            CMBJ=-CMBJ
            CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'SMBJ', SMBJ, IERR, WRITEXMLINCAR)
            CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'RSMBJ', RSMBJ, IERR, WRITEXMLINCAR)
            CMBJA=-0.012_q
            IF (ID_METAGGA==31) CMBJA=0.488_q
! fixme[vasp]: shouldnt NTYP == 1 since scalar
            CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'CMBJA', CMBJA, IERR, WRITEXMLINCAR)
            CMBJB=1.023_q
            IF (ID_METAGGA==31) CMBJB=0.5_q
! fixme[vasp]: shouldnt NTYP == 1 since scalar
            CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'CMBJB', CMBJB, IERR, WRITEXMLINCAR)
            CMBJE=0.5_q
            IF (ID_METAGGA==31) CMBJE=1._q
            CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'CMBJE', CMBJE, IERR, WRITEXMLINCAR)
         ENDIF
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'MBJ_SMALL', MBJ_SMALL, IERR, WRITEXMLINCAR)
      ENDIF

      IF (LHFCALC) THEN
         AMGGAX=1-AEXX
         IF (AEXX==1.0) AMGGAC=0.0_q ! for HF type calculations and full exchange, no correlation is usually included
      ENDIF
      CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'AMGGAX', AMGGAX, IERR, WRITEXMLINCAR, FOUNDNUMBER=N)
      IF ((.NOT.LDOMETAGGA).AND.(N>=1)) CALL vtutor%error("Error: AMGGAX can not be specified for a GGA.")
      CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'AMGGAC', AMGGAC, IERR, WRITEXMLINCAR, FOUNDNUMBER=N)
      IF ((.NOT.LDOMETAGGA).AND.(N>=1)) CALL vtutor%error("Error: AMGGAC can not be specified for a GGA.")

      IF (LDOMETAGGA) THEN
         AGGAX=AMGGAX
         ALDAX=AMGGAX
         AGGAC=AMGGAC
         ALDAC=AMGGAC
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'AGGAX', AGGAX, IERR, WRITEXMLINCAR, FOUNDNUMBER=N)
         IF (N>=1) CALL vtutor%error("Error: AGGAX can not be specified for a METAGGA.")
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'ALDAX', ALDAX, IERR, WRITEXMLINCAR, FOUNDNUMBER=N)
         IF (N>=1) CALL vtutor%error("Error: ALDAX can not be specified for a METAGGA.")
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'AGGAC', AGGAC, IERR, WRITEXMLINCAR, FOUNDNUMBER=N)
         IF (N>=1) CALL vtutor%error("Error: AGGAC can not be specified for a METAGGA.")
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'ALDAC', ALDAC, IERR, WRITEXMLINCAR, FOUNDNUMBER=N)
         IF (N>=1) CALL vtutor%error("Error: ALDAC can not be specified for a METAGGA.")
      ENDIF

#ifdef USELIBXC
      LIBXC_AMGGAXC=1._q
      DO IFUNC=1,2
         IF (LIBXC_MASK(IFUNC)>0) THEN
            IF ((XC_KIND(IFUNC).EQ.XC_EXCHANGE).AND.(.NOT.LIBXC_HYB(IFUNC))) THEN
               LIBXC_AMGGAXC(IFUNC)=AMGGAX
            ELSEIF ((XC_KIND(IFUNC).EQ.XC_CORRELATION).AND.(.NOT.LIBXC_HYB(IFUNC))) THEN
               LIBXC_AMGGAXC(IFUNC)=AMGGAC
            ENDIF
         ENDIF
      ENDDO
#endif

! for meta-GGAs LASPH=.TRUE. is quasi a must, write out a warning to this effect.
      IF ( LDOMETAGGA .AND. .NOT.LASPH ) CALL vtutor%warning(&
         "For meta-GGA calculations it is strongly recommended to include aspherical&
        & contributions to the potential inside the PAW spheres (set LASPH = .TRUE.)")

      IF (LASPH) THEN
         LMAXTAU=6
         CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'LMAXTAU', LMAXTAU, IERR, WRITEXMLINCAR)
      ELSE
         LMAXTAU=0
      ENDIF

      LMIXTAU=.FALSE.
      CALL PROCESS_INCAR(LOPEN, IO%IU0, IO%IU5, 'LMIXTAU', LMIXTAU, IERR, WRITEXMLINCAR)

      CALL CLOSE_INCAR_IF_FOUND(IO%IU5)

      IF ( LDOMETAGGA .AND. ICHARG >= 10 ) THEN
         CALL vtutor%error(&
         "ICHARG>9 is currently not supported for meta-GGA functionals.&
        & In case you want to calculate band structures with a meta-GGA,&
        & use the same method as proposed for hybrid functionals.")
      ENDIF
      ! Write to OUTCAR
      IF (IO%IU6>=0 .AND. LDOMETAGGA) THEN
         WRITE(IO%IU6,'(/X,A,X,A,4X,A,I3,4X,A,L3)',ADVANCE="No") 'METAGGA =',SZNAM,'LMAXTAU =',LMAXTAU,'LMIXTAU =',LMIXTAU
         IF ((ID_METAGGA==30).OR.(ID_METAGGA==31)) THEN
            IF (CMBJ_TYP(1)==-1) THEN
               WRITE(IO%IU6,'(4X,A,F10.4/)') 'CMBJ  =',CMBJ
               WRITE(IO%IU6,'(4X,A,F10.4/)') 'CMBJA =',CMBJA
               WRITE(IO%IU6,'(4X,A,F10.4/)') 'CMBJB =',CMBJB
               WRITE(IO%IU6,'(4X,A,F10.4/)') 'CMBJE =',CMBJE
               IF (ID_METAGGA==31) THEN
                  WRITE(IO%IU6,'(4X,A,F10.4/)') 'SMBJ  =',SMBJ
                  WRITE(IO%IU6,'(4X,A,F10.4/)') 'RSMBJ =',RSMBJ
               ENDIF
            ELSE
               WRITE(IO%IU6,'(4X,A,20F10.4/)') 'CMBJ =',CMBJ_TYP
            ENDIF
         ELSE
            WRITE(IO%IU6,'(/)')
         ENDIF
      ENDIF
!$ACC UPDATE DEVICE(CMBJ_TYP,CMBJ,ID_METAGGA,LMETA_SC_CMBJ,MSX_RKAPPA,MSX_CFE,MSX_CFC, &
!$ACC& SCAN_TAUREG_X,SCAN_TAUREG_C,SCAN_ALPREG,IDSCAN,AMGGAX,AMGGAC)

      RETURN
      END SUBROUTINE XC_META_READER


!***********************************************************************
!
!***********************************************************************

      SUBROUTINE GET_CMBJ_PW(I,CVMBJ)
!$ACC ROUTINE SEQ
      REAL(q) CVMBJ
      INTEGER I
      IF ((ID_METAGGA==30).OR.(ID_METAGGA==31)) THEN
         IF(CMBJ_TYP(1)/=-1 .OR. ID_METAGGA==31) CVMBJ=CMBJ_AUX(I)
      ENDIF
      RETURN
      END SUBROUTINE GET_CMBJ_PW


!***********************************************************************
!
!***********************************************************************

      SUBROUTINE GET_CMBJ_RAD(N,CVMBJ)
      REAL(q) CVMBJ
      INTEGER N
      IF (LDOMETAGGA.AND.(ID_METAGGA==30.OR.ID_METAGGA==31)) THEN
         IF (CMBJ_TYP(1)/=-1) CVMBJ=CMBJ_TYP(N)
         IF (ID_METAGGA==31) CVMBJ=CMBJ_AUG(N)
      ENDIF
      RETURN
      END SUBROUTINE GET_CMBJ_RAD


!***********************************************************************
!
!***********************************************************************
      FUNCTION LscMBJ()
!$ACC ROUTINE SEQ
      IMPLICIT NONE
      LOGICAL LscMBJ
      LscMBJ=LMETA_SC_CMBJ
      END FUNCTION LscMBJ


!***********************************************************************
!
!***********************************************************************
      SUBROUTINE SUM_GRHO_OVER_RHO_PW(RHO,GRHO)
!$ACC ROUTINE SEQ
      USE prec
      REAL(q) RHO,GRHO
!$ACC ATOMIC UPDATE
      GRHO_OVER_RHO_PW=GRHO_OVER_RHO_PW+GRHO/RHO
      RETURN
      END SUBROUTINE SUM_GRHO_OVER_RHO_PW



!***********************************************************************
!***********************************************************************
  END MODULE setxcmeta
!***********************************************************************
!***********************************************************************


!***********************************************************************
!***********************************************************************
!
!***********************************************************************
!***********************************************************************

  MODULE metalib
    USE prec
    USE constant
    USE setxcmeta

    PRIVATE :: IR_MATCH,IR_PSMAX

    CONTAINS

      SUBROUTINE METAGGASPIN(&
     &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,LAPLUP,LAPLDW,TAUUP,TAUDW, &
     &   EXC,dEXCdRHOup,dEXCdRHOdw,dEXCdABSNABup,dEXCdABSNABdw,dEXCdABSNAB, &
     &   dEXCdTAUup,dEXCdTAUdw,dEXCdLAPup,dEXCdLAPdw,CVMBJ)
!$ACC ROUTINE SEQ
      USE xclib
#ifdef USELIBXC
      USE xc_f03_lib_m
      USE setexm_struct_def, ONLY : XC_FAMILY,LIBXC_FUNC_SPN,LIBXC_MASK,LTBOUNDLIBXC,LIBXC_NOEXC, &
     &   LIBXC_FAMILY_UNKNOWN,LIBXC_FAMILY_NONE,LIBXC_FAMILY_LDA,LIBXC_FAMILY_GGA, &
     &   LIBXC_FAMILY_MGGA,LIBXC_FAMILY_LCA,LIBXC_FAMILY_OEP,LIBXC_FAMILY_HYB_GGA, &
     &   LIBXC_FAMILY_HYB_MGGA,LIBXC_FAMILY_HYB_LDA,LIBXC_AMGGAXC
#endif
      IMPLICIT NONE
      REAL(q) RHOUP,RHODW
      REAL(q) ABSNABUP,ABSNABDW,ABSNAB
      REAL(q) LAPLUP,LAPLDW
      REAL(q) TAUUP,TAUDW

      REAL(q) EXC
      REAL(q) dEXCdRHOup,dEXCdRHOdw
      REAL(q) dEXCdABSNABup,dEXCdABSNABdw,dEXCdABSNAB
      REAL(q) dEXCdTAUup,dEXCdTAUdw
      REAL(q) dEXCdLAPup,dEXCdLAPdw

      REAL(q) CVMBJ

      ! local variables
      REAL(q) EXL,ECL
      REAL(q) Ex_TPSS,Ec_TPSS
      REAL(q) Ex_revTPSS,Ec_revTPSS
      REAL(q) Ex_SCAN,Ec_SCAN
      REAL(q) Ex_M06,Ec_M06
      REAL(q) Ex_MSX,Ec_MSX
      REAL(q) VXD1,VXD2,VXDD1,VXDD2,AMUXD1,AMUXD2
      REAL(q) VCD1,VCD2,VCDD1,VCDD2,AMUCD1,AMUCD2
      REAL(q) VCDD12

      ! VMBJ related variables
      REAL(q), PARAMETER :: THRD=1._q/3._q
      REAL(q) D,DTHRD,RS,ZETA
      REAL(q) ECLDA,ECD1LDA,ECD2LDA,EC,ECD1,ECD2,ECQ

      ! for PBE
      REAL(q) FK,G,S,SK,T
      REAL(q) EXLDA1,EXC1,EXDLDA1,EXCD1,EXCQ1,EXLDA2,EXC2,EXDLDA2,EXCD2,EXCQ2

#ifdef USELIBXC
      INTEGER :: IFUNC
      REAL(q) :: XC_DENS(2),XC_SIGMA(3),XC_TAU(2),XC_LAPL(2),TAUWUP,TAUWDW
      REAL(q) :: XC_EXC(1),XC_VRHO(2),XC_VSIGMA(3),XC_VTAU(2),XC_VLAPL(2)
#endif

!$ACC ROUTINE(EPKZB,VrevTPSSx,VrevTPSSc,VTPSSx,VTPSSc,VMBJ_PROYNOV,CORPBE, &
!$ACC& VM06x,VM06c,VMSXx,VMSXc,VSCANx,VSCANc,VR2SCANx,VR2SCANc,scan_orb_free_xc,EXCHPBE) SEQ
#ifdef USELIBXC
!$ACC ROUTINE(XC_F03_LDA_VXC,XC_F03_LDA_EXC_VXC,XC_F03_GGA_VXC,XC_F03_GGA_EXC_VXC, &
!$ACC& XC_F03_MGGA_VXC,XC_F03_MGGA_EXC_VXC) SEQ
#endif

      EXC=0
      dEXCdRHOup=0; dEXCdRHOdw=0
      dEXCdABSNABup=0; dEXCdABSNABdw=0; dEXCdABSNAB=0
      dEXCdTAUup=0; dEXCdTAUdw=0
      dEXCdLAPup=0; dEXCdLAPdw=0

      IF (ID_METAGGA==-1) THEN
      ! Just a stub, no metaGGA requested
      ELSEIF (ID_METAGGA==10) THEN
      ! PKZB
         CALL EPKZB(RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
        &   EXL,ECL)
         EXC=(AMGGAX*EXL+AMGGAC*ECL)/(RHOUP+RHODW)
         ! from Hartree to Rydberg
         EXC=EXC*2
      ELSEIF (ID_METAGGA==20) THEN
      ! revTPSS
         ! Exchange
         CALL VrevTPSSx(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ex_revTPSS,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)

         ! Correlation
         CALL VrevTPSSc(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ec_revTPSS,VCD1,VCDD1,VCD2,VCDD2,VCDD12,AMUCD1,AMUCD2)

         ! Sum everything
         EXC=(AMGGAX*Ex_revTPSS+AMGGAC*Ec_revTPSS)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1+AMGGAC*VCDD1
         dEXCdABSNABdw=AMGGAX*VXDD2+AMGGAC*VCDD2
         dEXCdABSNAB=AMGGAC*VCDD12
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdABSNAB=dEXCdABSNAB*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF (ID_METAGGA==25) THEN
      ! TPSS
         ! Exchange
         CALL VTPSSx(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ex_TPSS,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)

         ! Correlation
         CALL VTPSSc(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ec_TPSS,VCD1,VCDD1,VCD2,VCDD2,VCDD12,AMUCD1,AMUCD2)

         ! Sum everything
         EXC=(AMGGAX*Ex_TPSS+AMGGAC*Ec_TPSS)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1+AMGGAC*VCDD1
         dEXCdABSNABdw=AMGGAX*VXDD2+AMGGAC*VCDD2
         dEXCdABSNAB=AMGGAC*VCDD12
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdABSNAB=dEXCdABSNAB*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF ((ID_METAGGA==30).OR.(ID_METAGGA==31)) THEN
      ! MBJ

         CALL VMBJ_PROYNOV(RHOUP,ABSNABUP,LAPLUP,2._q*TAUUP,CVMBJ,dEXCdRHOup)
         CALL VMBJ_PROYNOV(RHODW,ABSNABDW,LAPLDW,2._q*TAUDW,CVMBJ,dEXCdRHOdw)

         ! get the LDA correlation potential (using a call to CORPBE)
         D=RHOUP+RHODW
         DTHRD=exp(log(D)*THRD)
         RS=(0.75_q/PI)**THRD/DTHRD
         ZETA=(RHOUP-RHODW)/D
         ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)

         CALL CORPBE(RS,ZETA,ECLDA,ECD1LDA,ECD2LDA,0._q,0._q,0._q,EC,ECD1,ECD2,ECQ,.FALSE.)

         ! add the LDA correlation potential
         dEXCdRHOup=dEXCdRHOup+ECD1LDA
         dEXCdRHOdw=dEXCdRHOdw+ECD2LDA

         ! from Hartree to Rydberg
         dEXCdRHOup=dEXCdRHOup*2._q
         dEXCdRHOdw=dEXCdRHOdw*2._q

         ! LDA exchange-correlation energy
         EXC=2._q*ECLDA+0.5_q*EX((0.75_q/PI)**THRD/RHOUP**THRD,2,.TRUE.)+0.5_q*EX((0.75_q/PI)**THRD/RHODW**THRD,2,.TRUE.)
      ELSEIF (ID_METAGGA==35) THEN
      ! M06-L
         ! Exchange
         CALL VM06x(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ex_M06,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2,1)

         ! Correlation
         CALL VM06c(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ec_M06,VCD1,VCDD1,VCD2,VCDD2,AMUCD1,AMUCD2,1)

         ! Sum everything
         EXC=(AMGGAX*Ex_M06+AMGGAC*Ec_M06)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1+AMGGAC*VCDD1
         dEXCdABSNABdw=AMGGAX*VXDD2+AMGGAC*VCDD2
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF (ID_METAGGA==40.OR.ID_METAGGA==41.OR.ID_METAGGA==42) THEN
      ! revTPSS
         ! Exchange
         CALL VMSXx(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ex_MSX,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)

         ! Correlation
         CALL VMSXc(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ec_MSX,VCD1,VCD2,VCDD12,AMUCD1,AMUCD2)

         ! Sum everything
         EXC=(AMGGAX*Ex_MSX+AMGGAC*Ec_MSX)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1
         dEXCdABSNABdw=AMGGAX*VXDD2
         dEXCdABSNAB=AMGGAC*VCDD12
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdABSNAB=dEXCdABSNAB*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF (ID_METAGGA==50) THEN
      ! SCAN
         ! Exchange
         CALL VSCANx(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ex_SCAN,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)

         ! Correlation
         CALL VSCANc(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ec_SCAN,VCD1,VCD2,VCDD12,AMUCD1,AMUCD2)

         ! Sum everything
         EXC=(AMGGAX*Ex_SCAN+AMGGAC*Ec_SCAN)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1
         dEXCdABSNABdw=AMGGAX*VXDD2
         dEXCdABSNAB=AMGGAC*VCDD12
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdABSNAB=dEXCdABSNAB*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF (ID_METAGGA==51) THEN
      ! rSCAN (and rSCANZT)
         ! Exchange
         CALL VSCANx(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ex_SCAN,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)

         ! Correlation
         CALL VSCANc(&
       &   RHOUP,RHODW,ABSNABUP,ABSNABDW,ABSNAB,TAUUP,TAUDW, &
       &   Ec_SCAN,VCD1,VCD2,VCDD12,AMUCD1,AMUCD2)

         ! Sum everything
         EXC=(AMGGAX*Ex_SCAN+AMGGAC*Ec_SCAN)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1
         dEXCdABSNABdw=AMGGAX*VXDD2
         dEXCdABSNAB=AMGGAC*VCDD12
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdABSNAB=dEXCdABSNAB*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF (ID_METAGGA==52) THEN
      ! r^2SCAN
         ! Exchange
         Ex_SCAN = 0.0_q
         CALL VR2SCANx(RHOUP,ABSNABUP,TAUUP,EX_SCAN,VXD1,VXDD1,AMUXD1)
         CALL VR2SCANx(RHODW,ABSNABDW,TAUDW,EX_SCAN,VXD2,VXDD2,AMUXD2)

         ! Correlation
         CALL VR2SCANc(RHOUP,RHODW,ABSNAB,TAUUP,TAUDW,Ec_SCAN,VCD1,VCD2,&
      &                VCDD12,AMUCD1,AMUCD2)

         ! Sum everything
         EXC=(AMGGAX*Ex_SCAN+AMGGAC*Ec_SCAN)/(RHOUP+RHODW)
         dEXCdRHOup=AMGGAX*VXD1+AMGGAC*VCD1
         dEXCdRHOdw=AMGGAX*VXD2+AMGGAC*VCD2
         dEXCdABSNABup=AMGGAX*VXDD1
         dEXCdABSNABdw=AMGGAX*VXDD2
         dEXCdABSNAB=AMGGAC*VCDD12
         dEXCdTAUup=AMGGAX*AMUXD1+AMGGAC*AMUCD1
         dEXCdTAUdw=AMGGAX*AMUXD2+AMGGAC*AMUCD2
         ! from Hartree to Rydberg
         EXC=EXC*2
         dEXCdRHOup=dEXCdRHOup*2
         dEXCdRHOdw=dEXCdRHOdw*2
         dEXCdABSNABup=dEXCdABSNABup*2
         dEXCdABSNABdw=dEXCdABSNABdw*2
         dEXCdABSNAB=dEXCdABSNAB*2
         dEXCdTAUup=dEXCdTAUup*2
         dEXCdTAUdw=dEXCdTAUdw*2
      ELSEIF (ID_METAGGA==61.OR.ID_METAGGA==62.OR.ID_METAGGA==63.OR.ID_METAGGA==64) THEN
        ! Deorbitalized functionals using tau from Mejia-Rodriguez and Trickey:
        ! id_metagga = 61: SCAN-L
        ! id_metagga = 62: rSCAN-L
        ! id_metagga = 63: r2 SCAN-L
        ! Deorbitalized functional using tau from Kaplan-Perdew:
        ! id_metagga = 64: OF - r2 SCAN

        call scan_orb_free_xc((id_metagga==64),rhoup,rhodw,absnabup,absnabdw,absnab,&
        &  LAPLUP,LAPLDW,EXC,dEXCdRHOup,dEXCdRHOdw,dEXCdABSNABup,dEXCdABSNABdw, &
        &  dEXCdABSNAB,dEXCdLAPup,dEXCdLAPdw)

       ! from Hartree to Rydberg
       EXC=EXC*2 ! factor of 1/(rhoup + rhodw) already accounted for in subroutine
       dEXCdRHOup=dEXCdRHOup*2
       dEXCdRHOdw=dEXCdRHOdw*2
       dEXCdABSNABup=dEXCdABSNABup*2 ! here, because tau(n,grad n, lap n) only depends upon
       dEXCdABSNABdw=dEXCdABSNABdw*2 ! grad n_sigma, and not grad n, we need to add the appropriate derivs
       dEXCdABSNAB=dEXCdABSNAB*2 ! SCAN Ec depends on |grad n|
       dEXCdLAPup=dEXCdLAPup*2
       dEXCdLAPdw=dEXCdLAPdw*2
#ifdef USELIBXC
      ELSEIF (ID_METAGGA==99) THEN

         XC_DENS(1) = max(RHOUP, 1.0e-10_q)
         XC_DENS(2) = max(RHODW, 1.0e-10_q)

         ABSNABUP = max(min(ABSNABUP, 5.0e9_q), 1.0e-10_q)
         ABSNABDW = max(min(ABSNABDW, 5.0e9_q), 1.0e-10_q)
         ABSNAB = max(min(ABSNAB, 1.0e10_q), 2.0e-10_q)
         XC_SIGMA(1) = ABSNABUP*ABSNABUP
         XC_SIGMA(2) = 0.5_q*(ABSNAB*ABSNAB - ABSNABUP*ABSNABUP - ABSNABDW*ABSNABDW)
         XC_SIGMA(3) = ABSNABDW*ABSNABDW

         XC_TAU(1) = max(min(TAUUP, 5.0e9_q), 1.0e-10_q)
         XC_TAU(2) = max(min(TAUDW, 5.0e9_q), 1.0e-10_q)
         IF (LTBOUNDLIBXC) THEN
            TAUWUP = 0.125_q*ABSNABUP**2/XC_DENS(1)
            TAUWDW = 0.125_q*ABSNABDW**2/XC_DENS(2)
            XC_TAU(1) = MAX(XC_TAU(1),TAUWUP)
            XC_TAU(2) = MAX(XC_TAU(2),TAUWDW)
         ENDIF

         XC_LAPL(1) = LAPLUP
         XC_LAPL(2) = LAPLDW

         EXC           = 0._q
         dEXCdRHOup    = 0._q
         dEXCdRHOdw    = 0._q
         dEXCdABSNABup = 0._q
         dEXCdABSNABdw = 0._q
         dEXCdABSNAB   = 0._q
         dEXCdTAUup    = 0._q
         dEXCdTAUdw    = 0._q
         dEXCdLAPup    = 0._q
         dEXCdLAPdw    = 0._q

         DO IFUNC = 1, 2
            IF (LIBXC_MASK(IFUNC)>0) THEN
               IF ((XC_FAMILY(IFUNC) .EQ. LIBXC_FAMILY_LDA) .OR. (XC_FAMILY(IFUNC) .EQ. LIBXC_FAMILY_HYB_LDA)) THEN
                  IF (LIBXC_NOEXC(IFUNC)) THEN
                     call XC_F03_LDA_VXC(LIBXC_FUNC_SPN(IFUNC),1_qi8,XC_DENS,XC_VRHO)
                     XC_EXC = 0._q
                  ELSE
                     call XC_F03_LDA_EXC_VXC(LIBXC_FUNC_SPN(IFUNC),1_qi8,XC_DENS,XC_EXC,XC_VRHO)
                  ENDIF
                  EXC           = EXC + LIBXC_AMGGAXC(IFUNC)*XC_EXC(1)
                  dEXCdRHOup    = dEXCdRHOup + LIBXC_AMGGAXC(IFUNC)*XC_VRHO(1)
                  dEXCdRHOdw    = dEXCdRHOdw + LIBXC_AMGGAXC(IFUNC)*XC_VRHO(2)
               ELSEIF ((XC_FAMILY(IFUNC) .EQ. LIBXC_FAMILY_GGA) .OR. (XC_FAMILY(IFUNC) .EQ. LIBXC_FAMILY_HYB_GGA)) THEN
                  IF (LIBXC_NOEXC(IFUNC)) THEN
                     call XC_F03_GGA_VXC(LIBXC_FUNC_SPN(IFUNC),1_qi8,XC_DENS,XC_SIGMA,XC_VRHO,XC_VSIGMA)
                     XC_EXC = 0._q
                  ELSE
                     call XC_F03_GGA_EXC_VXC(LIBXC_FUNC_SPN(IFUNC),1_qi8,XC_DENS,XC_SIGMA,XC_EXC,XC_VRHO,XC_VSIGMA)
                  ENDIF
                  EXC           = EXC + LIBXC_AMGGAXC(IFUNC)*XC_EXC(1)
                  dEXCdRHOup    = dEXCdRHOup + LIBXC_AMGGAXC(IFUNC)*XC_VRHO(1)
                  dEXCdRHOdw    = dEXCdRHOdw + LIBXC_AMGGAXC(IFUNC)*XC_VRHO(2)
                  dEXCdABSNABup = dEXCdABSNABup + LIBXC_AMGGAXC(IFUNC)*(XC_VSIGMA(1)*2._q*ABSNABUP - XC_VSIGMA(2)*ABSNABUP)
                  dEXCdABSNABdw = dEXCdABSNABdw + LIBXC_AMGGAXC(IFUNC)*(XC_VSIGMA(3)*2._q*ABSNABDW - XC_VSIGMA(2)*ABSNABDW)
                  dEXCdABSNAB   = dEXCdABSNAB + LIBXC_AMGGAXC(IFUNC)*XC_VSIGMA(2)*ABSNAB
               ELSEIF ((XC_FAMILY(IFUNC) .EQ. LIBXC_FAMILY_MGGA) .OR. (XC_FAMILY(IFUNC) .EQ. LIBXC_FAMILY_HYB_MGGA)) THEN
                  IF (LIBXC_NOEXC(IFUNC)) THEN
                     call XC_F03_MGGA_VXC(LIBXC_FUNC_SPN(IFUNC),1_qi8,XC_DENS,XC_SIGMA,XC_LAPL,XC_TAU, &
                    &   XC_VRHO,XC_VSIGMA,XC_VLAPL,XC_VTAU)
                     XC_EXC = 0._q
                  ELSE
                     call XC_F03_MGGA_EXC_VXC(LIBXC_FUNC_SPN(IFUNC),1_qi8,XC_DENS,XC_SIGMA,XC_LAPL,XC_TAU, &
                    &   XC_EXC,XC_VRHO,XC_VSIGMA,XC_VLAPL,XC_VTAU)
                  ENDIF
                  EXC           = EXC + LIBXC_AMGGAXC(IFUNC)*XC_EXC(1)
                  dEXCdRHOup    = dEXCdRHOup + LIBXC_AMGGAXC(IFUNC)*XC_VRHO(1)
                  dEXCdRHOdw    = dEXCdRHOdw + LIBXC_AMGGAXC(IFUNC)*XC_VRHO(2)
                  dEXCdABSNABup = dEXCdABSNABup + LIBXC_AMGGAXC(IFUNC)*(XC_VSIGMA(1)*2._q*ABSNABUP - XC_VSIGMA(2)*ABSNABUP)
                  dEXCdABSNABdw = dEXCdABSNABdw + LIBXC_AMGGAXC(IFUNC)*(XC_VSIGMA(3)*2._q*ABSNABDW - XC_VSIGMA(2)*ABSNABDW)
                  dEXCdABSNAB   = dEXCdABSNAB + LIBXC_AMGGAXC(IFUNC)*XC_VSIGMA(2)*ABSNAB
                  dEXCdTAUup    = dEXCdTAUup + LIBXC_AMGGAXC(IFUNC)*XC_VTAU(1)
                  dEXCdTAUdw    = dEXCdTAUdw + LIBXC_AMGGAXC(IFUNC)*XC_VTAU(2)
                  dEXCdLAPup    = dEXCdLAPup + LIBXC_AMGGAXC(IFUNC)*XC_VLAPL(1)
                  dEXCdLAPdw    = dEXCdLAPdw + LIBXC_AMGGAXC(IFUNC)*XC_VLAPL(2)
               ENDIF
            ENDIF
         ENDDO
         !Conversion to Rydbergs
         EXC           = 2._q*EXC
         dEXCdRHOup    = 2._q*dEXCdRHOup
         dEXCdRHOdw    = 2._q*dEXCdRHOdw
         dEXCdABSNABup = 2._q*dEXCdABSNABup
         dEXCdABSNABdw = 2._q*dEXCdABSNABdw
         dEXCdABSNAB   = 2._q*dEXCdABSNAB
         dEXCdTAUup    = 2._q*dEXCdTAUup
         dEXCdTAUdw    = 2._q*dEXCdTAUdw
         dEXCdLAPup    = 2._q*dEXCdLAPup
         dEXCdLAPdw    = 2._q*dEXCdLAPdw
#endif
      ELSEIF (ID_METAGGA==999) THEN
      ! PBE, for testing mainly

         D=2*RHOUP
         DTHRD=exp(log(D)*THRD)
         FK=(3._q*PI*PI)**THRD*DTHRD
         IF(D>1.E-10_q)THEN
            S=ABSNABUP/(D*FK)
         ELSE
            S=0.0_q
         ENDIF
         CALL EXCHPBE(D,DTHRD,S,EXLDA1,EXC1,EXDLDA1,EXCD1,EXCQ1,1.0_q)

         D=2*RHODW
         DTHRD=exp(log(D)*THRD)
         FK=(3._q*PI*PI)**THRD*DTHRD
         IF(D>1.E-10_q)THEN
            S=ABSNABDW/(D*FK)
         ELSE
            S=0.0_q
         ENDIF
         CALL EXCHPBE(D,DTHRD,S,EXLDA2,EXC2,EXDLDA2,EXCD2,EXCQ2,1.0_q)

         D=RHOUP+RHODW
         DTHRD=exp(log(D)*THRD)
         RS=(0.75_q/PI)**THRD/DTHRD
         ZETA=(RHOUP-RHODW)/D
         ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)
         FK=(3._q*PI*PI)**THRD*DTHRD
         SK = SQRT(4.0_q*FK/PI)
         G = (exp((2*THRD)*log(1._q+ZETA)) &
                 +exp((2*THRD)*log(1._q-ZETA)))/2._q
         T = ABSNAB/(D*2._q*SK*G)
         CALL corpbe(RS,ZETA,ECLDA,ECD1LDA,ECD2LDA,G,SK,T,EC,ECD1,ECD2,ECQ,.TRUE.)

         EXC           = AMGGAX*(EXC1+EXC2)/(2._q*D)+AMGGAC*(ECLDA+EC)
         dEXCdRHOup    = AMGGAX*EXCD1+AMGGAC*(ECD1LDA+ECD1)
         dEXCdRHOdw    = AMGGAX*EXCD2+AMGGAC*(ECD2LDA+ECD2)
         dEXCdABSNABup = AMGGAX*EXCQ1
         dEXCdABSNABdw = AMGGAX*EXCQ2
         dEXCdABSNAB   = AMGGAC*ECQ

         EXC           = 2._q*EXC
         dEXCdRHOup    = 2._q*dEXCdRHOup
         dEXCdRHOdw    = 2._q*dEXCdRHOdw
         dEXCdABSNABup = 2._q*dEXCdABSNABup
         dEXCdABSNABdw = 2._q*dEXCdABSNABdw
         dEXCdABSNAB   = 2._q*dEXCdABSNAB

      ENDIF

      RETURN
      END SUBROUTINE METAGGASPIN

!***********************************************************************
! Below we should enter all functionals
!***********************************************************************

!****************** SUBROUTINE VMBJ_PROYNOV ****************************
!
! calculates modified Becke-Johnson exchange potential
! according to Tran and Blaha, PRL 102, 226401 (2009), which is
! based on Becke and Roussel, PRA 39, 3761 (1989) and
! Becke and Johnson, J. Chem. Phys. 124, 221101 (2006)
!
! This routine uses the analytical represention of the Becke-Roussel
! potential from Proynov, Chem. Phys. Lett. 455, 103 (2008)
!
! everything in Hartree unit and Bohr
!
! ATTENTION: All values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!
! RHO        electron density (up or down)
! GRHO       abs. val. gradient of density (up or down)
! G2RHO      abs. val. second gradient of total density (up or down)
! TAU        kinetic energy density (up or down)
! XCCONST    fitted value by int{|nabla rho|/rho}dr3
! VXBRJ      return value
!
!***********************************************************************

      SUBROUTINE VMBJ_PROYNOV(RHO,GRHO,G2RHO,TAU,XCCONST,VXBRJ)
#ifdef _OPENACC
!$ACC ROUTINE SEQ
      USE tutoracc
#endif
      USE prec
      USE constant
      IMPLICIT NONE

      INTEGER I
      REAL(q) RHO,GRHO,G2RHO,TAU,TAUTMP,TAUW,XCCONST,VXBRJ
      REAL(q) A(1:3),B(0:5),C(0:5),D(0:5),E(0:5),YP(0:5)
      REAL(q) DD,G,P1,P2,QQ,X,Y,Z

      VXBRJ = -(6.0_q/PI*max(RHO,0.0_q))**(1.0_q/3.0_q)

      IF (RHO .GT. MBJ_SMALL) THEN

         TAUTMP = TAU
         TAUW = 0.25_q*GRHO**2/RHO
         TAU=MAX(TAU,TAUW)

         A(1) = 1.5255251812009530_q
         A(2) = 0.4576575543602858_q
         A(3) = 0.4292036732051034_q

         C(0) =   0.7566445420735584_q
         C(1) =  -2.6363977871370960_q
         C(2) =   5.4745159964232880_q
         C(3) = -12.657308127108290_q
         C(4) =   4.1250584725121360_q
         C(5) = -30.425133957163840_q

         B(0) =   0.4771976183772063_q
         B(1) =  -1.7799813494556270_q
         B(2) =   3.8433841862302150_q
         B(3) =  -9.5912050880518490_q
         B(4) =   2.1730180285916720_q
         B(5) = -30.425133851603660_q

         D(0) =    0.00004435009886795587_q
         D(1) =    0.58128653604457910_q
         D(2) =   66.742764515940610_q
         D(3) =  434.26780897229770_q
         D(4) =  824.7765766052239000_q
         D(5) = 1657.9652731582120_q

         E(0) =    0.00003347285060926091_q
         E(1) =    0.47917931023971350_q
         E(2) =   62.392268338574240_q
         E(3) =  463.14816427938120_q
         E(4) =  785.2360350104029000_q
         E(5) = 1657.962968223273000000_q

         DD = TAU - TAUW
         QQ = (G2RHO - 2.0_q*0.8_q*DD)/6.0_q

         IF (ABS(QQ) .GT. 1.0E-18_q) THEN

            Y = (2.0_q/3.0_q)*PI**(2.0_q/3.0_q)*RHO**(5.0_q/3.0_q)/QQ
            DO I=0, 5
               YP(I) = Y**I
            ENDDO

            IF (Y .LE. 0.0_q) THEN
               G = -ATAN(A(1)*Y + A(2)) + A(3)
               P1 = SUM(C(0:5)*YP(0:5))
               P2 = SUM(B(0:5)*YP(0:5))
            ELSEIF (Y .GT. 0.0_q) THEN
               Z = 2.085749716493756_q*Y
               G = LOG(SQRT(1.0_q + 1.0_q/Z**2) + 1.0_q/Z) + 2.0_q
               P1 = SUM(D(0:5)*YP(0:5))
               P2 = SUM(E(0:5)*YP(0:5))
            ENDIF

            X = G*P1/P2

            IF (ABS(X) .GT. 1.0E-18_q) THEN

               VXBRJ = -2.0_q*PI**(1.0_q/3.0_q)*RHO**(1.0_q/3.0_q)*EXP(X/3.0_q)/X*(1.0_q - EXP(-X) - 0.5_q*X*EXP(-X))

               IF (TAU .GE. 0.0_q) THEN
                  VXBRJ = XCCONST*VXBRJ + (3.0_q*XCCONST-2.0_q)*SQRT(5.0_q/12.0_q)/PI*SQRT(TAU/RHO)
               ELSE
                  VXBRJ = XCCONST*VXBRJ - (3.0_q*XCCONST-2.0_q)*SQRT(5.0_q/12.0_q)/PI*SQRT(ABS(TAU/RHO))
               ENDIF

            ENDIF
         ENDIF

         TAU = TAUTMP

      ENDIF

      RETURN
      END SUBROUTINE VMBJ_PROYNOV


!************************ SUBROUTINE EPKZB *****************************
!
! calculates local contribution to metagga Exc according to
! Perdew et. al. PRL 82, 12 (1999)
!
! RH 20001119
!
! everything in Hartree units
!
! ATTENTION: Every values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!
! RU,RD      density up,down
! DRU, DRD   abs. val. gradient of density up/down
! DRT        abs. val. gradient of total density
! TAUU,TAUD  kinetic energy density up/down
! TAUWU,TAUWD Weizsaecker kinetic energy density up/down
! EXC        return value
!
!***********************************************************************

      SUBROUTINE EPKZB(RU,RD,DRU,DRD,DRT,TAUU,TAUD,EX,EC)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

      ! the following parameters are given by Perdew et.al.
      PARAMETER (RKAPPA=0.804_q)
      PARAMETER (D=0.113_q)
      PARAMETER (C=0.53_q)
      ! other parameters
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (TTHRD=2._q*THRD)
      PARAMETER (FTHRD=1._q+TTHRD)
      PARAMETER (ETHRD=1._q+FTHRD)
      PARAMETER (PISQ=PI*PI)
!$ACC ROUTINE(GGASPINCOR) SEQ

      TAUWU=0.125_q*DRU**2._q/RU
      TAUWU=MIN(TAUWU,TAUU)

      TAUWD=0.125_q*DRD**2._q/RD
      TAUWD=MIN(TAUWD,TAUD)

      EX=0._q;EC=0._q
      ! exchange energy
      ! spin up
      P=(2._q*DRU)**2._q/(4._q*(3._q*PISQ)**TTHRD*(2._q*RU)**ETHRD)
      QQS=6._q*TAUU/(2._q*(3._q*PISQ)**TTHRD*(2._q*RU)**FTHRD)-9._q/20._q-P/12._q
      X=10._q/81._q*P+146._q/2025._q*QQS*QQS-73._q/405._q*QQS*P
      X=X+(D+1._q/RKAPPA*(10._q/81._q)**2._q)*P*P
      FX=1._q+RKAPPA-RKAPPA/(1._q+(X/RKAPPA))
      EX=EX-RU*(3._q/(4._q*PI))*(3._q*PISQ*2._q*RU)**THRD*FX
      ! spin down
      P=(2._q*DRD)**2._q/(4._q*(3._q*PISQ)**TTHRD*(2._q*RD)**ETHRD)
      QQS=6._q*TAUD/(2._q*(3._q*PISQ)**TTHRD*(2._q*RD)**FTHRD)-9._q/20._q-P/12._q
      X=10._q/81._q*P+146._q/2025._q*QQS*QQS-73._q/405._q*QQS*P
      X=X+(D+1._q/RKAPPA*(10._q/81._q)**2._q)*P*P
      FX=1._q+RKAPPA-RKAPPA/(1._q+(X/RKAPPA))
      EX=EX-RD*(3._q/(4._q*PI))*(3._q*PISQ*2._q*RD)**THRD*FX

      ! correlation energy
      CALL GGASPINCOR(RU,RD,DRT,ECT)
      TAUK=(TAUWU+TAUWD)/(TAUU+TAUD)
      ECM1=(RU+RD)*ECT*(1._q+C*TAUK**2._q)

!     CALL GGACOR(RU,DRU,ECU)
      CALL GGASPINCOR(RU,0.0_q,DRU,ECU)
      TAUK=TAUWU/TAUU
      ECM2=TAUK**2._q*RU*ECU

!     CALL GGACOR(RD,DRD,ECD)
      CALL GGASPINCOR(RD,0.0_q,DRD,ECD)
      TAUK=TAUWD/TAUD
      ECM3=TAUK**2._q*RD*ECD
      EC=ECM1-(1._q+C)*(ECM2+ECM3)

      RETURN
      END SUBROUTINE EPKZB


!************************ SUBROUTINE VrevTPSSx *****************************
!
! calculates the first order derivatives of Ex wrt n and |grad(n)|
! Perdew et. al. PRL (2009)
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! everything in Hartree units
!
! ATTANTION: Every values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VXD1 VXD2                    THE DERIVATIVES OF EX WRT n
! VXDD1,VXDD2                  THE DERIVATIVES OF EX WRT |grad n|
! AMUXD1, AMUXD2               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE VrevTPSSx(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ex_revTPSS,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the exchange part
      PARAMETER (RKAPPA=0.804_q)
      PARAMETER (CFB=0.40_q)
      PARAMETER (CFC=2.35203946_q)
      PARAMETER (CFE=2.16769874_q)
      PARAMETER (CFMU=0.14_q)

! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (AX=-0.738558766382022405884230032680836_q)
! test
      PARAMETER (thresh=1.e-10_q)
      PARAMETER (xorder=12._q)
      PARAMETER (zinfinity=2._q)
! test
      VXD1=0._q;VXD2=0._q;
      VXDD1=0._q;VXDD2=0._q;
      AMUXD1=0._q;AMUXD2=0._q;


      CX1=10._q/81._q
      CX2=146._q/2025._q
      CX3=73._q/405._q
      CFE12=SQRT(CFE)

! Suspect that TAUWU and TAUWD are not well described. Use TAUW_TEMP=0.125_q*DRT**2/RT
! IF WANT TO TEST TAUW, SIMPLY OVERWRITE TAUW_TEMP BY TAUW
      TAUWU_TEMP=0.125_q*DRU**2._q/RU
!     TAUWU_TEMP=MIN(TAUWU_TEMP,TAUU)

      TAUWD_TEMP=0.125_q*DRD**2._q/RD
!     TAUWD_TEMP=MIN(TAUWD_TEMP,TAUD)

! spin up
! IN EXD1(2*RU), TAUWU AND TAUU SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RU
      DRHO=TWO*DRU
      TAUW_RHO=TWO*TAUWU_TEMP
      TAU_RHO=TWO*TAUU

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|
      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P
      Z=TAUW_RHO/TAU_RHO
! test
      !Z=max(min(Z,0.9999999999999_q),1.E-20_q)
#ifdef Zmethod1
      IF (Z>1) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=1
      ELSE IF(Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
      ENDIF
#endif
#ifdef Zmethod2
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1._q/(1._q+Z**xorder)**(1._q/xorder) - Z**xorder/(1._q+Z**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=Z/(1._q+Z**xorder)**(1._q/xorder)
      ENDIF
#endif
#ifdef Zmethod3
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1._q/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder) - (Z/zinfinity)**xorder/(1._q+(Z/zinfinity)**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=Z/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder)
      ENDIF
#endif
! test
      Z2=Z*Z
      Z3=Z2*Z
      ZTF=0.6_q*Z
      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5

!     ALPHA=(TAU_RHO-TAUW_RHO)/TAU0
      ALPHA=5._q/3._q*P*(1._q/Z-1._q)

      QB_NUM=9._q/20._q*(ALPHA-ONE)
      QB_DEN=SQRT(ONE+CFB*ALPHA*(ALPHA-ONE))
      QB=QB_NUM/QB_DEN+ TWO*P/THREE
      OPZ=ONE+Z2
      SFP=Z3/OPZ**TWO
      FQ=SQRT((ZTF**TWO+P2)/TWO)
      S1=(CX1+CFC*SFP)*P
      S2=CX2*QB**TWO
      S3=-CX3*FQ*QB
      S4=(CX1*P)**TWO/RKAPPA
      S5=TWO*CFE12*CX1*ZTF**TWO
      S6=CFE*CFMU*P2*P
      XN=S1+S2+S3+S4+S5+S6
      XD=(ONE+CFE12*P)**TWO
      X=XN/XD

!    GET THE VALUE FOR FX
      FX=ONE+RKAPPA-RKAPPA/(ONE+(X/RKAPPA))

!    NOW, DERIVATIVES COME
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q

      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

      DALPHAD=THRD5*(ONE/Z-ONE)*DPD-THRD5*P*DZD/Z**TWO
!     DALPHAD=-TAU_RHO*(THREE*PI**TWO*RHO)**THRD2/(TWO*TAU_UNIF**TWO)+   &
!    &   DRHO**TWO/RHO**(11._q/THREE)*(10._q/9._q/(THREE*PI**TWO)**THRD2)

      DALPHADD=THRD5*(ONE/Z-ONE)*DPDD-THRD5*P*DZDD/Z**TWO
!     DALPHADD=-DRHO/(FOUR*RHO*TAU_UNIF)

      DALPHADTAU=-THRD5*P*DZDTAU/Z**TWO
!     DALPHADTAU=ONE/TAU_UNIF

      DQB_NUM_D=9._q/20._q*DALPHAD
      DQB_NUM_DD=9._q/20._q*DALPHADD
      DQB_NUM_DTAU=9._q/20._q*DALPHADTAU
      C_DQB_DEN=ONE/TWO*CFB*(TWO*ALPHA-ONE)/QB_DEN
      DQB_DEN_D=C_DQB_DEN*DALPHAD
      DQB_DEN_DD=C_DQB_DEN*DALPHADD
      DQB_DEN_DTAU=C_DQB_DEN*DALPHADTAU

      DQBD=(DQB_NUM_D*QB_DEN-QB_NUM*DQB_DEN_D)/QB_DEN**TWO+THRD2*DPD
      DQBDD=(DQB_NUM_DD*QB_DEN-QB_NUM*DQB_DEN_DD)/QB_DEN**TWO+THRD2*DPDD
      DQBDTAU=(DQB_NUM_DTAU*QB_DEN-QB_NUM*DQB_DEN_DTAU)/QB_DEN**TWO+THRD2*DPDTAU

      C1_DS1=P*Z2*(THREE*CFC-CFC*Z2)/OPZ**THREE
      C2_DS1=(CX1+CFC*Z3/OPZ**TWO)
      DS1D=C1_DS1*DZD+C2_DS1*DPD
      DS1DD=C1_DS1*DZDD+C2_DS1*DPDD
      DS1DTAU=C1_DS1*DZDTAU+C2_DS1*DPDTAU

      C_DS2=CX2*TWO*QB
      DS2D=C_DS2*DQBD
      DS2DD=C_DS2*DQBDD
      DS2DTAU=C_DS2*DQBDTAU

      DFQD=ONE/TWO/FQ*(0.6_q**TWO*Z*DZD+P*DPD)
      DFQDD=ONE/TWO/FQ*(0.6_q**TWO*Z*DZDD+P*DPDD)
      DFQDTAU=ONE/TWO/FQ*(0.6_q**TWO*Z*DZDTAU+P*DPDTAU)
      DS3D=-CX3*(FQ*DQBD+QB*DFQD)
      DS3DD=-CX3*(FQ*DQBDD+QB*DFQDD)
      DS3DTAU=-CX3*(FQ*DQBDTAU+QB*DFQDTAU)

      C_S4=TWO/RKAPPA*CX1**TWO*P
      DS4D=C_S4*DPD
      DS4DD=C_S4*DPDD
      DS4DTAU=C_S4*DPDTAU

      C_S5=FOUR*CFE12*CX1*0.6_q**TWO*Z
      DS5D=C_S5*DZD
      DS5DD=C_S5*DZDD
      DS5DTAU=C_S5*DZDTAU

      C_S6=THREE*CFE*CFMU*P2
      DS6D=C_S6*DPD
      DS6DD=C_S6*DPDD
      DS6DTAU=C_S6*DPDTAU

      C_XD=TWO*(ONE+CFE12*P)*CFE12
      DXD_D=C_XD*DPD
      DXD_DD=C_XD*DPDD
      DXD_DTAU=C_XD*DPDTAU

      DXN_D=DS1D+DS2D+DS3D+DS4D+DS5D+DS6D
      DXN_DD=DS1DD+DS2DD+DS3DD+DS4DD+DS5DD+DS6DD
      DXN_DTAU=DS1DTAU+DS2DTAU+DS3DTAU+DS4DTAU+DS5DTAU+DS6DTAU

      DX_D=(XD*DXN_D-XN*DXD_D)/XD**TWO
!     DX_DD=(XD*DXN_DD-XN*DXD_DD)/XD**TWO
      DX_DD=DXN_DD/XD-X*DXD_DD/XD
      DX_DTAU=(XD*DXN_DTAU-XN*DXD_DTAU)/XD**TWO

      C_FX=ONE/(ONE+X/RKAPPA)**TWO
      DFX_D=C_FX*DX_D
      DFX_DD=C_FX*DX_DD
      DFX_DTAU=C_FX*DX_DTAU

!   OUTPUT THE VXD1,VXDD1 AND AMUXD1
      VXD1=EXDLDA*FX+EXLDA*DFX_D
      VXDD1=EXLDA*DFX_DD
      AMUXD1=EXLDA*DFX_DTAU
      EX_REVTPSS=0._q
      EX_REVTPSS=EX_REVTPSS+EXLDA*FX

! spin down
! IN EXD1(2*RD), TAUWD AND TAUD SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RD
      DRHO=TWO*DRD
      TAUW_RHO=TWO*TAUWD_TEMP
      TAU_RHO=TWO*TAUD

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|

      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P
      Z=TAUW_RHO/TAU_RHO
! test
      !Z=max(min(Z,0.9999999999999_q),1.E-20_q)
#ifdef Zmethod1
      IF (Z>1) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=1
      ELSE IF(Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
      ENDIF
#endif
#ifdef Zmethod2
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
         DZTILDEDZ=1._q/(1._q+Z**xorder)**(1._q/xorder) - Z**xorder/(1._q+Z**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
         Z=Z/(1._q+Z**xorder)**(1._q/xorder)
      ENDIF
#endif
#ifdef Zmethod3
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1._q/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder) - (Z/zinfinity)**xorder/(1._q+(Z/zinfinity)**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=Z/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder)
      ENDIF
#endif
! test
      Z2=Z*Z
      Z3=Z2*Z
      ZTF=0.6_q*Z
      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5

!     ALPHA=(TAU_RHO-TAUW_RHO)/TAU0
      ALPHA=5._q/3._q*P*(1._q/Z-1._q)

      QB_NUM=9._q/20._q*(ALPHA-ONE)
      QB_DEN=SQRT(ONE+CFB*ALPHA*(ALPHA-ONE))
      QB=QB_NUM/QB_DEN+ TWO*P/THREE
      OPZ=ONE+Z2
      SFP=Z3/OPZ**TWO
      FQ=SQRT((ZTF**TWO+P2)/TWO)
      S1=(CX1+CFC*SFP)*P
      S2=CX2*QB**TWO
      S3=-CX3*FQ*QB
      S4=(CX1*P)**TWO/RKAPPA
      S5=TWO*CFE12*CX1*ZTF**TWO
      S6=CFE*CFMU*P2*P
      XN=S1+S2+S3+S4+S5+S6
      XD=(ONE+CFE12*P)**TWO
      X=XN/XD

!    GET THE VALUE FOR FX
      FX=ONE+RKAPPA-RKAPPA/(ONE+(X/RKAPPA))

!    NOW, DERIVATIVES COME
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q

      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

      DALPHAD=THRD5*(ONE/Z-ONE)*DPD-THRD5*P*DZD/Z**TWO
!     DALPHAD=-TAU_RHO*(THREE*PI**TWO*RHO)**THRD2/(TWO*TAU_UNIF**TWO)+   &
!    &   DRHO**TWO/RHO**(11._q/THREE)*(10._q/9._q/(THREE*PI**TWO)**THRD2)

      DALPHADD=THRD5*(ONE/Z-ONE)*DPDD-THRD5*P*DZDD/Z**TWO
!     DALPHADD=-DRHO/(FOUR*RHO*TAU_UNIF)

      DALPHADTAU=-THRD5*P*DZDTAU/Z**TWO
!     DALPHADTAU=ONE/TAU_UNIF

      DQB_NUM_D=9._q/20._q*DALPHAD
      DQB_NUM_DD=9._q/20._q*DALPHADD
      DQB_NUM_DTAU=9._q/20._q*DALPHADTAU
      C_DQB_DEN=ONE/TWO*CFB*(TWO*ALPHA-ONE)/QB_DEN
      DQB_DEN_D=C_DQB_DEN*DALPHAD
      DQB_DEN_DD=C_DQB_DEN*DALPHADD
      DQB_DEN_DTAU=C_DQB_DEN*DALPHADTAU

      DQBD=(DQB_NUM_D*QB_DEN-QB_NUM*DQB_DEN_D)/QB_DEN**TWO+THRD2*DPD
      DQBDD=(DQB_NUM_DD*QB_DEN-QB_NUM*DQB_DEN_DD)/QB_DEN**TWO+THRD2*DPDD
      DQBDTAU=(DQB_NUM_DTAU*QB_DEN-QB_NUM*DQB_DEN_DTAU)/QB_DEN**TWO+THRD2*DPDTAU

      C1_DS1=P*Z2*(THREE*CFC-CFC*Z2)/OPZ**THREE
      C2_DS1=(CX1+CFC*Z3/OPZ**TWO)
      DS1D=C1_DS1*DZD+C2_DS1*DPD
      DS1DD=C1_DS1*DZDD+C2_DS1*DPDD
      DS1DTAU=C1_DS1*DZDTAU+C2_DS1*DPDTAU

      C_DS2=CX2*TWO*QB
      DS2D=C_DS2*DQBD
      DS2DD=C_DS2*DQBDD
      DS2DTAU=C_DS2*DQBDTAU

      DFQD=ONE/TWO/FQ*(0.6_Q**TWO*Z*DZD+P*DPD)
      DFQDD=ONE/TWO/FQ*(0.6_Q**TWO*Z*DZDD+P*DPDD)
      DFQDTAU=ONE/TWO/FQ*(0.6_Q**TWO*Z*DZDTAU+P*DPDTAU)
      DS3D=-CX3*(FQ*DQBD+QB*DFQD)
      DS3DD=-CX3*(FQ*DQBDD+QB*DFQDD)
      DS3DTAU=-CX3*(FQ*DQBDTAU+QB*DFQDTAU)

      C_S4=TWO/RKAPPA*CX1**TWO*P
      DS4D=C_S4*DPD
      DS4DD=C_S4*DPDD
      DS4DTAU=C_S4*DPDTAU

      C_S5=FOUR*CFE12*CX1*0.6_q**TWO*Z
      DS5D=C_S5*DZD
      DS5DD=C_S5*DZDD
      DS5DTAU=C_S5*DZDTAU

      C_S6=THREE*CFE*CFMU*P2
      DS6D=C_S6*DPD
      DS6DD=C_S6*DPDD
      DS6DTAU=C_S6*DPDTAU

      C_XD=TWO*(ONE+CFE12*P)*CFE12
      DXD_D=C_XD*DPD
      DXD_DD=C_XD*DPDD
      DXD_DTAU=C_XD*DPDTAU

      DXN_D=DS1D+DS2D+DS3D+DS4D+DS5D+DS6D
      DXN_DD=DS1DD+DS2DD+DS3DD+DS4DD+DS5DD+DS6DD
      DXN_DTAU=DS1DTAU+DS2DTAU+DS3DTAU+DS4DTAU+DS5DTAU+DS6DTAU

      DX_D=(XD*DXN_D-XN*DXD_D)/XD**TWO
!     DX_DD=(XD*DXN_DD-XN*DXD_DD)/XD**TWO
      DX_DD=DXN_DD/XD-X*DXD_DD/XD
      DX_DTAU=(XD*DXN_DTAU-XN*DXD_DTAU)/XD**TWO

      C_FX=ONE/(ONE+X/RKAPPA)**TWO
      DFX_D=C_FX*DX_D
      DFX_DD=C_FX*DX_DD
      DFX_DTAU=C_FX*DX_DTAU

!   OUTPUT THE VXD2,VXDD2 AND AMUXD2
      VXD2=EXDLDA*FX+EXLDA*DFX_D
      VXDD2=EXLDA*DFX_DD
      AMUXD2=EXLDA*DFX_DTAU

      EX_REVTPSS=EX_REVTPSS+EXLDA*FX
      EX_REVTPSS=EX_REVTPSS/TWO
      RETURN
      END SUBROUTINE VrevTPSSx


!***********************************************************************
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VCD1 VCD2                    THE DERIVATIVES OF EC WRT n
! VCDD1,VCDD2                  THE DERIVATIVES OF EC WRT |grad n|
! AMUCD1, AMUCD2                   THE DERIVATIVES OF EC WRT TAU
!
!***********************************************************************

      SUBROUTINE VrevTPSSc(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_revTPSS,VCD1,VCDD1,VCD2,VCDD2,VCDD12,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the correlatin part
      PARAMETER (CFD=2.8_q)

! other parameters
      PARAMETER (ZERO=0._q)
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
! test
      PARAMETER (thresh=1.e-10_q)
      PARAMETER (xorder=12._q)
      PARAMETER (zinfinity=2._q)
! test
!$ACC ROUTINE(COE_RPKZB,CORGGA_REVTPSS) SEQ

      VCD1=0._q;VCD2=0._q;
      VCDD1=0._q;VCDD2=0._q;VCDD12=0._q;
      AMUCD1=0._q;AMUCD2=0._q;

      RT=RU+RD
      YA=DRU**2._q
      YB=DRD**2._q
      Y=DRT**2._q
!    YC IS DEL RU DOT DEL RD
      YC=(Y-YA-YB)/2._q
      TAUW=1._q/8._q*(Y/RT)
      TAU=TAUU+TAUD

!     TAUW=MIN(TAUW,TAU)

      Z=TAUW/TAU
! test
      !Z=max(min(Z,0.9999999999999_q),1.E-20_q)
#ifdef Zmethod1
      DZTILDEDZ=ONE
      IF (Z>ONE.OR.Z<ZERO) DZTILDEDZ=ZERO
      DZD1=-Z/RT*DZTILDEDZ
      DZD2=DZD1
      DZDD12=ONE/FOUR*DRT/(RT*TAU)*DZTILDEDZ
      DZDTAU=-Z/TAU*DZTILDEDZ
      Z = MAX(MIN(ONE,Z),ZERO)
#endif
#ifdef Zmethod2
      IF (Z<ZERO) THEN
        DZTILDEDZ=ZERO
      ELSE
        DZTILDEDZ=ONE/(ONE+Z**xorder)**(ONE/xorder) - Z**xorder/(ONE+Z**xorder)**(ONE+ONE/xorder)
      ENDIF
      DZD1=-Z/RT*DZTILDEDZ
      DZD2=DZD1
      DZDD12=ONE/FOUR*DRT/(RT*TAU)*DZTILDEDZ
      DZDTAU=-Z/TAU*DZTILDEDZ
      Z=MAX(ZERO,Z)
      Z=Z/(1._q+Z**xorder)**(1._q/xorder)
#endif
#ifdef Zmethod3
      IF (Z<ZERO) THEN
        DZTILDEDZ=ZERO
      ELSE
        DZTILDEDZ=ONE/(ONE+(Z/zinfinity)**xorder)**(ONE/xorder) - (Z/zinfinity)**xorder/(ONE+(Z/zinfinity)**xorder)**(ONE+ONE/xorder)
      ENDIF
      DZD1=-Z/RT*DZTILDEDZ
      DZD2=DZD1
      DZDD12=ONE/FOUR*DRT/(RT*TAU)*DZTILDEDZ
      DZDTAU=-Z/TAU*DZTILDEDZ
      Z=MAX(ZERO,Z)
      Z=Z/(ONE+(Z/zinfinity)**xorder)**(ONE/xorder)
#endif
! test
      Z2=Z*Z
      Z3=Z2*Z

      CALL COE_RPKZB(RU,RD,DRU,DRD,DRT,CRPKZB,D_CRPKZB_D1,D_CRPKZB_D2,D_CRPKZB_DD1,D_CRPKZB_DD2,D_CRPKZB_DD12)

      CALL CORGGA_REVTPSS(RU,RD,DRU,DRD,DRT,EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD12)

! EPPGGA2_D1, EPPGGA1_D2 EPPGGA1_DD2 AND EPPGGA2_DD1 ARE ZEROS
      CALL CORGGA_REVTPSS(RU,ZERO,DRU,ZERO,DRU,EPPGGA1,EPPGGA1_D1,EPPGGA1_D2,EPPGGA1_DD1)
      EPPGGA1_D2=ZERO
      EPPGGA1_DD2=ZERO
      EPPGGA1_DD12=ZERO

      CALL CORGGA_REVTPSS(RD,ZERO,DRD,ZERO,DRD,EPPGGA2,EPPGGA2_D2,EPPGGA2_D1,EPPGGA2_DD2)
      EPPGGA2_D1=ZERO
      EPPGGA2_DD1=ZERO
      EPPGGA2_DD12=ZERO

      IF (EPPGGA1 .LT. EPPGGA)THEN
          EPPGGA1=EPPGGA
          EPPGGA1_D1=EPPGGA_D1
          EPPGGA1_D2=EPPGGA_D2
          EPPGGA1_DD1=ZERO
          EPPGGA1_DD12=EPPGGA_DD12
      ENDIF

      IF (EPPGGA2 .LT. EPPGGA)THEN
          EPPGGA2=EPPGGA
          EPPGGA2_D1=EPPGGA_D1
          EPPGGA2_D2=EPPGGA_D2
          EPPGGA2_DD2=ZERO
          EPPGGA2_DD12=EPPGGA_DD12
      ENDIF

      WEIRD=(RU*EPPGGA1+RD*EPPGGA2)/RT
      WEIRD_D1=RD*EPPGGA1/RT**TWO+RU/RT*EPPGGA1_D1-RD*EPPGGA2/RT**TWO+RD/RT*EPPGGA2_D1
      WEIRD_D2=-RU*EPPGGA1/RT**TWO+RU/RT*EPPGGA1_D2+RU*EPPGGA2/RT**TWO+RD/RT*EPPGGA2_D2
      WEIRD_DD1=RU/RT*EPPGGA1_DD1+RD/RT*EPPGGA2_DD1
      WEIRD_DD2=RU/RT*EPPGGA1_DD2+RD/RT*EPPGGA2_DD2
      WEIRD_DD12=RU/RT*EPPGGA1_DD12+RD/RT*EPPGGA2_DD12

      EPSC_REVPKZB=EPPGGA*(ONE+CRPKZB*Z2)-(ONE+CRPKZB)*Z2*WEIRD

      FP_D_EPSC_REVPKZB_D1=(ONE+CRPKZB*Z2)*EPPGGA_D1+EPPGGA*(D_CRPKZB_D1*Z2+TWO*Z*CRPKZB*DZD1)
      FP_D_EPSC_REVPKZB_D2=(ONE+CRPKZB*Z2)*EPPGGA_D2+EPPGGA*(D_CRPKZB_D2*Z2+TWO*Z*CRPKZB*DZD2)

      SD_D_EPSC_REVPKZB_D1=D_CRPKZB_D1*Z2*WEIRD+(ONE+CRPKZB)*TWO*Z*DZD1*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_D1
      SD_D_EPSC_REVPKZB_D2=D_CRPKZB_D2*Z2*WEIRD+(ONE+CRPKZB)*TWO*Z*DZD2*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_D2

      D_EPSC_REVPKZB_D1=FP_D_EPSC_REVPKZB_D1-SD_D_EPSC_REVPKZB_D1
      D_EPSC_REVPKZB_D2=FP_D_EPSC_REVPKZB_D2-SD_D_EPSC_REVPKZB_D2

      FP_D_EPSC_REVPKZB_DD1=EPPGGA*D_CRPKZB_DD1*Z2
      FP_D_EPSC_REVPKZB_DD2=EPPGGA*D_CRPKZB_DD2*Z2
      FP_D_EPSC_REVPKZB_DD12=(ONE+CRPKZB*Z2)*EPPGGA_DD12+EPPGGA*(D_CRPKZB_DD12*Z2+TWO*Z*CRPKZB*DZDD12)

      SD_D_EPSC_REVPKZB_DD1=D_CRPKZB_DD1*Z2*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_DD1
      SD_D_EPSC_REVPKZB_DD2=D_CRPKZB_DD2*Z2*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_DD2
      SD_D_EPSC_REVPKZB_DD12=D_CRPKZB_DD12*Z2*WEIRD+(ONE+CRPKZB)*TWO*Z*DZDD12*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_DD12

      D_EPSC_REVPKZB_DD1=FP_D_EPSC_REVPKZB_DD1-SD_D_EPSC_REVPKZB_DD1
      D_EPSC_REVPKZB_DD2=FP_D_EPSC_REVPKZB_DD2-SD_D_EPSC_REVPKZB_DD2
      D_EPSC_REVPKZB_DD12=FP_D_EPSC_REVPKZB_DD12-SD_D_EPSC_REVPKZB_DD12

      D_EPSC_REVPKZB_DTAU=EPPGGA*CRPKZB*TWO*Z*DZDTAU-(ONE+CRPKZB)*TWO*Z*DZDTAU*WEIRD

      VCD1=(EPSC_REVPKZB+RT*D_EPSC_REVPKZB_D1)*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_D1+THREE*Z2*EPSC_REVPKZB*DZD1)

      VCD2=(EPSC_REVPKZB+RT*D_EPSC_REVPKZB_D2)*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_D2+THREE*Z2*EPSC_REVPKZB*DZD2)

      VCDD1=RT*D_EPSC_REVPKZB_DD1*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DD1)

      VCDD2=RT*D_EPSC_REVPKZB_DD2*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DD2)

      VCDD12=RT*D_EPSC_REVPKZB_DD12*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DD12+THREE*Z2*EPSC_REVPKZB*DZDD12)

      AMUCD1=RT*D_EPSC_REVPKZB_DTAU*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DTAU+THREE*Z2*EPSC_REVPKZB*DZDTAU)
      AMUCD2=AMUCD1

      EC_REVTPSS=RT*EPSC_REVPKZB*(ONE+CFD*EPSC_REVPKZB*Z3)
      RETURN
      END SUBROUTINE VrevTPSSC


!***********************************************************************
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! CRPKZB                       C(ZETA,XI)
! D_CRPKZB_D1,D_CRPKZB_D2      THE DERIVATIVE OF C(ZETA,XI) WRT n
! D_CRPKZB_DD1,D_CRPKZB_DD2    THE DERIVATIVE OF C(ZETA,XI) WRT |GRAD n|
!
!***********************************************************************

      SUBROUTINE COE_RPKZB(&
     &   RU,RD,DRU,DRD,DRT, &
     &   CRPKZB,D_CRPKZB_D1,D_CRPKZB_D2,D_CRPKZB_DD1,D_CRPKZB_DD2,D_CRPKZB_DD12)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the correlatin part
      PARAMETER (CF1=0.59_q)
      PARAMETER (CF2=0.9269_q)
      PARAMETER (CF3=0.6225_q)
      PARAMETER (CF4=2.1540_q)

! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)

      CRPKZB=0._q
      D_CRPKZB_D1=0._q;D_CRPKZB_D2=0._q;
      D_CRPKZB_DD1=0._q;D_CRPKZB_DD2=0._q;
      D_CRPKZB_DD12=0._q;

      RT=RU+RD
      YA=DRU**2._q
      YB=DRD**2._q
      Y=DRT**2._q
! YC IS DEL RU DOT DEL RD
      YC=(Y-YA-YB)/2._q

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)
      OPZ = ONE + ZETA
      OMZ = ONE - ZETA
      ZETA2=ZETA*ZETA
      OPZETA=ONE/(ONE+ZETA)
      OMZETA=ONE/(ONE-ZETA)
      D_ZETA_D1=TWO*RD/RT**TWO
      D_ZETA_D2=-TWO*RU/RT**TWO

! |GRAD ZETA|,
! IN SOME EXTREME CASES, THE TERM (YA*RD**TWO-TWO*RU*RD*YC+YB*RU**TWO)
! GOES TO NEGATIVE BECAUSE OF THE NUMERICAL PRESICION OF COMPUTERS. SO, WE USE 2/4 AS THE POWER
! INSTEAD OF 1/2
      DEL_ZETA2 = (TWO*YA*OMZ + TWO*YB*OPZ - OPZ*OMZ*Y)/RT**2
      D_DEL_ZETA2_DYA = TWO*OMZ/RT**2
      D_DEL_ZETA2_DYB = TWO*OPZ/RT**2
      D_DEL_ZETA2_DY = -OPZ*OMZ/RT**2
      D_DEL_ZETA2_DZETA = TWO*(ZETA*Y + YB - YA)/RT**2
      D_DEL_ZETA2_D1 = -TWO*DEL_ZETA2/RT + D_DEL_ZETA2_DZETA*OMZ/RT
      D_DEL_ZETA2_D2 = -TWO*DEL_ZETA2/RT - D_DEL_ZETA2_DZETA*OPZ/RT

! XI
      XIDEN2=4._q*(THREE*PISQ*RT)**THRD2
      XI2=DEL_ZETA2/XIDEN2
      D_XI2_D1=(D_DEL_ZETA2_D1-THRD2*DEL_ZETA2/RT)/XIDEN2
      D_XI2_D2=(D_DEL_ZETA2_D2-THRD2*DEL_ZETA2/RT)/XIDEN2
      D_XI2_DYA=D_DEL_ZETA2_DYA/XIDEN2
      D_XI2_DYB=D_DEL_ZETA2_DYB/XIDEN2
      D_XI2_DY=D_DEL_ZETA2_DY/XIDEN2

      CNUM=CF1+(CF2+(CF3+CF4*ZETA2)*ZETA2)*ZETA2
      D_CNUM_D1=D_ZETA_D1*(TWO*CF2+(FOUR*CF3+SIX*CF4*ZETA2)*ZETA2)*ZETA
      D_CNUM_D2=D_ZETA_D2*(TWO*CF2+(FOUR*CF3+SIX*CF4*ZETA2)*ZETA2)*ZETA

      OPZETA43=OPZETA**THRD4
      OMZETA43=OMZETA**THRD4
      CDENL=ONE+XI2*(OPZETA43+OMZETA43)/TWO
      CDEN=CDENL**FOUR
      D_CDENL_DXI2=(OPZETA43+OMZETA43)/TWO
      D_CDENL_DZETA=-THRD2*XI2*(OPZETA43*OPZETA-OMZETA43*OMZETA)
      D_CDENL_D1=D_CDENL_DXI2*D_XI2_D1+D_CDENL_DZETA*D_ZETA_D1
      D_CDENL_D2=D_CDENL_DXI2*D_XI2_D2+D_CDENL_DZETA*D_ZETA_D2
      D_CDENL_DYA=D_CDENL_DXI2*D_XI2_DYA
      D_CDENL_DYB=D_CDENL_DXI2*D_XI2_DYB
      D_CDENL_DY=D_CDENL_DXI2*D_XI2_DY

      D_CDEN_D1=FOUR*CDENL**THREE*D_CDENL_D1
      D_CDEN_D2=FOUR*CDENL**THREE*D_CDENL_D2
      D_CDEN_DYA=FOUR*CDENL**THREE*D_CDENL_DYA
      D_CDEN_DYB=FOUR*CDENL**THREE*D_CDENL_DYB
      D_CDEN_DY=FOUR*CDENL**THREE*D_CDENL_DY


! OUTPUT CRPKZB,,D_CRPKZB_D1,D_CRPKZB_D2,D_CRPKZB_DD1,D_CRPKZB_DD2
      CRPKZB=CNUM/CDEN
      D_CRPKZB_D1=(CDEN*D_CNUM_D1-CNUM*D_CDEN_D1)/CDEN**TWO
      D_CRPKZB_D2=(CDEN*D_CNUM_D2-CNUM*D_CDEN_D2)/CDEN**TWO
      D_CRPKZB_DD1=-TWO*DRU*CNUM*D_CDEN_DYA/CDEN**TWO
      D_CRPKZB_DD2=-TWO*DRD*CNUM*D_CDEN_DYB/CDEN**TWO
      D_CRPKZB_DD12=-TWO*DRT*CNUM*D_CDEN_DY/CDEN**TWO

      RETURN
      END SUBROUTINE COE_RPKZB


!***********************************************************************
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! EPPGGA                       GGA ENERGY PER PARTICLE
! EPPGGA_D1,EPPGGA_D2          THE DERIVATIVE OF EPPGGA WRT n
! EPPGGA_DD1,EPPGGA_DD2        THE DERIVATIVE OF EPPGGA WRT |GRAD n|
!
!***********************************************************************
      SUBROUTINE CORGGA_REVTPSS(&
     &   RU,RD,DRU,DRD,DRT, &
     &   EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD12)
!$ACC ROUTINE SEQ

      USE prec
      USE constant

      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)

      PARAMETER (GAMMA=0.03109069086965489503494086371273_q)
      PARAMETER (BETA_mb=0.06672455060314922_q)

      EPPGGA  =0._q
      EPPGGA_D1=0._q
      EPPGGA_D2=0._q
      EPPGGA_DD12=0._q

      RT=RU+RD
      YA=DRU**2._q
      YB=DRD**2._q
      Y=DRT**2._q
!     YC IS DEL RU DOT DEL RD
      YC=(Y-YA-YB)/2._q

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)
      DZETAD1=TWO*RD/RT**TWO
      DZETAD2=-TWO*RU/RT**TWO


      DTHRD=exp(log(RT)*THRD)
      RS=(0.75_q/PI)**THRD/DTHRD
      DRSD1=-THRD/RT*RS
      DRSD2=-THRD/RT*RS


      PHI = (exp((TWO*THRD)*log(1._q+ZETA)) &
                +exp((TWO*THRD)*log(1._q-ZETA)))/2._q
      D_PHI_DZETA=THRD*((ONE+ZETA)**(-THRD)-(ONE-ZETA)**(-THRD))
      D_PHI_D1=D_PHI_DZETA*DZETAD1
      D_PHI_D2=D_PHI_DZETA*DZETAD2

      AFIX_T=SQRT(PI/FOUR)*(9._q*PI/FOUR)**(ONE/SIX)
      S=DRT/(TWO*(THREE*PISQ)**THRD*RT**THRD4)
      DSD1=-THRD4*S/RT
      DSD2=-THRD4*S/RT
      DSDD12 = ONE/(TWO*(THREE*PISQ)**THRD*RT**THRD4)

      T=AFIX_T*S/SQRT(RS)/PHI
      T2 = T*T
      T4 = T2*T2

      DTD1=AFIX_T*(PHI*RS*DSD1-0.5_q*S*PHI*DRSD1-S*RS*D_PHI_D1)/(PHI**TWO*RS**(THREE/TWO))
      DTD2=AFIX_T*(PHI*RS*DSD2-0.5_q*S*PHI*DRSD2-S*RS*D_PHI_D2)/(PHI**TWO*RS**(THREE/TWO))
      DTDD12=AFIX_T*DSDD12/(SQRT(RS)*PHI)

      FK=(3._q*PI*PI)**THRD*DTHRD
      SK = SQRT(4.0_q*FK/PI)
! Only the local part (EC,VCUPLDA,VCDNLDA) are used from the following call to CORPBE
      CALL CORPBE_revtpss(RS,ZETA,EC,VCUPLDA,VCDNLDA,PHI,SK, &
           T,H,DVCUP,DVCDN,ECQ,.FALSE.)
! OBTAIN THE CONTRIBUTION FROM LDA PART AND D_EC_DRS AND D_EC_DZETA
!      EPPGGA=EC
!      EPPGGA_D1=(VCUPLDA-EC)/RT
!      EPPGGA_D2=(VCDNLDA-EC)/RT
      D_EC_DZETA=(VCUPLDA-VCDNLDA)/TWO
      D_EC_DRS=(EC-ZETA*D_EC_DZETA-(VCUPLDA+VCDNLDA)/TWO)*THREE/RS

! THE RS DEPENDENCE OF BETA
      AFACTOR=0.1_q
      BFACTOR=0.1778_Q
      BETA_NUM=ONE + AFACTOR*RS
      BETA_DEN=ONE+ BFACTOR*RS
      D_BETA_NUM=AFACTOR
      D_BETA_DEN=BFACTOR
      BETA = BETA_MB*BETA_NUM/BETA_DEN
      D_BETA_DRS=BETA_MB*(BETA_DEN*D_BETA_NUM-BETA_NUM*D_BETA_DEN)/BETA_DEN**TWO


      PHI3=PHI**THREE
      PON=-EC/(PHI3*gamma)
      W=DEXP(PON)-ONE
      D_W_DRS=-(W+ONE)*D_EC_DRS/(GAMMA*PHI3)
      D_W_DZETA=-(W+ONE)/(GAMMA*PHI3)*(D_EC_DZETA-THREE*EC*D_PHI_DZETA/PHI)


      A=BETA/(GAMMA*W)
      D_A_DRS=(W*D_BETA_DRS-BETA*D_W_DRS)/(GAMMA*W**TWO)
      D_A_DZETA=-BETA*D_W_DZETA/(GAMMA*W**TWO)

      V=A*T2
      D_V_DRS=T2*D_A_DRS
      D_V_DZETA=T2*D_A_DZETA
      D_V_DT=TWO*A*T

      FUNKG=ONE/(ONE+V+V**TWO)
      D_FUNKG_DV=-(ONE+TWO*V)*FUNKG**TWO


      HCORE=ONE+W*(ONE-FUNKG)
      AH=GAMMA*PHI3
      H=AH*DLOG(HCORE)

      DH1=ONE-FUNKG
      DH2=W*D_FUNKG_DV
      D_H_DRS=(DH1*D_W_DRS-DH2*D_V_DRS)*AH/HCORE
      D_H_DZETA=THREE*H*D_PHI_DZETA/PHI+(DH1*D_W_DZETA-DH2*D_V_DZETA)*AH/HCORE
      D_H_DT=(-DH2*D_V_DT)*AH/HCORE

! OUTPUT EPPGGA AND ITS DERIVATIVES EPPGGA_D1,EPPGGA_D2, EPPGGA_DD1, EPPGGA_DD2
      EPPGGA=EC+H
      EPPGGA_D1=D_EC_DRS*DRSD1+D_EC_DZETA*DZETAD1+D_H_DRS*DRSD1+D_H_DZETA*DZETAD1+D_H_DT*DTD1
      EPPGGA_D2=D_EC_DRS*DRSD2+D_EC_DZETA*DZETAD2+D_H_DRS*DRSD2+D_H_DZETA*DZETAD2+D_H_DT*DTD2
      EPPGGA_DD12=D_H_DT*DTDD12

      RETURN
      END SUBROUTINE CORGGA_REVTPSS


      SUBROUTINE GGASPINCOR_revTPSS(D1,D2,DDA,EC)
!     D1   density up
!     D2   density down
!     DDA  |gradient of the total density|

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (THRD=1._q/3._q)

      D=D1+D2
      DTHRD=exp(log(D)*THRD)
      RS=(0.75_q/PI)**THRD/DTHRD

      ZETA=(D1-D2)/D
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)

      FK=(3._q*PI*PI)**THRD*DTHRD
      SK = SQRT(4.0_q*FK/PI)
      G = (exp((2*THRD)*log(1._q+ZETA)) &
                +exp((2*THRD)*log(1._q-ZETA)))/2._q
      T = DDA/(D*2._q*SK*G)

      CALL CORPBE_revtpss(RS,ZETA,ECLDA,ECD1LDA,ECD2LDA,G,SK, &
           T,EC,ECD1,ECD2,ECQ,.TRUE.)

      EC  =(EC  +ECLDA)
      RETURN
      END SUBROUTINE GGASPINCOR_revTPSS


! Modified by Adrienn Ruzsinszky
!######################################################################
!----------------------------------------------------------------------
      SUBROUTINE CORPBE_revtpss(RS,ZET,EC,VCUP,VCDN,g,sk, &
     &                  T,H,DVCUP,DVCDN,ecdd,lgga)
!$ACC ROUTINE SEQ
!----------------------------------------------------------------------
!  Official PBE correlation code. K. Burke, May 14, 1996.
!  INPUT: RS=SEITZ RADIUS=(3/4pi rho)^(1/3)
!       : ZET=RELATIVE SPIN POLARIZATION = (rhoup-rhodn)/rho
!       : t=ABS(GRAD rho)/(rho*2.*KS*G)  -- only needed for PBE
!       : lgga=flag to do gga (0=>LSD only)
!       : lmetagga=flag to do metagga (revTPSS)
!       : lpot=flag to do potential (0=>energy only)
!  output: ec=lsd correlation energy from [a]
!        : vcup=lsd up correlation potential
!        : vcdn=lsd dn correlation potential
!        : h=NONLOCAL PART OF CORRELATION ENERGY PER ELECTRON
!        : dvcup=nonlocal correction to vcup
!        : dvcdn=nonlocal correction to vcdn
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! References:
! [a] J.P.~Perdew, K.~Burke, and M.~Ernzerhof,
!     {\sl Generalized gradient approximation made simple}, sub.
!     to Phys. Rev.Lett. May 1996.
! [b] J. P. Perdew, K. Burke, and Y. Wang, {\sl Real-space cutoff
!     construction of a generalized gradient approximation:  The PW91
!     density functional}, submitted to Phys. Rev. B, Feb. 1996.
! [c] J. P. Perdew and Y. Wang, Phys. Rev. B {\bf 45}, 13244 (1992).
!----------------------------------------------------------------------
!----------------------------------------------------------------------
      USE prec
      IMPLICIT REAL(q) (A-H,O-Z)
      logical lgga
! thrd*=various multiples of 1/3
! numbers for use in LSD energy spin-interpolation formula, [c](9).
!      GAM= 2^(4/3)-2
!      FZZ=f''(0)= 8/(9*GAM)
! numbers for construction of PBE
!      gamma=(1-log(2))/pi^2
!      bet=coefficient in gradient expansion for correlation, [a](4).
!      eta=small number to stop d phi/ dzeta from blowing up at
!          |zeta|=1.
      parameter(thrd=1._q/3._q,thrdm=-thrd,thrd2=2._q*thrd)
      parameter(sixthm=thrdm/2._q)
      parameter(thrd4=4._q*thrd)
      parameter(GAM=0.5198420997897463295344212145565_q)
      parameter(fzz=8._q/(9._q*GAM))
      parameter(gamma=0.03109069086965489503494086371273_q)
      parameter(bet_mb=0.06672455060314922_q)
      parameter(eta=1.e-12_q)
!$ACC ROUTINE(gcor2) SEQ
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! find LSD energy contributions, using [c](10) and Table I[c].
! EU=unpolarized LSD correlation energy
! EURS=dEU/drs
! EP=fully polarized LSD correlation energy
! EPRS=dEP/drs
! ALFM=-spin stiffness, [c](3).
! ALFRSM=-dalpha/drs
! F=spin-scaling factor from [c](9).
! construct ec, using [c](8)
      rtrs=dsqrt(rs)
      CALL gcor2(0.0310907_q,0.21370_q,7.5957_q,3.5876_q,1.6382_q, &
     &    0.49294_q,rtrs,EU,EURS)
      CALL gcor2(0.01554535_q,0.20548_q,14.1189_q,6.1977_q,3.3662_q, &
     &    0.62517_q,rtRS,EP,EPRS)
      CALL gcor2(0.0168869_q,0.11125_q,10.357_q,3.6231_q,0.88026_q, &
     &    0.49671_q,rtRS,ALFM,ALFRSM)
      ALFC = -ALFM
      Z4 = ZET**4
      F=((1._q+ZET)**THRD4+(1._q-ZET)**THRD4-2._q)/GAM
      EC = EU*(1._q-F*Z4)+EP*F*Z4-ALFM*F*(1._q-Z4)/FZZ
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! LSD potential from [c](A1)
! ECRS = dEc/drs [c](A2)
! ECZET=dEc/dzeta [c](A3)
! FZ = dF/dzeta [c](A4)
      ECRS = EURS*(1._q-F*Z4)+EPRS*F*Z4-ALFRSM*F*(1._q-Z4)/FZZ
      FZ = THRD4*((1._q+ZET)**THRD-(1._q-ZET)**THRD)/GAM
      ECZET = 4._q*(ZET**3)*F*(EP-EU+ALFM/FZZ)+FZ*(Z4*EP-Z4*EU &
     &        -(1._q-Z4)*ALFM/FZZ)
      COMM = EC -RS*ECRS/3._q-ZET*ECZET
      VCUP = COMM + ECZET
      VCDN = COMM - ECZET
!write(*,*)'rs,VCUP,VCDN',rs,VCUP,VCDN
      if (.not.lgga) return
!----------------------------------------------------------------------
! PBE correlation energy
! G=phi(zeta), given after [a](3)
! DELT=bet/gamma
! B=A of [a](8)
      bet = bet_mb*(1._q + 0.1_q*RS)/(1._q + 0.1778_q*RS)

      delt=bet/gamma
      G3 = G**3
      PON=-EC/(G3*gamma)
      B = DELT/(DEXP(PON)-1._q)
      B2 = B*B
      T2 = T*T
      T4 = T2*T2
      RS2 = RS*RS
      RS3 = RS2*RS
      Q4 = 1._q+B*T2
      Q5 = 1._q+B*T2+B2*T4
      H = G3*(BET/DELT)*DLOG(1._q+DELT*Q4*T2/Q5)
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
      G4 = G3*G
      T6 = T4*T2
      RSTHRD = RS/3._q
      GZ=(((1._q+zet)**2+eta)**sixthm- &
     &((1._q-zet)**2+eta)**sixthm)/3._q
      FAC = DELT/B+1._q
      BG = -3._q*B2*EC*FAC/(BET*G4)
      BEC = B2*FAC/(BET*G3)
      Q8 = Q5*Q5+DELT*Q4*Q5*T2
      Q9 = 1._q+2._q*B*T2
      hB = -BET*G3*B*T6*(2._q+B*T2)/Q8
      hRS = -RSTHRD*hB*BEC*ECRS
      hZ = 3._q*GZ*h/G + hB*(BG*GZ+BEC*ECZET)
      hT = 2._q*BET*G3*Q9/Q8
      COMM = H+HRS-7.0_q*T2*HT/6._q
      PREF = HZ-GZ*T2*HT/G
      COMM = COMM-PREF*ZET
      DVCUP = COMM + PREF
      DVCDN = COMM - PREF
      ecdd=0.5_q/(sk*g)*t*ht
      RETURN
      END SUBROUTINE CORPBE_revtpss


!************************ SUBROUTINE VTPSSx ****************************
!
! calculates the first order derivatives of Ex wrt n and |grad(n)|
! Perdew et. al. PRL (2009)
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! everything in Hartree units
!
! ATTANTION: Every values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VXD1 VXD2                    THE DERIVATIVES OF EX WRT n
! VXDD1,VXDD2                  THE DERIVATIVES OF EX WRT |grad n|
! AMUXD1, AMUXD2               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE VTPSSx(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ex_revTPSS,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the exchange part
      PARAMETER (RKAPPA=0.804_q)
      PARAMETER (CFB=0.40_q)
      PARAMETER (CFC=1.59096_q)
      PARAMETER (CFE=1.537_q)
      PARAMETER (CFMU=0.21951_q)

! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (AX=-0.738558766382022405884230032680836_q)
! test
      PARAMETER (thresh=1.e-10_q)
      PARAMETER (xorder=12._q)
      PARAMETER (zinfinity=2._q)
! test
!$ACC ROUTINE(COE_RPKZB_TPSS,CORGGA_TPSS) SEQ

      VXD1=0._q;VXD2=0._q;
      VXDD1=0._q;VXDD2=0._q;
      AMUXD1=0._q;AMUXD2=0._q;


      CX1=10._q/81._q
      CX2=146._q/2025._q
      CX3=73._q/405._q
      CFE12=SQRT(CFE)

! Suspect that TAUWU and TAUWD are not well described. Use TAUW_TEMP=0.125_q*DRT**2/RT
! IF WANT TO TEST TAUW, SIMPLY OVERWRITE TAUW_TEMP BY TAUW
      TAUWU_TEMP=0.125_q*DRU**2._q/RU
!     TAUWU_TEMP=MIN(TAUWU_TEMP,TAUU)

      TAUWD_TEMP=0.125_q*DRD**2._q/RD
!     TAUWD_TEMP=MIN(TAUWD_TEMP,TAUD)

! spin up
! IN EXD1(2*RU), TAUWU AND TAUU SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RU
      DRHO=TWO*DRU
      TAUW_RHO=TWO*TAUWU_TEMP
      TAU_RHO=TWO*TAUU

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|
      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P
      Z=TAUW_RHO/TAU_RHO
! test
      !Z=max(min(Z,0.9999999999999_q),1.E-20_q)
#ifdef Zmethod1
      IF (Z>1) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=1
      ELSE IF(Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
      ENDIF
#endif
#ifdef Zmethod2
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1._q/(1._q+Z**xorder)**(1._q/xorder) - Z**xorder/(1._q+Z**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=Z/(1._q+Z**xorder)**(1._q/xorder)
      ENDIF
#endif
#ifdef Zmethod3
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1._q/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder) - (Z/zinfinity)**xorder/(1._q+(Z/zinfinity)**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=Z/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder)
      ENDIF
#endif
! test
      Z2=Z*Z
      Z3=Z2*Z
      ZTF=0.6_q*Z
      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5

!     ALPHA=(TAU_RHO-TAUW_RHO)/TAU0
      ALPHA=5._q/3._q*P*(1._q/Z-1._q)

      QB_NUM=9._q/20._q*(ALPHA-ONE)
      QB_DEN=SQRT(ONE+CFB*ALPHA*(ALPHA-ONE))
      QB=QB_NUM/QB_DEN+ TWO*P/THREE
      OPZ=ONE+Z2
      SFP=Z2/OPZ**TWO
      FQ=SQRT((ZTF**TWO+P2)/TWO)
      S1=(CX1+CFC*SFP)*P
      S2=CX2*QB**TWO
      S3=-CX3*FQ*QB
      S4=(CX1*P)**TWO/RKAPPA
      S5=TWO*CFE12*CX1*ZTF**TWO
      S6=CFE*CFMU*P2*P
      XN=S1+S2+S3+S4+S5+S6
      XD=(ONE+CFE12*P)**TWO
      X=XN/XD

!    GET THE VALUE FOR FX
      FX=ONE+RKAPPA-RKAPPA/(ONE+(X/RKAPPA))

!    NOW, DERIVATIVES COME
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q

      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

      DALPHAD=THRD5*(ONE/Z-ONE)*DPD-THRD5*P*DZD/Z**TWO
!     DALPHAD=-TAU_RHO*(THREE*PI**TWO*RHO)**THRD2/(TWO*TAU_UNIF**TWO)+   &
!    &   DRHO**TWO/RHO**(11._q/THREE)*(10._q/9._q/(THREE*PI**TWO)**THRD2)

      DALPHADD=THRD5*(ONE/Z-ONE)*DPDD-THRD5*P*DZDD/Z**TWO
!     DALPHADD=-DRHO/(FOUR*RHO*TAU_UNIF)

      DALPHADTAU=-THRD5*P*DZDTAU/Z**TWO
!     DALPHADTAU=ONE/TAU_UNIF

      DQB_NUM_D=9._q/20._q*DALPHAD
      DQB_NUM_DD=9._q/20._q*DALPHADD
      DQB_NUM_DTAU=9._q/20._q*DALPHADTAU
      C_DQB_DEN=ONE/TWO*CFB*(TWO*ALPHA-ONE)/QB_DEN
      DQB_DEN_D=C_DQB_DEN*DALPHAD
      DQB_DEN_DD=C_DQB_DEN*DALPHADD
      DQB_DEN_DTAU=C_DQB_DEN*DALPHADTAU

      DQBD=(DQB_NUM_D*QB_DEN-QB_NUM*DQB_DEN_D)/QB_DEN**TWO+THRD2*DPD
      DQBDD=(DQB_NUM_DD*QB_DEN-QB_NUM*DQB_DEN_DD)/QB_DEN**TWO+THRD2*DPDD
      DQBDTAU=(DQB_NUM_DTAU*QB_DEN-QB_NUM*DQB_DEN_DTAU)/QB_DEN**TWO+THRD2*DPDTAU

      C1_DS1=TWO*CFC*P*Z*(ONE-Z2)/OPZ**THREE
      C2_DS1=(CX1+CFC*Z2/OPZ**TWO)
      DS1D=C1_DS1*DZD+C2_DS1*DPD
      DS1DD=C1_DS1*DZDD+C2_DS1*DPDD
      DS1DTAU=C1_DS1*DZDTAU+C2_DS1*DPDTAU

      C_DS2=CX2*TWO*QB
      DS2D=C_DS2*DQBD
      DS2DD=C_DS2*DQBDD
      DS2DTAU=C_DS2*DQBDTAU

      DFQD=ONE/TWO/FQ*(0.6_q**TWO*Z*DZD+P*DPD)
      DFQDD=ONE/TWO/FQ*(0.6_q**TWO*Z*DZDD+P*DPDD)
      DFQDTAU=ONE/TWO/FQ*(0.6_q**TWO*Z*DZDTAU+P*DPDTAU)
      DS3D=-CX3*(FQ*DQBD+QB*DFQD)
      DS3DD=-CX3*(FQ*DQBDD+QB*DFQDD)
      DS3DTAU=-CX3*(FQ*DQBDTAU+QB*DFQDTAU)

      C_S4=TWO/RKAPPA*CX1**TWO*P
      DS4D=C_S4*DPD
      DS4DD=C_S4*DPDD
      DS4DTAU=C_S4*DPDTAU

      C_S5=FOUR*CFE12*CX1*0.6_q**TWO*Z
      DS5D=C_S5*DZD
      DS5DD=C_S5*DZDD
      DS5DTAU=C_S5*DZDTAU

      C_S6=THREE*CFE*CFMU*P2
      DS6D=C_S6*DPD
      DS6DD=C_S6*DPDD
      DS6DTAU=C_S6*DPDTAU

      C_XD=TWO*(ONE+CFE12*P)*CFE12
      DXD_D=C_XD*DPD
      DXD_DD=C_XD*DPDD
      DXD_DTAU=C_XD*DPDTAU

      DXN_D=DS1D+DS2D+DS3D+DS4D+DS5D+DS6D
      DXN_DD=DS1DD+DS2DD+DS3DD+DS4DD+DS5DD+DS6DD
      DXN_DTAU=DS1DTAU+DS2DTAU+DS3DTAU+DS4DTAU+DS5DTAU+DS6DTAU

      DX_D=(XD*DXN_D-XN*DXD_D)/XD**TWO
!     DX_DD=(XD*DXN_DD-XN*DXD_DD)/XD**TWO
      DX_DD=DXN_DD/XD-X*DXD_DD/XD
      DX_DTAU=(XD*DXN_DTAU-XN*DXD_DTAU)/XD**TWO

      C_FX=ONE/(ONE+X/RKAPPA)**TWO
      DFX_D=C_FX*DX_D
      DFX_DD=C_FX*DX_DD
      DFX_DTAU=C_FX*DX_DTAU

!   OUTPUT THE VXD1,VXDD1 AND AMUXD1
      VXD1=EXDLDA*FX+EXLDA*DFX_D
      VXDD1=EXLDA*DFX_DD
      AMUXD1=EXLDA*DFX_DTAU
      EX_REVTPSS=0._q
      EX_REVTPSS=EX_REVTPSS+EXLDA*FX

! spin down
! IN EXD1(2*RD), TAUWD AND TAUD SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RD
      DRHO=TWO*DRD
      TAUW_RHO=TWO*TAUWD_TEMP
      TAU_RHO=TWO*TAUD

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|

      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P
      Z=TAUW_RHO/TAU_RHO
! test
      !Z=max(min(Z,0.9999999999999_q),1.E-20_q)
#ifdef Zmethod1
      IF (Z>1) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=1
      ELSE IF(Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
      ENDIF
#endif
#ifdef Zmethod2
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
         DZTILDEDZ=1._q/(1._q+Z**xorder)**(1._q/xorder) - Z**xorder/(1._q+Z**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
         Z=Z/(1._q+Z**xorder)**(1._q/xorder)
      ENDIF
#endif
#ifdef Zmethod3
      IF (Z<0) THEN
        DZTILDEDZ=0
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=0
      ELSE
        DZTILDEDZ=1._q/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder) - (Z/zinfinity)**xorder/(1._q+(Z/zinfinity)**xorder)**(1._q+1._q/xorder)
        DZD=-Z/RHO*DZTILDEDZ
        DZDD=DRHO/(FOUR*RHO*TAU_RHO)*DZTILDEDZ
        DZDTAU=-Z/TAU_RHO*DZTILDEDZ
        Z=Z/(1._q+(Z/zinfinity)**xorder)**(1._q/xorder)
      ENDIF
#endif
! test
      Z2=Z*Z
      Z3=Z2*Z
      ZTF=0.6_q*Z
      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5

!     ALPHA=(TAU_RHO-TAUW_RHO)/TAU0
      ALPHA=5._q/3._q*P*(1._q/Z-1._q)

      QB_NUM=9._q/20._q*(ALPHA-ONE)
      QB_DEN=SQRT(ONE+CFB*ALPHA*(ALPHA-ONE))
      QB=QB_NUM/QB_DEN+ TWO*P/THREE
      OPZ=ONE+Z2
      SFP=Z2/OPZ**TWO
      FQ=SQRT((ZTF**TWO+P2)/TWO)
      S1=(CX1+CFC*SFP)*P
      S2=CX2*QB**TWO
      S3=-CX3*FQ*QB
      S4=(CX1*P)**TWO/RKAPPA
      S5=TWO*CFE12*CX1*ZTF**TWO
      S6=CFE*CFMU*P2*P
      XN=S1+S2+S3+S4+S5+S6
      XD=(ONE+CFE12*P)**TWO
      X=XN/XD

!    GET THE VALUE FOR FX
      FX=ONE+RKAPPA-RKAPPA/(ONE+(X/RKAPPA))

!    NOW, DERIVATIVES COME
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q

      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

      DALPHAD=THRD5*(ONE/Z-ONE)*DPD-THRD5*P*DZD/Z**TWO
!     DALPHAD=-TAU_RHO*(THREE*PI**TWO*RHO)**THRD2/(TWO*TAU_UNIF**TWO)+   &
!    &   DRHO**TWO/RHO**(11._q/THREE)*(10._q/9._q/(THREE*PI**TWO)**THRD2)

      DALPHADD=THRD5*(ONE/Z-ONE)*DPDD-THRD5*P*DZDD/Z**TWO
!     DALPHADD=-DRHO/(FOUR*RHO*TAU_UNIF)

      DALPHADTAU=-THRD5*P*DZDTAU/Z**TWO
!     DALPHADTAU=ONE/TAU_UNIF

      DQB_NUM_D=9._q/20._q*DALPHAD
      DQB_NUM_DD=9._q/20._q*DALPHADD
      DQB_NUM_DTAU=9._q/20._q*DALPHADTAU
      C_DQB_DEN=ONE/TWO*CFB*(TWO*ALPHA-ONE)/QB_DEN
      DQB_DEN_D=C_DQB_DEN*DALPHAD
      DQB_DEN_DD=C_DQB_DEN*DALPHADD
      DQB_DEN_DTAU=C_DQB_DEN*DALPHADTAU

      DQBD=(DQB_NUM_D*QB_DEN-QB_NUM*DQB_DEN_D)/QB_DEN**TWO+THRD2*DPD
      DQBDD=(DQB_NUM_DD*QB_DEN-QB_NUM*DQB_DEN_DD)/QB_DEN**TWO+THRD2*DPDD
      DQBDTAU=(DQB_NUM_DTAU*QB_DEN-QB_NUM*DQB_DEN_DTAU)/QB_DEN**TWO+THRD2*DPDTAU

      C1_DS1=TWO*CFC*P*Z*(ONE-Z2)/OPZ**THREE
      C2_DS1=(CX1+CFC*Z2/OPZ**TWO)
      DS1D=C1_DS1*DZD+C2_DS1*DPD
      DS1DD=C1_DS1*DZDD+C2_DS1*DPDD
      DS1DTAU=C1_DS1*DZDTAU+C2_DS1*DPDTAU

      C_DS2=CX2*TWO*QB
      DS2D=C_DS2*DQBD
      DS2DD=C_DS2*DQBDD
      DS2DTAU=C_DS2*DQBDTAU

      DFQD=ONE/TWO/FQ*(0.6_Q**TWO*Z*DZD+P*DPD)
      DFQDD=ONE/TWO/FQ*(0.6_Q**TWO*Z*DZDD+P*DPDD)
      DFQDTAU=ONE/TWO/FQ*(0.6_Q**TWO*Z*DZDTAU+P*DPDTAU)
      DS3D=-CX3*(FQ*DQBD+QB*DFQD)
      DS3DD=-CX3*(FQ*DQBDD+QB*DFQDD)
      DS3DTAU=-CX3*(FQ*DQBDTAU+QB*DFQDTAU)

      C_S4=TWO/RKAPPA*CX1**TWO*P
      DS4D=C_S4*DPD
      DS4DD=C_S4*DPDD
      DS4DTAU=C_S4*DPDTAU

      C_S5=FOUR*CFE12*CX1*0.6_q**TWO*Z
      DS5D=C_S5*DZD
      DS5DD=C_S5*DZDD
      DS5DTAU=C_S5*DZDTAU

      C_S6=THREE*CFE*CFMU*P2
      DS6D=C_S6*DPD
      DS6DD=C_S6*DPDD
      DS6DTAU=C_S6*DPDTAU

      C_XD=TWO*(ONE+CFE12*P)*CFE12
      DXD_D=C_XD*DPD
      DXD_DD=C_XD*DPDD
      DXD_DTAU=C_XD*DPDTAU

      DXN_D=DS1D+DS2D+DS3D+DS4D+DS5D+DS6D
      DXN_DD=DS1DD+DS2DD+DS3DD+DS4DD+DS5DD+DS6DD
      DXN_DTAU=DS1DTAU+DS2DTAU+DS3DTAU+DS4DTAU+DS5DTAU+DS6DTAU

      DX_D=(XD*DXN_D-XN*DXD_D)/XD**TWO
!     DX_DD=(XD*DXN_DD-XN*DXD_DD)/XD**TWO
      DX_DD=DXN_DD/XD-X*DXD_DD/XD
      DX_DTAU=(XD*DXN_DTAU-XN*DXD_DTAU)/XD**TWO

      C_FX=ONE/(ONE+X/RKAPPA)**TWO
      DFX_D=C_FX*DX_D
      DFX_DD=C_FX*DX_DD
      DFX_DTAU=C_FX*DX_DTAU

!   OUTPUT THE VXD2,VXDD2 AND AMUXD2
      VXD2=EXDLDA*FX+EXLDA*DFX_D
      VXDD2=EXLDA*DFX_DD
      AMUXD2=EXLDA*DFX_DTAU

      EX_REVTPSS=EX_REVTPSS+EXLDA*FX
      EX_REVTPSS=EX_REVTPSS/TWO
      RETURN
      END SUBROUTINE VTPSSx


!***********************************************************************
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VCD1 VCD2                    THE DERIVATIVES OF EC WRT n
! VCDD1,VCDD2                  THE DERIVATIVES OF EC WRT |grad n|
! AMUCD1, AMUCD2                   THE DERIVATIVES OF EC WRT TAU
!
!***********************************************************************

      SUBROUTINE VTPSSc(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_revTPSS,VCD1,VCDD1,VCD2,VCDD2,VCDD12,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the correlatin part
      PARAMETER (CFD=2.8_q)

! other parameters
      PARAMETER (ZERO=0._q)
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
! test
      PARAMETER (thresh=1.e-10_q)
      PARAMETER (xorder=12._q)
      PARAMETER (zinfinity=2._q)
! test

      VCD1=0._q;VCD2=0._q;
      VCDD1=0._q;VCDD2=0._q;VCDD12=0._q
      AMUCD1=0._q;AMUCD2=0._q;

      RT=RU+RD
      YA=DRU**2._q
      YB=DRD**2._q
      Y=DRT**2._q
!    YC IS DEL RU DOT DEL RD
      YC=(Y-YA-YB)/2._q
      TAUW=1._q/8._q*(Y/RT)
      TAU=TAUU+TAUD

      Z=TAUW/TAU
! test
      !Z=max(min(Z,0.9999999999999_q),1.E-20_q)


#ifdef Zmethod1
      DZTILDEDZ=ONE
      IF (Z>ONE.OR.Z<ZERO) DZTILDEDZ=ZERO
      DZD1=-Z/RT*DZTILDEDZ
      DZD2=DZD1
      DZDD12=ONE/FOUR*DRT/(RT*TAU)*DZTILDEDZ
      DZDTAU=-Z/TAU*DZTILDEDZ
      Z = MAX(MIN(ONE,Z),ZERO)
#endif
#ifdef Zmethod2
      IF (Z<ZERO) THEN
        DZTILDEDZ=ZERO
      ELSE
        DZTILDEDZ=ONE/(ONE+Z**xorder)**(ONE/xorder) - Z**xorder/(ONE+Z**xorder)**(ONE+ONE/xorder)
      ENDIF
      DZD1=-Z/RT*DZTILDEDZ
      DZD2=DZD1
      DZDD12=ONE/FOUR*DRT/(RT*TAU)*DZTILDEDZ
      DZDTAU=-Z/TAU*DZTILDEDZ
      Z=MAX(ZERO,Z)
      Z=Z/(1._q+Z**xorder)**(1._q/xorder)
#endif
#ifdef Zmethod3
      IF (Z<ZERO) THEN
        DZTILDEDZ=ZERO
      ELSE
        DZTILDEDZ=ONE/(ONE+(Z/zinfinity)**xorder)**(ONE/xorder) - (Z/zinfinity)**xorder/(ONE+(Z/zinfinity)**xorder)**(ONE+ONE/xorder)
      ENDIF
      DZD1=-Z/RT*DZTILDEDZ
      DZD2=DZD1
      DZDD12=ONE/FOUR*DRT/(RT*TAU)*DZTILDEDZ
      DZDTAU=-Z/TAU*DZTILDEDZ
      Z=MAX(ZERO,Z)
      Z=Z/(ONE+(Z/zinfinity)**xorder)**(ONE/xorder)
#endif
! test
      Z2=Z*Z
      Z3=Z2*Z

      CALL COE_RPKZB_TPSS(RU,RD,DRU,DRD,DRT,CRPKZB,D_CRPKZB_D1,D_CRPKZB_D2,D_CRPKZB_DD1,D_CRPKZB_DD2,D_CRPKZB_DD12)

      CALL CORGGA_TPSS(RU,RD,DRU,DRD,DRT,EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD12)

! EPPGGA2_D1, EPPGGA1_D2 EPPGGA1_DD2 AND EPPGGA2_DD1 ARE ZEROS
      CALL CORGGA_TPSS(RU,ZERO,DRU,ZERO,DRU,EPPGGA1,EPPGGA1_D1,EPPGGA1_D2,EPPGGA1_DD1)
      EPPGGA1_D2=ZERO
      EPPGGA1_DD2=ZERO
      EPPGGA1_DD12=ZERO

      CALL CORGGA_TPSS(RD,ZERO,DRD,ZERO,DRD,EPPGGA2,EPPGGA2_D2,EPPGGA2_D1,EPPGGA2_DD2)
      EPPGGA2_D1=ZERO
      EPPGGA2_DD1=ZERO
      EPPGGA2_DD12=ZERO

      IF (EPPGGA1 .LT. EPPGGA)THEN
          EPPGGA1=EPPGGA
          EPPGGA1_D1=EPPGGA_D1
          EPPGGA1_D2=EPPGGA_D2
          EPPGGA1_DD1=ZERO
          EPPGGA1_DD12=EPPGGA_DD12
      ENDIF

      IF (EPPGGA2 .LT. EPPGGA)THEN
          EPPGGA2=EPPGGA
          EPPGGA2_D1=EPPGGA_D1
          EPPGGA2_D2=EPPGGA_D2
          EPPGGA2_DD2=ZERO
          EPPGGA2_DD12=EPPGGA_DD12
      ENDIF

      WEIRD=(RU*EPPGGA1+RD*EPPGGA2)/RT
      WEIRD_D1=RD*EPPGGA1/RT**TWO+RU/RT*EPPGGA1_D1-RD*EPPGGA2/RT**TWO+RD/RT*EPPGGA2_D1
      WEIRD_D2=-RU*EPPGGA1/RT**TWO+RU/RT*EPPGGA1_D2+RU*EPPGGA2/RT**TWO+RD/RT*EPPGGA2_D2
      WEIRD_DD1=RU/RT*EPPGGA1_DD1+RD/RT*EPPGGA2_DD1
      WEIRD_DD2=RU/RT*EPPGGA1_DD2+RD/RT*EPPGGA2_DD2
      WEIRD_DD12=RU/RT*EPPGGA1_DD12+RD/RT*EPPGGA2_DD12

      EPSC_REVPKZB=EPPGGA*(ONE+CRPKZB*Z2)-(ONE+CRPKZB)*Z2*WEIRD

      FP_D_EPSC_REVPKZB_D1=(ONE+CRPKZB*Z2)*EPPGGA_D1+EPPGGA*(D_CRPKZB_D1*Z2+TWO*Z*CRPKZB*DZD1)
      FP_D_EPSC_REVPKZB_D2=(ONE+CRPKZB*Z2)*EPPGGA_D2+EPPGGA*(D_CRPKZB_D2*Z2+TWO*Z*CRPKZB*DZD2)

      SD_D_EPSC_REVPKZB_D1=D_CRPKZB_D1*Z2*WEIRD+(ONE+CRPKZB)*TWO*Z*DZD1*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_D1
      SD_D_EPSC_REVPKZB_D2=D_CRPKZB_D2*Z2*WEIRD+(ONE+CRPKZB)*TWO*Z*DZD2*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_D2

      D_EPSC_REVPKZB_D1=FP_D_EPSC_REVPKZB_D1-SD_D_EPSC_REVPKZB_D1
      D_EPSC_REVPKZB_D2=FP_D_EPSC_REVPKZB_D2-SD_D_EPSC_REVPKZB_D2

      FP_D_EPSC_REVPKZB_DD1=EPPGGA*D_CRPKZB_DD1*Z2
      FP_D_EPSC_REVPKZB_DD2=EPPGGA*D_CRPKZB_DD2*Z2
      FP_D_EPSC_REVPKZB_DD12=(ONE+CRPKZB*Z2)*EPPGGA_DD12+EPPGGA*(D_CRPKZB_DD12*Z2+TWO*Z*CRPKZB*DZDD12)

      SD_D_EPSC_REVPKZB_DD1=D_CRPKZB_DD1*Z2*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_DD1
      SD_D_EPSC_REVPKZB_DD2=D_CRPKZB_DD2*Z2*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_DD2
      SD_D_EPSC_REVPKZB_DD12=D_CRPKZB_DD12*Z2*WEIRD+(ONE+CRPKZB)*TWO*Z*DZDD12*WEIRD+(ONE+CRPKZB)*Z2*WEIRD_DD12

      D_EPSC_REVPKZB_DD1=FP_D_EPSC_REVPKZB_DD1-SD_D_EPSC_REVPKZB_DD1
      D_EPSC_REVPKZB_DD2=FP_D_EPSC_REVPKZB_DD2-SD_D_EPSC_REVPKZB_DD2
      D_EPSC_REVPKZB_DD12=FP_D_EPSC_REVPKZB_DD12-SD_D_EPSC_REVPKZB_DD12

      D_EPSC_REVPKZB_DTAU=EPPGGA*CRPKZB*TWO*Z*DZDTAU-(ONE+CRPKZB)*TWO*Z*DZDTAU*WEIRD

      VCD1=(EPSC_REVPKZB+RT*D_EPSC_REVPKZB_D1)*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_D1+THREE*Z2*EPSC_REVPKZB*DZD1)

      VCD2=(EPSC_REVPKZB+RT*D_EPSC_REVPKZB_D2)*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_D2+THREE*Z2*EPSC_REVPKZB*DZD2)

      VCDD1=RT*D_EPSC_REVPKZB_DD1*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DD1)

      VCDD2=RT*D_EPSC_REVPKZB_DD2*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DD2)

      VCDD12=RT*D_EPSC_REVPKZB_DD12*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DD12+THREE*Z2*EPSC_REVPKZB*DZDD12)

      AMUCD1=RT*D_EPSC_REVPKZB_DTAU*(ONE+CFD*EPSC_REVPKZB*Z3) &
          & +RT*EPSC_REVPKZB*CFD*(Z3*D_EPSC_REVPKZB_DTAU+THREE*Z2*EPSC_REVPKZB*DZDTAU)
      AMUCD2=AMUCD1

      EC_REVTPSS=RT*EPSC_REVPKZB*(ONE+CFD*EPSC_REVPKZB*Z3)

      RETURN
      END SUBROUTINE VTPSSc


!***********************************************************************
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! CRPKZB                       C(ZETA,XI)
! D_CRPKZB_D1,D_CRPKZB_D2      THE DERIVATIVE OF C(ZETA,XI) WRT n
! D_CRPKZB_DD1,D_CRPKZB_DD2    THE DERIVATIVE OF C(ZETA,XI) WRT |GRAD n|
!
!***********************************************************************

      SUBROUTINE COE_RPKZB_TPSS(&
     &   RU,RD,DRU,DRD,DRT, &
     &   CRPKZB,D_CRPKZB_D1,D_CRPKZB_D2,D_CRPKZB_DD1,D_CRPKZB_DD2,D_CRPKZB_DD12)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the correlatin part
      PARAMETER (CF1=0.53_q)
      PARAMETER (CF2=0.87_q)
      PARAMETER (CF3=0.50_q)
      PARAMETER (CF4=2.26_q)

! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)



      CRPKZB=0._q
      D_CRPKZB_D1=0._q;D_CRPKZB_D2=0._q;
      D_CRPKZB_DD1=0._q;D_CRPKZB_DD2=0._q;D_CRPKZB_DD12=0._q;
      D_CRPKZB_DD12=0._q;

      RT=RU+RD
      YA=DRU**2._q
      YB=DRD**2._q
      Y=DRT**2._q
! YC IS DEL RU DOT DEL RD
      YC=(Y-YA-YB)/2._q

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)
      OPZ = ONE + ZETA
      OMZ = ONE - ZETA
      ZETA2=ZETA*ZETA
      OPZETA=ONE/(ONE+ZETA)
      OMZETA=ONE/(ONE-ZETA)
      D_ZETA_D1=TWO*RD/RT**TWO
      D_ZETA_D2=-TWO*RU/RT**TWO

! |GRAD ZETA|,
! IN SOME EXTREME CASES, THE TERM (YA*RD**TWO-TWO*RU*RD*YC+YB*RU**TWO)
! GOES TO NEGATIVE BECAUSE OF THE NUMERICAL PRESICION OF COMPUTERS. SO, WE USE 2/4 AS THE POWER
! INSTEAD OF 1/2
      DEL_ZETA2 = (TWO*YA*OMZ + TWO*YB*OPZ - OPZ*OMZ*Y)/RT**2
      D_DEL_ZETA2_DYA = TWO*OMZ/RT**2
      D_DEL_ZETA2_DYB = TWO*OPZ/RT**2
      D_DEL_ZETA2_DY = -OPZ*OMZ/RT**2
      D_DEL_ZETA2_DZETA = TWO*(ZETA*Y + YB - YA)/RT**2
      D_DEL_ZETA2_D1 = -TWO*DEL_ZETA2/RT + D_DEL_ZETA2_DZETA*OMZ/RT
      D_DEL_ZETA2_D2 = -TWO*DEL_ZETA2/RT - D_DEL_ZETA2_DZETA*OPZ/RT

! XI
      XIDEN2=4._q*(THREE*PISQ*RT)**THRD2
      XI2=DEL_ZETA2/XIDEN2
      D_XI2_D1=(D_DEL_ZETA2_D1-THRD2*DEL_ZETA2/RT)/XIDEN2
      D_XI2_D2=(D_DEL_ZETA2_D2-THRD2*DEL_ZETA2/RT)/XIDEN2
      D_XI2_DYA=D_DEL_ZETA2_DYA/XIDEN2
      D_XI2_DYB=D_DEL_ZETA2_DYB/XIDEN2
      D_XI2_DY=D_DEL_ZETA2_DY/XIDEN2

      CNUM=CF1+(CF2+(CF3+CF4*ZETA2)*ZETA2)*ZETA2
      D_CNUM_D1=D_ZETA_D1*(TWO*CF2+(FOUR*CF3+SIX*CF4*ZETA2)*ZETA2)*ZETA
      D_CNUM_D2=D_ZETA_D2*(TWO*CF2+(FOUR*CF3+SIX*CF4*ZETA2)*ZETA2)*ZETA

      OPZETA43=OPZETA**THRD4
      OMZETA43=OMZETA**THRD4
      CDENL=ONE+XI2*(OPZETA43+OMZETA43)/TWO
      CDEN=CDENL**FOUR
      D_CDENL_DXI2=(OPZETA43+OMZETA43)/TWO
      D_CDENL_DZETA=-THRD2*XI2*(OPZETA43*OPZETA-OMZETA43*OMZETA)
      D_CDENL_D1=D_CDENL_DXI2*D_XI2_D1+D_CDENL_DZETA*D_ZETA_D1
      D_CDENL_D2=D_CDENL_DXI2*D_XI2_D2+D_CDENL_DZETA*D_ZETA_D2
      D_CDENL_DYA=D_CDENL_DXI2*D_XI2_DYA
      D_CDENL_DYB=D_CDENL_DXI2*D_XI2_DYB
      D_CDENL_DY=D_CDENL_DXI2*D_XI2_DY

      D_CDEN_D1=FOUR*CDENL**THREE*D_CDENL_D1
      D_CDEN_D2=FOUR*CDENL**THREE*D_CDENL_D2
      D_CDEN_DYA=FOUR*CDENL**THREE*D_CDENL_DYA
      D_CDEN_DYB=FOUR*CDENL**THREE*D_CDENL_DYB
      D_CDEN_DY=FOUR*CDENL**THREE*D_CDENL_DY


! OUTPUT CRPKZB,,D_CRPKZB_D1,D_CRPKZB_D2,D_CRPKZB_DD1,D_CRPKZB_DD2
      CRPKZB=CNUM/CDEN
      D_CRPKZB_D1=(CDEN*D_CNUM_D1-CNUM*D_CDEN_D1)/CDEN**TWO
      D_CRPKZB_D2=(CDEN*D_CNUM_D2-CNUM*D_CDEN_D2)/CDEN**TWO
      D_CRPKZB_DD1=-TWO*DRU*CNUM*D_CDEN_DYA/CDEN**TWO
      D_CRPKZB_DD2=-TWO*DRD*CNUM*D_CDEN_DYB/CDEN**TWO
      D_CRPKZB_DD12=-TWO*DRT*CNUM*D_CDEN_DY/CDEN**TWO

      RETURN
      END SUBROUTINE COE_RPKZB_TPSS


!***********************************************************************
!
! Written by Jianwei Sun and Yoon-Suk Kim 06/18/2009
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! EPPGGA                       GGA ENERGY PER PARTICLE
! EPPGGA_D1,EPPGGA_D2          THE DERIVATIVE OF EPPGGA WRT n
! EPPGGA_DD1,EPPGGA_DD2        THE DERIVATIVE OF EPPGGA WRT |GRAD n|
!
!***********************************************************************
      SUBROUTINE CORGGA_TPSS(&
     &   RU,RD,DRU,DRD,DRT, &
     &   EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD12)
!$ACC ROUTINE SEQ

      USE prec
      USE constant

      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)

      PARAMETER (GAMMA=0.03109069086965489503494086371273_q)
      PARAMETER (BETA_mb=0.06672455060314922_q)
!$ACC ROUTINE(CORPBE_tpss) SEQ

      EPPGGA  =0._q
      EPPGGA_D1=0._q
      EPPGGA_D2=0._q
      EPPGGA_DD12=0._q


      RT=RU+RD
      YA=DRU**2._q
      YB=DRD**2._q
      Y=DRT**2._q
!     YC IS DEL RU DOT DEL RD
      YC=(Y-YA-YB)/2._q

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)
      DZETAD1=TWO*RD/RT**TWO
      DZETAD2=-TWO*RU/RT**TWO


      DTHRD=exp(log(RT)*THRD)
      RS=(0.75_q/PI)**THRD/DTHRD
      DRSD1=-THRD/RT*RS
      DRSD2=-THRD/RT*RS


      PHI = (exp((TWO*THRD)*log(1._q+ZETA)) &
                +exp((TWO*THRD)*log(1._q-ZETA)))/2._q
      D_PHI_DZETA=THRD*((ONE+ZETA)**(-THRD)-(ONE-ZETA)**(-THRD))
      D_PHI_D1=D_PHI_DZETA*DZETAD1
      D_PHI_D2=D_PHI_DZETA*DZETAD2

      AFIX_T=SQRT(PI/FOUR)*(9._q*PI/FOUR)**(ONE/SIX)
      S=DRT/(TWO*(THREE*PISQ)**THRD*RT**THRD4)
      DSD1=-THRD4*S/RT
      DSD2=-THRD4*S/RT
      DSDD12 = ONE/(TWO*(THREE*PISQ)**THRD*RT**THRD4)

      T=AFIX_T*S/SQRT(RS)/PHI
      T2 = T*T
      T4 = T2*T2

      DTD1=AFIX_T*(PHI*RS*DSD1-0.5_q*S*PHI*DRSD1-S*RS*D_PHI_D1)/(PHI**TWO*RS**(THREE/TWO))
      DTD2=AFIX_T*(PHI*RS*DSD2-0.5_q*S*PHI*DRSD2-S*RS*D_PHI_D2)/(PHI**TWO*RS**(THREE/TWO))
      DTDD12=AFIX_T*DSDD12/(SQRT(RS)*PHI)

      FK=(3._q*PI*PI)**THRD*DTHRD
      SK = SQRT(4.0_q*FK/PI)
! Only the local part (EC,VCUPLDA,VCDNLDA) are used from the following call to CORPBE
      CALL CORPBE_tpss(RS,ZETA,EC,VCUPLDA,VCDNLDA,PHI,SK, &
           T,H,DVCUP,DVCDN,ECQ,.FALSE.)
! OBTAIN THE CONTRIBUTION FROM LDA PART AND D_EC_DRS AND D_EC_DZETA
!      EPPGGA=EC
!      EPPGGA_D1=(VCUPLDA-EC)/RT
!      EPPGGA_D2=(VCDNLDA-EC)/RT
      D_EC_DZETA=(VCUPLDA-VCDNLDA)/TWO
      D_EC_DRS=(EC-ZETA*D_EC_DZETA-(VCUPLDA+VCDNLDA)/TWO)*THREE/RS

! THE RS DEPENDENCE OF BETA
      BETA = BETA_MB
      D_BETA_DRS=0._q


      PHI3=PHI**THREE
      PON=-EC/(PHI3*gamma)
      W=DEXP(PON)-ONE
      D_W_DRS=-(W+ONE)*D_EC_DRS/(GAMMA*PHI3)
      D_W_DZETA=-(W+ONE)/(GAMMA*PHI3)*(D_EC_DZETA-THREE*EC*D_PHI_DZETA/PHI)


      A=BETA/(GAMMA*W)
      D_A_DRS=(W*D_BETA_DRS-BETA*D_W_DRS)/(GAMMA*W**TWO)
      D_A_DZETA=-BETA*D_W_DZETA/(GAMMA*W**TWO)

      V=A*T2
      D_V_DRS=T2*D_A_DRS
      D_V_DZETA=T2*D_A_DZETA
      D_V_DT=TWO*A*T

      FUNKG=ONE/(ONE+V+V**TWO)
      D_FUNKG_DV=-(ONE+TWO*V)*FUNKG**TWO


      HCORE=ONE+W*(ONE-FUNKG)
      AH=GAMMA*PHI3
      H=AH*DLOG(HCORE)

      DH1=ONE-FUNKG
      DH2=W*D_FUNKG_DV
      D_H_DRS=(DH1*D_W_DRS-DH2*D_V_DRS)*AH/HCORE
      D_H_DZETA=THREE*H*D_PHI_DZETA/PHI+(DH1*D_W_DZETA-DH2*D_V_DZETA)*AH/HCORE
      D_H_DT=(-DH2*D_V_DT)*AH/HCORE

! OUTPUT EPPGGA AND ITS DERIVATIVES EPPGGA_D1,EPPGGA_D2, EPPGGA_DD1, EPPGGA_DD2
      EPPGGA=EC+H
      EPPGGA_D1=D_EC_DRS*DRSD1+D_EC_DZETA*DZETAD1+D_H_DRS*DRSD1+D_H_DZETA*DZETAD1+D_H_DT*DTD1
      EPPGGA_D2=D_EC_DRS*DRSD2+D_EC_DZETA*DZETAD2+D_H_DRS*DRSD2+D_H_DZETA*DZETAD2+D_H_DT*DTD2
      EPPGGA_DD12=D_H_DT*DTDD12

      RETURN
      END SUBROUTINE CORGGA_TPSS


      SUBROUTINE GGASPINCOR_TPSS(D1,D2,DDA,EC)
!$ACC ROUTINE SEQ
!     D1   density up
!     D2   density down
!     DDA  |gradient of the total density|

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (THRD=1._q/3._q)
!$ACC ROUTINE(CORPBE_tpss) SEQ

      D=D1+D2
      DTHRD=exp(log(D)*THRD)
      RS=(0.75_q/PI)**THRD/DTHRD

      ZETA=(D1-D2)/D
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)

      FK=(3._q*PI*PI)**THRD*DTHRD
      SK = SQRT(4.0_q*FK/PI)
      G = (exp((2*THRD)*log(1._q+ZETA)) &
                +exp((2*THRD)*log(1._q-ZETA)))/2._q
      T = DDA/(D*2._q*SK*G)

      CALL CORPBE_tpss(RS,ZETA,ECLDA,ECD1LDA,ECD2LDA,G,SK, &
           T,EC,ECD1,ECD2,ECQ,.TRUE.)

      EC  =(EC  +ECLDA)
      RETURN
      END SUBROUTINE GGASPINCOR_TPSS


! Modified by Adrienn Ruzsinszky
!######################################################################
!----------------------------------------------------------------------
      SUBROUTINE CORPBE_tpss(RS,ZET,EC,VCUP,VCDN,g,sk, &
     &                  T,H,DVCUP,DVCDN,ecdd,lgga)
!$ACC ROUTINE SEQ
!----------------------------------------------------------------------
!  Official PBE correlation code. K. Burke, May 14, 1996.
!  INPUT: RS=SEITZ RADIUS=(3/4pi rho)^(1/3)
!       : ZET=RELATIVE SPIN POLARIZATION = (rhoup-rhodn)/rho
!       : t=ABS(GRAD rho)/(rho*2.*KS*G)  -- only needed for PBE
!       : lgga=flag to do gga (0=>LSD only)
!       : lmetagga=flag to do metagga (revTPSS)
!       : lpot=flag to do potential (0=>energy only)
!  output: ec=lsd correlation energy from [a]
!        : vcup=lsd up correlation potential
!        : vcdn=lsd dn correlation potential
!        : h=NONLOCAL PART OF CORRELATION ENERGY PER ELECTRON
!        : dvcup=nonlocal correction to vcup
!        : dvcdn=nonlocal correction to vcdn
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! References:
! [a] J.P.~Perdew, K.~Burke, and M.~Ernzerhof,
!     {\sl Generalized gradient approximation made simple}, sub.
!     to Phys. Rev.Lett. May 1996.
! [b] J. P. Perdew, K. Burke, and Y. Wang, {\sl Real-space cutoff
!     construction of a generalized gradient approximation:  The PW91
!     density functional}, submitted to Phys. Rev. B, Feb. 1996.
! [c] J. P. Perdew and Y. Wang, Phys. Rev. B {\bf 45}, 13244 (1992).
!----------------------------------------------------------------------
!----------------------------------------------------------------------
      USE prec
      IMPLICIT REAL(q) (A-H,O-Z)
      logical lgga
! thrd*=various multiples of 1/3
! numbers for use in LSD energy spin-interpolation formula, [c](9).
!      GAM= 2^(4/3)-2
!      FZZ=f''(0)= 8/(9*GAM)
! numbers for construction of PBE
!      gamma=(1-log(2))/pi^2
!      bet=coefficient in gradient expansion for correlation, [a](4).
!      eta=small number to stop d phi/ dzeta from blowing up at
!          |zeta|=1.
      parameter(thrd=1._q/3._q,thrdm=-thrd,thrd2=2._q*thrd)
      parameter(sixthm=thrdm/2._q)
      parameter(thrd4=4._q*thrd)
      parameter(GAM=0.5198420997897463295344212145565_q)
      parameter(fzz=8._q/(9._q*GAM))
      parameter(gamma=0.03109069086965489503494086371273_q)
      parameter(bet_mb=0.06672455060314922_q)
      parameter(eta=1.e-12_q)
!$ACC ROUTINE(gcor2) SEQ
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! find LSD energy contributions, using [c](10) and Table I[c].
! EU=unpolarized LSD correlation energy
! EURS=dEU/drs
! EP=fully polarized LSD correlation energy
! EPRS=dEP/drs
! ALFM=-spin stiffness, [c](3).
! ALFRSM=-dalpha/drs
! F=spin-scaling factor from [c](9).
! construct ec, using [c](8)
      rtrs=dsqrt(rs)
      CALL gcor2(0.0310907_q,0.21370_q,7.5957_q,3.5876_q,1.6382_q, &
     &    0.49294_q,rtrs,EU,EURS)
      CALL gcor2(0.01554535_q,0.20548_q,14.1189_q,6.1977_q,3.3662_q, &
     &    0.62517_q,rtRS,EP,EPRS)
      CALL gcor2(0.0168869_q,0.11125_q,10.357_q,3.6231_q,0.88026_q, &
     &    0.49671_q,rtRS,ALFM,ALFRSM)
      ALFC = -ALFM
      Z4 = ZET**4
      F=((1._q+ZET)**THRD4+(1._q-ZET)**THRD4-2._q)/GAM
      EC = EU*(1._q-F*Z4)+EP*F*Z4-ALFM*F*(1._q-Z4)/FZZ
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! LSD potential from [c](A1)
! ECRS = dEc/drs [c](A2)
! ECZET=dEc/dzeta [c](A3)
! FZ = dF/dzeta [c](A4)
      ECRS = EURS*(1._q-F*Z4)+EPRS*F*Z4-ALFRSM*F*(1._q-Z4)/FZZ
      FZ = THRD4*((1._q+ZET)**THRD-(1._q-ZET)**THRD)/GAM
      ECZET = 4._q*(ZET**3)*F*(EP-EU+ALFM/FZZ)+FZ*(Z4*EP-Z4*EU &
     &        -(1._q-Z4)*ALFM/FZZ)
      COMM = EC -RS*ECRS/3._q-ZET*ECZET
      VCUP = COMM + ECZET
      VCDN = COMM - ECZET
!write(*,*)'rs,VCUP,VCDN',rs,VCUP,VCDN
      if (.not.lgga) return
!----------------------------------------------------------------------
! PBE correlation energy
! G=phi(zeta), given after [a](3)
! DELT=bet/gamma
! B=A of [a](8)
!  in TPSS beta is rs-independent
!      bet = bet_mb*(1._q + 0.1_q*RS)/(1._q + 0.1778_q*RS)
       bet = bet_mb

      delt=bet/gamma
      G3 = G**3
      PON=-EC/(G3*gamma)
      B = DELT/(DEXP(PON)-1._q)
      B2 = B*B
      T2 = T*T
      T4 = T2*T2
      RS2 = RS*RS
      RS3 = RS2*RS
      Q4 = 1._q+B*T2
      Q5 = 1._q+B*T2+B2*T4
      H = G3*(BET/DELT)*DLOG(1._q+DELT*Q4*T2/Q5)
!----------------------------------------------------------------------
!----------------------------------------------------------------------
! ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
      G4 = G3*G
      T6 = T4*T2
      RSTHRD = RS/3._q
      GZ=(((1._q+zet)**2+eta)**sixthm- &
     &((1._q-zet)**2+eta)**sixthm)/3._q
      FAC = DELT/B+1._q
      BG = -3._q*B2*EC*FAC/(BET*G4)
      BEC = B2*FAC/(BET*G3)
      Q8 = Q5*Q5+DELT*Q4*Q5*T2
      Q9 = 1._q+2._q*B*T2
      hB = -BET*G3*B*T6*(2._q+B*T2)/Q8
      hRS = -RSTHRD*hB*BEC*ECRS
      hZ = 3._q*GZ*h/G + hB*(BG*GZ+BEC*ECZET)
      hT = 2._q*BET*G3*Q9/Q8
      COMM = H+HRS-7.0_q*T2*HT/6._q
      PREF = HZ-GZ*T2*HT/G
      COMM = COMM-PREF*ZET
      DVCUP = COMM + PREF
      DVCDN = COMM - PREF
      ecdd=0.5_q/(sk*g)*t*ht
      RETURN
      END SUBROUTINE CORPBE_tpss


!************************ SUBROUTINE M06 family ****************************
!
! calculates the first order derivatives of Ex wrt n, tau, and |grad(n)|
! Zhao & Truhlar TCA (2008)
!
! Written by Yan Zhao 09/22/2011
!
! everything in Hartree units
!
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VXD1 VXD2                    THE DERIVATIVES OF EX WRT n
! VXDD1,VXDD2                  THE DERIVATIVES OF EX WRT |grad n|
! AMUXD1, AMUXD2               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE VM06x(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ex_M06,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2,IJZY)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (TWO=2._q)
!$ACC ROUTINE(M6X,VS98X) SEQ

      STAUU = TAUU*TWO
      STAUD = TAUD*TWO
      Ex_M06 = 0._q
      EM6U  = 0._q
      EVSXU = 0._q
      EM6D  = 0._q
      EVSXD = 0._q
      VXD1=0._q;VXD2=0._q;
      VXDD1=0._q;VXDD2=0._q;
      AMUXD1=0._q;AMUXD2=0._q;

      CALL M6X(EM6U,RU,DRU,STAUU,EM6D1,EM6DD1,EM6AMUXD1,IJZY)
      CALL VS98X(EVSXU,RU,DRU,STAUU,VSD1,VSDD1,VSAMUXD1,IJZY+1)

      CALL M6X(EM6D,RD,DRD,STAUD,EM6D2,EM6DD2,EM6AMUXD2,IJZY)
      CALL VS98X(EVSXD,RD,DRD,STAUD,VSD2,VSDD2,VSAMUXD2,IJZY+1)

      Ex_M06 = EM6U + EVSXU + EM6D + EVSXD
      VXD1 = EM6D1 + VSD1
      VXD2 = EM6D2 + VSD2
!  EM6DD and VSDD are  DERIVATIVES OF EX WRT |grad n|^2
!  so We need to multiply them by 2*|grad n|
      VXDD1 = (EM6DD1 + VSDD1)*TWO*DRU
      VXDD2 = (EM6DD2 + VSDD2)*TWO*DRD
! EM6AMUXD and VSAMUXD are  DERIVATIVES OF EX WRT 2Tau
! so We need to multiply them by 2
      AMUXD1 = (EM6AMUXD1 + VSAMUXD1)*TWO
      AMUXD2 = (EM6AMUXD2 + VSAMUXD2)*TWO

      RETURN
      END SUBROUTINE VM06x

!************************ SUBROUTINE M06 family ****************************
!
! calculates the first order derivatives of Ex wrt n, tau, and |grad(n)|
! Zhao & Truhlar TCA (2008)
!
! Written by Yan Zhao 09/22/2011
!
! everything in Hartree units
!
!
! R                     density up,down
! DR                    abs. val. gradient of density up/down
! TAU                   kinetic energy density up/down
! M6D                   THE DERIVATIVES OF EX WRT n
! M6DD                  THE DERIVATIVES OF EX WRT |grad n|
! M6AMUXD               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE M6X(EM6,R,DR,TAU,EM6D,EM6DD,EM6AMUXD,IJZY)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the coefficients
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (SEVEN=7._q)
      PARAMETER (EIGHT=8._q)
      PARAMETER (NINE=9._q)

!      PI    = FOUR*ATAN(ONE)
      F1O3  = ONE / THREE
      F1O4  = ONE / FOUR
      F1O8  = ONE / EIGHT
      F2O3  = TWO / THREE
      F3O2  = THREE / TWO
      F4O3  = FOUR / THREE
      F4O9  = FOUR / NINE
      F3O5  = THREE / FIVE
      F5O3  = FIVE / THREE
      F5O2  = FIVE / TWO
      F7O3  = SEVEN / THREE
      F8O27 = EIGHT / ( THREE * NINE )
      F12   = TWO * SIX
      F18   = TWO * NINE
      F10 = TWO*FIVE
      F11 = 11._q
      DTol = 1.0e-10_q


!
!     PBE FUNCTIONAL'S PARAMETERS.
!
      C1     = 3.36116e-03_q
      C2     = 4.49267e-03_q
!     PARAMETERS FOR M06-L
      IF (IJZY.EQ.1) THEN
        AT0=    3.987756e-01_q
        AT1=    2.548219e-01_q
        AT2=    3.923994e-01_q
        AT3=    -2.103655e+00_q
        AT4=    -6.302147e+00_q
        AT5=    1.097615e+01_q
        AT6=    3.097273e+01_q
        AT7=    -2.318489e+01_q
        AT8=    -5.673480e+01_q
        AT9=    2.160364e+01_q
        AT10=   3.421814e+01_q
        AT11=   -9.049762e+00_q
       ELSEIF (IJZY.EQ.2) THEN
!     PARAMETERS FOR M06-HF
        AT0=    1.179732e-01_q
        AT1=    -1.066708e+00_q
        AT2=    -1.462405e-01_q
        AT3=    7.481848e+00_q
        AT4=    3.776679e+00_q
        AT5=    -4.436118e+01_q
        AT6=    -1.830962e+01_q
        AT7=    1.003903e+02_q
        AT8=    3.864360e+01_q
        AT9=    -9.806018e+01_q
        AT10=   -2.557716e+01_q
        AT11=   3.590404e+01_q
       ELSEIF (IJZY.EQ.3) THEN
!     PARAMETERS FOR M06
        AT0=    5.877943e-01_q
        AT1=    -1.371776e-01_q
        AT2=    2.682367e-01_q
        AT3=    -2.515898e+00_q
        AT4=    -2.978892e+00_q
        AT5=    8.710679e+00_q
        AT6=    1.688195e+01_q
        AT7=    -4.489724e+00_q
        AT8=    -3.299983e+01_q
        AT9=    -1.449050e+01_q
        AT10=   2.043747e+01_q
        AT11=   1.256504e+01_q
       ELSEIF (IJZY.EQ.4) THEN
!     PARAMETERS FOR M06-2X
        AT0=    4.600000e-01_q
        AT1=    -2.206052e-01_q
        AT2=    -9.431788e-02_q
        AT3=    2.164494e+00_q
        AT4=    -2.556466e+00_q
        AT5=    -1.422133e+01_q
        AT6=    1.555044e+01_q
        AT7=    3.598078e+01_q
        AT8=    -2.722754e+01_q
        AT9=    -3.924093e+01_q
        AT10=   1.522808e+01_q
        AT11=   1.522227e+01_q
      ENDIF


      IF ((R .GT. DTol) .AND. (Tau .GT. DTol)) THEN
        Ax = -F3o2*(F4o3*PI)**(-F1o3)
        RHOO = R
        RHO43 = RHOO**F4O3
        RRHO = ONE/RHOO       ! RECIPROCAL OF RHO
        RHO13 = RHO43*RRHO
        RHO53 = RHOO**F5O3
        TAUN = TAU
        TAUUEG=F3O5*((SIX*PI*PI)**F2O3)*RHO53
        TSIG =TAUUEG/TAUN

        WSIG =(TSIG-ONE)/(TSIG+ONE)
        FSIG=(AT0 + WSIG*(AT1 + WSIG*(AT2 + WSIG*(AT3 + WSIG*( &
     &            AT4 + WSIG*(AT5 + WSIG*(AT6 + WSIG*(AT7 + WSIG*( &
     &            AT8 + WSIG*(AT9 + WSIG*(AT10+WSIG*AT11)))))))))))
        Gamma = DR
        X = GAMMA/RHO43
        X2 = X*X
        EN = C1*X2
        ED = ONE + C2*X2
        E  = -EN/ED
        EM6=(AX+E)*FSIG*RHO43

        DEN   = TWO*C1*X
        DED   = TWO*C2*X
        DE    = -(DEN*ED-EN*DED)/(ED*ED)
        DFDW=(AT1 + WSIG*(TWO  *AT2 + WSIG*(THREE*AT3 + WSIG*( &
     &           FOUR *AT4 + WSIG*(FIVE *AT5 + WSIG*(SIX  *AT6 + WSIG*(&
     &           SEVEN*AT7 + WSIG*(EIGHT*AT8 + WSIG*(NINE *AT9 + WSIG*(&
     &           F10 *AT10+ WSIG*F11*AT11))))))))))
         DWDT = TWO/((ONE + TSIG)**2)
         DTDR = ((SIX*PI*PI)**F2O3)*(RHOO**F2O3)/TAUN
         DTDTAU = -TAUUEG/TAUN**2
         DGGADR = F4O3*RHO13*(AX+(E-X*DE))
         DFDR = DFDW*DWDT*DTDR
         DFDTAU=DFDW*DWDT*DTDTAU
         DGGADG =DE/(TWO*GAMMA)
!       DGGADG =(DE/(TWO*GAMMA))

!        DF/DRHOA
         EM6D = DGGADR*FSIG + (AX+E)*RHO43*DFDR
!        DF/DGAMMAAA
         EM6DD = DGGADG*FSIG
!        DF/DTAUA
         EM6AMUXD = RHO43*(AX+E)*DFDTAU
      ELSE
         EM6= 0._q
         EM6D = 0._q
         EM6DD = 0._q
         EM6AMUXD = 0._q
      ENDIF
      RETURN
      END SUBROUTINE M6X

!************************ SUBROUTINE VS98 family ****************************
!
! calculates the first order derivatives of Ex wrt n, tau, and |grad(n)|
! Zhao & Truhlar TCA (2008)
!
! Written by Yan Zhao 09/22/2011
!
! everything in Hartree units
!
!
! R                     density up,down
! DR                    abs. val. gradient of density up/down
! TAU                   kinetic energy density up/down
! VSD                   THE DERIVATIVES OF EX WRT n
! VSDD                  THE DERIVATIVES OF EX WRT |grad n|
! VSAMUXD               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE VS98X(EVS,R,DR,TAU,VSD,VSDD,VSAMUXD,IJZY)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

      REAL(q) KX,NINE

!      PARAMETER( PI = 3.1415926535897932384626433832795_q )

      PARAMETER (CF = 9.115599720_q)
      PARAMETER (AXLSDA = -0.9305257363491_q)
      PARAMETER (GG  = 0.00186726_q)
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (SEVEN=7._q)
      PARAMETER (EIGHT=8._q)
      PARAMETER (NINE=9._q)
      PARAMETER (F10=10._q)
      PARAMETER (F11=11._q)
!$ACC ROUTINE(GVT4) SEQ

      DTol = 1.0e-10_q
!      IF ((R .LT. DTol) .OR. (Tau .LT. DTol)) Return
      F13 = ONE/THREE
      F43 = FOUR/THREE
      F53 = FIVE/THREE
      F83 = EIGHT/THREE
      F113 = F11/THREE
      F3O5 = THREE/FIVE
      F2O3 = TWO/THREE

      IF (IJZY.EQ.1) THEN

!     PARAMETERS FOR VS98

        R1=  -9.800683E-01_q
        R2=  -3.556788E-03_q
        R3=   6.250326E-03_q
        R4=  -2.354518E-05_q
        R5=  -1.282732E-04_q
        R6=   3.574822E-04_q
      ELSEIF (IJZY.EQ.2) THEN

!     PARAMETERS FOR M06-L

        R1 =   6.012244E-01_q*AXLSDA
        R2 =   4.748822E-03_q*AXLSDA
        R3 =  -8.635108E-03_q*AXLSDA
        R4 =  -9.308062E-06_q*AXLSDA
        R5 =   4.482811E-05_q*AXLSDA
        R6 =   0.000000E+00_q
      ELSEIF (IJZY.EQ.3) THEN

!     PARAMETERS FOR M06-HF

        R1 =   -1.179732E-01_q*AXLSDA
        R2 =   -2.500000E-03_q*AXLSDA
        R3 =   -1.180065E-02_q*AXLSDA
        R4 =   0.000000E+00_q
        R5 =   0.000000E+00_q
        R6 =   0.000000E+00_q
      ELSEIF (IJZY.EQ.4) THEN

!     PARAMETERS FOR M06

        R1 =   1.422057E-01_q*AXLSDA
        R2 =   7.370319E-04_q*AXLSDA
        R3 =   -1.601373E-02_q*AXLSDA
        R4 =   0.000000E+00_q
        R5 =   0.000000E+00_q
        R6 =   0.000000E+00_q
      ENDIF

      IF ((R .GT. DTol) .AND. (Tau .GT. DTol)) THEN
        RHOO = R
        RHO43 = RHOO**F43
        RRHO = ONE/RHOO       ! RECIPROCAL OF RHO
        RHO13 = RHO43*RRHO
        RHO53 = RHOO**F53
        TAUN =  TAU
        TAUUEG=F3O5*((SIX*PI*PI)**F2O3)*RHO53
        TSIG = TAUUEG/TAUN

        RHO83 = RHO53*RHOO
        GAMMA = DR*DR
        X = GAMMA/RHO83
        DXDR = -F83*X*RRHO
        DXDG = ONE/RHO83
        Z = TAUN/RHO53 - CF
        DZDR = -F53 * TAUN/RHO83
        DZDT = ONE/RHO53
        KX = ONE + GG*X + GG*Z
        XK = X/KX
        ZK = Z/KX
        CALL GVT4(GX,DGDX,DGDZ,XK,ZK,KX,GG,R1,R2,R3,R4,R5,R6)
        EVS =  RHO43*GX
        VSD =  F43*RHO13*GX + RHO43*(DGDX*DXDR + DGDZ*DZDR)
        VSDD =  RHO43*(DGDX*DXDG)
        VSAMUXD =  RHO43*(DGDZ*DZDT)
      ELSE
        EVS = 0._q
        VSD = 0._q
        VSDD = 0._q
        VSAMUXD = 0._q
      ENDIF

      RETURN
      END SUBROUTINE VS98X


      SUBROUTINE GVT4(GVT,DG_DX,DG_DZ,XG,ZG,GAMA,CT,A,B,C,D,E,F)
!$ACC ROUTINE SEQ
       USE prec
       USE constant
       IMPLICIT REAL(q) (A-H,O-Z)
!    SOME WORKING VARIABLES
       PARAMETER (F1= 1._q)
       PARAMETER (F2= 2._q)
       PARAMETER (F3= 3._q)


       G=GAMA
       G2=GAMA*GAMA

       GVT =(A + B*XG + C*ZG + D*XG*XG + E*ZG*XG + F*ZG*ZG)/G
       DG_DX =(-A*CT+B*(F1-F2*CT*XG)-F2*C*ZG*CT+D*(F2*XG-F3*XG*XG*CT) &
     &  +E*(ZG -F3*ZG*XG*CT)-F3*F*ZG*ZG*CT )/G2
       DG_DZ =(-A*CT -F2*B*XG*CT +C*(F1-F2*ZG*CT)-F3*D*XG*XG*CT &
     &  +E*(XG-F3*XG*ZG*CT)+F*(F2*ZG-F3*ZG*ZG*CT))/G2

       RETURN
       END SUBROUTINE GVT4


!************************ SUBROUTINE M06 family ****************************
!
! calculates the first order derivatives of Ex wrt n, tau, and |grad(n)|
! Zhao & Truhlar TCA (2008)
!
! Written by Yan Zhao 09/22/2011
!
! everything in Hartree units
!
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VXD1 VXD2                    THE DERIVATIVES OF EX WRT n
! VXDD1,VXDD2                  THE DERIVATIVES OF EX WRT |grad n|
! AMUXD1, AMUXD2               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE VM06c(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_M06,VCD1,VCDD1,VCD2,VCDD2,AMUCD1,AMUCD2,IJZY)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (F1=1._q)
      PARAMETER (F2=2._q)
      PARAMETER (F3=3._q)
      PARAMETER (F4=4._q)
      PARAMETER (COpp=0.0031_q)
!$ACC ROUTINE(VS98C,M06CSS,CORPBE) SEQ
      IF (IJZY.EQ.1) THEN
!     PARAMETERS FOR M06-L CORRELATION
         SOPP0= 6.042374e-01_q
         SOPP1= 1.776783e+02_q
         SOPP2= -2.513252e+02_q
         SOPP3= 7.635173e+01_q
         SOPP4= -1.255699e+01_q
      ELSEIF (IJZY.EQ.2) THEN
!     PARAMETERS FOR M06-HF CORRELATION
         SOPP0= 1.674634e+00_q
         SOPP1= 5.732017e+01_q
         SOPP2= 5.955416e+01_q
         SOPP3= -2.311007e+02_q
         SOPP4= 1.255199e+02_q
      ELSEIF (IJZY.EQ.3) THEN
!     PARAMETERS FOR M06 CORRELATION
         SOPP0= 3.741539e+00_q
         SOPP1= 2.187098e+02_q
         SOPP2= -4.531252e+02_q
         SOPP3= 2.936479e+02_q
         SOPP4= -6.287470e+01_q
      ELSEIF (IJZY.EQ.4) THEN
!     PARAMETERS FOR M06-2X CORRELATION
         SOPP0= 8.833596e-01_q
         SOPP1= 3.357972e+01_q
         SOPP2= -7.043548e+01_q
         SOPP3= 4.978271e+01_q
         SOPP4= -1.852891e+01_q
      ENDIF
      DTol = 1.0e-8_q
      Ec_M06=0._q
      VCD1=0._q;VCD2=0._q;
      VCDD1=0._q;VCDD2=0._q;
      AMUCD1=0._q;AMUCD2=0._q;


      CALL VS98C(DTol, &
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_VS,VSD1,VSDD1,VSD2,VSDD2,VSAMUCD1,VSAMUCD2,IJZY+1)

!      PI = F4*ATAN(F1)
      F6=6.0D0
      F43 = F4 / F3
      PI34 = F3 / (F4*PI)
      F13 = F1 / F3

!     parallel spin case UP
        PA = RU
      IF (RU .GT. DTol .AND. TAUU .GT. DTol) THEN
        GAA = DRU*DRU
        TAUA = F2*TAUU
        CALL M06CSS(DTol,PA,GAA,TAUA,FA,FPA,FGA,FTA,EUA, &
     &                CHIA,EUPA,CHIAP,CHIAG,IJZY)
      ELSE
        FA = 0._q
        FPA = 0._q
        FGA = 0._q
        FTA = 0._q
        EUA = 0._q
        CHIA = 0._q
        EUPA = 0._q
        CHIAP = 0._q
        CHIAG = 0._q
      ENDIF
!     parallel spin case DOWN
      PB = RD
      IF (RD .GT. DTol .AND. TAUD .GT. DTol) THEN
      GBB = DRD*DRD
      TAUB= F2*TAUD
      CALL M06CSS(DTol,PB,GBB,TAUB,FB,FPB,FGB,FTB,EUB, &
     &                CHIB,EUPB,CHIBP,CHIBG,IJZY)

       ELSE
        FB = 0._q
        FPB = 0._q
        FGB = 0._q
        FTB = 0._q
        EUB = 0._q
        CHIB = 0._q
        EUPB = 0._q
        CHIBP = 0._q
        CHIBG = 0._q
      ENDIF

!    antiparallel spin case
        P = PA + PB
!      IF (PB.GT.DTol.AND.PA.GT.DTol.AND.TAUA.GT.DTol.AND.TAUB.GT.DTol) THEN
       IF (PB.GT.DTol.AND.PA.GT.DTol) THEN
        RS = (PI34/P) ** F13
        RSP = -RS/(F3*P)
        ZETA = (PA-PB)/P
        DZDA = (F1-ZETA)/P
        DZDB = (-F1-ZETA)/P
!        CALL LSDAC(RS,ZETA,POTLC,DLDS,DLDZ,D2LDSS,D2LDSZ, &
!     &      D2LDZZ)

! Only the local part (EC,VCUPLDA,VCDNLDA) are used from the following call to CORPBE
       CALL CORPBE(RS,ZETA,PotLC,VCUPLDA,VCDNLDA,unknown,unknown, &
         &        unknown,unknown,unknown,unknown,unknown,.FALSE.)
! OBTAIN THE CONTRIBUTION FROM LDA PART AND D_EC_DRS AND D_EC_DZETA
!      EPPGGA=PotLC
!      EPPGGA_D1=(VCUPLDA-PotLC)/RT
!      EPPGGA_D2=(VCDNLDA-PotLC)/RT
       dLdz=(VCUPLDA-VCDNLDA)/F2
       dLdS=(PotLC-ZETA*dLdZ-(VCUPLDA+VCDNLDA)/F2)*F3/RS

        EUEG = P*POTLC - EUA - EUB
        U = COPP*(CHIA+CHIB)/(F1 + COPP*(CHIA+CHIB))
        W = SOPP0+U*(SOPP1+U*(SOPP2+U*(SOPP3+U*SOPP4)))
        EAB = EUEG*W
        DUDCHIA =COPP/(F1 + COPP*(CHIA+CHIB))**2
        DUDCHIB =COPP/(F1 + COPP*(CHIA+CHIB))**2
        DUDPA= DUDCHIA*CHIAP
        DUDPB= DUDCHIB*CHIBP
        DUDGA= DUDCHIA*CHIAG
        DUDGB= DUDCHIB*CHIBG
        DWDU =SOPP1+U*(F2*SOPP2+U*(F3*SOPP3+U*F4*SOPP4))
        DWDPA= DWDU*DUDPA
        DWDPB= DWDU*DUDPB
        DWDGA= DWDU*DUDGA
        DWDGB= DWDU*DUDGB
        EUEGPA = POTLC + P*DLDS*RSP + P*DLDZ*DZDA - EUPA
        EUEGPB = POTLC + P*DLDS*RSP + P*DLDZ*DZDB - EUPB
        DEABDPA = EUEGPA*W + EUEG*DWDPA
        DEABDGAA = EUEG*DWDGA
        DEABDPB = EUEGPB*W + EUEG*DWDPB
        DEABDGBB = EUEG*DWDGB
      ELSE
         EAB = 0._q
         DEABDPA = 0._q
         DEABDGAA = 0._q
         DEABDPB = 0._q
         DEABDGBB = 0._q
      ENDIF
      Ec_M06 = FA + FB + EAB + Ec_VS
      VCD1 = FPA + DEABDPA + VSD1
      VCD2 = FPB + DEABDPB + VSD2
      VCDD1 = F2*(FGA + DEABDGAA)*DRU + VSDD1
      VCDD2 = F2*(FGB + DEABDGBB)*DRD + VSDD2
      AMUCD1 = F2 * FTA + VSAMUCD1
      AMUCD2 = F2 * FTB + VSAMUCD2
!debug
!      if (abs(Ec_M06) .gt. 0.00001_q) then
!       write (*,*) "RU, RD, DRU, DRD, TAUU, TAUD", RU, RD, DRU, DRD, TAUU, TAUD
!       write (*,*) " Ec_M061, Ec_VS, Ec_M06", FA + FB + EAB, Ec_VS, Ec_M06
!       write (*,*) "VCD1, VCD2  ", VCD1, VCD2
!       write (*,*) "VCDD1, VCDD2 =", VCDD1, VCDD2
!       write (*,*) "AMUCD1,  AMUCD2 = ", AMUCD1,  AMUCD2
!       write (*,*) "VSD1,  VSD2", VSD1,  VSD2
!       write (*,*) "VSDD1, VSDD2", VSDD1, VSDD2
!       write (*,*) "VSAMUCD1, VSAMUCD2", VSAMUCD1, VSAMUCD2
!       write (*,*) "M06C FPA + DEABDPA", FPA + DEABDPA
!       write (*,*) "M06C FPB + DEABDPB", FPB + DEABDPB
!       write (*,*) "FGA + DEABDGAA", FGA + DEABDGAA
!       write (*,*) "FGB + DEABDGBB", FGB + DEABDGBB
!       write (*,*) "FTA, FTB", FTA, FTB
!       stop
!      ENDIF
      RETURN
      END SUBROUTINE VM06c

      SUBROUTINE M06CSS(DTol,PX,GX,TX,F,FP,FG,FT,EUEG,CHI,EUEGP, &
     &                   CHIP,CHIG,IJZY)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

!     COMPUTE THE SAME-SPIN PART OF THE M06 CORRELATION FUNCTIONAL FOR ONE GRID
!     POINT AND ONE SPIN-CASE.
!
      PARAMETER (ZERO = 0._q)
      PARAMETER (F1=1._q)
      PARAMETER (F2=2._q)
      PARAMETER (F3=3._q)
      PARAMETER (F4=4._q)
      PARAMETER (F5=5._q)
      PARAMETER (F6=6._q)
      PARAMETER (F8=8._q)
      PARAMETER (F11=11._q)
      PARAMETER (CSS = 0.06_q)
      PARAMETER (PT25 = 0.25_q)
!$ACC ROUTINE(CORPBE) SEQ
!
      SS=1._q
      IF (IJZY.EQ.1) THEN
!     PARAMETERS FOR M06-L CORRELATION
         SSS0=  5.349466e-01_q
         SSS1=  5.396620e-01_q
         SSS2=  -3.161217e+01_q
         SSS3=  5.149592e+01_q
         SSS4=  -2.919613e+01_q
      ELSEIF (IJZY.EQ.2) THEN
!     PARAMETERS FOR M06-HF CORRELATION
         SSS0=  1.023254e-01_q
         SSS1=  -2.453783e+00_q
         SSS2=  2.913180e+01_q
         SSS3=  -3.494358e+01_q
         SSS4=  2.315955e+01_q
      ELSEIF (IJZY.EQ.3) THEN
!     PARAMETERS FOR M06 CORRELATION
         SSS0=  5.094055e-01_q
         SSS1=  -1.491085e+00_q
         SSS2=  1.723922e+01_q
         SSS3=  -3.859018e+01_q
         SSS4=  2.845044e+01_q
      ELSEIF (IJZY.EQ.4) THEN
!     PARAMETERS FOR M06-2X CORRELATION
         SSS0=  3.097855e-01_q
         SSS1=  -5.528642e+00_q
         SSS2=  1.347420e+01_q
         SSS3=  -3.213623e+01_q
         SSS4=  2.846742e+01_q
      ENDIF

!      IF ((PX.LE.DTol).OR.(TX.LE.DTol).OR.(GX.LE.DTol))  THEN
       IF ((PX.LE.DTol))  THEN
        EUEG = ZERO
        CHI = ZERO
        EUEGP = ZERO
        CHIP = ZERO
        CHIG = ZERO
        PX = ZERO
        GX = ZERO
        TX = ZERO
        F  = ZERO
        FP = ZERO
        FG = ZERO
        FT = ZERO
      ELSE
!        PI = F4*ATAN(F1)
        PI34 = F3 / (F4*PI)
        F13 = F1 / F3
        F23 = F2 / F3
        F43 = F2 * F23
        F53 = F5 / F3
        F83 = F8 / F3
        F113 = F11 / F3
        FDUEG = (F3/F5)*(F6*PI*PI)**F23
        RS = (PI34/PX) ** F13
!        CALL LSDAC(RS,F1,POTLC,DLDS,DLDZ,D2LDSS,D2LDSZ,D2LDZZ)
! Only the local part (EC,VCUPLDA,VCDNLDA) are used from the following call to CORPBE
       CALL CORPBE(RS,F1,PotLC,VCUPLDA,VCDNLDA,1._q,1._q,1._q,unknown,unknown,unknown,unknown,.FALSE.)
! OBTAIN THE CONTRIBUTION FROM LDA PART AND D_EC_DRS AND D_EC_DZETA
!      EPPGGA=PotLC
!      EPPGGA_D1=(VCUPLDA-PotLC)/RT
!      EPPGGA_D2=(VCDNLDA-PotLC)/RT
       dLdz=(VCUPLDA-VCDNLDA)/F2
       dLdS=(PotLC-F1*dLdZ-(VCUPLDA+VCDNLDA)/F2)*F3/RS
!c        Call lsdac(RS,F1,PotLC,dLdS,dLdZ)^M
!c  End of modification

        EUEG = PX*POTLC
        D = TX - PT25*GX/PX
!        DUEG = FDUEG*PX**F53
        CHI = GX/PX**F83
        U = CSS*CHI/(F1 + CSS*CHI)
        W = SSS0+U*(SSS1+U*(SSS2+U*(SSS3+U*SSS4)))
        FSCC=D/TX
        E = FSCC*W*EUEG
        F = E*SS
        RSP = -RS/(F3*PX)
        CHIG = F1/PX**F83
        CHIP = -F83*CHI/PX
        DFSCCP=PT25*GX/(TX*PX**2)
        DFSCCG=-PT25/(TX*PX)
        DFSCCT=PT25*GX/(PX*TX**2)
        DUDCHI=CSS/((F1+CSS*CHI)**2)
        DWDU=SSS1+U*(F2*SSS2+U*(F3*SSS3+U*F4*SSS4))
        DWDP=DWDU*DUDCHI*CHIP
        DWDG=DWDU*DUDCHI*CHIG
        EUEGP = POTLC + PX*DLDS*RSP
        FP = SS*(DFSCCP*W*EUEG            &
     &                 + FSCC*DWDP*EUEG   &
     &                 + FSCC*W*EUEGP)
        FG = SS*(DFSCCG*W*EUEG            &
     &                 + FSCC*DWDG*EUEG)

        FT = SS*(DFSCCT*W*EUEG)
       ENDIF

       RETURN
       END SUBROUTINE M06CSS



      SUBROUTINE VS98C(DTol, &
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_VS,VSD1,VSDD1,VSD2,VSDD2,VSAMUCD1,VSAMUCD2,IJZY)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      REAL(q) KAB
!     EVALUATE THE INTERPOLATION FUNCTION FOR PW91 LOCAL CORRELATION.
      PARAMETER (F1=1._q)
      PARAMETER (F2=2._q)
      PARAMETER (F3=3._q)
      PARAMETER (F4=4._q)
      PARAMETER (GAB=0.00304966e0_q)
      PARAMETER (CF=9.115599720e0_q)
!$ACC ROUTINE(VS98SS,CORPBE) SEQ


!     PARAMETERS FOR VS98
      IF (IJZY.EQ.1) THEN
              R7=   7.035010e-01_q
              R8=   7.694574e-03_q
              R9=   5.152765e-02_q
              R10=   3.394308e-05_q
              R11=  -1.269420e-03_q
              R12=   1.296118e-03_q
!     PARAMETERS FOR M06-L
      ELSEIF (IJZY.EQ.2) THEN
              R7=      3.957626e-01_q
              R8=      -5.614546e-01_q
              R9=      1.403963e-02_q
              R10=     9.831442e-04_q
              R11=     -3.577176e-03_q
              R12=     0.000000e+00_q
!     PARAMETERS FOR M06-HF
      ELSEIF (IJZY.EQ.3) THEN
              R7=    -6.746338e-01_q
              R8=    -1.534002e-01_q
              R9=    -9.021521e-02_q
              R10=   -1.292037e-03_q
              R11=   -2.352983e-04_q
              R12=   0.000000e+00_q

!     PARAMETERS FOR M06
      ELSEIF (IJZY.EQ.4) THEN
               R7= -2.741539e+00_q
               R8= -6.720113e-01_q
               R9= -7.932688e-02_q
               R10=1.918681e-03_q
               R11=-2.032902e-03_q
               R12=0.000000e+00_q

!     PARAMETERS FOR M06-2X
      ELSEIF (IJZY.EQ.5) THEN
              R7=  1.166404e-01_q
              R8=  -9.120847e-02_q
              R9=  -6.726189e-02_q
              R10= 6.720580e-05_q
              R11= 8.448011e-04_q
              R12= 0.000000e+00_q
      ENDIF
!      PI = F4*ATAN(F1)
      F6=6._q
      F43 = F4 / F3
      PI34 = F3 / (F4*PI)
      F13 = F1 / F3

!     parallel spin case UP
        PA = RU
      IF (RU .GT. DTol .AND. TAUU .GT. DTol) THEN
        GAA = DRU*DRU
        TAUA = F2*TAUU
        CALL VS98SS(DTol,PA,GAA,TAUA,FA,FPA,FGA,FTA,EUA,ZA,&
     &                CHIA,EUPA,CHIAP,CHIAG,ZAP,ZAT,IJZY)
      ELSE
       FA = 0._q
       FPA = 0._q
       FGA = 0._q
       FTA = 0._q
       EUA = 0._q
       ZA = 0._q
       CHIA = 0._q
       EUPA = 0._q
       CHIAP = 0._q
       CHIAG = 0._q
       ZAP = 0._q
       ZAT = 0._q
      ENDIF
!     parallel spin case DOWN
      PB = RD
      IF (RD .GT. DTol .AND. TAUD .GT. DTol) THEN
      GBB = DRD*DRD
      TAUB= F2*TAUD
      CALL VS98SS(DTol,PB,GBB,TAUB,FB,FPB,FGB,FTB,EUB,ZB,&
     &                CHIB,EUPB,CHIBP,CHIBG,ZBP,ZBT,IJZY)
      ELSE
       FB = 0._q
       FPB = 0._q
       FGB = 0._q
       FTB = 0._q
       EUB = 0._q
       ZB = 0._q
       CHIB = 0._q
       EUPB = 0._q
       CHIBP = 0._q
       CHIBG = 0._q
       ZBP = 0._q
       ZBT = 0._q
      ENDIF


!    antiparallel spin case
      P=PA+PB
!      IF (PB.GT.DTol.AND.PA.GT.DTol.AND.TAUA.GT.DTol.AND.TAUB.GT.DTol) THEN
       IF (PB.GT.DTol.AND.PA.GT.DTol) THEN
        RS = (PI34/P) ** F13
        RSP = -RS/(F3*P)
        ZETA = (PA-PB)/P
        DZDA = (F1-ZETA)/P
        DZDB = (-F1-ZETA)/P
!        CALL LSDAC(RS,ZETA,POTLC,DLDS,DLDZ,D2LDSS,D2LDSZ, &
!     &      D2LDZZ)
! Only the local part (EC,VCUPLDA,VCDNLDA) are used from the following call to CORPBE
        CALL CORPBE(RS,ZETA,PotLC,VCUPLDA,VCDNLDA,1._q,1._q,1._q,unknown,unknown,unknown,unknown,.FALSE.)
! OBTAIN THE CONTRIBUTION FROM LDA PART AND D_EC_DRS AND D_EC_DZETA
!      EPPGGA=PotLC
!      EPPGGA_D1=(VCUPLDA-PotLC)/RT
!      EPPGGA_D2=(VCDNLDA-PotLC)/RT
        dLdz=(VCUPLDA-VCDNLDA)/F2
        dLdS=(PotLC-ZETA*dLdZ-(VCUPLDA+VCDNLDA)/F2)*F3/RS

        EUEG = P*POTLC - EUA - EUB
        ZAB = ZA + ZB
        XAB = CHIA+CHIB
        KAB = F1 + GAB*(XAB+ZAB)
        XK = XAB/KAB
        ZK = ZAB/KAB
        CALL GVT4(GCAB,DGDX,DGDZ,XK,ZK,KAB,GAB,R7,R8,R9,R10,R11,R12)
        EAB =  GCAB*EUEG
        DGDPA = DGDX*CHIAP + DGDZ*ZAP
        DGDGA = DGDX*CHIAG
        DGDTA = DGDZ*ZAT
        DGDPB = DGDX*CHIBP + DGDZ*ZBP
        DGDGB = DGDX*CHIBG
        DGDTB = DGDZ*ZBT
        EUEGPA = POTLC + P*DLDS*RSP + P*DLDZ*DZDA - EUPA
        EUEGPB = POTLC + P*DLDS*RSP + P*DLDZ*DZDB - EUPB
        DEABDPA =  (EUEGPA*GCAB + EUEG*DGDPA)
        DEABDPB =  (EUEGPB*GCAB + EUEG*DGDPB)
        DEABDGAA =  EUEG*DGDGA
        DEABDGBB =  EUEG*DGDGB
        DEABDTA =   EUEG*DGDTA
        DEABDTB =   EUEG*DGDTB
      ELSE
        EAB = 0._q
        DEABDPA = 0._q
        DEABDPB = 0._q
        DEABDGAA = 0._q
        DEABDGBB = 0._q
        DEABDTA =  0._q
        DEABDTB =  0._q
      ENDIF
      Ec_VS = EAB + FA + FB
      VSD1 = FPA + DEABDPA
      VSD2 = FPB + DEABDPB
      VSDD1 = F2*(FGA + DEABDGAA)*DRU
      VSDD2 = F2*(FGB + DEABDGBB)*DRD
      VSAMUCD1 = F2 * (FTA + DEABDTA)
      VSAMUCD2 = F2 * (FTB + DEABDTB)

      RETURN
      END SUBROUTINE VS98C


      SUBROUTINE VS98SS(DTol,PX,GX,TX,F,FP,FG,FT,EUEG,Z,CHI,EUEGP, &
     &                   CHIP,CHIG,ZP,ZT,IJZY)
!$ACC ROUTINE SEQ
      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)


!     COMPUTE THE SAME-SPIN PART OF THE M06 CORRELATION FUNCTIONAL FOR ONE GRID
!     POINT AND ONE SPIN-CASE.



      REAL(q) KC
      PARAMETER (ZERO=0._q)
      PARAMETER (ONE=1._q)
      PARAMETER (F1=1._q)
      PARAMETER (F2=2._q)
      PARAMETER (F3=3._q)
      PARAMETER (F4=4._q)
      PARAMETER (F5=5._q)
      PARAMETER (F6=6._q)
      PARAMETER (F8=8._q)
      PARAMETER (F11=11._q)
      PARAMETER (GCC = 0.00515088_q)
      PARAMETER (CF = 9.11559972_q)
      PARAMETER (PT25 = 0.25_q)
!$ACC ROUTINE(CORPBE,GVT4) SEQ

      F4O3 = F4/F3
!     PARAMETERS FOR VS98
      IF (IJZY.EQ.1) THEN
              R13=   3.270912e-01_q
              R14=  -3.228915e-02_q
              R15=  -2.942406e-02_q
              R16=   2.134222e-03_q
              R17=  -5.451559e-03_q
              R18=   1.577575e-02_q
!     PARAMETERS FOR M06-L
      ELSEIF (IJZY.EQ.2) THEN
              R13=   4.650534e-01_q
              R14=   1.617589e-01_q
              R15=   1.833657e-01_q
              R16=   4.692100e-04_q
              R17=  -4.990573e-03_q
              R18=   0.000000e+00_q
!     PARAMETERS FOR M06-HF
      ELSEIF (IJZY.EQ.3) THEN
              R13=   8.976746e-01_q
              R14=  -2.345830e-01_q
              R15=   2.368173e-01_q
              R16=  -9.913890e-04_q
              R17=  -1.146165e-02_q
              R18=   0.000000e+00_q
!     PARAMETERS FOR M06
      ELSEIF (IJZY.EQ.4) THEN
               R13=  4.905945e-01_q
               R14= -1.437348e-01_q
               R15=  2.357824e-01_q
               R16=  1.871015e-03_q
               R17= -3.788963e-03_q
               R18=  0.000000e+00_q
!     PARAMETERS FOR M06-2X
      ELSEIF (IJZY.EQ.5) THEN
              R13=  6.902145e-01_q
              R14=  9.847204e-02_q
              R15=  2.214797e-01_q
              R16= -1.968264e-03_q
              R17= -6.775479e-03_q
              R18=  0.000000e+00_q
      ENDIF

!      IF(PX.LE.DTol.OR.TX.LE.DTol.OR.GX.LE.DTol) THEN
       IF(PX.LE.DTol) THEN
        EUEG = ZERO
        CHI = ZERO
        EUEGP = ZERO
        CHIP = ZERO
        CHIG = ZERO
        PX = ZERO
        GX = ZERO
        TX = ZERO
        F  = ZERO
        FP = ZERO
        FG = ZERO
        FT = ZERO
        Z  = ZERO
        ZP = ZERO
        ZT = ZERO
      ELSE
!        PI = F4*ATAN(F1)
        PI34 = F3 / (F4*PI)
        F13 = F1 / F3
        F23 = F2 / F3
        F43 = F2 * F23
        F53 = F5 / F3
        F83 = F8 / F3
        F113 = F11 / F3
        RHOO = PX
        RRHO = ONE/RHOO
        RHO43 = RHOO**F4O3
        RHO13 = RHO43*RRHO
        RHO53 = RHOO**F53
        RHO83 = RHO53*RHOO

        RS = (PI34/PX) ** F13
!        CALL LSDAC(RS,F1,POTLC,DLDS,DLDZ,D2LDSS,D2LDSZ,D2LDZZ)

! Only the local part (EC,VCUPLDA,VCDNLDA) are used from the following call to CORPBE
        CALL CORPBE(RS,F1,PotLC,VCUPLDA,VCDNLDA,1._q,1._q,1._q,unknown,unknown,unknown,unknown,.FALSE.)
! OBTAIN THE CONTRIBUTION FROM LDA PART AND D_EC_DRS AND D_EC_DZETA
!      EPPGGA=PotLC
!      EPPGGA_D1=(VCUPLDA-PotLC)/RT
!      EPPGGA_D2=(VCDNLDA-PotLC)/RT

        dLdz=(VCUPLDA-VCDNLDA)/F2
        dLdS=(PotLC-F1*dLdZ-(VCUPLDA+VCDNLDA)/F2)*F3/RS
!          Call lsdac(RS,F1,PotLC,dLdS,dLdZ)
!  End of modification
        EUEG = PX*POTLC
        CHI = GX/RHO83
        Z = (TX/RHO53) - CF
        KC = F1 + GCC*(CHI + Z)
        XK = CHI/KC
        ZK = Z/KC
        D = F1 - CHI/(F4*(Z + CF))
        CALL GVT4(GC,DGDX,DGDZ,XK,ZK,KC,GCC,R13,R14,R15,R16,R17,R18)
        E = D*EUEG*GC
!         WRITE (*,*) "CHI, Z, GC", CHI, Z, GC
        F = E
        RSP = -RS/(F3*PX)
        CHIG = F1/PX**F83
        CHIP = -F83*CHI/PX
        ZP = -F53 * TX/RHO83
        ZT =  F1/RHO53
        DZ = CHI/(F4*(Z + CF)*(Z + CF))
        DX = -F1/(F4*(Z + CF))
        DP = DZ*ZP + DX*CHIP
        DG = DX*CHIG
        DT = DZ*ZT
        DGDP = DGDX*CHIP + DGDZ*ZP
        DGDG = DGDX*CHIG
        DGDT = DGDZ*ZT
        EUEGP = POTLC + PX*DLDS*RSP
        FP = DP*EUEG*GC + D*EUEGP*GC + D*EUEG*DGDP
        FG = DG*EUEG*GC + D*EUEG*DGDG
        FT = DT*EUEG*GC + D*EUEG*DGDT
       ENDIF
       RETURN
       END SUBROUTINE VS98SS


!************************ SUBROUTINE MSx family ****************************
!
!***********************************************************************

      SUBROUTINE VMSXx(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ex_revTPSS,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the exchange part
! modified by Jianwei Sun 06/29/2011
      REAL(q) :: RKAPPA
      REAL(q) :: CFC
      PARAMETER (CFD=1.0_q)
      PARAMETER (CFG=0.0_q)
      REAL(q) :: CFE
      PARAMETER (CFMUSO=0.12345679_q)
      PARAMETER (CFMUAK=0.12345679_q)
      PARAMETER (CFN=1.0_q)
      PARAMETER (CFM=1.0_q)

!end of modification

! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (AX=-0.738558766382022405884230032680836_q)

      RKAPPA=MSX_RKAPPA
      CFC=MSX_CFC
      CFE=MSX_CFE

      VXD1=0._q;VXD2=0._q;
      VXDD1=0._q;VXDD2=0._q;
      AMUXD1=0._q;AMUXD2=0._q;


      CX1=10._q/81._q
      CX2=146._q/2025._q
      CX3=73._q/405._q
      CFE12=SQRT(CFE)

! Suspect that TAUWU and TAUWD are not well described. Use TAUW_TEMP=0.125_q*DRT**2/RT
! IF WANT TO TEST TAUW, SIMPLY OVERWRITE TAUW_TEMP BY TAUW
      TAUWU_TEMP=0.125_q*DRU**2._q/RU
!     TAUWU_TEMP=MIN(TAUWU_TEMP,TAUU)

      TAUWD_TEMP=0.125_q*DRD**2._q/RD
!     TAUWD_TEMP=MIN(TAUWD_TEMP,TAUD)

! spin up
! IN EXD1(2*RU), TAUWU AND TAUU SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RU
      DRHO=TWO*DRU
      TAUW_RHO=TWO*TAUWU_TEMP
      TAU_RHO=TWO*TAUU

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|
      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P

      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5
      ALPHA=(TAU_RHO-TAUW_RHO)/TAU0
       FX_PBEsol=ONE+RKAPPA-RKAPPA/(ONE+(CFMUAK*P/RKAPPA))
       FX_SO=ONE+RKAPPA-RKAPPA/(ONE+((CFMUSO*P+CFC)/RKAPPA))

       ALPHA2=ALPHA*ALPHA
       ALPHA3=ALPHA*ALPHA2
       ALPHA4=ALPHA2*ALPHA2
       ALPHA6=ALPHA4*ALPHA2
       OMA=ONE-ALPHA2
       OMA2=OMA*OMA
       OMA3=OMA2*OMA
       OPA=ONE+CFD*ALPHA3+CFE*ALPHA6
       FINT=OMA3/OPA

       FX=FX_PBEsol+FINT*(FX_SO-FX_PBEsol)

!    NOW, DERIVATIVES COME
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q

      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

     DALPHAD=-TAU_RHO*(THREE*PI**TWO*RHO)**THRD2/(TWO*TAU_UNIF**TWO)+   &
    &   DRHO**TWO/RHO**(11._q/THREE)*(10._q/9._q/(THREE*PI**TWO)**THRD2)

     DALPHADD=-DRHO/(FOUR*RHO*TAU_UNIF)

     DALPHADTAU=ONE/TAU_UNIF


! d Falpha / dy
      OPA2=OPA*OPA
      D_FINT_ALPHA=-6._q*ALPHA*OMA2/OPA-(THREE*CFD+6._q*CFE*ALPHA3)*ALPHA2*OMA3/OPA2


      D_FINT_D=D_FINT_ALPHA*DALPHAD
      D_FINT_DD=D_FINT_ALPHA*DALPHADD
      D_FINT_DTAU=D_FINT_ALPHA*DALPHADTAU


      D_FXPBESOL_P=CFMUAK/(ONE+CFMUAK*P/RKAPPA)**TWO
      D_FXSO_P=CFMUSO/(ONE+(CFMUSO*P+CFC)/RKAPPA)**TWO


      COE_FX_P=D_FXPBESOL_P+FINT*(D_FXSO_P-D_FXPBESOL_P)
      DFX_D=COE_FX_P*DPD+(FX_SO-FX_PBEsol)*D_FINT_D
      DFX_DD=COE_FX_P*DPDD+(FX_SO-FX_PBEsol)*D_FINT_DD
      DFX_DTAU=COE_FX_P*DPDTAU+(FX_SO-FX_PBEsol)*D_FINT_DTAU




!   OUTPUT THE VXD1,VXDD1 AND AMUXD1
      VXD1=EXDLDA*FX+EXLDA*DFX_D
      VXDD1=EXLDA*DFX_DD
      AMUXD1=EXLDA*DFX_DTAU
      EX_REVTPSS=0._q
      EX_REVTPSS=EX_REVTPSS+EXLDA*FX

! spin down
! IN EXD1(2*RD), TAUWD AND TAUD SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RD
      DRHO=TWO*DRD
      TAUW_RHO=TWO*TAUWD_TEMP
      TAU_RHO=TWO*TAUD

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|

      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P

      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5

      ALPHA=(TAU_RHO-TAUW_RHO)/TAU0


       FX_PBEsol=ONE+RKAPPA-RKAPPA/(ONE+(CFMUAK*P/RKAPPA))
       FX_SO=ONE+RKAPPA-RKAPPA/(ONE+((CFMUSO*P+CFC)/RKAPPA))

       ALPHA2=ALPHA*ALPHA
       ALPHA3=ALPHA*ALPHA2
       ALPHA4=ALPHA2*ALPHA2
       ALPHA6=ALPHA4*ALPHA2
       OMA=ONE-ALPHA2
       OMA2=OMA*OMA
       OMA3=OMA2*OMA
       OPA=ONE+CFD*ALPHA3+CFE*ALPHA6
       FINT=OMA3/OPA

       FX=FX_PBEsol+FINT*(FX_SO-FX_PBEsol)


!    NOW, DERIVATIVES COME
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q

      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

     DALPHAD=-TAU_RHO*(THREE*PI**TWO*RHO)**THRD2/(TWO*TAU_UNIF**TWO)+   &
    &   DRHO**TWO/RHO**(11._q/THREE)*(10._q/9._q/(THREE*PI**TWO)**THRD2)

     DALPHADD=-DRHO/(FOUR*RHO*TAU_UNIF)

     DALPHADTAU=ONE/TAU_UNIF


! d Falpha / dy
      OPA2=OPA*OPA
      D_FINT_ALPHA=-6._q*ALPHA*OMA2/OPA-(THREE*CFD+6._q*CFE*ALPHA3)*ALPHA2*OMA3/OPA2



      D_FINT_D=D_FINT_ALPHA*DALPHAD
      D_FINT_DD=D_FINT_ALPHA*DALPHADD
      D_FINT_DTAU=D_FINT_ALPHA*DALPHADTAU


      D_FXPBESOL_P=CFMUAK/(ONE+CFMUAK*P/RKAPPA)**TWO
      D_FXSO_P=CFMUSO/(ONE+(CFMUSO*P+CFC)/RKAPPA)**TWO


      COE_FX_P=D_FXPBESOL_P+FINT*(D_FXSO_P-D_FXPBESOL_P)
      DFX_D=COE_FX_P*DPD+(FX_SO-FX_PBEsol)*D_FINT_D
      DFX_DD=COE_FX_P*DPDD+(FX_SO-FX_PBEsol)*D_FINT_DD
      DFX_DTAU=COE_FX_P*DPDTAU+(FX_SO-FX_PBEsol)*D_FINT_DTAU


!   OUTPUT THE VXD2,VXDD2 AND AMUXD2
      VXD2=EXDLDA*FX+EXLDA*DFX_D
      VXDD2=EXLDA*DFX_DD
      AMUXD2=EXLDA*DFX_DTAU

      EX_REVTPSS=EX_REVTPSS+EXLDA*FX
      EX_REVTPSS=EX_REVTPSS/TWO
      RETURN
      END SUBROUTINE VMSXx


      SUBROUTINE VMSXc(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_revTPSS,VCD1,VCD2,VCDD12,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

! the following parameters are given by Perdew et.al.
! the coefficients for the correlatin part
      PARAMETER (CFD=2.8_q)

! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
!$ACC ROUTINE(CORGGA_REVTPSS) SEQ

      VCD1=0._q;VCD2=0._q;
      VCDD12=0._q
      AMUCD1=0._q;AMUCD2=0._q;

      RT=RU+RD

      CALL CORGGA_REVTPSS(RU,RD,DRU,DRD,DRT,EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD12)

      VCD1=EPPGGA+RT*EPPGGA_D1

      VCD2=EPPGGA+RT*EPPGGA_D2

      VCDD12=RT*EPPGGA_DD12


      EC_REVTPSS=RT*EPPGGA


      RETURN
      END SUBROUTINE VMSXc


!************************ SUBROUTINE VSCANx ****************************
!
! calculates the first order derivatives of Ex wrt n and |grad(n)|
! Perdew et. al. PRL (2009)
!
! Written by Jianwei Sun
!
! everything in Hartree units
!
! ATTANTION: Every values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VXD1 VXD2                    THE DERIVATIVES OF EX WRT n
! VXDD1,VXDD2                  THE DERIVATIVES OF EX WRT |grad n|
! AMUXD1, AMUXD2               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************

      SUBROUTINE VSCANx(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ex_SCAN,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)
!$ACC ROUTINE SEQ

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)

      PARAMETER (CFC1X=0.667_q)
      PARAMETER (CFC2X=0.800_q)
      PARAMETER (CFD1X=1.240_q)
      PARAMETER (CFK1=0.065_q)
! other parameters
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (TWO53=TWO**THRD5)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (AX=-0.738558766382022405884230032680836_q)
!$ACC ROUTINE(metaggafx) SEQ

      VXD1=0._q;VXD2=0._q;
      VXDD1=0._q;VXDD2=0._q;
      AMUXD1=0._q;AMUXD2=0._q;


      CX1=10._q/81._q
      CX2=146._q/2025._q
      CX3=73._q/405._q

      TAUREG = SCAN_TAUREG_X

! Suspect that TAUWU and TAUWD are not well described. Use TAUW_TEMP=0.125_q*DRT**2/RT
! IF WANT TO TEST TAUW, SIMPLY OVERWRITE TAUW_TEMP BY TAUW
      TAUWU_TEMP=0.125_q*DRU**2._q/RU
!     TAUWU_TEMP=MIN(TAUWU_TEMP,TAUU)

      TAUWD_TEMP=0.125_q*DRD**2._q/RD
!     TAUWD_TEMP=MIN(TAUWD_TEMP,TAUD)

! spin up
! IN EXD1(2*RU), TAUWU AND TAUU SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RU
      DRHO=TWO*DRU
      TAUW_RHO=TWO*TAUWU_TEMP
      TAU_RHO=TWO*TAUU

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|
      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P

      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q
      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

! If TAUREG=0 and SCAN_ALPREG=0,
! RALPHA = ALPHA and D_RALPHA_DALPHA = 1
! This works for both SCAN and rSCAN
      DENOM = TAU0 + TAUREG
      ALPHA = (TAU_RHO - TAUW_RHO)/DENOM
      DALPHAD = THRD5*TAU0/(RHO*DENOM) * (P-ALPHA)
      DALPHADD = -DRHO/(FOUR*RHO*DENOM)
      DALPHADTAU = ONE/DENOM

      RALPHA = ALPHA**3/(ALPHA**2 + SCAN_ALPREG)
      D_RALPHA_DALPHA = ALPHA/(ALPHA**2 + SCAN_ALPREG) * (3*ALPHA - 2*RALPHA)
      DALPHAD = DALPHAD*D_RALPHA_DALPHA
      DALPHADD = DALPHADD*D_RALPHA_DALPHA
      DALPHADTAU = DALPHADTAU*D_RALPHA_DALPHA

! calculate the exchange enhancement factor and its derivatives wrt p
! and alpha
       call metaggafx(cfc1x,cfc2x,cfd1x,cfk1, &
     & p, ralpha, Fx, fx1p, fx1a, fx2p2, fx2pa, fx2a2)

! Calculate fx DERIVATIVES WRT n, |grad n|, and tau
      DFX_D=fx1p*DPD+fx1a*DALPHAD
      DFX_DD=fx1p*DPDD+fx1a*DALPHADD
      DFX_DTAU=fx1a*DALPHADTAU



!   OUTPUT THE VXD1,VXDD1 AND AMUXD1
      VXD1=EXDLDA*FX+EXLDA*DFX_D
      VXDD1=EXLDA*DFX_DD
      AMUXD1=EXLDA*DFX_DTAU
      EX_SCAN=0._q
      EX_SCAN=EX_SCAN+EXLDA*FX

! spin down
! IN EXD1(2*RD), TAUWD AND TAUD SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RD
      DRHO=TWO*DRD
      TAUW_RHO=TWO*TAUWD_TEMP
      TAU_RHO=TWO*TAUD

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|
      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      P2=P*P

      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5
      DPD=-THRD8*P/RHO
      DPDD=TWO*P/DRHO
      DPDTAU=0._q
      TAU_UNIF=THREE/10._q*(THREE*PI**TWO)**THRD2*RHO**THRD5

! If TAUREG=0 and SCAN_ALPREG=0,
! RALPHA = ALPHA and D_RALPHA_DALPHA = 1
! This works for both SCAN and rSCAN
      DENOM = TAU0 + TAUREG
      ALPHA = (TAU_RHO - TAUW_RHO)/DENOM
      DALPHAD = THRD5*TAU0/(RHO*DENOM) * (P-ALPHA)
      DALPHADD = -DRHO/(FOUR*RHO*DENOM)
      DALPHADTAU = ONE/DENOM

      RALPHA = ALPHA**3/(ALPHA**2 + SCAN_ALPREG)
      D_RALPHA_DALPHA = ALPHA/(ALPHA**2 + SCAN_ALPREG) * (3*ALPHA - 2*RALPHA)
      DALPHAD = DALPHAD*D_RALPHA_DALPHA
      DALPHADD = DALPHADD*D_RALPHA_DALPHA
      DALPHADTAU = DALPHADTAU*D_RALPHA_DALPHA

! calculate the exchange enhancement factor and its derivatives wrt p
! and alpha
       call metaggafx(cfc1x,cfc2x,cfd1x,cfk1, &
     & p, ralpha, Fx, fx1p, fx1a, fx2p2, fx2pa, fx2a2)

! Calculate fx DERIVATIVES WRT n, |grad n|, and tau
      DFX_D=fx1p*DPD+fx1a*DALPHAD
      DFX_DD=fx1p*DPDD+fx1a*DALPHADD
      DFX_DTAU=fx1a*DALPHADTAU



!   OUTPUT THE VXD2,VXDD2 AND AMUXD2
      VXD2=EXDLDA*FX+EXLDA*DFX_D
      VXDD2=EXLDA*DFX_DD
      AMUXD2=EXLDA*DFX_DTAU

      EX_SCAN=EX_SCAN+EXLDA*FX
      EX_SCAN=EX_SCAN/TWO
      RETURN
      END SUBROUTINE VSCANx


      SUBROUTINE metaggafx(cfc1,cfc2,cfd1,cfk1, &
     &            p, a, fx, fx1p, fx1a, fx2p2, fx2pa, fx2a2)
!$ACC ROUTINE SEQ

      IMPLICIT REAL(q) (A-H,O-Z)

      INTEGER I

      REAL(q) :: CREGU(0:7),CREGU1(7),ALPHAI(0:7)
      PARAMETER (CREGU = (/ 1.0_q, -0.667_q, -0.4445555_q, -0.663086601049_q,&
                             &   1.451297044490_q, -0.887998041597_q,          &
                             &   0.234528941479_q, -0.023185843322_q /) )

      PARAMETER (cfk0=0.1740d0)
      PARAMETER (CFA1=4.9479d0)

      PARAMETER (CFMUAK=10.00d0/81.0d0)
      PARAMETER (CFB1=0.156632d0)
      PARAMETER (CFB2=0.12083d0)
      PARAMETER (CFB3=0.5d0)

      PARAMETER (TWO=2.0d0)
      PARAMETER (THREE=3.0d0)
      PARAMETER (FOUR=4.0d0)

      ALPHAI(0) = 1.0_q
      DO I=1,7
        ALPHAI(I) = ALPHAI(I-1)*A
        CREGU1(I) = I*CREGU(I)
      END DO

      fx=0.0d0
      fx1p=0.0d0
      fx1a=0.0d0
      fx2p2=0.0d0
      fx2pa=0.0d0
      fx2a2=0.0d0


      P2=P*P
      oma=1.0d0-a
      oma2=oma*oma

      HX0=1.0d0+CFK0

      cfb4=cfmuak**two/cfk1-0.112654d0
      if (cfb4 .gt. 0.0d0) then
         wfac=cfb4*p2*dexp(-cfb4*p/cfmuak)
         d_wfac_dp=cfb4*p*dexp(-cfb4*p/cfmuak)*(two-cfb4*p/cfmuak)
      else
         wfac=cfb4*p2*dexp(cfb4*p/cfmuak)
         d_wfac_dp=cfb4*p*dexp(cfb4*p/cfmuak)*(two+cfb4*p/cfmuak)
      endif
      vfac=cfb1*p+cfb2*oma*dexp(-cfb3*oma2)
      yfac=cfmuak*p+wfac+vfac**two
      hx1=1.0d0+cfk1-cfk1/(1.0d0+yfac/cfk1)

      FA=0.d0
      d_fa_da=0.d0

      ! SCAN switching function
      if (id_metagga.eq.50) then
        if (a.le.0.998_q) then
          fa = dexp(-cfc1*a/oma)
          d_fa_da = -cfc1*fa/oma2
        else if (a.ge.1.002_q) then
          fa = -cfd1*dexp(cfc2/oma)
          d_fa_da = cfc2*fa/oma2
        end if

      ! rSCAN switching function
      else if (id_metagga.eq.51) then
        if (a.le.0.0_q) then
          fa = dexp(-cfc1*a/oma)
          d_fa_da = -cfc1*fa/oma2
        else if (a.le.2.5_q) then
          fa = dot_product(cregu,alphai)
          d_fa_da = dot_product(cregu1,alphai(0:6))
        else
          fa = -cfd1*dexp(cfc2/oma)
          d_fa_da = cfc2*fa/oma2
        end if
      end if

      p14=p**(1.0d0/four)
      gx=1.d0
      if (p .gt. 0.d0) then
          gx=1.0d0-dexp(-cfa1/p14)
      endif

      Fx1 = hx1+FA*(hx0-hx1)

      Fx = Fx1*gx

      d_hx0_dp=0.d0

      d_vfac_dp=cfb1
      d_yfac_dp=cfmuak+d_wfac_dp+two*vfac*d_vfac_dp
      d_hx1_dp=d_yfac_dp/(1.0d0+yfac/cfk1)**two

      d_vfac_da=-cfb2*(1.0d0-two*cfb3*oma2)*dexp(-cfb3*oma2)
      d_yfac_da=two*vfac*d_vfac_da
      d_hx1_da=d_yfac_da/(1.0d0+yfac/cfk1)**two

      d_gx_dp=0.d0
      if (p .gt. 0.d0) then
          d_gx_dp=-cfa1/four/p/p14*dexp(-cfa1/p14)
      endif

      d_Fx1_dp=d_hx1_dp+FA*(d_hx0_dp-d_hx1_dp)

      d_Fx1_da=(1.0d0-FA)*d_hx1_da+d_FA_da*(hx0-hx1)


      fx1p=d_Fx1_dp*gx+Fx1*d_gx_dp

      fx1a=d_Fx1_da*gx

      RETURN
      END SUBROUTINE metaggafx


!************************ SUBROUTINE VSCANc ****************************
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VCD1 VCD2                    THE DERIVATIVES OF EC WRT n
! VCDD1,VCDD2                  THE DERIVATIVES OF EC WRT |grad n|
! AMUCD1, AMUCD2                   THE DERIVATIVES OF EC WRT TAU
!
!***********************************************************************

      SUBROUTINE VSCANc(&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD,&
     &   Ec_SCAN,VCD1,VCD2,VCDD,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ

      IMPLICIT REAL*8 (A-H,O-Z)

! the coefficients for the exchange part
      PARAMETER (CFC1C=0.640d0)
      PARAMETER (CFC2C=1.500d0)
      PARAMETER (CFD1C=0.700d0)
!$ACC ROUTINE(Vmetaggac) SEQ



! other parameter
      PARAMETER (ONE=1.0d0)
      PARAMETER (TWO=2.0d0)
      PARAMETER (THREE=3.0d0)
      PARAMETER (FOUR=4.0d0)
      PARAMETER (PI =3.141592653589793238d0)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (THRD=1.0d0/3.0d0)
      PARAMETER (THRD2=2.0d0*THRD)
      PARAMETER (THRD4=4.0d0*THRD)
      PARAMETER (THRD5=1.0d0+THRD2)
      PARAMETER (THRD8=1.0d0+THRD5)

      call Vmetaggac(cfc1c,cfc2c,cfd1c,&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD,&
     &   Ec_SCAN,VCD1,VCD2,VCDD,AMUCD1,AMUCD2)

      RETURN
      END SUBROUTINE VSCANc


      SUBROUTINE Vmetaggac(cfc1,cfc2,cfd1,&
     &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
     &   Ec_SCAN,VCD1,VCD2,VCDD,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ

      IMPLICIT REAL*8 (A-H,O-Z)

      INTEGER I
      REAL(q) :: CREGU(0:7),CREGU1(7),ALPHAI(0:7)
      PARAMETER (TWO=2.0d0)
      PARAMETER (THREE=3.0d0)
      PARAMETER (FOUR=4.0d0)
      PARAMETER (PI =3.141592653589793238d0)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (THRD=1.0d0/3.0d0)
      PARAMETER (THRD2=2.0d0*THRD)
      PARAMETER (THRD4=4.0d0*THRD)
      PARAMETER (THRD5=1.0d0+THRD2)
      PARAMETER (THRD8=1.0d0+THRD5)
      PARAMETER (CREGU = (/ 1.0_q, -0.64_q, -0.4352_q,  -1.535685604549_q,&
        &              3.061560252175_q, -1.915710236206_q, 0.516884468372_q,&
        &             -0.051848879792_q /) )
!$ACC ROUTINE(CORGGA_0,CORGGA_1) SEQ


      VCD1=0.0d0
      VCD2=0.0d0
      VCDD=0.0d0
      AMUCD1=0.0d0
      AMUCD2=0.0d0


      RT=RU+RD
      YA=DRU**2.0d0
      YB=DRD**2.0d0
      Y=DRT**2.0d0
      YC=(Y-YA-YB)/2.0d0
      TAUW=1.0d0/8.0d0*(Y/RT)
      TAU=TAUU+TAUD
      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.99999999999990d0),0.99999999999990d0)
      DS_ZETA=((1.0d0+ZETA)**THRD5+(1.0d0-ZETA)**THRD5)/TWO
      DX_ZETA=((1.0d0+ZETA)**THRD4+(1.0d0-ZETA)**THRD4)/TWO
      TAU0=0.30d0*(THREE*PISQ)**THRD2*RT**THRD5*DS_ZETA

      D_ZETA_D1=TWO*RD/RT**TWO
      D_ZETA_D2=-TWO*RU/RT**TWO
      D_DS_ZETA_D1=THRD5*((1.0d0+ZETA)**THRD2 &
     &             -(1.0d0-ZETA)**THRD2)*D_ZETA_D1/TWO
      D_DS_ZETA_D2=THRD5*((1.0d0+ZETA)**THRD2 &
     &             -(1.0d0-ZETA)**THRD2)*D_ZETA_D2/TWO
      DTAU0D1=THRD5*TAU0/RT+TAU0*D_DS_ZETA_D1/DS_ZETA
      DTAU0D2=THRD5*TAU0/RT+TAU0*D_DS_ZETA_D2/DS_ZETA

      DTAUWD1=-TAUW/RT
      DTAUWD2=DTAUWD1
      DTAUWDD=1.0d0/FOUR * DRT/RT

      DENOM = TAU0 + DS_ZETA*SCAN_TAUREG_C
      ALPHA = (TAU - TAUW)/DENOM
      D_ALPHA_D1 = (-DTAUWD1 - ALPHA*(DTAU0D1+SCAN_TAUREG_C*D_DS_ZETA_D1))/DENOM
      D_ALPHA_D2 = (-DTAUWD2 - ALPHA*(DTAU0D2+SCAN_TAUREG_C*D_DS_ZETA_D2))/DENOM
      D_ALPHA_DD=-DTAUWDD/DENOM
      D_ALPHA_DTAU=1.0d0/DENOM

      RALPHA = ALPHA**3/(ALPHA**2 + SCAN_ALPREG)
      D_RALPHA_DALPHA = ALPHA/(ALPHA**2 + SCAN_ALPREG) * (3*ALPHA - 2*RALPHA)
      D_ALPHA_D1 = D_ALPHA_D1*D_RALPHA_DALPHA
      D_ALPHA_D2 = D_ALPHA_D2*D_RALPHA_DALPHA
      D_ALPHA_DD = D_ALPHA_DD*D_RALPHA_DALPHA
      D_ALPHA_DTAU = D_ALPHA_DTAU*D_RALPHA_DALPHA

      OMA = 1.0_q - RALPHA
      OMA2 = OMA*OMA

      ALPHAI(0) = 1.0_q
      DO I=1,7
        ALPHAI(I) = ALPHAI(I-1)*RALPHA
        CREGU1(I) = I*CREGU(I)
      END DO

      FUNKC_ALPHA=0.0d0
      D_FUNKC_ALPHA_DALPHA=0.0d0
      IF (ID_METAGGA.EQ.50) THEN
        IF (RALPHA.LE.0.998_q) THEN
          FUNKC_ALPHA = DEXP(-CFC1*RALPHA/OMA)
          D_FUNKC_ALPHA_DALPHA = -CFC1*FUNKC_ALPHA/OMA2
        ELSE IF (RALPHA.GE.1.002_q) THEN
          FUNKC_ALPHA = -CFD1*DEXP(CFC2/OMA)
          D_FUNKC_ALPHA_DALPHA = CFC2*FUNKC_ALPHA/OMA2
        END IF
      ELSE IF (ID_METAGGA.EQ.51) THEN
        IF (RALPHA.LE.0.0_q) THEN
          FUNKC_ALPHA = DEXP(-CFC1*RALPHA/OMA)
          D_FUNKC_ALPHA_DALPHA = -CFC1*FUNKC_ALPHA/OMA2
        ELSE IF (RALPHA.LE.2.5_q) THEN
          FUNKC_ALPHA = DOT_PRODUCT(CREGU,ALPHAI)
          D_FUNKC_ALPHA_DALPHA = DOT_PRODUCT(CREGU1,ALPHAI(0:6))
        ELSE
          FUNKC_ALPHA = -CFD1*DEXP(CFC2/OMA)
          D_FUNKC_ALPHA_DALPHA = CFC2*FUNKC_ALPHA/OMA2
        END IF
      END IF


      CALL CORGGA_0(RU,RD,DRU,DRD,DRT,&
     &        EPPGGA0,EPPGGA0_D1,EPPGGA0_D2,EPPGGA0_DD)
      CALL CORGGA_1(RU,RD,DRU,DRD,DRT, &
     &       EPPGGA1,EPPGGA1_D1,EPPGGA1_D2,EPPGGA1_DD)


      EPP=EPPGGA1+FUNKC_ALPHA*(EPPGGA0-EPPGGA1)
      D_EPP_D1=EPPGGA1_D1 &
     &          +(EPPGGA0-EPPGGA1)*D_FUNKC_ALPHA_DALPHA*D_ALPHA_D1 &
     &          +FUNKC_ALPHA*(EPPGGA0_D1-EPPGGA1_D1)
      D_EPP_D2=EPPGGA1_D2 &
     &          +(EPPGGA0-EPPGGA1)*D_FUNKC_ALPHA_DALPHA*D_ALPHA_D2 &
     &          +FUNKC_ALPHA*(EPPGGA0_D2-EPPGGA1_D2)
      D_EPP_DD=EPPGGA1_DD &
     &          +(EPPGGA0-EPPGGA1)*D_FUNKC_ALPHA_DALPHA*D_ALPHA_DD &
     &          +FUNKC_ALPHA*(EPPGGA0_DD-EPPGGA1_DD)
      D_EPP_DTAU=(EPPGGA0-EPPGGA1)*D_FUNKC_ALPHA_DALPHA*D_ALPHA_DTAU



      VCD1=EPP+RT*D_EPP_D1
      VCD2=EPP+RT*D_EPP_D2
      VCDD=RT*D_EPP_DD
      AMUCD1=RT*D_EPP_DTAU
      AMUCD2=AMUCD1

      EC_SCAN=RT*EPP

      RETURN
      END SUBROUTINE Vmetaggac


      SUBROUTINE CORGGA_1( &
     &   RU,RD,DRU,DRD,DRT, &
     &   EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD)
!$ACC ROUTINE SEQ


      IMPLICIT REAL*8 (A-H,O-Z)
      PARAMETER (TWO=2.0d0)
      PARAMETER (THREE=3.0d0)
      PARAMETER (FOUR=4.0d0)
      PARAMETER (FIVE=5.0d0)
      PARAMETER (SIX=6.0d0)
      PARAMETER (THRD=1.0d0/3.0d0)
      PARAMETER (THRD2=2.0d0*THRD)
      PARAMETER (THRD4=4.0d0*THRD)
      PARAMETER (THRD5=1.0d0+THRD2)
      PARAMETER (THRD8=1.0d0+THRD5)
      PARAMETER (PI =3.141592653589793238d0)
      PARAMETER (PISQ=PI*PI)

      PARAMETER (GAMMA=0.031090690869654895034940863712730d0)
      PARAMETER (BETA_mb=0.066724550603149220d0)
!$ACC ROUTINE(CORPBE_revtpss) SEQ

      EPPGGA  =0.0d0
      EPPGGA_D1=0.0d0
      EPPGGA_D2=0.0d0
      EPPGGA_DD=0.0d0

      RT=RU+RD
      YA=DRU**2.0d0
      YB=DRD**2.0d0
      Y=DRT**2.0d0
      YC=(Y-YA-YB)/2.0d0

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.99999999999990d0),0.99999999999990d0)
      DZETAD1=TWO*RD/RT**TWO
      DZETAD2=-TWO*RU/RT**TWO


      DTHRD=exp(log(RT)*THRD)
      RS=(0.750d0/PI)**THRD/DTHRD
      DRSD1=-THRD/RT*RS
      DRSD2=-THRD/RT*RS


      PHI = (exp((TWO*THRD)*log(1.0d0+ZETA)) &
     &       +exp((TWO*THRD)*log(1.0d0-ZETA)))/2.0d0
      D_PHI_DZETA=THRD*((1.0d0+ZETA)**(-THRD)-(1.0d0-ZETA)**(-THRD))
      D_PHI_D1=D_PHI_DZETA*DZETAD1
      D_PHI_D2=D_PHI_DZETA*DZETAD2

      AFIX_T=SQRT(PI/FOUR)*(9.0d0*PI/FOUR)**(1.0d0/SIX)
      S=DRT/(TWO*(THREE*PISQ)**THRD*RT**THRD4)
      DSD1=-THRD4*S/RT
      DSD2=-THRD4*S/RT
      DSDD=1.0D0/(TWO*RT*(THREE*PISQ*RT)**THRD)

      T=AFIX_T*S/SQRT(RS)/PHI
      T2 = T*T
      T4 = T2*T2

      DTD1=AFIX_T*(PHI*RS*DSD1-0.50d0*S*PHI*DRSD1-S*RS*D_PHI_D1) &
     &           /(PHI**TWO*RS**(THREE/TWO))
      DTD2=AFIX_T*(PHI*RS*DSD2-0.50d0*S*PHI*DRSD2-S*RS*D_PHI_D2) &
     &           /(PHI**TWO*RS**(THREE/TWO))
      DTDD=AFIX_T*DSDD/(SQRT(RS)*PHI)

      FK=(3.0d0*PI*PI)**THRD*DTHRD
      SK = SQRT(4.00d0*FK/PI)
      CALL CORPBE_revtpss(RS,ZETA,EC,VCUPLDA,VCDNLDA,PHI,SK, &
     &           T,H,DVCUP,DVCDN,ECQ,.FALSE.)
      D_EC_DZETA=(VCUPLDA-VCDNLDA)/TWO
      D_EC_DRS=(EC-ZETA*D_EC_DZETA-(VCUPLDA+VCDNLDA)/TWO)*THREE/RS

      AFACTOR=0.10d0
      BFACTOR=0.17780d0
      BETA_NUM=1.0d0 + AFACTOR*RS
      BETA_DEN=1.0d0+ BFACTOR*RS
      D_BETA_NUM=AFACTOR
      D_BETA_DEN=BFACTOR
      BETA = BETA_MB*BETA_NUM/BETA_DEN
      D_BETA_DRS=BETA_MB*(BETA_DEN*D_BETA_NUM-BETA_NUM*D_BETA_DEN) &
     &                  /BETA_DEN**TWO


      PHI3=PHI**THREE
      PON=-EC/(PHI3*gamma)
      W=DEXP(PON)-1.0d0
      D_W_DRS=-(W+1.0d0)*D_EC_DRS/(GAMMA*PHI3)
      D_W_DZETA=-(W+1.0d0)/(GAMMA*PHI3) &
     &                  *(D_EC_DZETA-THREE*EC*D_PHI_DZETA/PHI)


      A=BETA/(GAMMA*W)
      D_A_DRS=(W*D_BETA_DRS-BETA*D_W_DRS)/(GAMMA*W**TWO)
      D_A_DZETA=-BETA*D_W_DZETA/(GAMMA*W**TWO)

      V=A*T2
      D_V_DRS=T2*D_A_DRS
      D_V_DZETA=T2*D_A_DZETA
      D_V_DT=TWO*A*T


      FUNKG=1.0d0/(1.0d0+4.0d0*V)**0.250d0
      D_FUNKG_DV=-1.0d0/(1.0d0+4.0d0*V)**1.250d0



      HCORE=1.0d0+W*(1.0d0-FUNKG)
      AH=GAMMA*PHI3
      H=AH*DLOG(HCORE)

      DH1=1.0d0-FUNKG
      DH2=W*D_FUNKG_DV
      D_H_DRS=(DH1*D_W_DRS-DH2*D_V_DRS)*AH/HCORE
      D_H_DZETA=THREE*H*D_PHI_DZETA/PHI &
     &          +(DH1*D_W_DZETA-DH2*D_V_DZETA)*AH/HCORE
      D_H_DT=(-DH2*D_V_DT)*AH/HCORE

      EPPGGA=EC+H
      EPPGGA_D1=D_EC_DRS*DRSD1+D_EC_DZETA*DZETAD1+D_H_DRS*DRSD1 &
     &                        +D_H_DZETA*DZETAD1+D_H_DT*DTD1
      EPPGGA_D2=D_EC_DRS*DRSD2+D_EC_DZETA*DZETAD2+D_H_DRS*DRSD2 &
     &                        +D_H_DZETA*DZETAD2+D_H_DT*DTD2
      EPPGGA_DD=D_H_DT*DTDD

      RETURN
      END SUBROUTINE CORGGA_1


      SUBROUTINE CORGGA_0(RU,RD,DRU,DRD,DRT, &
     &   EPPGGA,EPPGGA_D1,EPPGGA_D2,EPPGGA_DD)
!$ACC ROUTINE SEQ

      IMPLICIT REAL*8 (A-H,O-Z)

      PARAMETER (CFB1=0.0285764d0)
      PARAMETER (CFB2=0.0889d0)
      PARAMETER (CFB3=0.125541d0)
      PARAMETER (cfkaiLD=0.12802585262625815d0)

      PARAMETER (TWO=2.0d0)
      PARAMETER (THREE=3.0d0)
      PARAMETER (FOUR=4.0d0)
      PARAMETER (FIVE=5.0d0)
      PARAMETER (SIX=6.0d0)
      PARAMETER (THRD=1.0d0/3.0d0)
      PARAMETER (THRD2=2.0d0*THRD)
      PARAMETER (THRD4=4.0d0*THRD)
      PARAMETER (THRD5=1.0d0+THRD2)
      PARAMETER (THRD8=1.0d0+THRD5)
      PARAMETER (PI =3.141592653589793238d0)
      PARAMETER (PISQ=PI*PI)

      PARAMETER (GAMMA=0.031090690869654895034940863712730d0)
      PARAMETER (BETA_mb=0.066724550603149220d0)

      EPPGGA  =0.0d0
      EPPGGA_D1=0.0d0
      EPPGGA_D2=0.0d0
      EPPGGA_DD=0.0d0
      AX_LDA=-THREE/(FOUR*PI)*(9.00d0*PI/FOUR)**THRD

      RT=RU+RD
      YA=DRU**2.0d0
      YB=DRD**2.0d0
      Y=DRT**2.0d0
      YC=(Y-YA-YB)/2.0d0

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-0.99999999999990d0),0.99999999999990d0)
      DZETAD1=TWO*RD/RT**TWO
      DZETAD2=-TWO*RU/RT**TWO


      DTHRD=exp(log(RT)*THRD)
      RS=(0.750d0/PI)**THRD/DTHRD
      DRSD1=-THRD/RT*RS
      DRSD2=-THRD/RT*RS


      PHI = (exp((TWO*THRD)*log(1.0d0+ZETA)) &
     &           +exp((TWO*THRD)*log(1.0d0-ZETA)))/2.0d0
      D_PHI_DZETA=THRD*((1.0d0+ZETA)**(-THRD)-(1.0d0-ZETA)**(-THRD))
      D_PHI_D1=D_PHI_DZETA*DZETAD1
      D_PHI_D2=D_PHI_DZETA*DZETAD2

      AFIX_T=SQRT(PI/FOUR)*(9.0d0*PI/FOUR)**(1.0d0/SIX)
      S=DRT/(TWO*(THREE*PISQ)**THRD*RT**THRD4)
      DSD1=-THRD4*S/RT
      DSD2=-THRD4*S/RT
      DSDD=1.0D0/(TWO*(THREE*PISQ)**THRD*RT**THRD4)

      RSHALF=SQRT(RS)
      FACTOR1=1.0d0+CFB2*RSHALF+CFB3*RS
      EC0LDA=-CFB1/FACTOR1

      D_EC0LDA_DRS=(CFB3+CFB2/RSHALF/TWO)*EC0LDA**TWO/cfb1

      dx_zeta=((1.0d0+zeta)**THRD4+(1.0d0-zeta)**THRD4)/two
      d_dx_zeta_dzeta=two*((1.0d0+zeta)**THRD-(1.0d0-zeta)**THRD)/three
      TWO13=TWO**THRD
!      gc_zeta=(two13-dx_zeta)/(two13-1.0d0)
!      d_gc_zeta_dzeta=-d_dx_zeta_dzeta/(two13-1.0d0)

      gc_zeta=(1.0d0-2.363d0*(dx_zeta-1.0d0))*(1.0d0-zeta**12.0d0)
      d_gc_zeta_dzeta=-(1.0d0-2.363d0*(dx_zeta-1.0d0))*12.d0*zeta**11.d0
      d_gc_zeta_dzeta=d_gc_zeta_dzeta -2.363d0*d_dx_zeta_dzeta*(1.0d0-zeta**12.0d0)


      w0=dexp(-EC0LDA/cfb1)-1.0d0
      d_w0_drs=-(w0+1.0d0)*D_EC0LDA_DRS/cfb1

      gfunkinf=1.0d0/(1.0d0+four*cfkaiLD*s*s)**(1.0d0/four)
      d_gfunkinf_ds=-two*cfkaiLD*s*gfunkinf**five

      hcore0=1.0d0+w0*(1.0d0-gfunkinf)
      h0=cfb1*dlog(hcore0)
      d_h0_drs=cfb1*d_w0_drs*(1.0d0-gfunkinf)/hcore0
      d_h0_ds=-cfb1*w0*d_gfunkinf_ds/hcore0


      EPPGGA=(EC0LDA+h0)*gc_zeta

      d_EPPGGA_dzeta=(EC0LDA+h0)*d_gc_zeta_dzeta
      d_EPPGGA_drs=(D_EC0LDA_DRS+d_h0_drs)*gc_zeta
      d_EPPGGA_ds=d_h0_ds*gc_zeta

      EPPGGA_D1=d_EPPGGA_dzeta*DZETAD1+d_EPPGGA_drs*DRSD1 &
     &          +d_EPPGGA_ds*DSD1
      EPPGGA_D2=d_EPPGGA_dzeta*DZETAD2+d_EPPGGA_drs*DRSD2 &
     &          +d_EPPGGA_ds*DSD2



      EPPGGA_DD=d_EPPGGA_ds*DSDD

      RETURN
      END SUBROUTINE CORGGA_0

!***********************************************************************
! r^2-SCAN subroutines
! Written by Daniel Mejia-Rodriguez
! M2QM and QTP
! University of Florida
!***********************************************************************

      SUBROUTINE VR2SCANx(RX,DRX,TAUX,Ex,VXD,VXDD,AMUXD)
!$ACC ROUTINE SEQ

      USE prec
      USE constant

      IMPLICIT NONE

      REAL(q) :: RX,DRX,TAUX,EX,VXD,VXDD,AMUXD
      REAL(q) :: C1X,C2X,CDX,CK1,CH0,CA1,CMU
      REAL(q) :: ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN
      REAL(q) :: THRD,THRD2,THRD4,THRD5,THRD8
      REAL(q) :: ETA,CETA,C2,CDP24,PISQ,AX
      REAL(q) :: TAU_RHO,TAUW_RHO,TAU0,TAUW_TEMP
      REAL(q) :: RHO,DRHO,P,P2,P14,EXP1,EXP2,EXP3,EXP4
      REAL(q) :: FA,DFADA,ALPHA,DALPHAD,DALPHADD,DALPHADTAU
      REAL(q) :: DPD,DPDD,EXUNIF,EXLDA,EXDLDA,OMA,OMA2,X
      REAL(q) :: H,DHDX,DXDP,HDEN,HNUM,DHDP,DG,DGDP
      REAL(q) :: FX,DFXDP,DFXDA,DFX_D,DFX_DD,DFX_DTAU
      REAL(q) :: CREGU(0:7),CREGU1(7),RTEMP(0:7)
      INTEGER :: IFX

      PARAMETER (C1X=0.667_q)
      PARAMETER (C2X=0.800_q)
      PARAMETER (CDX=1.240_q)
      PARAMETER (CK1=0.065_q)

      PARAMETER (CH0=1.1740d0)
      PARAMETER (CA1=4.9479d0)

      PARAMETER (CMU=10.00d0/81.0d0)
! other parameters
      PARAMETER (ZERO=0.0_q)
      PARAMETER (ONE=1._q)
      PARAMETER (TWO=2._q)
      PARAMETER (THREE=3._q)
      PARAMETER (FOUR=4._q)
      PARAMETER (FIVE=5._q)
      PARAMETER (SIX=6._q)
      PARAMETER (THRD=1._q/3._q)
      PARAMETER (THRD2=2._q*THRD)
      PARAMETER (THRD4=4._q*THRD)
      PARAMETER (THRD5=1._q+THRD2)
      PARAMETER (THRD8=1._q+THRD5)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (AX=-0.738558766382022405884230032680836_q)
      PARAMETER (ETA=0.001_q)
      PARAMETER (CETA=20.0_q/27.0_q+ETA*THRD5)
      PARAMETER (CDP24=0.361_q**4)

      PARAMETER (CREGU = (/ ONE, -0.667_q, -0.4445555_q, &
     &                    -6.63086601049291E-1_q, 1.45129704448975_q, &
     &                    -8.87998041596655E-1_q, 2.34528941478571E-1_q, &
     &                    -2.31858433223407E-2_q/) )

      PARAMETER (CREGU1 = (/ -0.667_q, -TWO*0.4445555_q, &
     &             -THREE*6.63086601049291E-1_q, FOUR*1.45129704448975_q, &
     &             -5._q*8.87998041596655E-1_q, SIX*2.34528941478571E-1_q, &
     &             -7._q*2.31858433223407E-2_q/) )

      PARAMETER (C2 = -(CREGU1(1)+CREGU1(2)+CREGU1(3)+CREGU1(4)+CREGU1(5)+CREGU1(6)+CREGU1(7))*(ONE-CH0))

      RTEMP(0) = ONE

      VXD=0._q
      VXDD=0._q
      AMUXD=0._q


! Suspect that TAUWU and TAUWD are not well described. Use TAUW_TEMP=0.125_q*DRT**2/RT
! IF WANT TO TEST TAUW, SIMPLY OVERWRITE TAUW_TEMP BY TAUW
      TAUW_TEMP=0.125_q*DRX**2._q/RX

! spin up
! IN EXD1(2*RU), TAUWU AND TAUU SCALES AS 2 AND TAU0 SCALES AS 2**FTHRD
      RHO=TWO*RX
      DRHO=TWO*DRX
      TAUW_RHO=TWO*TAUW_TEMP
      TAU_RHO=TWO*TAUX
      TAU0=0.3_q*(THREE*PISQ)**THRD2*(RHO)**THRD5

!----------------------------------------------------------------------
! construct LDA exchange energy density AND ITS DERIVATIVE WRT n
      EXUNIF=AX*RHO**THRD
      EXLDA=EXUNIF*RHO
      EXDLDA=EXUNIF*THRD4


! CONSTRUCT FX AND ITS DERIVATIVES WRT n AND |grad n|
      P=(DRHO)**TWO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)
      DPD=-THRD8*P/RHO
      DPDD=TWO*DRHO/(FOUR*(THREE*PISQ)**THRD2*(RHO)**THRD8)

      ALPHA = (TAU_RHO - TAUW_RHO)/(TAU0 + ETA*TAUW_RHO)
      DALPHAD = THRD5*TAU0/(RHO*(TAU0+ETA*TAUW_RHO))*(P-ALPHA+ETA*P*ALPHA)
      DALPHADD = -0.25_q*DRHO*(ALPHA*ETA+ONE)/(RHO*(TAU0+ETA*TAUW_RHO))
      DALPHADTAU = ONE/(TAU0 + ETA*TAUW_RHO)

      P14 = SQRT(SQRT(P))
      P2 = P*P
      OMA = ONE - ALPHA
      OMA2 = OMA*OMA

      EXP1 = EXP(-P2/CDP24)
      EXP2 = 0.0_q
      IF (P14.GT.0.002_q) EXP2 = EXP(-CA1/P14)

      X = (CETA*C2*EXP1 + CMU)*P
      DXDP = CETA*C2*EXP1 + CMU - TWO*P2*CETA*C2*EXP1/CDP24

      HDEN = CK1 + X
      HNUM = HDEN + CK1*X
      H = HNUM/HDEN
      DHDX = (CK1/HDEN)**2
      DHDP = DHDX*DXDP

      DG = ONE - EXP2
      DGDP = ZERO
      IF (P14.GT.0.002_q) DGDP = -0.25_q*CA1*EXP2/(P*P14)

      IF (ALPHA.LT.ZERO) THEN
        EXP3 = EXP(-C1X*ALPHA/OMA)
        FA = EXP3
        DFADA = -C1X*EXP3/OMA2
      ELSEIF (ALPHA.LT.2.5_q) THEN
        DO IFX=1,7
          RTEMP(IFX) = RTEMP(IFX-1)*ALPHA
        ENDDO
        FA = DOT_PRODUCT(CREGU,RTEMP)
        DFADA = DOT_PRODUCT(CREGU1,RTEMP(0:6))
      ELSE
        EXP4 = EXP(C2X/OMA)
        FA = -CDX*EXP4
        DFADA = -CDX*EXP4*C2X/OMA2
      ENDIF

      FX = DG*(H + FA*(CH0-H))
      DFXDP = DGDP*(H + FA*(CH0-H)) + DG*DHDP*(ONE-FA)
      DFXDA = DG*(DFADA*(CH0-H))

! Calculate fx DERIVATIVES WRT n, |grad n|, and tau
      DFX_D=DFXDP*DPD+DFXDA*DALPHAD
      DFX_DD=DFXDP*DPDD+DFXDA*DALPHADD
      DFX_DTAU=DFXDA*DALPHADTAU

!   OUTPUT THE VXD1,VXDD1 AND AMUXD1
      VXD=EXDLDA*FX+EXLDA*DFX_D
      VXDD=EXLDA*DFX_DD
      AMUXD=EXLDA*DFX_DTAU
      EX=EX+EXLDA*FX/TWO
      RETURN
      END SUBROUTINE VR2SCANx



      SUBROUTINE VR2SCANc(RU,RD,DRT,TAUU,TAUD,Ec,VCD1,VCD2,VCDD,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ
      USE prec
      USE constant
      USE setxcmeta

      IMPLICIT NONE

      REAL(q) :: Ec,DRT,VCDD
      REAL(q) :: RU,TAUU,VCD1,AMUCD1
      REAL(q) :: RD,TAUD,VCD2,AMUCD2

      REAL(q) :: RT,Y,TAU
      REAL(q) :: TAUW,D_TAUW,D_TAUW_DD
      REAL(q) :: ZETA,OPZ,OMZ,D_ZETA_D1,D_ZETA_D2
      REAL(q) :: DS,D_DS_DZETA,D_DS_D1,D_DS_D2
      REAL(q) :: DX,D_DX_DZETA
      REAL(q) :: GC,D_GC_DZETA
      REAL(q) :: PHI,PHI2,PHI3,D_PHI_DZETA
      REAL(q) :: TAU0,D_TAU0_D1,D_TAU0_D2
      REAL(q) :: RS,RS12,D_RS
      REAL(q) :: P,D_P,D_P_DD
      REAL(q) :: AFIX_T,T2,D_T2_DP,D_T2_DRS,D_T2_DZETA
      REAL(q) :: ALPHA,ALPHA_DEN,D_ALPHA_D1,D_ALPHA_D2,D_ALPHA_DD,D_ALPHA_DT
      REAL(q) :: FA,D_FA_DA,D_FA_D1,D_FA_D2,D_FA_DD,D_FA_DT
      REAL(q) :: FACTOR0,D_FACTOR0_DRS,D2_FACTOR0_DRS
      REAL(q) :: ECLDA0,D_ECLDA0_DRS,D2_ECLDA0_DRS
      REAL(q) :: ECLDA1,D_ECLDA1_DRS,D_ECLDA1_DZETA,D2_ECLDA1_DRS,D2_ECLDA1_DRSDZETA
      REAL(q) :: DUMMY,ECTEMP,VCTEMPUP,VCTEMPDW
      REAL(q) :: BETA,D_BETA_DRS
      REAL(q) :: W1FAC,W1,D_W1_DRS,D_W1_DZETA
      REAL(q) :: A,D_A_DRS,D_A_DZETA
      REAL(q) :: V,D_V_DRS,D_V_DZETA,D_V_DP
      REAL(q) :: FACTOR1,EXP1,DELTAY,DELTAYP,D_DELTAYP_DRS,D_DELTAYP_DZETA,D_DELTAYP_DP
      REAL(q) :: GAUX,G,D_G_DGAUX,D_G_DRS,D_G_DZETA,D_G_DP
      REAL(q) :: ARG1,D_ARG1_DP,D_ARG1_DZETA,D_ARG1_DRS
      REAL(q) :: H1,D_H1_DRS,D_H1_DP,D_H1_DZETA
      REAL(q) :: EC1,D_EC1_DRS,D_EC1_DP,D_EC1_DZETA,D_EC1_D1,D_EC1_D2,D_EC1_DD
      REAL(q) :: W0,D_W0_DRS
      REAL(q) :: GINF,D_GINF_DP
      REAL(q) :: HCORE0,H0,D_H0_DRS,D_H0_DP
      REAL(q) :: EC0,D_EC0_DRS,D_EC0_DP,D_EC0_DZETA,D_EC0_D1,D_EC0_D2,D_EC0_DD
      REAL(q) :: EPP,D_EPP_D1,D_EPP_D2,D_EPP_DD,D_EPP_DT

      REAL(q) :: BETA_MB,GAMMA,FACTORA,FACTORB,B1C,B2C,B3C,XI
      REAL(q) :: A0,A1,A2,A3,A4,A5,A6,A7
      REAL(q) :: CFC1,CFC2,CFD1
      REAL(q) :: ZERO,ONE,TWO,THREE,FOUR,FIVE,SIX,SEVEN,PISQ
      REAL(q) :: THRD,THRD2,THRD4,THRD5,THRD8
      REAL(q) :: ETA,CKF2,DP24,C2

      PARAMETER (ZERO=0.0_q)
      PARAMETER (ONE=1.0_q)
      PARAMETER (TWO=2.0_q)
      PARAMETER (THREE=3.0_q)
      PARAMETER (FOUR=4.0_q)
      PARAMETER (FIVE=5.0_q)
      PARAMETER (SIX=6.0_q)
      PARAMETER (SEVEN=7.0_q)
      PARAMETER (PISQ=PI*PI)
      PARAMETER (THRD=1.0_q/3.0_q)
      PARAMETER (THRD2=2.0_q*THRD)
      PARAMETER (THRD4=4.0_q*THRD)
      PARAMETER (THRD5=1.0_q+THRD2)
      PARAMETER (THRD8=1.0_q+THRD5)
      PARAMETER (CFC1=0.640_q)
      PARAMETER (CFC2=1.500_q)
      PARAMETER (CFD1=0.700_q)
      parameter( a0 =  1.0_q )
      parameter( a1 = -0.64_q )
      parameter( a2 = -0.4352_q )
      parameter( a3 = -1.535685604549_q )
      parameter( a4 =  3.061560252175_q )
      parameter( a5 = -1.915710236206_q )
      parameter( a6 =  0.516884468372_q )
      parameter( a7 = -0.051848879792_q )
      PARAMETER(DP24=0.361_q**4)
      PARAMETER(B1C=0.0285764_q,B2C=0.0889_q,B3C=0.125541_q)
      PARAMETER(BETA_MB=0.06672455060314922_q)
      PARAMETER(FACTORA=0.1_q,FACTORB=0.1778_q)
      PARAMETER(XI=0.12802585262625815_q)
      PARAMETER(ETA=0.001_q)
      PARAMETER(C2=A1 + TWO*A2 + THREE*A3 + FOUR*A4 + FIVE*A5 + SIX*A6 + SEVEN*A7)
      PARAMETER(GAMMA=(ONE-DLOG(TWO))/PISQ)
      PARAMETER(CKF2=(THREE*PISQ)**THRD2)

      RT=RU+RD
      Y=DRT**2
      TAU=TAUU+TAUD

      TAUW=1.0d0/8.0d0*(Y/RT)
      D_TAUW = -TAUW/RT
      D_TAUW_DD = 0.25_q*DRT/RT

      ZETA=(RU-RD)/RT
      ZETA=MIN(MAX(ZETA,-ONE),ONE)
      D_ZETA_D1= TWO*RD/RT**2
      D_ZETA_D2=-TWO*RU/RT**2

      OMZ = ONE - ZETA
      OPZ = ONE + ZETA

      DS=(OPZ**THRD5+OMZ**THRD5)/TWO
      D_DS_DZETA = THRD5*(OPZ**THRD2 - OMZ**THRD2)/TWO
      D_DS_D1=D_DS_DZETA*D_ZETA_D1
      D_DS_D2=D_DS_DZETA*D_ZETA_D2

      PHI = (OPZ**THRD2 + OMZ**THRD2)/TWO
      PHI2 = PHI*PHI
      PHI3 = PHI2*PHI
      D_PHI_DZETA = 0.0_q
      IF (OPZ.GT.1E-10_q) D_PHI_DZETA = THRD/OPZ**THRD
      IF (OMZ.GT.1E-10_q) D_PHI_DZETA = D_PHI_DZETA - THRD/OMZ**THRD

      DX = (OPZ**THRD4 + OMZ**THRD4)/TWO
      D_DX_DZETA = THRD2*(OPZ**THRD - OMZ**THRD)

      GC = (ONE - 2.363D0*(DX - ONE))*(ONE - ZETA**12)
      D_GC_DZETA = -12D0*(ONE - 2.363D0*(DX - ONE))*ZETA**11 - &
                 &  2.363D0*D_DX_DZETA*(ONE - ZETA**12)


      TAU0=0.30d0*(THREE*PISQ)**THRD2*RT**THRD5*DS
      D_TAU0_D1 = THRD5*TAU0/RT + TAU0*D_DS_D1/DS
      D_TAU0_D2 = THRD5*TAU0/RT + TAU0*D_DS_D2/DS

      RS    = (0.750d0/PI)**THRD/RT**THRD
      RS12  = DSQRT(RS)
      D_RS  = -THRD/RT*RS

      P = Y/(FOUR*CKF2*RT**THRD8)
      D_P = -THRD8*P/RT
      D_P_DD = DRT/(TWO*CKF2*RT**THRD8)

      AFIX_T = CKF2/FOUR**THRD4
      T2 = AFIX_T*P/(PHI2*RS)
      D_T2_DRS = -T2/RS
      D_T2_DP = AFIX_T/(PHI2*RS)
      D_T2_DZETA = -TWO*T2/PHI*D_PHI_DZETA

      ALPHA_DEN = ONE/(TAU0 + ETA*TAUW)
      ALPHA = (TAU-TAUW)*ALPHA_DEN

      D_ALPHA_D1 = -ALPHA_DEN*(D_TAUW + ALPHA*(D_TAU0_D1 + ETA*D_TAUW))
      D_ALPHA_D2 = -ALPHA_DEN*(D_TAUW + ALPHA*(D_TAU0_D2 + ETA*D_TAUW))
      D_ALPHA_DD = -D_TAUW_DD*ALPHA_DEN*(ONE + ALPHA*ETA)
      D_ALPHA_DT = ALPHA_DEN

      !--
      !FA
      !--
      IF (ALPHA.LT.0.0_q) THEN
        FA = DEXP(-CFC1*ALPHA/(ONE-ALPHA))
        D_FA_DA = -CFC1*FA/(ONE-ALPHA)**2
      ELSE IF (ALPHA.LT.2.5_q) THEN
        FA = A0 + ALPHA*(A1 + ALPHA*(A2 + ALPHA*(A3 + ALPHA*(A4 + ALPHA*(A5 + ALPHA*(A6 + ALPHA*A7))))))
        D_FA_DA = A1 + ALPHA*(TWO*A2 + ALPHA*(THREE*A3 + ALPHA*(FOUR*A4 + ALPHA*(FIVE*A5 + ALPHA*(SIX*A6 + ALPHA*SEVEN*A7)))))
      ELSE
        FA = -CFD1*DEXP(CFC2/(ONE-ALPHA))
        D_FA_DA = CFC2*FA/(ONE-ALPHA)**2
      END IF

      D_FA_D1 = D_FA_DA*D_ALPHA_D1
      D_FA_D2 = D_FA_DA*D_ALPHA_D2
      D_FA_DD = D_FA_DA*D_ALPHA_DD
      D_FA_DT = D_FA_DA*D_ALPHA_DT

      !--------------------------------------------------------------------------
      !EC1
      !--------------------------------------------------------------------------

      FACTOR0 = ONE + B2C*RS12 + B3C*RS
      D_FACTOR0_DRS = B2C/RS12/TWO + B3C
      D2_FACTOR0_DRS = -B2C/RS/RS12/FOUR

      ECLDA0 = -B1C/FACTOR0
      D_ECLDA0_DRS = D_FACTOR0_DRS*B1C/FACTOR0**2
      D2_ECLDA0_DRS = B1C/FACTOR0**2 * (D2_FACTOR0_DRS  - TWO*D_FACTOR0_DRS**2/FACTOR0)

      CALL PW91LDA(RS,ZETA,ECLDA1,D_ECLDA1_DRS,D_ECLDA1_DZETA,D2_ECLDA1_DRS,D2_ECLDA1_DRSDZETA)

      BETA = BETA_mb*(ONE + FACTORA*RS)/(ONE + FACTORB*RS)
      D_BETA_DRS = BETA_mB*(FACTORA - FACTORB)/(ONE + FACTORB*RS)**2

      W1FAC = ECLDA1/(GAMMA*PHI3)
      W1 = DEXP(-W1FAC) - ONE
      D_W1_DRS = -(W1+ONE)*D_ECLDA1_DRS/(GAMMA*PHI3)
      D_W1_DZETA = (W1+ONE)*(THREE*W1FAC*D_PHI_DZETA/PHI - D_ECLDA1_DZETA/(GAMMA*PHI3))

      A = BETA/(W1*GAMMA)
      D_A_DRS = D_BETA_DRS/(W1*GAMMA) - A*D_W1_DRS/W1
      D_A_DZETA = -A*D_W1_DZETA/W1

      V = A*T2
      D_V_DRS = D_A_DRS*T2 + A*D_T2_DRS
      D_V_DZETA = D_A_DZETA*T2 + A*D_T2_DZETA
      D_V_DP = A*D_T2_DP

      EXP1 = DEXP(-P**2/DP24)
      FACTOR1 = C2/(27.0_q*GAMMA*PHI3*W1*DS)
      DELTAY = FACTOR1*(20.0_q*RS*(D_ECLDA0_DRS - D_ECLDA1_DRS) - 45.0_q*ETA*(ECLDA0 - ECLDA1))
      DELTAYP = DELTAY*P*EXP1
      D_DELTAYP_DRS = -DELTAYP/W1*D_W1_DRS + FACTOR1*( (D_ECLDA0_DRS-D_ECLDA1_DRS)*(20.0_q - 45.0_q*ETA) + &
                    & 20.0_q*RS*(D2_ECLDA0_DRS - D2_ECLDA1_DRS))*P*EXP1
      D_DELTAYP_DZETA = -DELTAYP*(D_W1_DZETA/W1 + D_DS_DZETA/DS + THREE*D_PHI_DZETA/PHI) + &
                      & FACTOR1*(45.0_q*ETA*D_ECLDA1_DZETA - 20.0_q*RS*D2_ECLDA1_DRSDZETA)*P*EXP1
      D_DELTAYP_DP = DELTAY*EXP1 - TWO*P*DELTAYP/DP24

      GAUX = V - DELTAYP
      G = ONE/(ONE + FOUR*GAUX)**(0.25_q)
      D_G_DGAUX = -G**5
      D_G_DRS = D_G_DGAUX*(D_V_DRS - D_DELTAYP_DRS)
      D_G_DZETA = D_G_DGAUX*(D_V_DZETA - D_DELTAYP_DZETA)
      D_G_DP = D_G_DGAUX*(D_V_DP - D_DELTAYP_DP)

      ARG1 = ONE + W1*(ONE-G)
      D_ARG1_DP = -W1*D_G_DP
      D_ARG1_DRS = D_W1_DRS*(ONE-G) - W1*D_G_DRS
      D_ARG1_DZETA = D_W1_DZETA*(ONE-G) - W1*D_G_DZETA

      H1 = GAMMA*PHI3*DLOG(ARG1)
      D_H1_DRS = GAMMA*PHI3*D_ARG1_DRS/ARG1
      D_H1_DP = GAMMA*PHI3*D_ARG1_DP/ARG1
      D_H1_DZETA = THREE*H1*D_PHI_DZETA/PHI + GAMMA*PHI3*D_ARG1_DZETA/ARG1

      EC1 = ECLDA1 + H1
      D_EC1_DRS = D_ECLDA1_DRS + D_H1_DRS
      D_EC1_DP = D_H1_DP
      D_EC1_DZETA = D_ECLDA1_DZETA + D_H1_DZETA

      D_EC1_D1 = D_EC1_DRS*D_RS + D_EC1_DP*D_P + D_EC1_DZETA*D_ZETA_D1
      D_EC1_D2 = D_EC1_DRS*D_RS + D_EC1_DP*D_P + D_EC1_DZETA*D_ZETA_D2
      D_EC1_DD = D_EC1_DP*D_P_DD

      !-----------------------------------------------------------------------------
      ! EC0
      !-----------------------------------------------------------------------------
      W0 = DEXP(-ECLDA0/B1C) - ONE
      D_W0_DRS = -(W0+ONE)*D_ECLDA0_DRS/B1C

      GINF = ONE/(ONE + FOUR*XI*P)**(0.25_q)
      D_GINF_DP = -XI*GINF**5

      HCORE0 = ONE + W0*(ONE - GINF)
      H0 = B1C*dlog(HCORE0)
      D_H0_DRS  = B1C*D_W0_DRS*(ONE - GINF)/HCORE0
      D_H0_DP  = -B1C*W0*D_GINF_DP/HCORE0

      EC0 = (ECLDA0 + H0)*GC
      D_EC0_DRS = GC*(D_ECLDA0_DRS + D_H0_DRS)
      D_EC0_DP = GC*D_H0_DP
      D_EC0_DZETA = D_GC_DZETA*(ECLDA0 + H0)

      D_EC0_D1 = D_EC0_DRS*D_RS + D_EC0_DZETA*D_ZETA_D1 + D_EC0_DP*D_P
      D_EC0_D2 = D_EC0_DRS*D_RS + D_EC0_DZETA*D_ZETA_D2 + D_EC0_DP*D_P
      D_EC0_DD = D_EC0_DP*D_P_DD

      !-----------------------------------------------------------------------------

      EPP = EC1 + FA*(EC0 - EC1)
      EC=RT*EPP

      D_EPP_D1 = D_EC1_D1 + D_FA_D1*(EC0-EC1) + FA*(D_EC0_D1 - D_EC1_D1)
      D_EPP_D2 = D_EC1_D2 + D_FA_D2*(EC0-EC1) + FA*(D_EC0_D2 - D_EC1_D2)
      D_EPP_DD = D_EC1_DD + D_FA_DD*(EC0-EC1) + FA*(D_EC0_DD - D_EC1_DD)
      D_EPP_DT = D_FA_DT*(EC0-EC1)

      VCD1 = EPP + RT*D_EPP_D1
      VCD2 = EPP + RT*D_EPP_D2
      VCDD = RT*D_EPP_DD
      AMUCD1 = RT*D_EPP_DT
      AMUCD2 = AMUCD1

      RETURN
      END SUBROUTINE VR2SCANc


      SUBROUTINE PW91LDA(RS,ZET,EC,DECRS,DECDZ,D2ECRS,D2ECRSZ)
!$ACC ROUTINE SEQ
      IMPLICIT NONE
      REAL(q) :: RS,ZET,EC,DECRS,DECDZ,D2ECRS,D2ECRSZ
      REAL(q) :: ONE,FOUR,THRD,THRDM,THRD2,SIXTHM,THRD4,GAM
      REAL(q) :: FZZ,GAMMA,BET,ETA,DELT,RTRS,EU,EURS,D2EURS
      REAL(q) :: EP,EPRS,D2EPRS,ALFM,ALFRSM,D2ALFRSM
      REAL(q) :: OPZ,OMZ,Z3,Z4,F,GZ,HZ,DFZ,DGZ,DHZ
      parameter(ONE=1.0_q)
      parameter(four=4.0_q)
      parameter(thrd=1._q/3._q,thrdm=-thrd,thrd2=2._q*thrd)
      parameter(sixthm=thrdm/2._q)
      parameter(thrd4=4._q*thrd)
      parameter(GAM=0.5198420997897463295344212145565_q)
      parameter(fzz=8._q/(9._q*GAM))
      parameter(gamma=0.03109069086965489503494086371273_q)
      parameter(bet=0.06672455060314922_q,delt=bet/gamma)
      parameter(eta=1.e-12_q)

      rtrs=dsqrt(rs)
      CALL gcor2mgga(0.0310907_q,0.21370_q,7.5957_q,3.5876_q,1.6382_q, &
     &    0.49294_q,rtrs,EU,EURS,D2EURS)
      CALL gcor2mgga(0.01554535_q,0.20548_q,14.1189_q,6.1977_q,3.3662_q, &
     &    0.62517_q,rtRS,EP,EPRS,D2EPRS)
      CALL gcor2mgga(0.0168869_q,0.11125_q,10.357_q,3.6231_q,0.88026_q, &
     &    0.49671_q,rtRS,ALFM,ALFRSM,D2ALFRSM)

      OPZ = ONE + ZET
      OMZ = ONE - ZET

      Z3 = ZET**3
      Z4 = Z3*ZET
      F = (OPZ**THRD4+OMZ**THRD4-2._q)/GAM
      GZ = F*Z4
      HZ = (F-GZ)/FZZ

      EC = EU*(ONE-GZ) + EP*GZ - ALFM*HZ
      DECRS = EURS*(ONE-GZ) + EPRS*GZ - ALFRSM*HZ
      D2ECRS = D2EURS*(ONE-GZ) + D2EPRS*GZ - D2ALFRSM*HZ

      DFZ = THRD4*(OPZ**THRD - OMZ**THRD)/GAM
      DGZ = DFZ*Z4 + FOUR*F*Z3
      DHZ = (DFZ-DGZ)/FZZ

      DECDZ = (EP-EU)*DGZ - ALFM*DHZ
      D2ECRSZ = (EPRS-EURS)*DGZ - ALFRSM*DHZ

      END SUBROUTINE PW91LDA


      SUBROUTINE GCOR2MGGA(A,A1,B1,B2,B3,B4,rtrs,GG,GGRS,D2GGRS)
!$ACC ROUTINE SEQ
      USE prec
      IMPLICIT NONE
      REAL(q) :: A,A1,B1,B2,B3,B4,RTRS,GG,GGRS,D2GGRS
      REAL(q) :: Q0,Q1,Q2,Q3,DQ0,DQ2,D2Q1,D2Q2,DQ1
      Q0 = -2._q*A*(1._q+A1*rtrs*rtrs)
      Q1 = 2._q*A*rtrs*(B1+rtrs*(B2+rtrs*(B3+B4*rtrs)))
      Q2 = DLOG(1._q+1._q/Q1)
      GG = Q0*Q2

      DQ0 = -2._q*A*A1
      DQ1 = A*(B1/rtrs+2._q*B2+rtrs*(3._q*B3+4._q*B4*rtrs))
      DQ2 = -DQ1/(Q1+Q1**2)
      GGRS = DQ0*Q2+Q0*DQ2


      D2Q1 = A*(3._q*B3/(2._q*RTRS)-B1/(2._q*RTRS**3)+4._q*B4)
      D2Q2 = (2._q*Q1+1._q)*DQ2**2 - D2Q1/(Q1+Q1**2)
      D2GGRS = 2._q*DQ0*DQ2 + Q0*D2Q2
      RETURN
      END SUBROUTINE GCOR2MGGA

!************************ SUBROUTINE VSCAN2x ****************************
!
! calculates the first order derivatives of Ex wrt n and |grad(n)|
! Perdew et. al. PRL (2009)
!
! Originally written by Jianwei Sun
!
! Re-written and generalised by James W. Furness and Aaron D. Kaplan,
! 5 August 2020,
! to accomodate rSCAN, r++SCAN, r2SCAN, and r4SCAN
! JWF: jfurness@tulane.edu
! ADK: kaplan@temple.edu
! r2 SCAN preprint (arXiv:2008.03374)
!
! New flags for METAGGA tag: RSCAN, RPPSCAN, R2SCAN, and R4SCAN (respectively)
!
! r4SCAN is still a work in progress
! r++SCAN is unpublished, and was a test of some of the principles in the
! r2SCAN preprint
!
! everything in Hartree units
!
! Funtional selection uses 3 integer flags:
!   IALPHA  - controls iso-orbital indcator
!           (0 = alpha, 1 = alpha', 2 = \bar{alpha} )
!   IINTERP - controls interpolation function
!           (0 = SCAN, 1 = rSCAN)
!   IDELFX  - controls gradient expansion corrections
!           (0 = SCAN, 1 = rSCAN (2nd order), 2 = rSCAN (4th order), 3 = r2SCAN with diff pars)
!
! Hence for (IALPHA, IINTERP, IDELFX):
!     SCAN = (0, 0, 0)
!     rSCAN = (1, 1, 0)
!     r++SCAN = (2, 1, 0)
!     r2SCAN = (2, 1, 1)
!     r4SCAN = (2, 1, 2)
!
! ATTENTION: Every values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!
! RU,RD                        density up,down
! DRU, DRD                     abs. val. gradient of density up/down
! DRT                          abs. val. gradient of total density
! TAUU,TAUD                    kinetic energy density up/down
! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
! VXD1 VXD2                    THE DERIVATIVES OF EX WRT n
! VXDD1,VXDD2                  THE DERIVATIVES OF EX WRT |grad n|
! AMUXD1, AMUXD2               THE DERIVATIVES OF EX WRT TAU
!
!***********************************************************************



      SUBROUTINE VSCAN2x(&
      &   RU,RD,DRU,DRD,DRT,TAUU,TAUD, &
      &   Ex_SCAN,VXD1,VXDD1,VXD2,VXDD2,AMUXD1,AMUXD2)
!$ACC ROUTINE SEQ

      !      USE prec
      !      USE constant
      IMPLICIT none

      INTEGER, PARAMETER :: q=SELECTED_REAL_KIND(10)
      integer :: IALPHA, IINTERP, IDELFX
      real(q),intent(in) :: ru,rd,dru,drd,drt,tauu,taud
      real(q),intent(out) :: VXD1,VXD2,VXDD1,VXDD2,AMUXD1,AMUXD2
      real(q),intent(out) :: Ex_SCAN
      real(q) :: ex_up,ex_down
      real(q),parameter :: two=2._q
!$ACC ROUTINE(eps_SCANx) SEQ

      VXD1=0._q;VXD2=0._q;
      VXDD1=0._q;VXDD2=0._q;
      AMUXD1=0._q;AMUXD2=0._q;
      Ex_SCAN=0._q
      ex_up = 0._q
      ex_down=0._q

      if (IDSCAN==0) then ! SCAN
        IALPHA=0; IINTERP=0; IDELFX=0;
      else if (IDSCAN==1) then ! rSCAN
        IALPHA=1; IINTERP=1; IDELFX=0;
      else if (IDSCAN==2) then !r++SCAN
        IALPHA=2; IINTERP=1; IDELFX=0;
      else if (IDSCAN==3) then !r2SCAN
        IALPHA=2; IINTERP=1; IDELFX=1;
      else if (IDSCAN==4) then !r4SCAN
        IALPHA=2; IINTERP=1; IDELFX=2;
      else if (IDSCAN==5) then !r2SCAN w/diff pars
        IALPHA=2; IINTERP=1; IDELFX=3;
      endif

      call eps_SCANx(two*ru,two*dru,two*tauu,ex_up, VXD1, VXDD1, AMUXD1,&
      &    IALPHA, IINTERP, IDELFX) ! spin-up

      call eps_SCANx(two*rd,two*drd,two*taud,ex_down, VXD2, VXDD2, AMUXD2,&
      &    IALPHA, IINTERP, IDELFX) ! spin-down

      Ex_SCAN = (ex_up+ex_down)/two

      RETURN
      END SUBROUTINE VSCAN2x


      subroutine eps_SCANx(den, grd, tau, eps_x, dedd, dedg, dedt, &
         &                 IALPHA, IINTERP, IDELFX)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: den, grd, tau
          real(kdp), intent(out) :: eps_x, dedd, dedg, dedt
          integer, intent(in) :: IALPHA, IINTERP, IDELFX

          real(kdp) :: cp, den83, den53
          real(kdp) :: exlda, dexldadd, fx, dfxdp, dfxda
          real(kdp) :: p, dpdd, dpdg
          real(kdp) :: alpha, dadd, dadg, dadt, reg, dreg
          real(kdp) :: tueg, dtuegdd, tueg_con
          real(kdp) :: tauw, dtauwdd, dtauwdg

          real(kdp), parameter :: AX = -0.7385587663820224058842300326808360_kdp
          real(kdp), parameter :: PI = 3.1415926535897932384626433832795_kdp
          real(kdp), parameter :: PI2 = PI*PI
          real(kdp), parameter :: ETA = 1.0e-3_kdp
          real(kdp), parameter :: TAU_R = 1.0e-4_kdp
          real(kdp), parameter :: A_REG = 1.0e-3_kdp
!$ACC ROUTINE(quit,exchange_enhancement) SEQ

      !       Reduced density gradient [FD]
          den83 = den**(8._kdp/3._kdp)
          cp = 4._kdp*(3._kdp*PI2)**(2._kdp/3._kdp)
          p = grd**2/(cp*den83)
          dpdd = -8._kdp/3._kdp*p/den
          dpdg = 2._kdp*p/grd

      !       Regularised Alpha [FD]
          tueg_con = 3._kdp/10._kdp*(3._kdp*PI2)**(2._kdp/3._kdp)
          den53 = den**(5._kdp/3._kdp)
          if (IALPHA .eq. 1) then ! regularised tau_ueg for rSCAN \tilde{alpha}
              tueg = tueg_con*den53 + TAU_R
          else                    ! Unregularised tau_ueg
              tueg = tueg_con*den53
          end if
          dtuegdd = 5._kdp/3._kdp*tueg_con*den53/den

          tauw = grd**2/8._kdp/den
          dtauwdd = -grd**2/(8._kdp*den**2)
          dtauwdg = 2._kdp*grd/(8._kdp*den)

          if (IALPHA .eq. 0) then ! SCAN unregularised alpha
              alpha = (tau - tauw)/tueg
              dadd = -(tau - tauw)*dtuegdd/tueg**2 - dtauwdd/tueg
              dadg = -dtauwdg/tueg
              dadt = 1._kdp/tueg

          else if (IALPHA .eq. 1) then ! rSCAN alpha'
              alpha = (tau - tauw)/tueg
              dadd = ((tauw - tau)*dtuegdd - tueg*dtauwdd)/tueg**2
              dadg = -grd/(4._kdp*den*tueg)
              dadt = 1._kdp/tueg

              if (A_REG .gt. 0._kdp) then
                  reg = alpha**3/(alpha**2 + A_REG)
                  dreg = (alpha**4 + 3._kdp*alpha**2*A_REG)/(alpha**2 + A_REG)**2
                  dadd = dadd*dreg
                  dadg = dadg*dreg
                  dadt = dadt*dreg
                  alpha = reg
              endif

          else if (IALPHA .eq. 2) then ! \bar{alpha} for r2scan and r4scan
              alpha = (tau - tauw)/(tueg + ETA*tauw)
              dadd = -dtauwdd/(tueg + ETA*tauw) &
             &    - (tau - tauw)*(dtuegdd + ETA*dtauwdd)/(tueg + ETA*tauw)**2
              dadg = -ETA*(tau - tauw)*dtauwdg/(tueg + ETA*tauw)**2 &
             &    - dtauwdg/(tueg + ETA*tauw)
              dadt = 1._kdp/(tueg + ETA*tauw)

          else
              call quit('ERROR: Unknown IALPHA in SCAN')
          end if

      !       UEG exchange density [FD]
          exlda = AX*den**(4._kdp/3._kdp)
          dexldadd = 4._kdp*AX*den**(1._kdp/3._kdp)/3._kdp

          call exchange_enhancement(p, alpha, fx, dfxdp, dfxda, ETA, IINTERP, IDELFX)

      !       Exchange Energy[FD]
          eps_x = exlda*fx
          dedd = dexldadd*fx + exlda*(dfxdp*dpdd + dfxda*dadd)
          dedg = exlda*(dfxdp*dpdg + dfxda*dadg)
          dedt = exlda*dfxda*dadt

      end subroutine eps_SCANx

      subroutine exchange_enhancement(p, alpha, Fx, dfxdp, dfxda, ETA, IINTERP, IDELFX)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: p, alpha
          real(kdp), intent(out) :: Fx, dfxdp, dfxda
          real(kdp), intent(in) :: ETA
          integer, intent(in) :: IINTERP, IDELFX


          real(kdp) :: ief, diefda, oma
          real(kdp) :: h0x
          real(kdp) :: h1x, dh1xdp, dh1xda
          real(kdp) :: gx, dgxdp
          real(kdp) :: del_f2, C2, ALPHA_GE, damp, ddampdp
          real(kdp) :: del_fx, ddel_fxdp, ddel_fxda
          real(kdp) :: wfac, dwfacdp, vfac, dvfacdp, dvfacda
          real(kdp) :: yfac, dyfacdp, dyfacda,D_DAMP2

          real(kdp), parameter :: A1 = 4.9479_kdp
          real(kdp), parameter :: K0 = 0.174_kdp
          real(kdp), parameter :: MU = 10._kdp/81._kdp
          real(kdp), parameter :: K1 = 0.065_kdp

          real(kdp), parameter :: cfx1 = 0.667_kdp
          real(kdp), parameter :: cfx2 = 0.800_kdp
          real(kdp), parameter :: cfdx1 = 1.24_kdp

          real(kdp), parameter :: B1 = 0.156632_kdp
          real(kdp), parameter :: B2 = 0.12083_kdp
          real(kdp), parameter :: B3 = 0.5_kdp
          real(kdp), parameter :: B4 = MU*MU/K1 - 0.112654_kdp

          real(kdp), dimension(8) :: PARAMS
          integer, dimension(8) :: f_x_e
          !real(kdp), parameter :: D_DAMP2 = 0.361_kdp
!$ACC ROUTINE(quit,get_del_fx) SEQ

          PARAMS = (/ &
          &      -0.023185843322_kdp,0.234528941479_kdp,-0.887998041597_kdp, &
          &      1.451297044490_kdp,-0.663086601049_kdp,-0.4445555_kdp,-0.667_kdp, &
          &      1._kdp/)

          f_x_e = (/7,6,5,4,3,2,1,0/)

          if (IDELFX==3) then
            D_DAMP2 = 5.259688_kdp
          else
            D_DAMP2 = 0.361_kdp
          end if

          ALPHA_GE = 20._kdp/27._kdp + ETA*5._kdp/3._kdp

          ief = 0._kdp
          diefda = 0._kdp
          oma = 1._kdp - alpha
          if (IINTERP .eq. 0) then  ! scan interpolation function
              if (alpha .lt. 1._kdp) then
                  ief = exp(-cfx1*alpha/oma)
                  diefda = -cfx1*exp(-cfx1*alpha/oma)/oma**2
              else
                  ief = -cfdx1*exp(cfx2/oma)
                  diefda = -cfx2*cfdx1*exp(cfx2/oma)/oma**2
              endif

          else if (IINTERP .eq. 1) then ! rscan, r2scan, r4scan interpolation function
              if (alpha .lt. 1.0e-13_kdp) then
                  ief = exp(-cfx1*alpha/oma)
                  diefda = -cfx1*exp(-cfx1*alpha/oma)/oma**2
              else if( alpha .lt. 2.5_kdp) then
                  ief = dot_product(alpha**f_x_e, PARAMS)
                  diefda = dot_product(alpha**f_x_e(2:), f_x_e(:7)*PARAMS(:7))
              else if (alpha .ge. 2.5_kdp) then
                  ief = -cfdx1*exp(cfx2/oma)
                  diefda = -cfx2*cfdx1*exp(cfx2/oma)/oma**2
              endif

          else
              call quit('ERROR: Unknown IINTERP in SCAN')
          end if

      !       Single orbital enhancement
          h0x = 1._kdp + K0

      !       Slowly varying enhancement
          if (IDELFX .eq. 0) then     ! scan, rscan
              wfac = B4*p**2*exp(-B4*p/MU)
              dwfacdp = B4*p*exp(-B4*p/MU)*(2._kdp - B4*p/MU)

              vfac = B1*p + B2*oma*exp(-B3*oma**2)
              yfac = MU*p + wfac + vfac**2
              h1x = 1._kdp + K1 - K1/(1._kdp + yfac/K1)

              dvfacdp = B1
              dyfacdp = MU + dwfacdp + 2._kdp*vfac*dvfacdp
              dh1xdp = dyfacdp/(1._kdp + yfac/K1)**2

              dvfacda = -B2*(1._kdp - 2._kdp*B3*oma**2)*exp(-B3*oma**2)
              dyfacda = 2._kdp*vfac*dvfacda
              dh1xda = dyfacda/(1._kdp + yfac/K1)**2

          else if (IDELFX .eq. 1 .or. IDELFX .eq. 2 .or. IDELFX .eq. 3) then  ! Second order corrections
              del_f2 = dot_product(f_x_e(:7), PARAMS(:7))
              C2 = -del_f2*(1._kdp - h0x)

      !       Damping
              damp = exp(-p**2/D_DAMP2**4)
              ddampdp = -2._kdp*damp*p/D_DAMP2**4

      !       Slowly varying contribution [FD]
              h1x = 1._kdp + K1 - K1/(1._kdp + p*(MU + ALPHA_GE*C2*damp)/K1)
              dh1xdp = K1**2*(MU + ALPHA_GE*C2*(damp + p*ddampdp)) &
              &              /(K1 + MU*p + ALPHA_GE*C2*p*damp)**2
              dh1xda = 0._kdp

          else
              call quit('ERROR: Unknown IDELFX in SCAN')
          end if

          gx = 1._kdp - exp(-A1/p**(1._kdp/4._kdp))
          dgxdp = -A1*exp(-A1/p**(1._kdp/4._kdp))/(4._kdp*p**(5._kdp/4._kdp))

          if (IDELFX .eq. 2) then  ! 4th order corrections for r4scan
              call get_del_fx(p, alpha, del_fx, ddel_fxdp, ddel_fxda, &
              &                        K0, K1, C2, ETA, ALPHA_GE, PARAMS, f_x_e)
          else
              del_fx = 0._kdp
              ddel_fxdp = 0._kdp
              ddel_fxda = 0._kdp
          end if

          fx = (h1x + ief*(h0x - h1x) + del_fx)*gx
          dfxdp = (del_fx + h1x + (h0x - h1x)*ief)*dgxdp &
          &       + gx*(ddel_fxdp + dh1xdp - ief*dh1xdp)
          dfxda = gx*((h0x - h1x)*diefda + ddel_fxda + dh1xda - ief*dh1xda)

      end subroutine exchange_enhancement

      subroutine get_del_fx(p, alpha, del_fx, ddel_fxdp, ddel_fxda, &
      &                        K0, K1, C2, ETA, ALPHA_GE, PARAMS, f_x_e)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: p, alpha, K0, K1, C2, ETA, ALPHA_GE
          real(kdp), dimension(8), intent(in) :: PARAMS
          integer, dimension(8), intent(in) :: f_x_e
          real(kdp), intent(out) :: del_fx, ddel_fxdp, ddel_fxda
          real(kdp) :: order_1, dorder_1dp, dorder_1da, C_pa, C_aa, C_pp
          real(kdp) :: oma, damp, t1, dt1dp, dt1da, ddampdp, ddampda
!$ACC ROUTINE(get_dx_terms,get_fourth_order_damp) SEQ

          call get_dx_terms(C_aa, C_pa, C_pp, &
          &              K0, K1, C2, ETA, PARAMS, f_x_e)

          oma = 1._kdp - alpha

          order_1 = C2*(oma - ALPHA_GE*p)
          dorder_1dp = -C2*ALPHA_GE
          dorder_1da = -C2

      !       Correcting contribution [FD]
          t1 = order_1 + C_aa*oma**2 + C_pa*p*oma + C_pp*p**2
          dt1dp = dorder_1dp + 2*C_pp*p + C_pa*oma
          dt1da = dorder_1da - 2*C_aa*oma - C_pa*p

          call get_fourth_order_damp(p, alpha, damp, ddampdp, ddampda)

          del_fx = t1*damp
          ddel_fxdp = damp*dt1dp + t1*ddampdp
          ddel_fxda = t1*ddampda + dt1da*damp

      end subroutine get_del_fx

      subroutine get_dx_terms(C_aa, C_pa, C_pp, K0, K1, C2, ETA, &
      &                  PARAMS, f_x_e)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: K0, K1, C2, ETA
          real(kdp), dimension(8), intent(in) :: PARAMS
          integer, dimension(8), intent(in) :: f_x_e
          real(kdp), intent(out) :: C_aa, C_pa, C_pp
          real(kdp) :: h0x, eta_term, del_f2, del_f4
          real(kdp) :: ALPHA_GE

          real(kdp), parameter :: MU = 10._kdp/81._kdp

          ALPHA_GE = 20._kdp/27._kdp + ETA*5._kdp/3._kdp

          eta_term = ETA*3._kdp/4._kdp + 2._kdp/3._kdp
          h0x = 1._kdp + K0

          del_f2 = dot_product(f_x_e(:7), PARAMS(:7))
          del_f4 = dot_product(f_x_e(:7)*(f_x_e(:7) - 1._kdp), PARAMS(:7))

          C_aa = 73._kdp/5000._kdp - 0.5_kdp*del_f4*(h0x - 1._kdp)

          C_pa = 511._kdp/13500._kdp - 73._kdp/1500._kdp*ETA &
          &            - del_f2*(ALPHA_GE*C2 + MU)

          C_pp = 146._kdp/2025._kdp*eta_term**2 - 73._kdp/405._kdp*eta_term &
          &            + (ALPHA_GE*C2 + MU)**2/K1

      end subroutine get_dx_terms

      subroutine get_fourth_order_damp(p, alpha, damp4, &
      &            ddamp4dp, ddamp4da)
!$ACC ROUTINE SEQ

          implicit NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: p, alpha
          real(kdp), intent(out) :: damp4, ddamp4dp, ddamp4da
          real(kdp) :: t1, t2, dt1da, dt2dp, dt2da, oma
          real(kdp), parameter :: DX_DAMP4_P = 0.802_kdp
          real(kdp), parameter :: DX_DAMP4_A = 0.178_kdp

          oma = 1._kdp - alpha

          t1 = 2._kdp*alpha**2/(1._kdp + alpha**4)
          dt1da = -4._kdp*alpha*(alpha**4 - 1._kdp)/(1._kdp + alpha**4)**2

          t2 = exp(-oma**2/DX_DAMP4_A**2 - p**2/DX_DAMP4_P**4)
          dt2dp = -2.d0*t2*p/DX_DAMP4_P**4
          dt2da = 2*oma*t2/DX_DAMP4_A**2

          damp4 = t1*t2
          ddamp4dp = t1*dt2dp
          ddamp4da = t1*dt2da + t2*dt1da

      end subroutine get_fourth_order_damp


      !************************ SUBROUTINE VSCAN2c ****************************
      !! Originally written by Jianwei Sun
      !
      ! Re-written and generalised by James W. Furness and Aaron D. Kaplan,
      ! 5 August 2020,
      ! to accomodate rSCAN, r++SCAN, r2SCAN, and r4SCAN
      ! JWF: jfurness@tulane.edu
      ! ADK: kaplan@temple.edu
      ! r2 SCAN preprint (arXiv:2008.03374)
      !
      ! New flags for METAGGA tag: RSCAN, RPPSCAN, R2SCAN, and R4SCAN (respectively)
      !
      ! r4SCAN is still a work in progress
      ! r++SCAN is unpublished, and was a test of some of the principles in the
      ! r2SCAN preprint
      !
      ! everything in Hartree units
      !
      ! Funtional selection uses 3 integer flags:
      !   IALPHA  - controls iso-orbital indcator
      !           (0 = alpha, 1 = alpha', 2 = \bar{alpha} )
      !   IINTERP - controls interpolation function
      !           (0 = SCAN, 1 = rSCAN)
      !   IDELEC  - controls gradient expansion corrections
      !           (0 = SCAN, 1 or 2 = rSCAN (2nd order), 3 = r2SCAN with different params)
      !
      ! Hence for (IALPHA, IINTERP, IDELEC):
      !     SCAN = (0, 0, 0)
      !     rSCAN = (1, 1, 0)
      !     r++SCAN = (2, 1, 0)
      !     r2SCAN = (2, 1, 1)
      !     r4SCAN = (2, 1, 1) or (2, 1, 2)
      !
      ! RU,RD                        density up,down
      ! DRU, DRD                     abs. val. gradient of density up/down
      ! DRT                          abs. val. gradient of total density
      ! TAUU,TAUD                    kinetic energy density up/down
      ! TAUWU,TAUWD                  Weizsaecker kinetic energy density up/down
      ! VCD1 VCD2                    THE DERIVATIVES OF EC WRT n
      ! VCDD1,VCDD2                  THE DERIVATIVES OF EC WRT |grad n|
      ! AMUCD1, AMUCD2                   THE DERIVATIVES OF EC WRT TAU
      !
      !***********************************************************************

      SUBROUTINE VSCAN2c(&
          &   RU,RD,DRU,DRD,DRT,TAUU,TAUD,&
          &   Ec_SCAN,VCD1,VCD2,VCDD1,VCDD2,VCDD,AMUCD1,AMUCD2)
!$ACC ROUTINE SEQ

          IMPLICIT NONE

          real*8,intent(in) :: ru,rd,dru,drd,drt,tauu,taud
          real*8,intent(out) :: Ec_SCAN,VCD1,VCD2,VCDD1,VCDD2,VCDD,AMUCD1,AMUCD2
          integer :: IALPHA, IINTERP, IDELEC
!$ACC ROUTINE(scan_c_new) SEQ

          if (IDSCAN==0) then ! SCAN
            IALPHA=0; IINTERP=0; IDELEC=0;
          else if (IDSCAN==1) then ! rSCAN
            IALPHA=1; IINTERP=1; IDELEC=0;
          else if (IDSCAN==2) then !r++SCAN
            IALPHA=2; IINTERP=1; IDELEC=0;
          else if (IDSCAN==3) then !r2SCAN
            IALPHA=2; IINTERP=1; IDELEC=1;
          else if (IDSCAN==4) then !r4SCAN
            IALPHA=2; IINTERP=1; IDELEC=2;
          else if (IDSCAN==5) then !r2SCAN w/diff pars
            IALPHA=2; IINTERP=1; IDELEC=3;
          endif

          call scan_c_new(ru, rd, dru, drd, drt, tauu, taud, ec_scan, &
              &             vcd1, vcd2, vcdd1, vcdd2, vcdd, amucd1, amucd2, &
              &             IALPHA, IINTERP, IDELEC)

      end subroutine VSCAN2c

      subroutine scan_c_new(d0, d1, g0, g1, gt, t0, t1, eps_c, &
          &             dedd0, dedd1, dedg0, dedg1, dedg, dedt0, dedt1, &
          &             IALPHA, IINTERP, IDELEC)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)
          real(kdp), intent(in) :: d0, d1, g0, g1, gt, t0, t1
          real(kdp), intent(out) :: eps_c, dedd0, dedt0, dedd1, dedt1,dedg0,dedg1,dedg
          integer, intent(in) :: IALPHA, IINTERP, IDELEC

          real(kdp) :: dt, tt, dthrd, rs, drsdd0, drsdd1
          real(kdp) :: zeta, dzetadd0, dzetadd1, ds_z, dds_zdd0, dds_zdd1
          real(kdp) :: s, dsdd0, dsdg0, dsdd1, dsdg1, gngn0, gngn1
          real(kdp) :: y0, y1, y, yc, dycdg0, dycdg1
          real(kdp) :: alpha, dadd0, dadg0, dadt0, dadd1, dadg1, dadt1, oma
          real(kdp) :: reg, dreg
          real(kdp) :: tueg, tueg_con, dtuegdd0, dtuegdd1
          real(kdp) :: tauw, dtauwdd0, dtauwdg0, dtauwdd1, dtauwdg1
          real(kdp) :: ief, diefda, diefdd0, diefdd1, diefdg0, diefdg1
          real(kdp) :: diefdt0, diefdt1
          real(kdp) :: ec0, dec0drs, dec0ds, dec0dz
          real(kdp) :: dec0dd0, dec0dd1, dec0dg0, dec0dg1
          real(kdp) :: ec1, dec1drs, dec1ds, dec1dz ! got rid of dec1da, as this was not assigned, ADK
          real(kdp) :: dec1dd0, dec1dd1, dec1dg0, dec1dg1
          real(kdp) :: dsdg,dtauwdg,dadg,diefdg,dec0dg,dec1dg ! corrections for spin-polarized calculations, ADK

          real(kdp), parameter :: CFDC1 = 0.7_kdp
          real(kdp), parameter :: CFC1 = 0.640_kdp
          real(kdp), parameter :: CFC2 = 1.5_kdp

          real(kdp), dimension(7) :: IE_PARAMS_C

          real(kdp), parameter :: ETA = 1.0e-3_kdp
          real(kdp), parameter :: TAU_R = 1.0e-4_kdp
          real(kdp), parameter :: A_REG = 1.0e-3_kdp

          integer :: i

          real(kdp), parameter :: BETA_MB = 0.066725_kdp
          real(kdp), parameter :: GAMMA = 0.031090690869655_kdp
          real(kdp), parameter :: AFACTOR = 0.1_kdp
          real(kdp), parameter :: BFACTOR = 0.1778_kdp
          real(kdp), parameter :: PI = 3.1415926535897932384626433832795_kdp
          real(kdp), parameter :: PI2 = PI*PI
!$ACC ROUTINE(quit,scan_ec0,scan_ec1) SEQ

          IE_PARAMS_C = &
          &    (/-0.64_kdp, -0.4352_kdp, -1.535685604549_kdp, 3.061560252175_kdp, &
          &        -1.915710236206_kdp, 0.516884468372_kdp, -0.051848879792_kdp/)

          dt = d0 + d1
          y0 = g0**2
          y1 = g1**2
          y = gt**2
          yc = (y - y0 - y1)/2._kdp
          tt = t0 + t1

          dycdg0 = yc/g0
          dycdg1 = yc/g1

          !        Zeta [FD]
          zeta = min(max((d0 - d1)/dt, -0.99999999999990_kdp), 0.99999999999990_kdp)
          dzetadd0 = 2._kdp*d1/dt**2
          dzetadd1 = -2._kdp*d0/dt**2

          !        Wigner-Seitz radius [FD]
          dthrd = dt**(1._kdp/3._kdp)
          rs = (0.75_kdp/PI)**(1._kdp/3._kdp)/dthrd
          drsdd0 = -(0.75_kdp/PI)**(1._kdp/3._kdp)/(3._kdp*dthrd*dt)
          drsdd1 = drsdd0

          !        Reduced density gradient [FD]
          s = gt/(2._kdp*(3._kdp*PI2)**(1._kdp/3._kdp)*dt**(4._kdp/3._kdp))
          dsdd0 = -4._kdp/3._kdp*s/dt
          dsdd1 = dsdd0
          gngn0 = 1._kdp/(2._kdp*gt)*(2._kdp*g0+2._kdp*yc/g0)
          gngn1 = 1._kdp/(2._kdp*gt)*(2._kdp*g1+2._kdp*yc/g1)
          dsdg0 = s/gt*gngn0
          dsdg1 = s/gt*gngn1
          dsdg = s/gt ! ADK

          !        ds_zeta [FD]
          ds_z = ((1._kdp + zeta)**(5._kdp/3._kdp) + (1._kdp - zeta)**(5._kdp/3._kdp))/2._kdp
          dds_zdd0 = 5._kdp/3._kdp* &
          &    ((1._kdp + zeta)**(2._kdp/3._kdp) - (1._kdp - zeta)**(2._kdp/3._kdp))*dzetadd0/2._kdp
          dds_zdd1 = 5._kdp/3._kdp* &
          &    ((1._kdp + zeta)**(2._kdp/3._kdp) - (1._kdp - zeta)**(2._kdp/3._kdp))*dzetadd1/2._kdp

          !       alpha
          tueg_con = 3._kdp/10._kdp*(3._kdp*PI2)**(2._kdp/3._kdp)

          if (IALPHA .eq. 1) then
              tueg = (tueg_con*dt**(5._kdp/3._kdp) + TAU_R)*ds_z
              dtuegdd0 = 5._kdp/3._kdp*tueg_con*dt**(2._kdp/3._kdp)*ds_z &
              &           + tueg*dds_zdd0/ds_z
              dtuegdd1 = 5._kdp/3._kdp*tueg_con*dt**(2._kdp/3._kdp)*ds_z &
              &           + tueg*dds_zdd1/ds_z
          else
              tueg = tueg_con*dt**(5._kdp/3._kdp)*ds_z
              dtuegdd0 = 5._kdp/3._kdp*tueg/dt + tueg*dds_zdd0/ds_z
              dtuegdd1 = 5._kdp/3._kdp*tueg/dt + tueg*dds_zdd1/ds_z
          end if

          !tauw = min(y/(8._kdp*dt), tt)
          tauw = y/(8._kdp*dt)
          dtauwdd0 = -tauw/dt
          dtauwdd1 = dtauwdd0
          dtauwdg0 = (g0 + dycdg0)/(4._kdp*dt)
          dtauwdg1 = (g1 + dycdg1)/(4._kdp*dt)
          dtauwdg = gt/(4._kdp*dt) ! ADK

          if (IALPHA .eq. 0 .or. IALPHA .eq. 1) then
              ! Conventional alpha
              alpha = (tt - tauw)/tueg
              dadd0 = -(dtauwdd0 + alpha*dtuegdd0)/tueg
              dadd1 = -(dtauwdd1 + alpha*dtuegdd1)/tueg
              dadg0 = -dtauwdg0/tueg
              dadg1 = -dtauwdg1/tueg
              dadg = -dtauwdg/tueg ! ADK
              dadt0 = 1._kdp/tueg
              dadt1 = 1._kdp/tueg

          else if (IALPHA .eq. 2) then
              ! regularised alpha of r++scan, r2scan, r4scan
              alpha = (tt - tauw)/(tueg + ETA*tauw)
              dadd0 = -dtauwdd0/(tueg + ETA*tauw) &
              &    - (tt - tauw)*(dtuegdd0 + ETA*dtauwdd0)/(tueg + ETA*tauw)**2
              dadd1 = -dtauwdd1/(tueg + ETA*tauw) &
              &    - (tt - tauw)*(dtuegdd1 + ETA*dtauwdd1)/(tueg + ETA*tauw)**2
              dadg0 = -ETA*(tt - tauw)*dtauwdg0/(tueg + ETA*tauw)**2 &
              &    - dtauwdg0/(tueg + ETA*tauw)
              dadg1 = -ETA*(tt - tauw)*dtauwdg1/(tueg + ETA*tauw)**2 &
              &    - dtauwdg1/(tueg + ETA*tauw)
              dadg =  -ETA*(tt - tauw)*dtauwdg/(tueg + ETA*tauw)**2 &
              &    - dtauwdg/(tueg + ETA*tauw) ! ADK
              dadt0 = 1._kdp/(tueg + ETA*tauw)
              dadt1 = dadt0
          else
              call quit('Bad IALPHA in SCAN')
          end if

          if (IALPHA .eq. 1) then
              ! alpha regularisation for rscan
              reg = alpha**3/(alpha**2 + A_REG)
              dreg = (alpha**4 + 3._kdp*alpha**2*A_REG)/(alpha**2 + A_REG)**2
              dadd0 = dadd0*dreg
              dadd1 = dadd1*dreg
              dadg0 = dadg0*dreg
              dadg1 = dadg1*dreg
              dadg = dadg*dreg ! ADK
              dadt0 = dadt0*dreg
              dadt1 = dadt1*dreg
              alpha = reg
          end if

          ief = 0._kdp
          diefda = 0._kdp
          oma = 1._kdp - alpha

          if (IINTERP .eq. 0) then
              ! SCAN interpolation function
              if (alpha .lt. 1._kdp) then
                  ief = exp(-CFC1*alpha/oma)
                  diefda = -CFC1*ief/oma**2
              else if (alpha .ge. 1.0_kdp) then
                  ief = -CFDC1*exp(CFC2/oma)
                  diefda = CFC2*ief/oma**2
              endif

          else if (IINTERP .eq. 1) then
              ! rSCAN interpolation function
              if (alpha .lt. 1.0e-13_kdp) then
                  ief = exp(-CFC1*alpha/oma)
                  diefda = -CFC1*ief/oma**2
              else if (alpha .lt. 2.5_kdp) then
                  ief = 1._kdp
                  do i = 1, 7
                      ief = ief + IE_PARAMS_C(i)*alpha**(i)
                      diefda = diefda + i*IE_PARAMS_C(i)*alpha**(i - 1)
                  end do
              else if (alpha .ge. 2.5_kdp) then
                  ief = -CFDC1*exp(CFC2/oma)
                  diefda = CFC2*ief/oma**2
              endif
          else
              call quit('Bad IINTERP in SCAN')
          end if

          diefdd0 = diefda*dadd0
          diefdd1 = diefda*dadd1
          diefdg0 = diefda*dadg0
          diefdg1 = diefda*dadg1
          diefdg = diefda*dadg ! ADK
          diefdt0 = diefda*dadt0
          diefdt1 = diefda*dadt1

          !        Single Orbital Correlation
          ec0 = 0._kdp
          dec0drs = 0._kdp
          dec0ds = 0._kdp
          dec0dz = 0._kdp
          call scan_ec0(rs, s, zeta, ec0, dec0drs, dec0ds, dec0dz)
          dec0dd0 = dec0drs*drsdd0 + dec0dz*dzetadd0 + dec0ds*dsdd0
          dec0dd1 = dec0drs*drsdd1 + dec0dz*dzetadd1 + dec0ds*dsdd1
          dec0dg0 = dec0ds*dsdg0
          dec0dg1 = dec0ds*dsdg1
          dec0dg = dec0ds*dsdg ! ADK

          !        Slowly Varying Correlation
          ec1 = 0._kdp
          dec1drs = 0._kdp
          dec1ds = 0._kdp
          dec1dz = 0._kdp
          call scan_ec1(rs, s, zeta, &
          &                  ec1, dec1drs, dec1dz, dec1ds, IE_PARAMS_C, ETA, IDELEC)
          dec1dd0 = dec1drs*drsdd0 + dec1dz*dzetadd0 + dec1ds*dsdd0
          dec1dd1 = dec1drs*drsdd1 + dec1dz*dzetadd1 + dec1ds*dsdd1
          dec1dg0 = dec1ds*dsdg0
          dec1dg1 = dec1ds*dsdg1
          dec1dg = dec1ds*dsdg ! got rid of unassigned variable dec1da, ADK

          !        Full correlation functional
          eps_c = (ec1 + ief*(ec0 - ec1))*dt
          dedd0 = ec1 + (ec0 - ec1)*ief &
          &    + dt*(ief*(dec0dd0 - dec1dd0) + dec1dd0 + (ec0 - ec1)*diefdd0)
          dedd1 = ec1 + (ec0 - ec1)*ief &
          &    + dt*(ief*(dec0dd1 - dec1dd1) + dec1dd1 + (ec0 - ec1)*diefdd1)
          dedg0 = dt* &
          &      (ief*(dec0dg0 - dec1dg0) + dec1dg0 + (ec0 - ec1)*diefdg0)
          dedg1 = dt* &
          &      (ief*(dec0dg1 - dec1dg1) + dec1dg1 + (ec0 - ec1)*diefdg1)
          ! VASP wants d E_c /d |grad n| rather than
          ! d E_c / d |grad n_sigma| for up and down
          ! spin-densities, ADK 26 August, 2020
          dedg = dt* &
          &      (ief*(dec0dg - dec1dg) + dec1dg + (ec0 - ec1)*diefdg)

          dedt0 = dt*(ec0 - ec1)*diefdt0
          dedt1 = dt*(ec0 - ec1)*diefdt1

      end subroutine scan_c_new

      subroutine scan_ec0(rs, s, zeta, ec0, dec0drs, dec0ds, dec0dz)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: rs, s, zeta
          real(kdp), intent(out) :: ec0, dec0drs, dec0ds, dec0dz

          real(kdp) :: eclda, dldadrs, dldadrsrs
          real(kdp) :: dx_z, ddx_zdz, gc_z, dgc_zdz
          real(kdp) :: w0, dw0drs, ginf, dginfds
          real(kdp) :: h0, dh0drs, dh0ds

          real(kdp), parameter :: B1C = 0.0285764_kdp
          real(kdp), parameter :: CHI_LD = 0.12802585262625815_kdp
!$ACC ROUTINE(lda_0) SEQ

          call lda_0(rs, eclda, dldadrs, dldadrsrs, B1C)

          dx_z = ((1._kdp + zeta)**(4._kdp/3._kdp) + (1._kdp - zeta)**(4._kdp/3._kdp))/2._kdp
          ddx_zdz = -2._kdp*((1._kdp - zeta)**(1._kdp/3._kdp) - (1._kdp + zeta)**(1._kdp/3._kdp))/3._kdp

          gc_z = (1._kdp - 2.363_kdp*(dx_z - 1._kdp))*(1._kdp - zeta**12)
          dgc_zdz = -(1._kdp - 2.363_kdp*(dx_z - 1._kdp))*12._kdp*zeta**11
          dgc_zdz = dgc_zdz - 2.363_kdp*ddx_zdz*(1._kdp - zeta**12)

          w0 = exp(-eclda/B1C) - 1._kdp
          dw0drs = -(w0 + 1._kdp)*dldadrs/B1C

          ginf = 1._kdp/(1._kdp + 4._kdp*CHI_LD*s*s)**(1._kdp/4._kdp)
          dginfds = -2._kdp*CHI_LD*s/(1._kdp + 4._kdp*CHI_LD*s*s)**(5._kdp/4._kdp)

          h0 = B1C*log(1._kdp + w0*(1._kdp - ginf))
          dh0drs = B1C*(1._kdp - ginf)*dw0drs/(1._kdp + (1._kdp - ginf)*w0)
          dh0ds = -B1C*w0*dginfds/(1._kdp + (1._kdp - ginf)*w0)

          ec0 = (eclda + h0)*gc_z
          dec0drs = (dldadrs + dh0drs)*gc_z
          dec0dz = (h0 + eclda)*dgc_zdz
          dec0ds = dh0ds*gc_z

      end subroutine scan_ec0

      subroutine scan_ec1(rs, s, zeta, &
          &                ec1, dec1drs, dec1dz, dec1ds, IE_PARAMS_C, ETA, IDELEC)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: rs, s, zeta
          real(kdp), intent(out) :: ec1, dec1drs, dec1dz, dec1ds
          real(kdp), dimension(7), intent(in) :: IE_PARAMS_C
          real(kdp), intent(in) :: ETA
          integer, intent(in) :: IDELEC

          real(kdp) :: sqrt_rs, dx_z, ddx_zdz, gc_z, dgc_zdz, phi, dphidz
          real(kdp) :: phi3, dphi3dz
          real(kdp) :: eclda0, declda0drs, declda0drsrs
          real(kdp) :: eclsda1, declsda1drs, declsda1dz, declsda1drsrs, declsda1drsz
          real(kdp) :: t, dtdrs, dtdz, dtds
          real(kdp) :: w1, dw1drs, dw1dz, y, dydrs, dydz, dyds
          real(kdp) :: del_y, ddel_ydrs, ddel_ydz, ddel_yds
          real(kdp) :: g_y, dg_ydrs, dg_ydz, dg_yds
          real(kdp) :: h1, dh1drs, dh1dz, dh1ds, D_DAMP2

          real(kdp), parameter :: B1C = 0.0285764_kdp
          real(kdp), parameter :: PI = 3.1415926535897932384626433832795_kdp
          real(kdp), parameter :: GAMMA = 0.0310906908696_kdp
          real(kdp), parameter :: BETA_MB = 0.066724550603149220_kdp
          real(kdp), parameter :: AFACTOR = 0.1_kdp
          real(kdp), parameter :: BFACTOR = 0.1778_kdp
          real(kdp) :: AFIX_T
!$ACC ROUTINE(lda_0,lsda_1,get_y,get_del_y,quit) SEQ

          AFIX_T = sqrt(PI/4._kdp)*(9._kdp*PI/4._kdp)**(1._kdp/6._kdp)

          dx_z = ((1._kdp + zeta)**(4._kdp/3._kdp) + (1._kdp - zeta)**(4._kdp/3._kdp))/2._kdp
          ddx_zdz = -2._kdp*((1._kdp - zeta)**(1._kdp/3._kdp) - (1._kdp + zeta)**(1._kdp/3._kdp))/3._kdp

          gc_z = (1._kdp - 2.3631_kdp*(dx_z - 1._kdp))*(1._kdp - zeta**12)
          dgc_zdz = -(1._kdp - 2.3631_kdp*(dx_z - 1._kdp))*12._kdp*zeta**11
          dgc_zdz = dgc_zdz - 2.3631_kdp*ddx_zdz*(1._kdp - zeta**12)

          phi = (exp((2._kdp/3._kdp)*log(1._kdp + zeta)) + exp((2._kdp/3._kdp)*log(1._kdp - zeta)))/2._kdp
          dphidz = (1._kdp/3._kdp)*((1._kdp + zeta)**(-1._kdp/3._kdp)-(1._kdp - zeta)**(-1._kdp/3._kdp))

          phi3 = phi**3
          dphi3dz = 3._kdp*phi**2*dphidz

          call lda_0(rs, eclda0, declda0drs, declda0drsrs, B1C)
          call lsda_1(rs, zeta, eclsda1, declsda1drs, declsda1dz, declsda1drsrs, declsda1drsz)

          sqrt_rs = sqrt(rs)

          t = AFIX_T*s/(sqrt_rs*phi)
          dtdrs = -AFIX_T*s/(2._kdp*phi*rs**(3.0/2.0))
          dtdz = -dphidz*AFIX_T*s/(sqrt_rs*phi**2)
          dtds = AFIX_T/(sqrt_rs*phi)

          w1 = exp(-eclsda1/(GAMMA*phi3)) - 1._kdp
          dw1drs = -(w1 + 1._kdp)*declsda1drs/(GAMMA*phi3)
          dw1dz = -(w1 + 1._kdp)/(GAMMA*phi3)*(declsda1dz - 3._kdp*eclsda1*dphidz/phi)

          call get_y(rs, t, dtdrs, dtdz, dtds, &
          &    w1, dw1drs, dw1dz, GAMMA, &
          &    y, dydrs, dydz, dyds)

          if (IDELEC .eq. 0) then
              del_y = 0._kdp
              ddel_ydrs = 0._kdp
              ddel_ydz = 0._kdp
              ddel_yds = 0._kdp

          else if (IDELEC .eq. 1 .or. IDELEC .eq. 2 .or. IDELEC .eq. 3) then
              if (IDELEC == 3) then
                D_DAMP2 = 5.259688_kdp
              else
                D_DAMP2 = 0.361_kdp
              end if

              call get_del_y(rs, s, zeta, &
              &  eclda0, declda0drs, declda0drsrs, &
              &  eclsda1, declsda1drs, declsda1dz, declsda1drsrs, declsda1drsz, &
              &  gc_z, dgc_zdz, &
              &  phi3, dphi3dz, w1, dw1drs, dw1dz, GAMMA, &
              &  del_y, ddel_ydrs, ddel_ydz, ddel_yds, IE_PARAMS_C, ETA, &
              &  D_DAMP2)

          else
              call quit('Bad IDELEC in SCAN')
          end if

          g_y = 1._kdp/(1._kdp + 4._kdp*(y - del_y))**(1.0/4.0)
          dg_ydrs = -(dydrs - ddel_ydrs) &
          &              /(1.d0 + 4.d0*(y - del_y))**(5.d0/4.d0)
          dg_ydz = -(dydz - ddel_ydz) &
          &              /(1.d0 + 4.d0*(y - del_y))**(5.d0/4.d0)
          dg_yds = -(dyds - ddel_yds) &
          &              /(1.d0 + 4.d0*(y - del_y))**(5.d0/4.d0)

          h1 = GAMMA*phi3*log(1._kdp + w1*(1._kdp - g_y))
          dh1drs = GAMMA*phi3*((1._kdp - g_y)*dw1drs - w1*dg_ydrs) &
          &          /(1._kdp + (1._kdp - g_y)*w1)
          dh1dz = GAMMA*log(1._kdp + (1._kdp - g_y)*w1)*dphi3dz &
          &        + GAMMA*phi3*((1._kdp - g_y)*dw1dz - w1*dg_ydz) &
          &          /(1._kdp + (1._kdp - g_y)*w1)
          dh1ds = -GAMMA*phi3*w1*dg_yds/(1._kdp + (1._kdp - g_y)*w1)

          ec1 = eclsda1 + h1
          dec1drs = declsda1drs + dh1drs
          dec1dz = declsda1dz + dh1dz
          dec1ds = dh1ds
      end subroutine scan_ec1

      subroutine get_y(rs, t, dtdrs, dtdz, dtds, &
          &    w1, dw1drs, dw1dz, GAMMA, &
          &    y, dydrs, dydz, dyds)
!$ACC ROUTINE SEQ

          implicit NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: rs, t, dtdrs, dtdz, dtds
          real(kdp), intent(in) :: w1, dw1drs, dw1dz, GAMMA
          real(kdp), intent(out) :: y, dydrs, dydz, dyds
          real(kdp) :: beta, dbetadrs

          real(kdp), parameter :: BETA_MB = 0.066725_kdp
          real(kdp), parameter :: AFACTOR = 0.1_kdp
          real(kdp), parameter :: BFACTOR = 0.1778_kdp

          beta = BETA_MB*(1._kdp + AFACTOR*rs)/(1._kdp + BFACTOR*rs)
          dbetadrs = BETA_MB*(AFACTOR - BFACTOR)/(1._kdp + BFACTOR*rs)**2

          y = beta/(GAMMA*w1)*t**2
          dydrs = t**2*dbetadrs/(GAMMA*w1) - beta*t**2*dw1drs/(GAMMA*w1**2) &
          &        + 2._kdp*beta*t*dtdrs/(GAMMA*w1)
          dydz = 2._kdp*beta*t*dtdz/(GAMMA*w1) - beta*t**2*dw1dz/(GAMMA*w1**2)
          dyds = 2._kdp*beta*t*dtds/(GAMMA*w1)
      end subroutine get_y

      subroutine get_del_y(rs, s, zeta, lda0, dlda0drs, dlda0drsrs, &
          &  lsda1, dlsda1drs, dlsda1dz, dlsda1drsrs, dlsda1drsz, &
          &  gc, dgcdz, &
          &  phi3, dphi3dz, w1, dw1drs, dw1dz, GAMMA, &
          &  del_y, ddel_ydrs, ddel_ydz, ddel_yds, IE_PARAMS_C, ETA, D_DAMP2)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: rs, s, zeta, lda0, dlda0drs, dlda0drsrs
          real(kdp), intent(in) :: lsda1, dlsda1drs, dlsda1dz, dlsda1drsrs, dlsda1drsz
          real(kdp), intent(in) :: gc, dgcdz
          real(kdp), intent(in) :: phi3, dphi3dz, w1, dw1drs, dw1dz, GAMMA
          real(kdp), intent(out) :: del_y, ddel_ydrs, ddel_ydz, ddel_yds
          real(kdp), dimension(7), intent(in) :: IE_PARAMS_C
          real(kdp), intent(in) :: ETA, D_DAMP2

          real(kdp) :: del_f2
          real(kdp) :: lsda0, dlsda0drs, dlsda0dz, dlsda0drsrs, dlsda0drsz
          real(kdp) :: K, dKdrs, dKdz
          real(kdp) :: t1, dt1drs, dt1dz, t2, dt2drs, dt2dz, t3, dt3drs, dt3dz
          real(kdp) :: damp, ddampds
          real(kdp) :: p, ds_z, dds_zdz
          integer :: i

          !real(kdp), parameter :: D_DAMP2 = 0.361_kdp

          p = s*s
          ds_z = ((1._kdp + zeta)**(5._kdp/3._kdp) + (1._kdp - zeta)**(5._kdp/3._kdp))/2._kdp
          dds_zdz = -5._kdp/6._kdp*((1._kdp - zeta)**(2._kdp/3._kdp) &
          &                         - (1._kdp + zeta)**(2._kdp/3._kdp))

          lsda0 = lda0*gc
          dlsda0drs = dlda0drs*gc
          dlsda0dz = lda0*dgcdz
          dlsda0drsrs = dlda0drsrs*gc
          dlsda0drsz = dlda0drs*dgcdz

          del_f2 = 0._kdp
          do i = 1, 7
              del_f2 = del_f2 + i*IE_PARAMS_C(i)
          end do

          t1 = del_f2/(27._kdp*GAMMA*ds_z*phi3*w1)
          dt1drs = -t1*dw1drs/w1
          dt1dz = -del_f2*(w1*(phi3*dds_zdz + ds_z*dphi3dz) + ds_z*phi3*dw1dz) &
          &         /(27._kdp*GAMMA*(ds_z*phi3*w1)**2)

          t2 = 20._kdp*rs*(dlsda0drs - dlsda1drs)
          dt2drs = 20._kdp*(dlsda0drs - dlsda1drs + rs*(dlsda0drsrs - dlsda1drsrs))
          dt2dz = 20._kdp*rs*(dlsda0drsz - dlsda1drsz)

          t3 = 45._kdp*ETA*(lsda0 - lsda1)
          dt3drs = 45._kdp*ETA*(dlsda0drs - dlsda1drs)
          dt3dz = 45._kdp*ETA*(dlsda0dz - dlsda1dz)

          K = t1*(t2 - t3)
          dKdrs = dt1drs*(t2 - t3) + t1*(dt2drs - dt3drs)
          dKdz = dt1dz*(t2 - t3) + t1*(dt2dz - dt3dz)

          damp = exp(-p**2/D_DAMP2**4)
          ddampds = -4._kdp*damp*s**3/D_DAMP2**4

          del_y = K*p*damp
          ddel_ydrs = p*damp*dKdrs
          ddel_ydz = p*damp*dKdz
          ddel_yds = K*s*(2._kdp*damp + s*ddampds)
      end subroutine get_del_y

      subroutine lda_0(rs, elda_0, dldadrs, dldadrsrs, B1C)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: rs
          real(kdp), intent(out) :: elda_0, dldadrs, dldadrsrs
          real(kdp), intent(in) :: B1C

          real(kdp) :: sqrtrs

          real(kdp), parameter :: B2C = 0.0889_kdp
          real(kdp), parameter :: B3C = 0.125541_kdp

          sqrtrs = sqrt(rs)
          elda_0 = -B1C/(1._kdp + B2C*sqrtrs + B3C*rs)
          dldadrs = (B3C + B2C/(2._kdp*sqrtrs))*elda_0**2/B1C
          dldadrsrs = -B1C*(B2C + 3._kdp*B2C**2*sqrtrs + 9._kdp*B2C*B3C*rs + 8._kdp*B3C**2*rs*sqrtrs) &
          &           /(4._kdp*rs*sqrtrs*(1._kdp + B2C*sqrtrs + B3C*rs)**3)
      end subroutine lda_0

      subroutine lsda_1(rs, zeta, eclda1, declda1drs, declda1dz, declda1drsrs, declda1drsz)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: rs, zeta
          real(kdp), intent(out) :: eclda1, declda1drs, declda1dz
          real(kdp), intent(out) :: declda1drsrs, declda1drsz
          real(kdp) :: z3, z4
          real(kdp) :: eu, deudrs, deudrsrs
          real(kdp) :: ep, depdrs, depdrsrs
          real(kdp) :: alfm, dalfmdrs, dalfmdrsrs
          real(kdp) :: F, dFdz

          real(kdp), parameter :: GAM = 0.51984209978974632953442121455650_kdp
          real(kdp), parameter :: FZZ = 8._kdp/(9._kdp*GAM)
!$ACC ROUTINE(gcorn) SEQ

          call gcorn(0.03109070_kdp, 0.213700_kdp, 7.59570_kdp, 3.58760_kdp, &
          &          1.63820_kdp, 0.492940_kdp, rs, eu, deudrs, deudrsrs)
          call gcorn(0.015545350_kdp, 0.205480_kdp, 14.11890_kdp, 6.19770_kdp, &
          &          3.36620_kdp, 0.625170_kdp, rs, ep, depdrs, depdrsrs)
          call gcorn(0.01688690_kdp, 0.111250_kdp, 10.3570_kdp, 3.62310_kdp, &
          &          0.880260_kdp, 0.496710_kdp, rs, alfm, dalfmdrs, dalfmdrsrs)

          z3 = zeta**3
          z4 = zeta*z3

          F = ((1._kdp + zeta)**(4._kdp/3._kdp) + (1._kdp - zeta)**(4._kdp/3._kdp) - 2._kdp)/GAM
          dFdz = -4._kdp*((1._kdp - zeta)**(1._kdp/3._kdp) - (1._kdp + zeta)**(1._kdp/3._kdp))/(3._kdp*GAM)

          eclda1 = EU*(1._kdp - F*z4) + EP*F*z4 - ALFM*F*(1._kdp - z4)/FZZ
          declda1drs = (1._kdp - z4*F)*deudrs + z4*F*depdrs &
          &              - (1._kdp - z4)*F*dalfmdrs/FZZ
          declda1dz = EU*(-4._kdp*z3*F - z4*dFdz) + z4*EP*dFdz + 4._kdp*z3*EP*F &
          &              + 4._kdp*z3*alfm*F/FZZ - (1._kdp - z4)*alfm*dFdz/FZZ

          ! Some second derivatives are required for r2scan/r4scan correlation.
          declda1drsrs = z4*F*depdrsrs + (1._kdp - z4*F)*deudrsrs &
          &               - (1._kdp - z4)*F*dalfmdrsrs/FZZ
          declda1drsz = (4._kdp*z3*F*(dalfmdrs + FZZ*(depdrs - deudrs)) &
          &             + ((z4 - 1._kdp)*dalfmdrs + FZZ*z4*(depdrs - deudrs))*dFdz)/FZZ
      end subroutine lsda_1

      subroutine gcorn(A, A1, B1, B2, B3, B4, rs, GG, GGRS, GGRSRS)
!$ACC ROUTINE SEQ

          IMPLICIT NONE
          integer, parameter :: kdp = selected_real_kind(15, 307)

          real(kdp), intent(in) :: A, A1, B1, B2, B3, B4, rs
          real(kdp), intent(out) :: GG, GGRS, GGRSRS
          real(kdp) :: rtrs, Q0, Q1, Q2
          real(kdp) :: Q0RS, Q1RS, Q1RSRS, Q2RS, Q2RSRS

          rtrs = sqrt(rs)

          Q0 = -2._kdp*A*(1._kdp + A1*rs)
          Q0RS = -2._kdp*A*A1

          Q1 = 2._kdp*A*rtrs*(B1 + rtrs*(B2 + rtrs*(B3 + B4*rtrs)))
          Q1RS = A*(2._kdp*B2 + B1/rtrs + 3._kdp*B3*rtrs + 4._kdp*B4*rs)
          Q1RSRS = A*(4._kdp*B4 - B1/(2._kdp*rs*rtrs) + 3._kdp*B3/(2._kdp*rtrs))

          Q2 = log(1._kdp + 1._kdp/Q1)
          Q2RS = -Q1RS/(Q1**2 + Q1)
          Q2RSRS = ((1._kdp + 2._kdp*Q1)*Q1RS**2 - Q1*(1._kdp + Q1)*Q1RSRS)/(Q1**2*(1._kdp + Q1)**2)

          GG = Q0*Q2
          GGRS = Q0*Q2RS + Q2*Q0RS
          GGRSRS = 2._kdp*Q0RS*Q2RS + Q0*Q2RSRS
      end subroutine gcorn

      subroutine quit(astr)
!$ACC ROUTINE SEQ

        implicit none
        character,intent(in) :: astr
        write(*,*) astr
        stop
      end subroutine quit

      subroutine scan_orb_free_xc(revpar,nu,nd,gnu,gnd,gn,lnu,lnd,&
       & exc,vxcu,vxcd,vxcgu,vxcgd,vxcg,vxclu,vxcld)
!$ACC ROUTINE SEQ

        implicit none

        integer, parameter :: dp = selected_real_kind(15, 307)
        logical, intent(in) :: revpar
        real(dp), dimension(2) :: cppars
        real(dp), intent(in) :: nu,nd,gnu,gnd,gn,lnu,lnd
        real(dp), intent(out) :: exc,vxcu,vxcd,vxcgu,vxcgd,vxcg,vxclu,vxcld

        real(dp) :: tauu,taud,dtdnu,dtdgnu,dtdlnu,dtdnd,dtdgnd,dtdlnd
        real(dp) :: ex,vxu,vxd,vxgu,vxgd,vxtu,vxtd
        real(dp) :: ec,vcu,vcd,vcgu,vcgd,vctu,vctd,vxct
!$ACC ROUTINE(tau_rpp_unp,pc_tau_unp,VSCAN2x,VSCAN2c) SEQ

        cppars = (/ 1.784720_dp, 0.258304_dp /)

        exc = 0._dp
        vxcu = 0._dp ; vxcd = 0._dp
        vxcgu = 0._dp ; vxcgd = 0._dp ; vxcg = 0._dp
        vxclu = 0._dp ; vxcld = 0._dp

        if (revpar) then
          call tau_rpp_unp(2*nu,2*gnu,2*lnu,tauu,dtdnu,dtdgnu,dtdlnu)
          call tau_rpp_unp(2*nd,2*gnd,2*lnd,taud,dtdnd,dtdgnd,dtdlnd)
        else
          call pc_tau_unp(cppars,2*nu,2*gnu,2*lnu,tauu,dtdnu,dtdgnu,dtdlnu)
          call pc_tau_unp(cppars,2*nd,2*gnd,2*lnd,taud,dtdnd,dtdgnd,dtdlnd)
        endif
        tauu = tauu*0.5_dp
        taud = taud*0.5_dp

        call VSCAN2x(nu,nd,gnu,gnd,gn,tauu,taud, &
        &   ex,vxu,vxgu,vxd,vxgd,vxtu,vxtd)
        call VSCAN2c(nu,nd,gnu,gnd,gn,tauu,taud,&
            &   ec,vcu,vcd,vcgu,vcgd,vxcg,vctu,vctd)

        exc = (AMGGAX*ex + AMGGAC*ec)/(nu + nd)

        vxct = AMGGAX*vxtu + AMGGAC*vctu
        vxcu = AMGGAX*vxu + AMGGAC*vcu + vxct*dtdnu
        vxcgu = AMGGAX*vxgu + vxct*dtdgnu
        vxclu = vxct*dtdlnu

        vxct = AMGGAX*vxtd + AMGGAC*vctd
        vxcd = AMGGAX*vxd + AMGGAC*vcd + vxct*dtdnd
        vxcgd = AMGGAX*vxgd + vxct*dtdgnd
        vxcld = vxct*dtdlnd

      end subroutine scan_orb_free_xc

      subroutine tau_rpp_unp(n,gn,ln,tau,dtdn,dtdgn,dtdln)
!$ACC ROUTINE SEQ

        implicit none
        integer, parameter :: dp = selected_real_kind(15, 307)
        real(dp), parameter :: pi = 3.14159265358979323846264338327950288419_dp

        real(dp), intent(in) :: n,gn,ln
        real(dp), intent(out) :: tau,dtdn,dtdgn,dtdln

        !real(dp), parameter :: x0 = 0.5245_dp, ca = 6._dp/x0**2, cb =  -8._dp/x0**3
        !real(dp), parameter :: cc = 3._dp/x0**4
        !real(dp), parameter :: x0 = 0.529772_dp!0.5583_dp

        ! tau-specific parameters
        real(dp), parameter :: x0 = 0.819411_dp, c1= 0.201352_dp, c2 = 0.185020_dp
        real(dp), parameter :: c3 = 1.53804_dp
        real(dp), parameter :: ca = 20._dp/x0**3, cb =  -45._dp/x0**4
        real(dp), parameter :: cc = 36._dp/x0**5, cd = -10._dp/x0**6

        ! r2 SCAN-specific parameters
        real(dp), parameter :: eta = 1.d-3, k0 = 0.174_dp, k1 = 0.065_dp
        real(dp), parameter :: uak = 10._dp/81._dp, epne = (8._dp + 9._dp*eta)
      !  real(dp), parameter :: cxv(8) = (/ 1._dp, -0.667_dp, -0.4445555_dp,&
      !  &     -0.663086601049_dp, 1.451297044490_dp, -0.887998041597_dp,&
      !  &     0.234528941479_dp, -0.023185843322_dp /)
        real(dp), parameter :: f1 = -0.93530008755199956_dp, f2 = 0.85003592049200183_dp
        real(dp), parameter :: h1 = 5._dp*(4._dp + 9._dp*eta)*k0*f1/27._dp + uak
        real(dp), parameter :: h2 = -2._dp*h1**2/k1

        integer :: i
        real(dp) :: kf,tau0,t0,p,q,ft!,d_p_dn,d_p_dgn,d_q_dn,d_q_dlap
        real(dp) :: d_tau0_dn, d_ft_dp,d_ft_dq, x, alp, dalpdx,dxdp,dxdq
        real(dp) :: cpp,cpq,cqq,f4,f4damp,d_f4_dp,d_f4_dq, d_f4damp_dp,d_f4damp_dq
        real(dp) :: f4c, d_f4c_dp!, f1,f2,h1,h2

        ! first the approximate tau

        kf = (3*pi**2*n)**(1._dp/3._dp)
        t0 = 0.3_dp*kf**2
        tau0 = t0*n

        p = (gn/(2*kf*n))**2
        q = ln/(4*kf**2*n)

        ! fourth-order gradient correction for r2 SCAN

        !f1 = 0._dp
        !f2 = 0._dp
        !do i = 1,7
        !    f1 = f1 + (1._dp*i)*cxv(i+1)
        !    f2 = f2 + i*(i-1._dp)*cxv(i+1)
        !end do
        !h1 = 5._dp*(4._dp + 9._dp*eta)*k0*f1/27._dp + uak
        !h2 = -2._dp*h1**2/k1

        cqq = (146._dp/2025._dp/k0 - 200._dp/81._dp*f2)/f1
        cpq = 100._dp/243._dp*epne*f2/f1 + 20._dp/9._dp*h1/k0 &
        &     + 100._dp*eta/27._dp - 73._dp/405._dp/(k0*f1)
        cpp = -(h2/2._dp + 5._dp/27*epne*h1*f1 + 25._dp/1458._dp*epne**2*k0*f2 )/(k0*f1)&
        &     - 25._dp*eta**2/9._dp - 200._dp*eta/81._dp

        f4 = (cpp-c3)*p**2 + cpq*p*q + cqq*q**2
        d_f4_dp = 2._dp*(cpp-c3)*p + cpq*q
        d_f4_dq = cpq*p + 2._dp*cqq*q
        f4damp = exp(-(p/c1)**2 - (q/c2)**2)
        d_f4damp_dp = -2._dp*p/c1**2*f4damp
        d_f4damp_dq = -2._dp*q/c2**2*f4damp

        f4c = c3*p**2*exp(-c3*p)
        d_f4c_dp = c3*p*(2._dp - c3*p)*exp(-c3*p)

        x = 1._dp - 40._dp/27._dp*p + 20._dp/9._dp*q + f4*f4damp + f4c
        dxdp = -40._dp/27._dp + d_f4_dp*f4damp + f4*d_f4damp_dp + d_f4c_dp
        dxdq = 20._dp/9._dp + d_f4_dq*f4damp + f4*d_f4damp_dq

        if (x < 0._dp) then
          alp = 0._dp
          dalpdx = 0._dp
        else if ((0._dp <= x).and.(x <= x0)) then
          !alp = x**3*(ca + x*(cb + x*cc))
          !dalpdx = x**2*(3._dp*ca + x*(4._dp*cb + 5._dp*x*cc))
          alp = x**4*(ca + x*(cb + x*(cc + x*cd)))
          dalpdx = x**3*(4._dp*ca + x*(5._dp*cb + x*(6._dp*cc + x*7._dp*cd)))
        else if (x > x0) then
          alp = x
          dalpdx = 1._dp
        end if

        ft = 5._dp*p/3._dp + alp
        d_ft_dp = 5._dp/3._dp + dalpdx*dxdp
        d_ft_dq = dalpdx*dxdq

        tau = tau0*ft

        d_tau0_dn = kf**2/2._dp

        !d_p_dn = -8._dp/3._dp *p/n
        !d_p_dgn = gn/(2*(kf*n)**2)

        !d_q_dn = -5._dp/3._dp*q/n
        !d_q_dlap = 1._dp/(4*kf**2*n)

        !dtdn = ft*d_tau0_dn + tau0*(d_ft_dp*d_p_dn + d_ft_dq*d_q_dn)
        dtdn = ft*d_tau0_dn - t0/3._dp*(8._dp*p*d_ft_dp + 5._dp*q*d_ft_dq)
        ! NB: tau0*d_p_dgn = 3/20 * |grad n|/n = 0.15 * |grad n|/n
        dtdgn = 0.15_dp*gn/n*d_ft_dp!tau0*d_ft_dp*d_p_dgn
        ! NB: tau0*d_q_dln = 3/40 = 0.075
        dtdln = 0.075_dp*d_ft_dq!tau0*d_ft_dq*d_q_dlap

      end subroutine tau_rpp_unp

      subroutine pc_tau_unp(pars,n,gn,ln,tau,dtdn,dtdgn,dtdln)
!$ACC ROUTINE SEQ

        implicit none
        integer, parameter :: dp = selected_real_kind(15, 307)
        real(dp), parameter :: pi = 3.14159265358979323846264338327950288419_dp

        real(dp), intent(in),dimension(2) :: pars
        real(dp), intent(in) :: n,gn,ln
        real(dp), intent(out) :: tau,dtdn,dtdgn,dtdln

        real(dp) :: kf,tau0,t0,p,q,ftw,ft2,ft4,ft
        real(dp) :: freg,ftge4,z,theta,d_theta_dz
        real(dp) :: d_tau0_dn!,d_p_dn,d_p_dgn,d_q_dn,d_q_dln
        real(dp) :: d_ftw_dp, d_ft2_dp, d_ft2_dq, d_ft4_dp, d_ft4_dq
        real(dp) :: d_freg_dp, d_freg_dq,d_ftge4_dp,d_ftge4_dq
        real(dp) :: d_z_dp,d_z_dq, d_ft_dp,d_ft_dq
!$ACC ROUTINE(pc_interpolation) SEQ

        ! first the approximate tau

        kf = (3*pi**2*n)**(1._dp/3._dp)
        t0 = 0.3_dp*kf**2
        tau0 = t0*n

        p = (gn/(2*kf*n))**2
        q = ln/(4*kf**2*n)

        ftw = 5*p/3._dp
        ft2 = 5*p/27._dp + 20*q/9._dp
        ft4 = 8*q**2/81._dp - p*q/9._dp + 8*p**2/243._dp

        freg = (1._dp + (ft4/(1._dp + ftw))**2)**(0.5_dp)
        ftge4 = (1._dp + ft2 + ft4)/freg
        z = ftge4 - ftw
        call pc_interpolation(pars,z,theta,d_theta_dz)

        ft = ftw + z*theta
        tau = ft*tau0

        ! now the derivatives of tau

        d_tau0_dn = kf**2/2._dp

        !d_p_dn = -8._dp/3._dp *p/n
        !d_p_dgn = gn/(2*(kf*n)**2)

        !d_q_dn = -5._dp/3._dp *q/n
        !d_q_dln = 1._dp/(4*kf**2*n)

        d_ftw_dp = 5._dp/3._dp
        d_ft2_dp = 5._dp/27._dp
        d_ft2_dq = 20._dp/9._dp

        d_ft4_dp = -q/9._dp + 16*p/243._dp
        d_ft4_dq = 16*q/81._dp - p/9._dp

        d_freg_dp = ft4*(d_ft4_dp*(1._dp + ftw) - ft4*d_ftw_dp)/(freg*(1._dp + ftw)**3)
        d_freg_dq = ft4*d_ft4_dq/(freg*(1._dp + ftw)**2)

        d_ftge4_dp = (d_ft2_dp + d_ft4_dp - ftge4*d_freg_dp)/freg
        d_ftge4_dq = (d_ft2_dq + d_ft4_dq - ftge4*d_freg_dq)/freg

        d_z_dp = d_ftge4_dp - d_ftw_dp
        d_z_dq = d_ftge4_dq

        d_ft_dp = d_ftw_dp + (d_theta_dz*z + theta)*d_z_dp
        d_ft_dq = (d_theta_dz*z + theta)*d_z_dq

        !dtdn = ft*d_tau0_dn + tau0*( d_ft_dp*d_p_dn + d_ft_dq*d_q_dn )
        dtdn = ft*d_tau0_dn - t0/3._dp*(8._dp*p*d_ft_dp + 5._dp*q*d_ft_dq)
        ! NB: tau0*d_p_dgn = 3/20 * |grad n|/n = 0.15 * |grad n|/n
        dtdgn = 0.15_dp*gn/n*d_ft_dp!tau0*d_ft_dp*d_p_dgn
        ! NB: tau0*d_q_dln = 3/40 = 0.075
        dtdln = 0.075_dp*d_ft_dq!tau0*d_ft_dq*d_q_dln

      end subroutine pc_tau_unp

      subroutine pc_interpolation(pars,z,th,dthdz)
!$ACC ROUTINE SEQ

        implicit none

        integer, parameter :: dp = selected_real_kind(15, 307)
        real(dp), parameter :: eps = 1.d-2

        real(dp), intent(in),dimension(2) :: pars
        real(dp), intent(in) :: z
        real(dp), intent(out) :: th,dthdz

        real(dp) :: a_fuzzy,fac1,fac2,dfac1,dfac2

        a_fuzzy = pars(1)-eps

        th = 0._dp
        dthdz = 0._dp
        if ((eps < z).and.(z < a_fuzzy)) then
          fac1 = exp(pars(1)/(pars(1) - z))
          dfac1 = pars(1)/(pars(1) - z)**2*fac1
          fac2 = exp(pars(1)/z)
          dfac2 = -pars(1)/z**2*fac2

          th = ( (1._dp + fac1)/(fac2 + fac1) )**pars(2)
          dthdz = pars(2)* ( (1._dp + fac1)/(fac2 + fac1) )**(pars(2) - 1)
          dthdz = dthdz*( dfac1*(fac2 - 1._dp) - dfac2*(1._dp + fac1) )/(fac2 + fac1)**2
        else if (z >= a_fuzzy) then
          th = 1._dp
        end if

      end subroutine pc_interpolation

!***********************************************************************
!***********************************************************************
  END MODULE metalib
!***********************************************************************
!***********************************************************************


!***********************************************************************
!***********************************************************************
!
!***********************************************************************
!***********************************************************************

  MODULE meta
    USE prec
    USE setxcmeta

    ! Methods that are private
    PRIVATE :: FEXCGS_METAGGA

    TYPE tau_handle
       COMPLEX(q), POINTER, CONTIGUOUS :: TAU(:,:)  ! kinetic energy density
       COMPLEX(q), POINTER, CONTIGUOUS :: TAUL(:,:) ! kinetic energy density (previous step)
       COMPLEX(q), POINTER, CONTIGUOUS :: TAUW(:,:) ! Weisaecker kinetic energy density
       RGRID,      POINTER, CONTIGUOUS :: TAUC(:)   ! kinetic energy density of the core electrons
    END TYPE tau_handle
    !
    ! parameters that determine the spherical integration mesh
    ! for potentials in the METAGGA
    !
    INTEGER, PARAMETER, PRIVATE :: PHPTS_FACT=3, THPTS_FACT=3

    ! auxiliary functions needed by RAD_KINEDEN and RAD_PROJ_METAGGA,
    ! allocated and constructed by RAD_AUXILIARY_FUNCTIONS_METAGGA
    REAL(q), ALLOCATABLE, PRIVATE, SAVE :: X_YLM_X_YLM(:,:,:)
    REAL(q), ALLOCATABLE, PRIVATE, SAVE :: YLMD_YLMD(:,:,:)
    REAL(q), ALLOCATABLE, PRIVATE, SAVE :: X_YLM_YLMD(:,:,:)

   CONTAINS

!***********************************************************************
!
!***********************************************************************

      SUBROUTINE ALLOCATE_MU(MU,MUTOT,GRID,GRIDC,WDES)
      USE mgrid
      USE ini
      USE wave
      IMPLICIT NONE
      TYPE (grid_3d) GRID, GRIDC
      TYPE (wavedes) WDES
      COMPLEX(q),POINTER :: MUTOT(:,:)  ! d e_xc / d tau
      RGRID , POINTER    :: MU(:,:)     ! soft version of the above

      IF (LDO_METAGGA()) THEN
         ALLOCATE(MU(DIMREAL(GRID%MPLWV),WDES%NCDIJ),MUTOT(GRIDC%MPLWV,WDES%NCDIJ))
         CALL REGISTER_ALLOCATE(16._q*(SIZE(MUTOT)+SIZE(MU)), "grid")
         MU=0; MUTOT=0
      ELSE
         NULLIFY(MUTOT, MU)
      ENDIF

      RETURN
      END SUBROUTINE ALLOCATE_MU


!***********************************************************************
!
!***********************************************************************

      SUBROUTINE DEALLOCATE_MU(MU,MUTOT)
      USE mgrid
      USE ini
      IMPLICIT NONE
      COMPLEX(q),POINTER :: MUTOT(:,:)  ! d e_xc / d tau
      RGRID , POINTER    :: MU(:,:)     ! soft version of the above

      IF (LDO_METAGGA()) THEN
         CALL DEREGISTER_ALLOCATE(16._q*(SIZE(MUTOT)+SIZE(MU)), "grid")
         DEALLOCATE(MU,MUTOT)
      ENDIF
      NULLIFY(MUTOT, MU)

      RETURN
      END SUBROUTINE DEALLOCATE_MU


!!!***********************************************************************
!!!
!!! generate the tau_handle
!!!
!!!***********************************************************************
!!
!!      SUBROUTINE GENERATE_TAU_HANDLE(KINEDEN, GRIDC, NCDIJ)
!!      USE mgrid
!!      IMPLICIT NONE
!!      TYPE(tau_handle), POINTER :: KINEDEN
!!      TYPE(grid_3d) GRIDC
!!      INTEGER NCDIJ
!!
!!      IF (.NOT.ASSOCIATED(KINEDEN).AND.LDO_METAGGA()) THEN
!!         ALLOCATE(KINEDEN)
!!         ALLOCATE(KINEDEN%TAU(GRIDC%MPLWV,NCDIJ),KINEDEN%TAUC(GRIDC%RL%NP))
!!         KINEDEN%TAU=0; KINEDEN%TAUC=0
!!         IF (LMIX_TAU()) THEN
!!            ALLOCATE(KINEDEN%TAUL(GRIDC%MPLWV,NCDIJ))
!!            KINEDEN%TAUL=0
!!         ELSE
!!            NULLIFY(KINEDEN%TAUL)
!!         ENDIF
!!      ENDIF
!!
!!      RETURN
!!      END SUBROUTINE GENERATE_TAU_HANDLE


!!!***********************************************************************
!!!
!!! deallocate the tau_handle
!!!
!!!***********************************************************************
!!
!!      SUBROUTINE DEALLOCATE_TAU_HANDLE(KINEDEN)
!!      IMPLICIT NONE
!!      TYPE(tau_handle), POINTER :: KINEDEN
!!
!!      IF (ASSOCIATED(KINEDEN)) THEN
!!         IF (ASSOCIATED(KINEDEN%TAU)) DEALLOCATE(KINEDEN%TAU)
!!         IF (ASSOCIATED(KINEDEN%TAUL)) DEALLOCATE(KINEDEN%TAUL)
!!         IF (ASSOCIATED(KINEDEN%TAUC)) DEALLOCATE(KINEDEN%TAUC)
!!         DEALLOCATE(KINEDEN)
!!      ENDIF
!!
!!      RETURN
!!      END SUBROUTINE DEALLOCATE_TAU_HANDLE


!***********************************************************************
!
! generate the tau_handle
!
!***********************************************************************

      SUBROUTINE ALLOCATE_TAU(TAU, TAUC, TAUL, GRIDC, NCDIJ)
      USE mgrid
      IMPLICIT NONE
      COMPLEX(q), POINTER :: TAU(:,:),TAUL(:,:)
      RGRID, POINTER      :: TAUC(:)
      TYPE(grid_3d) GRIDC
      INTEGER NCDIJ

      IF (LDO_METAGGA()) THEN
         ALLOCATE(TAU(GRIDC%MPLWV,NCDIJ),TAUC(GRIDC%RL%NP))
         TAU=0; TAUC=0
         IF (LMIX_TAU()) THEN
            ALLOCATE(TAUL(GRIDC%MPLWV,NCDIJ))
            TAUL=0
         ELSE
            NULLIFY(TAUL)
         ENDIF
      ELSE
         NULLIFY(TAU,TAUC,TAUL)
      ENDIF

      RETURN
      END SUBROUTINE ALLOCATE_TAU


!***********************************************************************
!
! deallocate the tau_handle
!
!***********************************************************************

      SUBROUTINE DEALLOCATE_TAU(TAU,TAUC,TAUL)
      IMPLICIT NONE
      COMPLEX(q), POINTER :: TAU(:,:),TAUL(:,:)
      RGRID, POINTER      :: TAUC(:)

      IF (LDO_METAGGA()) THEN
         DEALLOCATE(TAU,TAUC)
         IF (LMIX_TAU()) DEALLOCATE(TAUL)
      ENDIF
      NULLIFY(TAU,TAUC,TAUL)

      RETURN
      END SUBROUTINE DEALLOCATE_TAU


!***********************************************************************
!
!***********************************************************************

      SUBROUTINE CREATE_CMBJ_AUX(GRIDC,T_INFO,LATT_CUR)
#ifdef _OPENACC
    USE mopenacc
#endif
      USE poscar
      USE mgrid
      USE lattice
      IMPLICIT NONE
      TYPE (grid_3d)     GRIDC
      TYPE (type_info)   T_INFO
      TYPE (latt)        LATT_CUR

      INTEGER NG, NC, N1, N2, N3, NX, NY, NZ, NI, NJ, NI_FOUND, I
      INTEGER I1,I2,I3,M1,M2,M3
      REAL(q) X, Y, Z, X1, X2, X3, D, D2, DMIN, TSMBJ2, WTMP
      REAL(q) NORM_PW_AUG_TMP,NORM_AUG_PW_TMP,NORM_AUG_AUG_TMP,WEIGHT_AUG_PW_TMP,WEIGHT_AUG_AUG_TMP

      IF (LDO_METAGGA().AND.(ID_METAGGA==30.OR.ID_METAGGA==31)) THEN

         IF ((CMBJ_TYP(1)==-1).AND.(ID_METAGGA==30)) RETURN
         IF (ALLOCATED(CMBJ_AUX)) DEALLOCATE(CMBJ_AUX)

         IF (ALLOCATED(NORM_PW_AUG)) DEALLOCATE(NORM_PW_AUG)
         IF (ALLOCATED(NORM_AUG_PW)) DEALLOCATE(NORM_AUG_PW)
         IF (ALLOCATED(NORM_AUG_AUG)) DEALLOCATE(NORM_AUG_AUG)
         IF (ALLOCATED(WEIGHT_AUG_PW)) DEALLOCATE(WEIGHT_AUG_PW)
         IF (ALLOCATED(WEIGHT_AUG_AUG)) DEALLOCATE(WEIGHT_AUG_AUG)
         IF (ALLOCATED(SCA_VAC)) DEALLOCATE(SCA_VAC)
         ALLOCATE(CMBJ_AUX(GRIDC%RL%NP))

         ALLOCATE(NORM_PW_AUG(GRIDC%RL%NP))
         ALLOCATE(NORM_AUG_PW(T_INFO%NIONS))
         ALLOCATE(NORM_AUG_AUG(T_INFO%NIONS))
         ALLOCATE(WEIGHT_AUG_PW(GRIDC%RL%NP,T_INFO%NIONS))
         ALLOCATE(WEIGHT_AUG_AUG(T_INFO%NIONS,T_INFO%NIONS))
         ALLOCATE(SCA_VAC(GRIDC%RL%NP))

         IF (ID_METAGGA==30) THEN
         ! loop over all grid points
         DO NC=1,GRIDC%RL%NCOL
         N2= GRIDC%RL%I2(NC)
         N3= GRIDC%RL%I3(NC)

         DO N1=1,GRIDC%RL%NROW
            NG=(NC-1)*GRIDC%RL%NROW+N1
            IF (GRIDC%RL%NFAST==3) THEN
               NX=N2
               NY=N3
               NZ=N1
            ELSE
               NX=N1
               NY=N2
               NZ=N3
            ENDIF

            ! now search the ion that is closest to this grid point
            DMIN=1000
            NI_FOUND=-1

            DO NI=1,T_INFO%NIONS
               X1=MOD((REAL(NX,q)-1)*(1._q/GRIDC%NGX)-T_INFO%POSION(1,NI)+10.5_q,1._q)-0.5_q
               X2=MOD((REAL(NY,q)-1)*(1._q/GRIDC%NGY)-T_INFO%POSION(2,NI)+10.5_q,1._q)-0.5_q
               X3=MOD((REAL(NZ,q)-1)*(1._q/GRIDC%NGZ)-T_INFO%POSION(3,NI)+10.5_q,1._q)-0.5_q

               X= X1*LATT_CUR%A(1,1)+X2*LATT_CUR%A(1,2)+X3*LATT_CUR%A(1,3)
               Y= X1*LATT_CUR%A(2,1)+X2*LATT_CUR%A(2,2)+X3*LATT_CUR%A(2,3)
               Z= X1*LATT_CUR%A(3,1)+X2*LATT_CUR%A(3,2)+X3*LATT_CUR%A(3,3)

               D=SQRT(X*X+Y*Y+Z*Z)
            !   WRITE(*,'(7F14.7)') X1, X2, X3, X, Y, Z, D

               IF (D<DMIN) THEN
                  DMIN=D
                  NI_FOUND=NI
               ENDIF
            ENDDO
            IF (NI_FOUND<0) THEN
               WRITE(0,*) 'internal error in CREATE_CMBJ_AUX: NI_FOUND not correct', NI_FOUND
            ENDIF
            CMBJ_AUX(NG)=CMBJ_TYP(T_INFO%ITYP(NI_FOUND))
         !   WRITE(*,*) 'found',NG, KINEDEN%AUX(NG)
         ENDDO
         ENDDO

         ELSEIF (ID_METAGGA==31) THEN
            ! TR: local SC MBJ version
            ! find the weights for averaging over ions and PW grid points

#ifdef _OPENACC
            PUSH_ACC_EXEC_ON(.TRUE.)
            CALL ACC_COPYIN_TYPED_VAR(GRIDC)
#endif
!$ACC ENTER DATA COPYIN(T_INFO,LATT_CUR) __IF_ASYNC__

            TSMBJ2 = 2._q*SMBJ*SMBJ
            M1=NINT(9._q*SMBJ*LATT_CUR%BNORM(1))
            M2=NINT(9._q*SMBJ*LATT_CUR%BNORM(2))
            M3=NINT(9._q*SMBJ*LATT_CUR%BNORM(3))
!$ACC ENTER DATA COPYIN(TSMBJ2,M1,M2,M3) __IF_ASYNC__

!$ACC ENTER DATA CREATE(NORM_PW_AUG,NORM_AUG_PW,WEIGHT_AUG_PW) __IF_ASYNC__
!$ACC KERNELS PRESENT(NORM_PW_AUG,NORM_AUG_PW,WEIGHT_AUG_PW) __IF_ASYNC__
            NORM_PW_AUG = 0._q
            NORM_AUG_PW = 0._q
            WEIGHT_AUG_PW = 0._q
!$ACC END KERNELS
!$ACC PARALLEL LOOP COLLAPSE(force:3) GANG PRESENT(TSMBJ2,M1,M2,M3) &
!$ACC PRIVATE(N2,N3,NG,NX,NY,NZ,NORM_PW_AUG_TMP,NORM_AUG_PW_TMP,WEIGHT_AUG_PW_TMP) __IF_ASYNC__
            ! loop over all ions
            DO NI=1,T_INFO%NIONS
               DO NC=1,GRIDC%RL%NCOL
               N2= GRIDC%RL%I2(NC)
               N3= GRIDC%RL%I3(NC)
       
               DO N1=1,GRIDC%RL%NROW
                  NG=(NC-1)*GRIDC%RL%NROW+N1
                  IF (GRIDC%RL%NFAST==3) THEN
                     NX=N2
                     NY=N3
                     NZ=N1
                  ELSE
                     NX=N1
                     NY=N2
                     NZ=N3
                  ENDIF

                  NORM_PW_AUG_TMP = 0._q
                  NORM_AUG_PW_TMP = 0._q
                  WEIGHT_AUG_PW_TMP = 0._q
                  ! lattice summation (within the range of the Gaussian)
!$ACC LOOP COLLAPSE(3) REDUCTION(+:NORM_PW_AUG_TMP,NORM_AUG_PW_TMP,WEIGHT_AUG_PW_TMP) &
!$ACC PRIVATE(X1,X2,X3,X,Y,Z,D2,WTMP)
                  DO I1=-M1,M1
                   DO I2=-M2,M2
                    DO I3=-M3,M3
                     X1=I1+MODULO((REAL(NX,q)-1)*(1._q/GRIDC%NGX)-T_INFO%POSION(1,NI)+10.5_q,1._q)-0.5_q
                     X2=I2+MODULO((REAL(NY,q)-1)*(1._q/GRIDC%NGY)-T_INFO%POSION(2,NI)+10.5_q,1._q)-0.5_q
                     X3=I3+MODULO((REAL(NZ,q)-1)*(1._q/GRIDC%NGZ)-T_INFO%POSION(3,NI)+10.5_q,1._q)-0.5_q
       
                     X= X1*LATT_CUR%A(1,1)+X2*LATT_CUR%A(1,2)+X3*LATT_CUR%A(1,3)
                     Y= X1*LATT_CUR%A(2,1)+X2*LATT_CUR%A(2,2)+X3*LATT_CUR%A(2,3)
                     Z= X1*LATT_CUR%A(3,1)+X2*LATT_CUR%A(3,2)+X3*LATT_CUR%A(3,3)
  
                     D2=X*X+Y*Y+Z*Z
            
                     WTMP = EXP(-D2/TSMBJ2)

                     NORM_PW_AUG_TMP = NORM_PW_AUG_TMP + WTMP
                     NORM_AUG_PW_TMP = NORM_AUG_PW_TMP + WTMP
                     WEIGHT_AUG_PW_TMP = WEIGHT_AUG_PW_TMP + WTMP

                    ENDDO
                   ENDDO
                  ENDDO

!$ACC ATOMIC UPDATE
                  NORM_PW_AUG(NG) = NORM_PW_AUG(NG) + NORM_PW_AUG_TMP
!$ACC ATOMIC UPDATE
                  NORM_AUG_PW(NI) = NORM_AUG_PW(NI) + NORM_AUG_PW_TMP

                  WEIGHT_AUG_PW(NG,NI) = WEIGHT_AUG_PW(NG,NI) + WEIGHT_AUG_PW_TMP

               ENDDO
               ENDDO
            ENDDO
!$ACC EXIT DATA COPYOUT(NORM_PW_AUG,NORM_AUG_PW,WEIGHT_AUG_PW) __IF_ASYNC__
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)
            CALLMPI( M_sum_d(GRIDC%COMM, NORM_AUG_PW(1), T_INFO%NIONS) )

!$ACC ENTER DATA CREATE(NORM_AUG_AUG,WEIGHT_AUG_AUG) __IF_ASYNC__
!$ACC KERNELS PRESENT(NORM_AUG_AUG,WEIGHT_AUG_AUG) __IF_ASYNC__
            NORM_AUG_AUG = 0._q
            WEIGHT_AUG_AUG = 0._q
!$ACC END KERNELS
!$ACC PARALLEL LOOP COLLAPSE(2) GANG PRESENT(TSMBJ2,M1,M2,M3) &
!$ACC PRIVATE(NORM_AUG_AUG_TMP,WEIGHT_AUG_AUG_TMP) __IF_ASYNC__
            DO NI=1,T_INFO%NIONS
               DO NJ=1,T_INFO%NIONS

               NORM_AUG_AUG_TMP = 0._q
               WEIGHT_AUG_AUG_TMP = 0._q

!$ACC LOOP COLLAPSE(3) REDUCTION(+:NORM_AUG_AUG_TMP,WEIGHT_AUG_AUG_TMP) &
!$ACC PRIVATE(X1,X2,X3,X,Y,Z,D2,WTMP)
                DO I1=-M1,M1
                 DO I2=-M2,M2
                  DO I3=-M3,M3
                   X1=I1+MODULO(T_INFO%POSION(1,NI)-T_INFO%POSION(1,NJ)+10.5_q,1._q)-0.5_q
                   X2=I2+MODULO(T_INFO%POSION(2,NI)-T_INFO%POSION(2,NJ)+10.5_q,1._q)-0.5_q
                   X3=I3+MODULO(T_INFO%POSION(3,NI)-T_INFO%POSION(3,NJ)+10.5_q,1._q)-0.5_q
       
                   X= X1*LATT_CUR%A(1,1)+X2*LATT_CUR%A(1,2)+X3*LATT_CUR%A(1,3)
                   Y= X1*LATT_CUR%A(2,1)+X2*LATT_CUR%A(2,2)+X3*LATT_CUR%A(2,3)
                   Z= X1*LATT_CUR%A(3,1)+X2*LATT_CUR%A(3,2)+X3*LATT_CUR%A(3,3)
       
                   D2=X*X+Y*Y+Z*Z

                   WTMP = EXP(-D2/TSMBJ2)

                   NORM_AUG_AUG_TMP = NORM_AUG_AUG_TMP + WTMP
                   WEIGHT_AUG_AUG_TMP = WEIGHT_AUG_AUG_TMP + WTMP

                  ENDDO
                 ENDDO
                ENDDO

!$ACC ATOMIC UPDATE
                NORM_AUG_AUG(NI) = NORM_AUG_AUG(NI) + NORM_AUG_AUG_TMP

                WEIGHT_AUG_AUG(NI,NJ) = WEIGHT_AUG_AUG(NI,NJ) + WEIGHT_AUG_AUG_TMP

               ENDDO
            ENDDO
!$ACC EXIT DATA COPYOUT(NORM_AUG_AUG,WEIGHT_AUG_AUG,TSMBJ2,M1,M2,M3) __IF_ASYNC__
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)

            DO I=1,GRIDC%RL%NP
            ! an initial value maybe given on INCAR (as a "better starting point" ...)
!               CMBJ_AUX(I) = 1.0_q
               CMBJ_AUX(I) = CMBJ
            ENDDO

!$ACC EXIT DATA DELETE(T_INFO,LATT_CUR) __IF_ASYNC__
#ifdef _OPENACC
            CALL ACC_DELETE_TYPED_VAR(GRIDC)
            POP_ACC_EXEC_ON
#endif

         ENDIF
      ENDIF
!$ACC UPDATE DEVICE(CMBJ_AUX)

      RETURN
      END SUBROUTINE CREATE_CMBJ_AUX

!***********************************************************************
! TR: output of CMBJ_AUX
!***********************************************************************

      SUBROUTINE PRINT_CMBJ_AUX(GRIDC,LATT_CUR)
      USE poscar
      USE mgrid
      USE lattice
      IMPLICIT NONE
      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR
      INTEGER NG, NC, N1, N2, N3, NX, NY, NZ 
      REAL(q) X, Y, Z, X1, X2, X3 
      REAL(q), ALLOCATABLE :: CMBJ_AUX_SER(:,:,:)

      IF (LDO_METAGGA() .AND. (ID_METAGGA==31)) THEN
         ! accumulate the complete CMBJ_AUX into CMBJ_AUX_SER
         ALLOCATE(CMBJ_AUX_SER(GRIDC%NGX,GRIDC%NGY,GRIDC%NGZ))
         CALL MRG_GRID_RL(GRIDC,CMBJ_AUX_SER,CMBJ_AUX)

         OPEN(99,FILE='CMBJCAR')
         ! loop over all grid points
         DO NX=1,GRIDC%NGX
         DO NY=1,GRIDC%NGY
         DO NZ=1,GRIDC%NGZ

            ! only every second point plotted
            IF (MOD(NX,2)==0.AND.MOD(NY,2)==0.AND.MOD(NZ,2)==0) THEN
               X1=(REAL(NX,q)-1)*(1._q/GRIDC%NGX)
               X2=(REAL(NY,q)-1)*(1._q/GRIDC%NGY)
               X3=(REAL(NZ,q)-1)*(1._q/GRIDC%NGZ)

               X= X1*LATT_CUR%A(1,1)+X2*LATT_CUR%A(1,2)+X3*LATT_CUR%A(1,3)
               Y= X1*LATT_CUR%A(2,1)+X2*LATT_CUR%A(2,2)+X3*LATT_CUR%A(2,3)
               Z= X1*LATT_CUR%A(3,1)+X2*LATT_CUR%A(3,2)+X3*LATT_CUR%A(3,3)
            
               WRITE(99,'(4F14.7)') X, Y, Z, CMBJ_AUX_SER(NX,NY,NZ)
            ENDIF
               
         ENDDO
         ENDDO
         ENDDO
         CLOSE(99)

         DEALLOCATE(CMBJ_AUX_SER)
      ENDIF

      RETURN
      END SUBROUTINE PRINT_CMBJ_AUX

!***********************************************************************
! TR: Create CMBJ_AUG and GRHO_OVER_RHO_AUG
!***********************************************************************

      SUBROUTINE CREATE_CMBJ_AUG(T_INFO)
      USE poscar
      IMPLICIT NONE
      TYPE (type_info)   T_INFO
      INTEGER NI

      IF (LDO_METAGGA() .AND. (ID_METAGGA==31)) THEN
         IF (ALLOCATED(CMBJ_AUG)) DEALLOCATE(CMBJ_AUG)
         ALLOCATE(CMBJ_AUG(T_INFO%NIONS))
         IF (ALLOCATED(GRHO_OVER_RHO_AUG)) DEALLOCATE(GRHO_OVER_RHO_AUG)
         ALLOCATE(GRHO_OVER_RHO_AUG(T_INFO%NIONS))
         
         DO NI=1,T_INFO%NIONS
         ! an initial value maybe given on INCAR (as a "better starting point" ...)
!            CMBJ_AUG(NI) = 1.0_q
            CMBJ_AUG(NI) = CMBJ
            GRHO_OVER_RHO_AUG(NI) = 0.0_q
         ENDDO
      ENDIF

      RETURN
      END SUBROUTINE CREATE_CMBJ_AUG
 

!***********************************************************************
!
!***********************************************************************
      SUBROUTINE UPDATE_CMBJ(P,GRIDC,T_INFO,LATT_CUR,IU6)
#ifdef _OPENACC
      USE mopenacc
#endif
      USE poscar
      USE mgrid
      USE lattice
      USE vaspxml
      USE pseudo
      USE constant

      IMPLICIT NONE
      TYPE (grid_3d)     GRIDC
      TYPE (type_info)   T_INFO
      TYPE (latt)        LATT_CUR
      TYPE (potcar)      P(T_INFO%NTYP)
      INTEGER IU6
      ! local variables
      REAL(q) GRHO_OVER_RHO
      REAL(q) CMBJ_AUX_AVG ! average of CMBJ_AUX over all grid points
      INTEGER I,J, N, NC, N1, N2, N3, NX, NY, NZ, NGX, NGY, NGZ
      INTEGER NT
      REAL(q) X, Y, Z
      REAL(q) CMBJ_AVG
      REAL(q) VOL_AUG(T_INFO%NIONS) ! volume of the aug. sphere for PAW-contribution to CMBJ
      REAL(q), ALLOCATABLE :: CMBJ_AUX_H(:)
      REAL(q), ALLOCATABLE :: GRHO_OVER_RHO_H(:)
 
      IF (LDO_METAGGA() .AND. (ID_METAGGA==30) .AND. LscMBJ()) THEN
         ! write current CMBJ to OUTCAR and vasprun.xml
         IF (IU6>=0) THEN
!$ACC UPDATE SELF(CMBJ) IF(ACC_EXEC_ON) WAIT
            WRITE(IU6,'(4X,A,F10.4/)') 'CMBJ =',CMBJ
            CALL XML_TAG_REAL("CMBJ", CMBJ)
         ENDIF
         ! communicate \nabla rho / rho
!$ACC UPDATE SELF(GRHO_OVER_RHO_PW) IF(ACC_EXEC_ON)
         PUSH_ACC_EXEC_ON(.FALSE.)
         CALLMPI( M_sum_d(GRIDC%COMM, GRHO_OVER_RHO_PW, 1) )
         ! calculate CMBJ
         GRHO_OVER_RHO=GRHO_OVER_RHO_PW/GRIDC%NPLWV+GRHO_OVER_RHO_ONE_CENTER/LATT_CUR%OMEGA
         CMBJ=CMBJA+CMBJB*GRHO_OVER_RHO**CMBJE
         ! just to be sure
         IF (CMBJ<1._q) CMBJ=1._q
         IF (CMBJ>2._q) CMBJ=2._q
         ! initialize for the next step
         GRHO_OVER_RHO_PW=0._q; GRHO_OVER_RHO_ONE_CENTER=0._q
         POP_ACC_EXEC_ON
!$ACC UPDATE DEVICE(GRHO_OVER_RHO_PW,CMBJ) __IF_ASYNC__
      ENDIF
     
      ! TR: for local MBJ 
      !     calculate the averages of the augmentation spheres
      !     and add the missing parts (PW and AUG) to respective CMBJ
      IF (ID_METAGGA==31) THEN

         ! merge averages inside augmentation spheres
         CALLMPI( M_sum_d(GRIDC%COMM, GRHO_OVER_RHO_AUG(1), T_INFO%NIONS) )
         CALLMPI( M_sum_d(GRIDC%COMM_KINTER, GRHO_OVER_RHO_AUG(1), T_INFO%NIONS) )

         ! smear AUG contributions
         ALLOCATE(GRHO_OVER_RHO_H(T_INFO%NIONS))

         DO I=1,T_INFO%NIONS
            GRHO_OVER_RHO_H(I) = 0._q
            DO J=1,T_INFO%NIONS
               GRHO_OVER_RHO_H(I) = GRHO_OVER_RHO_H(I) + GRHO_OVER_RHO_AUG(J)*WEIGHT_AUG_AUG(I,J)/NORM_AUG_AUG(I)
            ENDDO
         ENDDO

         ! add the AUG contribution to PW
         ALLOCATE(CMBJ_AUX_H(GRIDC%RL%NP))

         ! volume of the aug. sphere for AUG contribution
         VOL_AUG = ((1.0_q-VACRAT)*LATT_CUR%OMEGA/T_INFO%NIONS)
         !DO I=1,T_INFO%NIONS
         !   VOL_AUG(I) = (4.0_q/3.0_q*PI*P(T_INFO%ITYP(I))%RDEP**3)
         !ENDDO

         ! To allow the use of CMBJE with LMBJ, the arrays CMBJ_AUX, CMBJ_AUX_H
         ! and CMBJ_AUX_AVG are temporarily storing grad(rho)/rho instead of c.
         DO I=1,GRIDC%RL%NP
            CMBJ_AUX(I) = (CMBJ_AUX(I) - CMBJA)/(SIGN(1.0_q,CMBJB)*MAX(ABS(CMBJB),1.E-10_q))
            CMBJ_AUX_H(I) = CMBJ_AUX(I)
            DO J=1,T_INFO%NIONS
               ! Add AUG to PW 
               CMBJ_AUX_H(I) = CMBJ_AUX_H(I) + SCA_VAC(I)*GRHO_OVER_RHO_AUG(J)/VOL_AUG(J)*WEIGHT_AUG_PW(I,J)/NORM_PW_AUG(I)
            ENDDO
         ENDDO

         DO I=1,T_INFO%NIONS
            GRHO_OVER_RHO_AUG(I) = GRHO_OVER_RHO_H(I)
         ENDDO
         DEALLOCATE(GRHO_OVER_RHO_H)

         ! average of CMBJ_AUX and add it to AUG
         DO I=1,T_INFO%NIONS
            CMBJ_AUX_AVG = 0._q
            DO J=1,GRIDC%RL%NP
               CMBJ_AUX_AVG = CMBJ_AUX_AVG + CMBJ_AUX(J)*WEIGHT_AUG_PW(J,I)/NORM_AUG_PW(I)
            ENDDO
            CALLMPI( M_sum_d(GRIDC%COMM, CMBJ_AUX_AVG, 1) )
            CMBJ_AUG(I) = CMBJA + CMBJB*(CMBJ_AUX_AVG+GRHO_OVER_RHO_AUG(I)/VOL_AUG(I))**CMBJE
        ENDDO

         ! set CMBJ_AUX to the full value
         DO I=1,GRIDC%RL%NP
            CMBJ_AUX(I) = CMBJA + CMBJB*CMBJ_AUX_H(I)**CMBJE
         ENDDO
         DEALLOCATE(CMBJ_AUX_H)

      ! find the average CMBJ
         CMBJ_AVG = 0.0_q

         DO I=1,GRIDC%RL%NP
            CMBJ_AVG = CMBJ_AVG + CMBJ_AUX(I)
         ENDDO 

         CALLMPI( M_sum_d(GRIDC%COMM, CMBJ_AVG, 1) )

         CMBJ_AVG = CMBJ_AVG / GRIDC%NPLWV
         IF (IU6>=0) THEN
            WRITE(IU6,'(4X,A,F10.4/)') 'CMBJ_AVG_PW =',CMBJ_AVG
            CALL XML_TAG_REAL("CMBJ_AVG_PW", CMBJ_AVG)
            WRITE(IU6,'(4X,A,F10.4/)') 'VACRAT =',VACRAT
            CALL XML_TAG_REAL("VACRAT", VACRAT)
            DO I=1,T_INFO%NIONS
               WRITE(IU6,'(4X,I3,X,A,F10.4/)') I,'CMBJ_AUG(I) =',CMBJ_AUG(I)
               CALL XML_TAG_REAL("CMBJ_AUG(I)", CMBJ_AUG(I))
            ENDDO
         ENDIF

         GRHO_OVER_RHO_AUG = 0._q

!$ACC UPDATE DEVICE(CMBJ_AUX)

      ENDIF

      RETURN
      END SUBROUTINE UPDATE_CMBJ

!***********************************************************************
! TR: update CMBJ_AUX, for local SC CMBJ
!***********************************************************************

      SUBROUTINE UPDATE_CMBJ_AUX(GRIDC,LATT_CUR,RHO,DENCOR,DRHO1,DRHO2,DRHO3,NCDIJ)
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE poscar
      USE prec
      USE mgrid
      USE lattice
      USE constant
      USE setxcmeta
      IMPLICIT NONE
      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR
      INTEGER NCDIJ
      RGRID RHO(DIMREAL(GRIDC%MPLWV),NCDIJ)
      RGRID DENCOR(GRIDC%RL%NP)
      REAL(q) DRHO1(GRIDC%RL%NP,NCDIJ),DRHO2(GRIDC%RL%NP,NCDIJ),DRHO3(GRIDC%RL%NP,NCDIJ)
      
      COMPLEX(q) GRHO_OVER_RHO_LOC(GRIDC%MPLWV), GAUSSIAN(GRIDC%MPLWV), RES(GRIDC%MPLWV)
      RGRID GRHO_OVER_RHO_LOC_R(GRIDC%RL%NP), RES_R(GRIDC%RL%NP)

      INTEGER NC, N1, N2, N3
      INTEGER NX, NY, NZ, NG, IS
      INTEGER NGX, NGY, NGZ
      REAL(q) X, Y, Z 
      REAL(q) X1, X2, X3 
      REAL(q) GX, GY, GZ
      INTEGER I
      REAL(q) RHOUP, RHODW, MAG_NORM
      REAL(q) ABSNABUP,ABSNABDW

      REAL(q), PARAMETER :: THR_HALF = 3.0_q/2.0_q
      REAL(q) :: PREF 
      REAL(q) :: CHGMIN=1E-10_q
      REAL(q) RSQUARE,SMBJ2H,RSMBJ3,TPI2
      REAL(q) RINPL
      REAL(q) TMBJ

      IF (LDO_METAGGA().AND.(ID_METAGGA==30.OR.ID_METAGGA==31)) THEN
         IF (CMBJ_TYP(1)/=-1) RETURN
         IF (ID_METAGGA==31) THEN
         IF (ALLOCATED(CMBJ_AUX)) DEALLOCATE(CMBJ_AUX)
         ALLOCATE(CMBJ_AUX(GRIDC%RL%NP))
        
         RSMBJ3=RSMBJ*RSMBJ*RSMBJ*AUTOA3
         TMBJ = (8.0_q/3.0_q)*PI*RSMBJ3
         SMBJ2H=SMBJ*SMBJ*0.5_q
         TPI2=TPI*TPI

         ! loop over all grid points
         NGX = GRIDC%NGX
         NGY = GRIDC%NGY
         NGZ = GRIDC%NGZ

         ! calculate the VACRAT parameter
         VACRAT = 0.0_q
!$ACC PARALLEL LOOP PRESENT(RHO,DENCOR,LATT_CUR) PRIVATE(RHOUP,RHODW) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            IF ((NCDIJ==1).OR.(NCDIJ==4)) THEN
               RHOUP= MAX(REAL((RHO(I,1)+DENCOR(I))*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
               RHODW= RHOUP
            ELSEIF (NCDIJ==2) THEN
               RHOUP= MAX(REAL((RHO(I,1)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
               RHODW= MAX(REAL((RHO(I,2)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            ENDIF
            IF ((RHOUP+RHODW)*0.5_q < 1._q/TMBJ) THEN
               VACRAT = VACRAT + 1.0_q
            ENDIF
         ENDDO
         CALLMPI( M_sum_d(GRIDC%COMM, VACRAT, 1) )
         VACRAT = VACRAT / GRIDC%NPLWV

!$ACC ENTER DATA CREATE(GRHO_OVER_RHO_LOC_R,GRHO_OVER_RHO_LOC,RES,RES_R) __IF_ASYNC__
!$ACC PARALLEL PRESENT(RHO,DENCOR,DRHO1,DRHO2,DRHO3) __IF_ASYNC__
!$ACC LOOP GANG VECTOR PRIVATE(RHOUP,RHODW,ABSNABUP,ABSNABDW,MAG_NORM)
         DO I=1,GRIDC%RL%NP
            ! First: Calculate GRHO_OVER_RHO_LOC

            IF (NCDIJ==1) THEN
               ! nonspin-polarized case
               RHOUP= MAX(REAL((RHO(I,1)+DENCOR(I))*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
               RHODW= RHOUP

               ABSNABUP= 0.5_q*SQRT(DRHO1(I,1)*DRHO1(I,1)+DRHO2(I,1)*DRHO2(I,1) &
                       +DRHO3(I,1)*DRHO3(I,1))
               ABSNABDW= ABSNABUP
            ELSEIF (NCDIJ==2) THEN
               ! Spin-polarized case
               RHOUP= MAX(REAL((RHO(I,1)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
               RHODW= MAX(REAL((RHO(I,2)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
  
               ABSNABUP=SQRT(DRHO1(I,1)*DRHO1(I,1)+DRHO2(I,1)*DRHO2(I,1) &
                          +DRHO3(I,1)*DRHO3(I,1))
 
               ABSNABDW=SQRT(DRHO1(I,2)*DRHO1(I,2)+DRHO2(I,2)*DRHO2(I,2) &
                          +DRHO3(I,2)*DRHO3(I,2))
            ELSEIF (NCDIJ==4) THEN
               ! noncollinear case
               !     
               ! | m |
               !
               MAG_NORM=SQRT(ABS( &
               &    RHO(I,2)*RHO(I,2)+RHO(I,3)*RHO(I,3)+RHO(I,4)*RHO(I,4)))
               !       
               ! RHOUP: \rho_up   = ( \rho_tot + | m | )/2
               ! RHODW: \rho_down = ( \rho_tot - | m | )/2
               !
               RHOUP= MAX(REAL((RHO(I,1)+DENCOR(I)+MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
               RHODW= MAX(REAL((RHO(I,1)+DENCOR(I)-MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
               ! \nabla \rho already calculated in upper routine
               ABSNABUP=SQRT(DRHO1(I,1)*DRHO1(I,1)+DRHO2(I,1)*DRHO2(I,1) &
                          +DRHO3(I,1)*DRHO3(I,1))

               ABSNABDW=SQRT(DRHO1(I,2)*DRHO1(I,2)+DRHO2(I,2)*DRHO2(I,2) &
                          +DRHO3(I,2)*DRHO3(I,2))
            ENDIF

            IF (VACRAT>0.0_q) THEN
               ! f = erf(RHO*TMBJ)
               GRHO_OVER_RHO_LOC_R(I) = ((1._q-CMBJA)/CMBJB + (AUTOA*ABSNABUP/RHOUP - (1._q-CMBJA)/CMBJB)*ERF(RHOUP*TMBJ))*0.5_q + &
              &                         ((1._q-CMBJA)/CMBJB + (AUTOA*ABSNABDW/RHODW - (1._q-CMBJA)/CMBJB)*ERF(RHODW*TMBJ))*0.5_q 
               ! factor for vacuum
               SCA_VAC(I) = ERF((RHOUP+RHODW)*0.5_q*TMBJ)
            ELSE
               ! f = 1
               GRHO_OVER_RHO_LOC_R(I) = (AUTOA*ABSNABUP/RHOUP + AUTOA*ABSNABDW/RHODW)*0.5_q
               SCA_VAC(I) = 1.0_q
            ENDIF

         ENDDO
!$ACC END PARALLEL

         ! FFT to reciprocal space
         RINPL=1._q/GRIDC%NPLWV
         ! GRHO_OVER_RHO_LOC         
         CALL RL_ADD(GRHO_OVER_RHO_LOC_R,RINPL,GRHO_OVER_RHO_LOC_R,0._q,GRHO_OVER_RHO_LOC,GRIDC)
         CALL FFT3D(GRHO_OVER_RHO_LOC(1),GRIDC,-1)
         CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, GRHO_OVER_RHO_LOC(1))
!$ACC UPDATE SELF(GRHO_OVER_RHO_LOC) __IF_ASYNC__
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)

         ! Multiply in RC
         DO I=1,GRIDC%RC%NP
            ! Calculate Gaussian
            N1= MOD((I-1),GRIDC%RC%NROW) +1
            NC= (I-1)/GRIDC%RC%NROW+1
            N2= GRIDC%RC%I2(NC)
            N3= GRIDC%RC%I3(NC)
            GX= GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
            GY= GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
            GZ= GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)

            RSQUARE=(GX*GX+GY*GY+GZ*GZ)*TPI2
            GAUSSIAN(I) = EXP(-SMBJ2H*RSQUARE)
            RES(I) = GRHO_OVER_RHO_LOC(I)*GAUSSIAN(I)
         ENDDO
!$ACC UPDATE DEVICE(RES) __IF_ASYNC__

         ! FFT RES back to real space
         CALL SETUNB(RES(1),GRIDC)
         CALL FFT3D(RES(1),GRIDC,1)
         CALL RL_ADD(RES,1.0_q,RES,0._q,RES_R,GRIDC)
!$ACC UPDATE SELF(RES_R) __IF_ASYNC__
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)

         ! Calculate CMBJ_AUX
         DO I=1,GRIDC%RL%NP
            CMBJ_AUX(I) = CMBJA + CMBJB*RES_R(I) 
         ENDDO

!$ACC EXIT DATA DELETE(GRHO_OVER_RHO_LOC_R,GRHO_OVER_RHO_LOC,RES,RES_R) __IF_ASYNC__
         ENDIF
      ENDIF

      RETURN
      END SUBROUTINE UPDATE_CMBJ_AUX


!***********************************************************************
!
!***********************************************************************
      SUBROUTINE DESTROY_CMBJ_AUX()
      IF (ALLOCATED(CMBJ_AUX)) DEALLOCATE(CMBJ_AUX)
      RETURN
      END SUBROUTINE DESTROY_CMBJ_AUX


!***********************************************************************
!
!***********************************************************************
      FUNCTION LDO_METAGGA()
      IMPLICIT NONE
      LOGICAL LDO_METAGGA
      LDO_METAGGA=LDOMETAGGA
      END FUNCTION LDO_METAGGA


!***********************************************************************
!
!***********************************************************************
      FUNCTION LCALCPOT()
      IMPLICIT NONE
      LOGICAL LCALCPOT
      LCALCPOT=LMETA_NEEDS_POT
      END FUNCTION LCALCPOT


!***********************************************************************
!
!***********************************************************************
      FUNCTION LCALCMU()
      IMPLICIT NONE
      LOGICAL LCALCMU
      LCALCMU=LMETA_NEEDS_MU
      END FUNCTION LCALCMU

!***********************************************************************
!
!***********************************************************************
      FUNCTION LCALCLAPD()
      IMPLICIT NONE
      LOGICAL LCALCLAPD
      LCALCLAPD=LMETA_NEEDS_LAP
      END FUNCTION LCALCLAPD

!***********************************************************************
!
!***********************************************************************
      FUNCTION LMIX_TAU()
      IMPLICIT NONE
      LOGICAL LMIX_TAU
      LMIX_TAU=LMIXTAU
      END FUNCTION LMIX_TAU


!******************** SUBROUTINE POTLOK_METAGGA ************************
!
!***********************************************************************

      SUBROUTINE POTLOK_METAGGA(&
     &   KINEDEN, &
     &   GRID,GRIDC,GRID_SOFT,COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR,  &
     &   CHDEN,CHTOT,DENCOR,CVTOT,SV,MUTOT,MU,SOFT_TO_C,XCSIF &
     &   )
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec
      USE mpimy
      USE mgrid
      USE pseudo
      USE lattice
      USE poscar
      USE setexm
      USE base
      USE xcgrad
      USE wave
      USE tutor, ONLY: vtutor

      IMPLICIT NONE

      TYPE (tau_handle)  KINEDEN
      TYPE (grid_3d)     GRID,GRIDC,GRID_SOFT
      TYPE (wavedes)     WDES
      TYPE (transit)     SOFT_TO_C
      TYPE (info_struct) INFO
      TYPE (type_info)   T_INFO
      TYPE (potcar)      P (T_INFO%NTYP)
      TYPE (energy)      E
      TYPE (latt)        LATT_CUR
      TYPE (communic)    COMM_INTER

      RGRID SV(DIMREAL(GRID%MPLWV),WDES%NCDIJ),DENCOR(GRIDC%RL%NP)
      COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
      COMPLEX(q) CHTOT(GRIDC%MPLWV,WDES%NCDIJ),CVTOT(GRIDC%MPLWV,WDES%NCDIJ)

      RGRID , POINTER :: MU(:,:)
      COMPLEX(q), POINTER :: MUTOT(:,:)

      REAL(q) XCSIF(3,3)

      ! local variables
      INTEGER ISP
      INTEGER MWORK1
      REAL(q) RINPL
      REAL(q) EXC,EXCG,XCENCG
      REAL(q) TMPSIF(3,3)
      COMPLEX(q) CVZERG
      RGRID , POINTER :: MU_(:,:)
      COMPLEX(q), POINTER :: MUTOT_(:,:)
      ! work arrays (allocated after call to FEXCG)
      COMPLEX(q), ALLOCATABLE:: CWORK1(:),CWORK(:,:)
#ifdef noAugXCmeta
      COMPLEX(q), ALLOCATABLE :: CTMP(:,:)
#endif
      PROFILING_START('potlok_metagga')

      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) THEN
         PROFILING_STOP('potlok_metagga')
         RETURN
      ENDIF
#ifdef noAugXCmeta
      ALLOCATE(CTMP(GRIDC%MPLWV,WDES%NCDIJ))
!$ACC ENTER DATA COPYIN(CHDEN) CREATE(CTMP) __IF_ASYNC__
#else
#define CTMP CHTOT
#endif
!$ACC ENTER DATA COPYIN(CVTOT,CHTOT,MU,MUTOT) __IF_ASYNC__
      ! just a failsafe
      IF (.NOT.ASSOCIATED(KINEDEN%TAU)) THEN
         CALL vtutor%bug("POTLOK_METAGGA: internal ERROR, KIN_EDEN handle not allocated", __FILE__, __LINE__)
      ENDIF

      MU_ => MU
      MUTOT_ => MUTOT

      MWORK1=MAX(GRIDC%MPLWV,GRID_SOFT%MPLWV)
      ALLOCATE(CWORK1(MWORK1),CWORK(GRIDC%MPLWV,WDES%NCDIJ))
!$ACC ENTER DATA CREATE(CWORK1,CWORK) __IF_ASYNC__
!-----------------------------------------------------------------------
!
!  calculate the exchange correlation potential and the dc. correction
!
!-----------------------------------------------------------------------

      EXCG  =0
      XCENCG=0
      CVZERG=0
      TMPSIF=0

!$ACC KERNELS PRESENT(CWORK) __IF_ASYNC__
      CWORK=0
!$ACC END KERNELS

#ifdef noAugXCmeta
      ! We will use the soft charge density instead of the augmented one
!$ACC KERNELS PRESENT(CTMP) __IF_ASYNC__
      CTMP=0
!$ACC END KERNELS
      DO ISP=1,WDES%NCDIJ
         CALL ADD_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CHDEN(1,ISP),CTMP(1,ISP))
         CALL SETUNB_COMPAT(CTMP(1,ISP),GRIDC)
      ENDDO
#endif
      ! Bring the charge density to real space
      DO ISP=1,WDES%NCDIJ
         CALL FFT3D(CTMP(1,ISP),GRIDC,1)
      ENDDO

      CALL FEXCGS_METAGGA( &
     &   WDES%NCDIJ,GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,TMPSIF, &
     &   KINEDEN,CTMP,DENCOR,CWORK,MUTOT_)

      XCSIF=XCSIF+TMPSIF
      E%EXCG=E%EXCG+EXCG
      E%XCENC=E%XCENC+XCENCG
      E%CVZERO=E%CVZERO+CVZERG

#ifndef noAugXCmeta
      ! Take the charge density back to reciprocal space
      DO ISP=1,WDES%NCDIJ
         CALL FFT_RC_SCALE(CTMP(1,ISP),CTMP(1,ISP),GRIDC)
         CALL SETUNB_COMPAT(CTMP(1,ISP),GRIDC)
      ENDDO
#endif
!-----------------------------------------------------------------------
! Add CWORK to CVTOT in real space, store the result in CVTOT
! and take it to reciprocal space
!-----------------------------------------------------------------------
#ifdef noAugXCmeta
      ! Store CVTOT in CTMP
!$ACC KERNELS PRESENT(CTMP,CVTOT) __IF_ASYNC__
      CTMP=CVTOT
!$ACC END KERNELS
#endif
      RINPL=1._q/GRIDC%NPLWV
      DO  ISP=1,WDES%NCDIJ
         CALL RL_ADD(CVTOT(1,ISP),RINPL,CWORK(1,ISP),RINPL,CVTOT(1,ISP),GRIDC)
         CALL FFT3D(CVTOT(1,ISP),GRIDC,-1)
      ENDDO
!-----------------------------------------------------------------------
! copy CVTOT to SV and set contribution of unbalanced lattice-vectors
! to zero, then FFT of SV and CVTOT to real space
!-----------------------------------------------------------------------
      DO ISP=1,WDES%NCDIJ
         CALL SETUNB_COMPAT(CVTOT(1,ISP),GRIDC)
         CALL CP_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CVTOT(1,ISP),CWORK1)
         CALL SETUNB(CWORK1,GRID_SOFT)
         CALL FFT3D(CWORK1,GRID_SOFT, 1)
         CALL RL_ADD(CWORK1,1.0_q,CWORK1,0.0_q,SV(1,ISP),GRID_SOFT)

    !  final result is only correct for first in-band-group
    ! (i.e. proc with nodeid 1 in COMM_INTER)
    !  copy to other in-band-groups using COMM_INTER
    ! (see SET_RL_GRID() in mgrid.F, and M_divide() in mpi.F)
#ifdef realmode
         CALLMPI( M_bcast_d(COMM_INTER, SV(1,ISP), GRID%RL%NP))
#else
         CALLMPI( M_bcast_z(COMM_INTER, SV(1,ISP), GRID%RL%NP))
#endif
#ifndef noAugXCmeta
         CALL FFT3D(CVTOT(1,ISP),GRIDC,1)
#endif
      ENDDO

#ifdef noAugXCmeta
      ! Restore CVTOT from CTMP
!$ACC KERNELS PRESENT(CTMP,CVTOT) __IF_ASYNC__
      CVTOT=CTMP
!$ACC END KERNELS
#endif
      IF (ASSOCIATED(MUTOT_).AND.ASSOCIATED(MU_)) THEN
!-----------------------------------------------------------------------
! The same procedure to calculate MU from MUTOT
!-----------------------------------------------------------------------
      RINPL=1._q/GRIDC%NPLWV
      DO  ISP=1,WDES%NCDIJ
         CALL RL_ADD(MUTOT_(1,ISP),RINPL,MUTOT_(1,ISP),0._q,MUTOT_(1,ISP),GRIDC)
         CALL FFT3D(MUTOT_(1,ISP),GRIDC,-1)
      ENDDO
!-----------------------------------------------------------------------
! copy MUTOT_ to MU_ and set contribution of unbalanced lattice-vectors
! to zero, then FFT of MU_ and MUTOT_ to real space
!-----------------------------------------------------------------------
      DO ISP=1,WDES%NCDIJ
         CALL SETUNB_COMPAT(MUTOT_(1,ISP),GRIDC)
         CALL CP_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,MUTOT_(1,ISP),CWORK1)
         CALL SETUNB(CWORK1,GRID_SOFT)
         CALL FFT3D(CWORK1,GRID_SOFT, 1)
         CALL RL_ADD(CWORK1,1.0_q,CWORK1,0.0_q,MU_(1,ISP),GRID_SOFT)

    !  final result is only correct for first in-band-group
    ! (i.e. proc with nodeid 1 in COMM_INTER)
    !  copy to other in-band-groups using COMM_INTER
    ! (see SET_RL_GRID() in mgrid.F, and M_divide() in mpi.F)
#ifdef realmode
         CALLMPI( M_bcast_d(COMM_INTER, MU_(1,ISP), GRID%RL%NP))
#else
         CALLMPI( M_bcast_z(COMM_INTER, MU_(1,ISP), GRID%RL%NP))
#endif
         CALL FFT3D(MUTOT_(1,ISP),GRIDC,1)
      ENDDO
      ENDIF

!$ACC EXIT DATA DELETE(CWORK1,CWORK) __IF_ASYNC__
      DEALLOCATE(CWORK1,CWORK)
      NULLIFY(MU_,MUTOT_)
#ifdef noAugXCmeta
!$ACC EXIT DATA DELETE(CTMP,CHDEN) __IF_ASYNC__
      DEALLOCATE(CTMP)
#endif
!$ACC EXIT DATA COPYOUT(CVTOT,CHTOT,MU,MUTOT) __IF_ASYNC__

      PROFILING_STOP('potlok_metagga')

      RETURN
      END SUBROUTINE POTLOK_METAGGA


!******************** SUBROUTINE POTXC_METAGGA *************************
!
!***********************************************************************

      SUBROUTINE POTXC_METAGGA(&
     &   KINEDEN,GRID,GRIDC,GRID_SOFT,SOFT_TO_C,WDES,LATT_CUR,  &
     &   CHDEN,CHTOT,DENCOR,CVTOT,MUTOT &
     &   )
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec
      USE mpimy
      USE mgrid
      USE pseudo
      USE lattice
      USE poscar
      USE setexm
      USE base
      USE xcgrad
      USE wave
      USE tutor, ONLY: vtutor

      IMPLICIT NONE

      TYPE (tau_handle)  KINEDEN
      TYPE (grid_3d)     GRID,GRIDC,GRID_SOFT
      TYPE (wavedes)     WDES
      TYPE (transit)     SOFT_TO_C
      TYPE (latt)        LATT_CUR

      RGRID DENCOR(GRIDC%RL%NP)
      COMPLEX(q) CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
      COMPLEX(q) CHTOT(GRIDC%MPLWV,WDES%NCDIJ),CVTOT(GRIDC%MPLWV,WDES%NCDIJ)

      COMPLEX(q), POINTER :: MUTOT(:,:)

      ! local variables
      INTEGER ISP
      REAL(q) RINPL
      REAL(q) EXC,EXCG,XCENCG
      REAL(q) TMPSIF(3,3)
      COMPLEX(q) CVZERG
      COMPLEX(q), POINTER :: MUTOT_(:,:)
#ifdef noAugXCmeta
      COMPLEX(q), ALLOCATABLE :: CTMP(:,:)
#endif
      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) RETURN

      PROFILING_START('potxc_metagga')

#ifdef noAugXCmeta
      ALLOCATE(CTMP(GRIDC%MPLWV,WDES%NCDIJ))
!$ACC ENTER DATA COPYIN(CHDEN) CREATE(CTMP) __IF_ASYNC__
#else
#define CTMP CHTOT
#endif
      ! just a failsafe
      IF (.NOT.ASSOCIATED(KINEDEN%TAU)) THEN
         CALL vtutor%bug("POTLOK_METAGGA: internal ERROR, KIN_EDEN handle not allocated", __FILE__, __LINE__)
      ENDIF

      MUTOT_ => MUTOT
!$ACC ENTER DATA CREATE(CVTOT,MUTOT) __IF_ASYNC__

!$ACC KERNELS PRESENT(CVTOT,MUTOT_) __IF_ASYNC__
      CVTOT=0; MUTOT_=0
!$ACC END KERNELS
      XCENCG=0; EXCG=0; CVZERG=0; TMPSIF=0

#ifdef noAugXCmeta
      ! We will use the soft charge density instead of the augmented one
!$ACC KERNELS PRESENT(CTMP) __IF_ASYNC__
      CTMP=0
!$ACC END KERNELS
      DO ISP=1,WDES%NCDIJ
         CALL ADD_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CHDEN(1,ISP),CTMP(1,ISP))
         CALL SETUNB_COMPAT(CTMP(1,ISP),GRIDC)
      ENDDO
#endif
      ! Bring the charge density to real space
      DO ISP=1,WDES%NCDIJ
         CALL FFT3D(CTMP(1,ISP),GRIDC,1)
      ENDDO

      CALL FEXCGS_METAGGA( &
     &   WDES%NCDIJ,GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,TMPSIF, &
     &   KINEDEN,CTMP,DENCOR,CVTOT,MUTOT_)

#ifndef noAugXCmeta
      ! Take the charge density back to reciprocal space
      DO ISP=1,WDES%NCDIJ
         CALL FFT_RC_SCALE(CTMP(1,ISP),CTMP(1,ISP),GRIDC)
         CALL SETUNB_COMPAT(CTMP(1,ISP),GRIDC)
      ENDDO
#endif
!-----------------------------------------------------------------------
! Add CWORK to CVTOT in real space, store the result in CVTOT
! and take it to reciprocal space
!-----------------------------------------------------------------------
      RINPL=1._q/GRIDC%NPLWV
      DO  ISP=1,WDES%NCDIJ
         CALL RL_ADD(CVTOT(1,ISP),RINPL,CVTOT(1,ISP),0._q,CVTOT(1,ISP),GRIDC)
         CALL FFT3D(CVTOT(1,ISP),GRIDC,-1)
         CALL SETUNB_COMPAT(CVTOT(1,ISP),GRIDC)
      ENDDO
     ! Flip CVTOT from (up,down) to (total,magnetization) storage mode
     ! This is done because the routine FORTAU needs the "total" component
     CALL RC_FLIP_POTENTIAL(CVTOT,GRIDC,WDES%NCDIJ,.FALSE.)

      IF (ASSOCIATED(MUTOT_)) THEN
!-----------------------------------------------------------------------
! The same procedure with MUTOT
!-----------------------------------------------------------------------
      RINPL=1._q/GRIDC%NPLWV
      DO  ISP=1,WDES%NCDIJ
         CALL RL_ADD(MUTOT_(1,ISP),RINPL,MUTOT_(1,ISP),0._q,MUTOT_(1,ISP),GRIDC)
         CALL FFT3D(MUTOT_(1,ISP),GRIDC,-1)
         CALL SETUNB_COMPAT(MUTOT_(1,ISP),GRIDC)
      ENDDO
      ! Flip MUTOT from (up,down) to (total,magnetization) storage mode
      ! This is done because the routine FORTAU needs the "total" component
      CALL RC_FLIP_POTENTIAL(MUTOT_,GRIDC,WDES%NCDIJ,.FALSE.)
      ENDIF

      NULLIFY(MUTOT_)
!$ACC EXIT DATA COPYOUT(CVTOT,MUTOT) IF(ACC_EXEC_ON) WAIT(ACC_ASYNC_Q)
#ifdef noAugXCmeta
!$ACC EXIT DATA DELETE(CTMP,CHDEN) __IF_ASYNC__
      DEALLOCATE(CTMP)
#endif

      PROFILING_STOP('potxc_metagga')

      RETURN
      END SUBROUTINE POTXC_METAGGA


!******************** SUBROUTINE FEXCGS_METAGGA ************************
!
!***********************************************************************

      SUBROUTINE FEXCGS_METAGGA(&
     &   NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
     &   KINEDEN,CHTOT,DENCOR,CWORK,MUTOT &
     &)
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec
      USE lattice
      USE mpimy
      USE mgrid
      USE setexm

      IMPLICIT COMPLEX(q) (C)
      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR
      TYPE (tau_handle)  KINEDEN

      RGRID DENCOR(GRIDC%RL%NP)
      COMPLEX(q) CHTOT(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ)
      DIMENSION XCSIF(3,3)
      COMPLEX(q), POINTER :: MUTOT(:,:)
      ! work arrays
      COMPLEX(q),ALLOCATABLE :: CWGRAD(:,:)
      REAL(q), ALLOCATABLE   :: DWORKG(:,:),DWORK1(:,:),DWORK2(:,:),DWORK3(:,:),DVC(:)

      REAL(q) LAPLUP,LAPLDW

      ! for rVV10
      REAL(q),ALLOCATABLE :: DWORK4(:), DWORK6(:), DWORK7(:)
      RGRID , ALLOCATABLE :: DWORK5(:)

      NP1=GRIDC%RL%NP

      IF (NCDIJ==1.OR.NCDIJ==2) THEN
      ! (Non)spinpolarized
         ALLOCATE(CWGRAD(GRIDC%MPLWV,NCDIJ), DWORKG(NP1,NCDIJ), &
           DWORK1(NP1,NCDIJ),DWORK2(NP1,NCDIJ),DWORK3(NP1,NCDIJ),DVC(NP1))
!$ACC ENTER DATA CREATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC) __IF_ASYNC__

         ! Flip CHTOT from (rho,mag) to (rho_up,rho_down)
         CALL RL_FLIP(CHTOT,GRIDC,NCDIJ,.TRUE.)

         IF (.NOT.LUSE_VDW) THEN
            CALL FEXCGS_METAGGA_(LCALCPOT(),LCALCMU(),LCALCLAPD(), &
        &            NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
        &            CWGRAD,CHTOT,CWORK,KINEDEN%TAU,CWGRAD,CHTOT,CWORK,KINEDEN%TAU, &
        &            DENCOR,KINEDEN%TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,MUTOT)
         ELSE
            ALLOCATE(DWORK4(NP1),DWORK5(NP1),DWORK6(NP1),DWORK7(NP1) )
!$ACC ENTER DATA CREATE(DWORK4,DWORK5,DWORK6,DWORK7) __IF_ASYNC__
            CALL FEXCGS_METAGGA_VDW_(LCALCPOT(),LCALCMU(),LCALCLAPD(), &
        &            NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
        &            CWGRAD,CHTOT,CWORK,KINEDEN%TAU,CWGRAD,CHTOT,CWORK,KINEDEN%TAU, &
        &            DENCOR,KINEDEN%TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,MUTOT, &
        &            DWORK4,DWORK5,DWORK6,DWORK7)
!$ACC EXIT DATA DELETE(DWORK4,DWORK5,DWORK6,DWORK7) __IF_ASYNC__
            DEALLOCATE(DWORK4,DWORK5,DWORK6,DWORK7)
         ENDIF
         ! Flip CHTOT back to (rho,mag)
         CALL RL_FLIP(CHTOT,GRIDC,NCDIJ,.FALSE.)
!$ACC EXIT DATA DELETE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC) __IF_ASYNC__
         DEALLOCATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
      ELSEIF (NCDIJ==4) THEN
      ! Non-collinear magnetism: gradient corrections in the
      ! noncollinear case are calculated a bit differently than in the collinear case
         ALLOCATE(CWGRAD(GRIDC%MPLWV,NCDIJ), DWORKG(NP1,NCDIJ/2), &
           DWORK1(NP1,NCDIJ),DWORK2(NP1,NCDIJ),DWORK3(NP1,NCDIJ),DVC(NP1))
!$ACC ENTER DATA CREATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC) __IF_ASYNC__

         ! CHTOT and KINEDEN should be in (rho,mag) representation
         IF (.NOT.LUSE_VDW) THEN
            CALL FEXCGS_METAGGA_NONCOL(LCALCPOT(),LCALCMU(),LCALCLAPD(), &
           &            NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
           &            CWGRAD,CHTOT,CWORK,KINEDEN%TAU,CWGRAD,CHTOT,CWORK,KINEDEN%TAU, &
           &            DENCOR,KINEDEN%TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,MUTOT)
         ELSE
            ALLOCATE(DWORK4(NP1),DWORK5(NP1),DWORK6(NP1),DWORK7(NP1) )
!$ACC ENTER DATA CREATE(DWORK4,DWORK5,DWORK6,DWORK7) __IF_ASYNC__
            CALL FEXCGS_METAGGA_NONCOL_VDW(LCALCPOT(),LCALCMU(),LCALCLAPD(), &
           &            NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
           &            CWGRAD,CHTOT,CWORK,KINEDEN%TAU,CWGRAD,CHTOT,CWORK,KINEDEN%TAU, &
           &            DENCOR,KINEDEN%TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,MUTOT, &
           &            DWORK4,DWORK5,DWORK6,DWORK7)
!$ACC EXIT DATA DELETE(DWORK4,DWORK5,DWORK6,DWORK7) __IF_ASYNC__
            DEALLOCATE(DWORK4,DWORK5,DWORK6,DWORK7)
         ENDIF

         IF (ASSOCIATED(MUTOT).AND.LCALCMU()) THEN
! mM: just until all is done
!           WRITE(*,*) 'non-collinear mode for revTPSS not yet fully implemented, sorry ...'
!           STOP
! mM
            ! MUTOT and CWORK come out as two component (up,down) quantities, where
            ! "up" and "down" are taken w.r.t. the local magnetization direction,
            ! this is now cast into (rho, mag) form.
            CALL MAG_DIRECTION_KINDENS(CHTOT(1,1), KINEDEN%TAU(1,1), MUTOT(1,1), CWORK(1,1), GRIDC, NCDIJ, LATT_CUR)
            ! and rearranged from (rho,mag) to spinor representation
            CALL POT_FLIP_RL(MUTOT(1,1), GRIDC, NCDIJ)
         ELSE
            ! CWORK(potential) comes out with (spin up and down) representation
            ! It needs to flip to (total, mag) representation
            CALL MAG_DIRECTION(CHTOT(1,1), CWORK(1,1), GRIDC, NCDIJ)
         ENDIF
         ! rearrange the potential in (spinor) representation
         CALL POT_FLIP_RL(CWORK(1,1), GRIDC, NCDIJ)
!$ACC EXIT DATA DELETE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC) __IF_ASYNC__
         DEALLOCATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
      ENDIF

      RETURN
      END SUBROUTINE FEXCGS_METAGGA


!******************** SUBROUTINE SET_PAW_METAGGA ***********************
!
!***********************************************************************
      SUBROUTINE SET_PAW_METAGGA(P)
      USE prec
      USE pseudo
      USE radial
      USE constant
      IMPLICIT NONE
      TYPE (potcar), POINTER :: P
      ! local variables
      INTEGER I,NMIN,NMAX
      REAL(q) SCALE
      REAL(q) RHO(P%R%NMAX),DRHO(P%R%NMAX)

      SCALE=1/(2*SQRT(PI)) ! Y00

      NMAX=P%R%NMAX

!     NMIN=NMAX
!     DO I=1,P%LMAX
!        NMIN=MIN(NMIN,IR_MATCH(P,I))
!     ENDDO
      NMIN=IR_PSMAX(P)

      RHO(:)=SCALE*P%RHOAE(:)/(P%R%R(:)*P%R%R(:))

      CALL GRAD(P%R,RHO,DRHO)
      DRHO=ABS(DRHO)
      DO I=1,NMAX
         IF ((DRHO(I)*DRHO(I)/RHO(I)/8._q*2._q*HSQDTM) > (P%TAUAE(I)*SCALE/(P%R%R(I)*P%R%R(I))) ) &
        &   P%TAUAE(I)=(DRHO(I)*DRHO(I)/RHO(I)/8._q*2._q*HSQDTM)/SCALE*(P%R%R(I)*P%R%R(I)) !*1.00001
      ENDDO

!     P%TAUAE(NMIN:NMAX)=0
      P%RHOAE(NMIN:NMAX)=P%RHOPS(NMIN:NMAX)

      RETURN
      END SUBROUTINE SET_PAW_METAGGA


!******************** SUBROUTINE SET_KINEDEN ***************************
!
! SET_KINEDEN calculates the kinetic energy density of the PW part of
! the wavefunctions (0.5*|grad psi|**2).
!
! The actual work is done in TAU_PW_DIRECT
! L
!> @details @ref openacc :
!> On entering this subroutine W%CW and W%CPROJ are updated on the host
!> (if present on the device) and then OpenACC execution is switched off.
!> On exit the OpenACC execution mode reverts to its original status.
!
!***********************************************************************

      SUBROUTINE SET_KINEDEN(&
     &   GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM,NIOND,W,WDES,KINEDEN &
     &)
#ifdef _OPENACC
      USE mopenacc
#endif
      USE prec
      USE lattice
      USE mgrid
      USE msymmetry
      USE base
      USE wave
      USE mpimy
      USE tutor, ONLY: vtutor

      IMPLICIT NONE

      TYPE (grid_3d)     GRIDC,GRID,GRID_SOFT
      TYPE (latt)        LATT_CUR
      TYPE (transit)     SOFT_TO_C
      TYPE (symmetry)    SYMM
      TYPE (wavespin)    W
      TYPE (wavedes)     WDES
      TYPE (tau_handle)  KINEDEN

      INTEGER NIOND

      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) THEN
         RETURN
      ENDIF
      PROFILING_START('set_kineden')

      ! just a failsafe
      IF (.NOT.ASSOCIATED(KINEDEN%TAU)) THEN
         CALL vtutor%bug("SET_KINEDEN: internal ERROR, KIN_EDEN handle not allocated", __FILE__, __LINE__)
      ENDIF

      CALL TAU_PW(&
     &   GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM,NIOND,W,WDES,KINEDEN%TAU)

      PROFILING_STOP('set_kineden')

      RETURN
      END SUBROUTINE SET_KINEDEN


!************************* SUBROUTINE TAUPAR ***************************
!
!  subroutine to calculate the partial kinetic energy density of the
!  core electrons from overlapping atoms in real space and store
!  it in an real array
!  NOTE: the DENS array is not necessarily suffiently large
!  to allow for 3d-FFT, hence a work array is temporarily allocated
!
!***********************************************************************

      SUBROUTINE TAUPAR(GRIDC,T_INFO,B,OMEGA,P,CSTRF,DENS)
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec
      USE mpimy
      USE mgrid
      USE poscar
      USE pseudo
      IMPLICIT NONE

      TYPE (type_info)   T_INFO
      TYPE (potcar)      P(T_INFO%NTYP)
      TYPE (grid_3d)     GRIDC
      RGRID        DENS(GRIDC%RL%NP)
      COMPLEX(q)   CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
      REAL(q)      B(3,3),OMEGA
      ! work arrays
      COMPLEX(q),ALLOCATABLE::    CWORK1(:),CWORK2(:)

      ALLOCATE(CWORK1(GRIDC%MPLWV),CWORK2(GRIDC%MPLWV))
!$ACC ENTER DATA CREATE(CWORK1,CWORK2) __IF_ASYNC__
      CALL TAUATO(.TRUE.,GRIDC,T_INFO,B,P,CSTRF,CWORK1,CWORK2)
      CALL RL_ADD(CWORK1,1.0_q/OMEGA,CWORK1,0.0_q,DENS,GRIDC)

!$ACC EXIT DATA DELETE(CWORK1,CWORK2) __IF_ASYNC__
      DEALLOCATE(CWORK1,CWORK2)

      RETURN
      END SUBROUTINE TAUPAR


!************************* SUBROUTINE TAUATO ***************************
!
!  This routine calculates the partial kinetic energy density of the
!  core electrons corresponding to overlapping atoms
!
!  LFOUR
!   .FALSE. set up density in reciprocal space
!   .TRUE.  set up density in real space
!
!***********************************************************************

      SUBROUTINE TAUATO(LFOUR,GRIDC,T_INFO,B,P,CSTRF,CHTOT,CHDER)
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec
      USE mpimy
      USE mgrid
      USE poscar
      USE pseudo
      USE constant
      IMPLICIT COMPLEX(q) (C)

      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (type_info)   T_INFO
      TYPE (potcar)      P(T_INFO%NTYP)
      TYPE (grid_3d)     GRIDC
      COMPLEX(q)   CHTOT(GRIDC%RC%NP),CHDER(GRIDC%RC%NP)
      COMPLEX(q)   CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
      REAL(q)      B(3,3)
      LOGICAL LFOUR
      ! local variables
      REAL(q), POINTER :: PRHO(:)

!$ACC KERNELS PRESENT(CHTOT,CHDER) __IF_ASYNC__
      CHTOT=0
      CHDER=0
!$ACC END KERNELS
!=======================================================================
! loop over all types of atoms
! if no pseudocharge for this ion next ion
!=======================================================================
      typ: DO NT=1,T_INFO%NTYP
       PRHO=>P(NT)%PSPTAU
       IF (.NOT.ASSOCIATED(PRHO)) CYCLE
!=======================================================================
! calculate the scaling factor ARGSC that converts the magnitude of a
! reciprocal lattice vector to the correponding position in the
! pseudopotential arrays
!=======================================================================
      ARGSC=NPSPTS/P(NT)%PSGMAX
      PSGMA2=P(NT)%PSGMAX-P(NT)%PSGMAX/NPSPTS*3

!$ACC PARALLEL LOOP PRESENT(P,GRIDC,CHTOT,CSTRF,CHDER) __IF_ASYNC__ &
!$ACC& PRIVATE(N1,N2,N3,NC,GX,GY,GZ,G,ARG,NADDR,REM,V1,V2,V3,V4,T0,T1,T2,T3)
      DO N=1,GRIDC%RC%NP
        N1= MOD((N-1),GRIDC%RC%NROW) +1
        NC= (N-1)/GRIDC%RC%NROW+1
        N2= GRIDC%RC%I2(NC)
        N3= GRIDC%RC%I3(NC)
!=======================================================================
! calculate the magnitude of the reciprocal lattice vector
!=======================================================================
        GX= GRIDC%LPCTX(N1)*B(1,1)+GRIDC%LPCTY(N2)*B(1,2)+GRIDC%LPCTZ(N3)*B(1,3)
        GY= GRIDC%LPCTX(N1)*B(2,1)+GRIDC%LPCTY(N2)*B(2,2)+GRIDC%LPCTZ(N3)*B(2,3)
        GZ= GRIDC%LPCTX(N1)*B(3,1)+GRIDC%LPCTY(N2)*B(3,2)+GRIDC%LPCTZ(N3)*B(3,3)

        G=SQRT(GX*GX+GY*GY+GZ*GZ)*TPI

        IF (G/=0 .AND.G<PSGMA2) THEN
!=======================================================================
! convert the magnitude of the reciprocal latice vector to a position
! in the charge-dens. array  and interpolate the atomic-chargedensity
!=======================================================================
          ARG=(G*ARGSC)+1
          NADDR=MAX(INT(ARG),2)
          REM=ARG-NADDR
          V1=PRHO(NADDR-1)
          V2=PRHO(NADDR)
          V3=PRHO(NADDR+1)
          V4=PRHO(NADDR+2)
          T0=V2
          T1=((6*V3)-(2*V1)-(3*V2)-V4)/6._q
          T2=(V1+V3-(2*V2))/2._q
          T3=(V4-V1+(3*(V2-V3)))/6._q
          CHTOT(N)=CHTOT(N)+(T0+REM*(T1+REM*(T2+REM*T3))) *CSTRF(N,NT)
          CHDER(N)=CHDER(N)+(T1+REM*(2*T2+REM*3*T3))*ARGSC*CSTRF(N,NT)
        ELSE IF (G==0) THEN
          CHTOT(N)=CHTOT(N)+PRHO(1)*CSTRF(N,NT)
          CHDER(N)=0
        ENDIF
      ENDDO
      ENDDO typ
!=======================================================================
! set the charge-density of unbalanced lattice-vectors to 0
! and transform the charge-density to real space
!=======================================================================
      CALL SETUNB(CHTOT(1),GRIDC)
      CALL SETUNB(CHDER(1),GRIDC)

      IF (LFOUR) THEN
        CALL FFT3D(CHTOT,GRIDC,1)
      ENDIF

      RETURN
      END SUBROUTINE TAUATO

!
!  small subroutine which allocates CHDER calls the subroutine
!  above, and then returns
!

      SUBROUTINE TAUATO_WORK(LFOUR,GRIDC,T_INFO,B,P,CSTRF,CHTOT)
      USE prec
      USE mpimy
      USE mgrid
      USE poscar
      USE pseudo
      IMPLICIT NONE

      TYPE (type_info)   T_INFO
      TYPE (potcar)      P(T_INFO%NTYP)
      TYPE (grid_3d)     GRIDC
      COMPLEX(q)   CHTOT(GRIDC%RC%NP)
      COMPLEX(q), ALLOCATABLE :: CHDER(:)
      COMPLEX(q)   CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
      REAL(q)      B(3,3)
      LOGICAL LFOUR
      ! local variables
      REAL(q), POINTER :: PRHO(:)

      ALLOCATE(CHDER(GRIDC%RC%NP))
      CALL TAUATO(LFOUR,GRIDC,T_INFO,B,P,CSTRF,CHTOT,CHDER)
      DEALLOCATE(CHDER)

      END SUBROUTINE TAUATO_WORK


!************************ SUBROUTINE FORTAU ****************************
!
! This subroutine calculates the correction to the Hellmann-Feynman
! forces due to the (possible) presence of a partial core kinetic energy
! density
!
!***********************************************************************

      SUBROUTINE FORTAU(GRIDC,P,T_INFO,LATT_CUR,MUTOT,TAUFOR)
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec

      USE mpimy
      USE mgrid
      USE pseudo
      USE lattice
      USE poscar
      USE constant
      IMPLICIT COMPLEX(q) (C)

      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (grid_3d)     GRIDC
      TYPE (type_info)   T_INFO
      TYPE (potcar)      P (T_INFO%NTYP)
      TYPE (latt)        LATT_CUR
      COMPLEX(q)   MUTOT(GRIDC%MPLWV)
      REAL(q)      TAUFOR(3,T_INFO%NIONS)
      ! work arrays
      REAL(q), POINTER :: PRHO(:)
      REAL(q), ALLOCATABLE :: WORK(:)

      PROFILING_START('fortau')

      ALLOCATE(WORK(GRIDC%RC%NP))
!$ACC ENTER DATA CREATE(WORK,TAUFOR) __IF_ASYNC__

      SCALE=1._q/(RYTOEV*AUTOA2)

!$ACC KERNELS PRESENT(TAUFOR) __IF_ASYNC__
      TAUFOR(1:3,1:T_INFO%NIONS)=0
!$ACC END KERNELS
!=======================================================================
! loop over all types of atoms
!=======================================================================
      NIS=1
      typ: DO NT=1,T_INFO%NTYP
      NIADD=T_INFO%NITYP(NT)

      PRHO=>P(NT)%PSPTAU

      IF (ASSOCIATED(PRHO)) THEN
!=======================================================================
! iterpolate the pseudopotential on the grid of reciprocal
! lattice-vectors
!=======================================================================
      ARGSC=NPSPTS/P(NT)%PSGMAX
      PSGMA2=P(NT)%PSGMAX-P(NT)%PSGMAX/NPSPTS*3

!$ACC PARALLEL LOOP PRIVATE(N1,NC,N2,N3,FACTM,GX,GY,GZ,G,ARG,NADDR,REM,V1,V2,V3,V4,T0,T1,T2,T3) &
!$ACC& PRESENT(GRIDC,LATT_CUR,P,WORK) __IF_ASYNC__
      DO N=1,GRIDC%RC%NP
        N1= MOD((N-1),GRIDC%RC%NROW) +1
        NC= (N-1)/GRIDC%RC%NROW+1
        N2= GRIDC%RC%I2(NC)
        N3= GRIDC%RC%I3(NC)

        SETFACT1
        SETFACT
!=======================================================================
! calculate the magnitude of the reciprocal lattice vector
!=======================================================================
        GX= GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
        GY= GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
        GZ= GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)

        G=SQRT(GX*GX+GY*GY+GZ*GZ)*TPI

        IF (G/=0 .AND.G<PSGMA2) THEN
!=======================================================================
! convert the magnitude of the reciprocal latice vector to a position
! in the charge-dens. array  and interpolate the atomic-chargedensity
!=======================================================================
          ARG=(G*ARGSC)+1
          NADDR=MAX(INT(ARG),2)
          REM=ARG-NADDR
          V1=PRHO(NADDR-1)
          V2=PRHO(NADDR)
          V3=PRHO(NADDR+1)
          V4=PRHO(NADDR+2)
          T0=V2
          T1=((6*V3)-(2*V1)-(3*V2)-V4)/6._q
          T2=(V1+V3-(2*V2))/2._q
          T3=(V4-V1+(3*(V2-V3)))/6._q
          WORK(N)=T0+REM*(T1+REM*(T2+REM*T3))
!       ELSE IF (G==0) THEN
!         WORK(N)=PRHO(1)
        ELSE
          WORK(N)=0
        ENDIF

      ENDDO

#ifdef vector
!$ACC PARALLEL LOOP GANG PRIVATE(FOR1,FOR2,FOR3) &
#else
!$ACC PARALLEL LOOP GANG PRIVATE(FOR1,FOR2,FOR3,CX,G1) &
#endif
!$ACC& PRESENT(GRIDC,T_INFO,T_INFO%POSION,T_INFO%VCA,WORK,TAUFOR,MUTOT) __IF_ASYNC__
      ion: DO NI=NIS,NIADD+NIS-1
!=======================================================================
! initialise the force on the ion to zero
!=======================================================================
         FOR1=0._q
         FOR2=0._q
         FOR3=0._q
!=======================================================================
! calculate the total force on the ions by summing over reciprocal
! lattice vectors
! first calculate phase factor:
! there are two version for calculating the phase factor
! on vector machines you might try the first version
! but usually the second version is much faster (less calls to CEXP)
!=======================================================================
#ifdef vector
!$ACC LOOP VECTOR REDUCTION(-:FOR1,FOR2,FOR3) PRIVATE(N1,NC,N2,N3,G1,G2,G3,FACTM,CEXPF,FOR)
         DO NG=1,GRIDC%RC%NP

           N1= MOD((NG-1),GRIDC%RC%NROW) +1
           NC= (NG-1)/GRIDC%RC%NROW+1
           N2= GRIDC%RC%I2(NC)
           N3= GRIDC%RC%I3(NC)

           G1=T_INFO%POSION(1,NI)*GRIDC%LPCTX(N1)
           G2=T_INFO%POSION(2,NI)*GRIDC%LPCTY(N2)
           G3=T_INFO%POSION(3,NI)*GRIDC%LPCTZ(N3)
           SETFACT1
           SETFACT
           CEXPF=EXP(-CITPI*(G3+G2+G1))*T_INFO%VCA(NT)
#else
         CX =EXP(-CITPI*T_INFO%POSION(1,NI))
         G1 =T_INFO%POSION(1,NI)*xmin(GRIDC%NGX)

!$ACC LOOP VECTOR REDUCTION(-:FOR1,FOR2,FOR3) PRIVATE(NGP,N2,N3,G2,G3,CE,N1,NG,FACTM,CEXPF,FOR)
         DO NC=1,GRIDC%RC%NCOL
           NGP=(NC-1)*GRIDC%RC%NROW+1

           N2= GRIDC%RC%I2(NC)
           N3= GRIDC%RC%I3(NC)
           G2=T_INFO%POSION(2,NI)*GRIDC%LPCTY(N2)
           G3=T_INFO%POSION(3,NI)*GRIDC%LPCTZ(N3)
           CE=EXP(-CITPI*(G3+G2+G1))*T_INFO%VCA(NT)

!$ACC LOOP SEQ
           DO N1P=0,GRIDC%RC%NROW-1
           SETN1fromN1P
           NG=NGP+N1
           N1=N1+1
           SETFACT1
           SETFACT
           CEXPF=CE
           CE=CE*CX
#endif
!=======================================================================
! add the contribution to the force from the present reciprocal lattice
! vector  and multiply by i (ie take imaginary part)
!=======================================================================
           FOR=WORK(NG)*MULFACT AIMAG(CONJG(MUTOT(NG))*CEXPF)

           FOR1=FOR1-GRIDC%LPCTX_(N1)*FOR
           FOR2=FOR2-GRIDC%LPCTY_(N2)*FOR
           FOR3=FOR3-GRIDC%LPCTZ_(N3)*FOR
         ENDDO
#ifndef vector
         ENDDO
#endif
!=======================================================================
! multiply forces by 2*Pi
!=======================================================================
         TAUFOR(1,NI)=FOR1*TPI*SCALE
         TAUFOR(2,NI)=FOR2*TPI*SCALE
         TAUFOR(3,NI)=FOR3*TPI*SCALE

      ENDDO ion
      ENDIF
      NIS=NIS+NIADD
      ENDDO typ
!$ACC EXIT DATA COPYOUT(TAUFOR) DELETE(WORK) WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)
!=======================================================================
! forces are now in the reciprocal lattice transform it to
! cartesian coordinates
!=======================================================================
      CALLMPI( M_sum_d(GRIDC%COMM,TAUFOR(1,1),T_INFO%NIONS*3))
      CALL DIRKAR(T_INFO%NIONS,TAUFOR,LATT_CUR%B)
      DEALLOCATE(WORK)

      PROFILING_STOP('fortau')

      RETURN
      END SUBROUTINE FORTAU


!******************** SUBROUTINE RAD_KINEDEN ***************************
!
!***********************************************************************
      SUBROUTINE RAD_KINEDEN(&
     &   P,W,LMAX_TAU,NCDIJ,COCC,TAU)
      USE prec
      USE asa
      USE radial
      USE constant
      USE pseudo
      USE string, ONLY: str
      USE tutor, ONLY: vtutor
      IMPLICIT NONE
      TYPE (potcar) P
      REAL(q) W(:,:)
      INTEGER LMAX_TAU,NCDIJ
      OVERLAP COCC(:,:,:)
      REAL(q) TAU(:,:,:)
      ! local variables
      INTEGER ISP,I,Ch1,Ch2
      INTEGER LLMAX_TAU,LMMAX_TAU,LM,LMP,LL,LLP,M,MP,MPLOW,INDYLM,INDYLMP

      REAL(q) FAKT
      REAL(q) W1(P%R%NMAX),W2(P%R%NMAX),DW1(P%R%NMAX),DW2(P%R%NMAX)

      TAU=0

      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) RETURN

      ! check consistency
      LMMAX_TAU=(LMAX_TAU+1)**2
      IF (SIZE(TAU,2)<LMMAX_TAU) THEN
         CALL vtutor%error("RAD_KINEDEN: ERROR, size(TAU,2)<LMMAX_TAU " // str(SIZE(TAU,2)) // " " // &
            str(LMMAX_TAU))
      ENDIF

      ! restriction for the angular development of \tau and \mu
      LLMAX_TAU=MIN(LMAXTAU,LMAX_TAU); LMMAX_TAU=(LLMAX_TAU+1)**2

      spin: DO ISP=1,NCDIJ

         ! loops over channels (l,epsilon)
         LM=1; DO Ch1=1,P%LMAX
         ! d(w1/r)/dr
         W1(:)=W(:,Ch1)/P%R%R(:); CALL GRAD(P%R,W1,DW1)

         LMP=LM; DO Ch2=Ch1,P%LMAX
         ! d(w2/r)/dr
         W2(:)=W(:,Ch2)/P%R%R(:); CALL GRAD(P%R,W2,DW2)

            LL=P%LPS(Ch1); LLP=P%LPS(Ch2)
            DO M=1,2*LL+1
            MPLOW=1; IF(Ch1==Ch2) MPLOW=M
            DO MP=MPLOW,2*LLP+1
               INDYLM= LL**2 +M
               INDYLMP=LLP**2+MP

               FAKT=REAL(COCC(LM+M-1,LMP+MP-1,ISP)+COCC(LMP+MP-1,LM+M-1,ISP),q)
               IF ((LM+M-1)==(LMP+MP-1)) THEN
                  FAKT=REAL(COCC(LM+M-1,LMP+MP-1,ISP),q)
               ENDIF

               DO I=1,LMMAX_TAU
                  TAU(:P%R%NMAX,I,ISP)=TAU(:P%R%NMAX,I,ISP)+FAKT*&
                 &   (DW1(:)*X_YLM_X_YLM(INDYLM,INDYLMP,I)*DW2(:)*P%R%R(:)*P%R%R(:) + &
                 &    DW1(:)*X_YLM_YLMD(INDYLM,INDYLMP,I)*W2(:)*P%R%R(:) + &
                 &    W1(:)*X_YLM_YLMD(INDYLMP,INDYLM,I)*DW2(:)*P%R%R(:) + &
                 &    W1(:)*YLMD_YLMD(INDYLM,INDYLMP,I)*W2(:))
               ENDDO

            ENDDO
            ENDDO
         LMP=LMP+2*LLP+1
         ENDDO
         LM =LM +2*LL +1
         ENDDO

      ENDDO spin

      TAU=TAU*HSQDTM

      RETURN
      END SUBROUTINE RAD_KINEDEN


!********************* SUBROUTINE RAD_TAU_ATOM *************************
!
!***********************************************************************
      SUBROUTINE RAD_TAU_ATOM( &
     &   P,W,LMAX_TAU,TAU)
      USE prec
      USE pseudo
      USE string, ONLY: str
      USE tutor, ONLY: vtutor
      IMPLICIT NONE
      TYPE (potcar) P
      REAL(q) W(:,:)
      REAL(q) TAU(:,:,:)
      INTEGER LMAX_TAU
      ! local variables
      OVERLAP, ALLOCATABLE :: COCC(:,:,:)
      INTEGER Ch,LM,M,LMMAX_TAU

      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) RETURN

      ! check consistency
      LMMAX_TAU=(LMAX_TAU+1)**2
      IF (SIZE(TAU,2)<LMMAX_TAU) THEN
         CALL vtutor%error("RAD_TAU_ATOM: ERROR, size(TAU,2)<LMMAX_TAU " // str(SIZE(TAU,2)) // " " &
            // str(LMMAX_TAU))
      ENDIF

      ALLOCATE(COCC(P%LMDIM,P%LMDIM,1))
      COCC=0

      LM=1
      DO Ch=1,P%LMAX
         DO M=1,2*P%LPS(Ch)+1
            COCC(LM,LM,1)=P%QATO(Ch,Ch)
            LM=LM+1
         ENDDO
      ENDDO

      CALL RAD_KINEDEN(P,W,LMAX_TAU,1,COCC,TAU)

      DEALLOCATE(COCC)

      RETURN
      END SUBROUTINE RAD_TAU_ATOM


!********************* SUBROUTINE RAD_POT_METAGGA **********************
!
!***********************************************************************
      SUBROUTINE RAD_POT_METAGGA(&
     &   R,ISPIN,LMAX_CALC,LMAX_TAU,LASPH,CVMBJ,RHO,RHOPS,RHOC,POTC,TAU,POTH,POT,DOUBLEC,EXCG,GRDR,MU,NI,AUGFACT,TAUC)
      USE prec
      USE constant
      USE radial
      IMPLICIT NONE
      TYPE (rgrid) R
      INTEGER ISPIN
      INTEGER LMAX_CALC,LMAX_TAU
      REAL(q) RHO(:,:,:)     ! charge distribution see above (charge,magnetization)
      REAL(q) RHOPS(:,:,:)   ! same as above (but possibly without augmentation)
      REAL(q) RHOC(:)        ! core charge distribution
      REAL(q) POTC(:)        ! frozen core potential (Hartree)
      REAL(q) TAU(:,:,:)     ! kinetic energy density (up,down)
      REAL(q) POTH(:,:,:)    ! Hartree potential (up,down)
      REAL(q) POT(:,:,:)     ! Total potential (up,down)
      REAL(q) CVMBJ          ! MBJ C-parameter
      REAL(q) GRDR           ! integral of |nabla rho(r)|/ rho(r) over the PAW sphere
      REAL(q) EXCG           ! exchange energy only
      REAL(q) DOUBLEC        ! double counting corrections
      REAL(q) MU(:,:,:)      ! d e_xc/d tau (up,down)
      REAL(q), INTENT(IN) :: AUGFACT
      REAL(q), OPTIONAL :: TAUC(:) ! kinetic energy density of the core electrons
      LOGICAL LASPH
      INTEGER NI
      ! local variables
      INTEGER N,L,M,LM,K
      REAL(q) SCALE
      REAL(q) SUM,DHARTREE
      REAL(q) DEXC,DVXC

      MU=0

      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) RETURN

      POT=0; POTH=0

      SCALE=2*SQRT(PI)
      N=R%NMAX

      ! Hartree contributions
      DHARTREE=0
      DO L=0,LMAX_CALC
      DO M=0,2*L
         LM=L*L+M+1
         CALL RAD_POT_HAR(L,R,POTH(:,LM,1),RHO(:,LM,1),SUM)
         IF (ISPIN==2) POTH(:,LM,2)=POTH(:,LM,1)
         DHARTREE=DHARTREE+SUM
      ENDDO
      ENDDO
      DO K=1,N
         POTH(K,1,1)=POTH(K,1,1)+POTC(K)*SCALE
      ENDDO
      IF (ISPIN==2) POTH(:,1,2)=POTH(:,1,1)

      ! Exchange-correlation
      DEXC=0
      DVXC=0

      POT=POTH

      IF (PRESENT(TAUC)) THEN
         CALL RAD_METAGGA_XC(R,ISPIN,LMAX_CALC,LMAX_TAU,LASPH,CVMBJ,RHOPS,RHOC,POTC,TAU,DEXC,DVXC,GRDR,POT,MU,NI,AUGFACT,TAUC)
      ELSE
         CALL RAD_METAGGA_XC(R,ISPIN,LMAX_CALC,LMAX_TAU,LASPH,CVMBJ,RHOPS,RHOC,POTC,TAU,DEXC,DVXC,GRDR,POT,MU,NI,AUGFACT)
      ENDIF

      EXCG=DEXC
      DOUBLEC=-DHARTREE*0.5_q+DEXC-DVXC
#ifdef debug
      WRITE(*,1)  DHARTREE/2+DEXC, DOUBLEC
1     FORMAT('  Hartree + exc, -Hartree + exc -vxc',6F14.7)
#endif

      RETURN
      END SUBROUTINE RAD_POT_METAGGA


!********************* SUBROUTINE RAD_METAGGA_XC ***********************
!
!***********************************************************************
      SUBROUTINE RAD_METAGGA_XC(&
     &   R,ISPIN,LMAX_CALC,LMAX_TAU,LASPH,CVMBJ,RHO,RHOC,POTC,TAU,DEXC,DVXC,GRDR,POT,MU,NI,AUGFACT,TAUC)
#ifdef _OPENACC
      USE tutoracc, ONLY : ACC_VTUTOR_CHECK
#endif
      USE prec
      USE asa
      USE radial
      USE constant
      USE metalib

      IMPLICIT NONE
      TYPE (rgrid) :: R
      INTEGER ISPIN
      INTEGER LMAX_CALC,LMAX_TAU
      INTEGER ELL,LFAC,M
      REAL(q) RHOC(:)        ! core charge distribution
      REAL(q) POTC(:)        ! frozen core potential (Hartree)
      REAL(q) RHO(:,:,:)     ! charge distribution see above (charge,magnetization)
      REAL(q) TAU(:,:,:)     ! kinetic energy density (up,down)
      REAL(q) CVMBJ          ! MBJ C-parameter
      REAL(q) GRDR           ! integral of |nabla rho(r)|/ rho(r) over the PAW sphere
      REAL(q) DEXC, DVXC
      REAL(q) POT(:,:,:)     ! potential (up,down)
      REAL(q) MU(:,:,:)      ! d e_xc/d tau (up,down)
      REAL(q), INTENT(IN) :: AUGFACT
      REAL(q), OPTIONAL :: TAUC(:) ! kinetic energy density of the core electrons
      LOGICAL LASPH
      INTEGER NI
      ! local variables
      REAL(q) RHOT(R%NMAX,2),RHO_ANG(R%NMAX,2,3),T1(R%NMAX,2),T2(R%NMAX,2)
      REAL(q) TAUU(R%NMAX),TAUD(R%NMAX)
      INTEGER ISP,K,I,J,IFAIL
      INTEGER LM,LMP,LLMAX,LMMAX,LMMAX_alloc,LMMAX_CALC,LLMAX_TAU,LMMAX_TAU,LMAX_TMP
      INTEGER NP,PHPTS,THPTS,NPTS
      REAL(q) SCALE,SUM,DELTAPHI,EVTOH

      REAL(q) DVINI,DCMU

      REAL(q) SIM_FAKT
      REAL(q) TEMP1
      REAL(q), ALLOCATABLE :: RADPTS(:,:), XYZPTS(:,:)
      REAL(q), ALLOCATABLE :: YLM(:,:),YLMD(:,:,:),YLMDD(:,:,:)
      REAL(q), ALLOCATABLE :: YLM_NABLA_YLM(:,:,:),YLM_X_YLM(:,:,:)
      REAL(q), ALLOCATABLE :: dFXC(:,:,:,:),dFXCdT(:,:,:),dFXCdLap(:,:,:)
      REAL(q), ALLOCATABLE :: WEIGHT(:),ABSCIS(:)
      REAL(q), ALLOCATABLE :: RHOLM(:,:,:), RHOLMD(:,:,:)

      REAL(q) XU,YU,ZU,XD,YD,ZD
      REAL(q) TG,LAPLUP,LAPLDW,MUUP,MUDW,DLXC1,DLXC2
      REAL(q) EXT,DEXC1,DEXC2,DVXC1,DVXC2,DVC
      REAL(q) TMP(ISPIN,3)
      EXTERNAL GAUSSI2

      REAL(q) :: CHGMIN=1E-10_q, NABMIN=1E-10_q, TAUMIN=1E-10_q

!     TAUMIN=0 for MBJ is ok since there is no division by TAU
      IF ((ID_METAGGA == 30).OR.(ID_METAGGA == 31)) TAUMIN=0._q
      ! initial double counting corrections
      DVINI=0
      IF (LCALCPOT()) THEN
         CALL RAD_POT_IN_RHO(R,ISPIN,LMAX_CALC,RHO,POT,DVINI)
      ENDIF

      SCALE=2*SQRT(PI) ! 1/Y00

      EVTOH=1._q/(2.*HSQDTM)*AUTOA5

      LMMAX_CALC=(LMAX_CALC+1)**2
      ! restriction for the angular development of \rho
      LLMAX=MIN(6,LMAX_CALC)
      ! in GGA this needs to be increased by 1 (nabla-comment)
      LLMAX=LLMAX+1; LMMAX=(LLMAX+1)**2

      ! restriction for the angular development of \tau and \mu
      LLMAX_TAU=MIN(LMAXTAU,LMAX_TAU); LMMAX_TAU=(LLMAX_TAU+1)**2

      ! restrict everything to spherical contributions only (LASPH=.FALSE.)
      IF (.NOT.LASPH) THEN
         LLMAX=1; LMMAX=4; LLMAX_TAU=0; LMMAX_TAU=1; LMMAX_CALC=1
      ENDIF

      LMMAX_alloc=(MAX(LLMAX,LLMAX_TAU)+1)**2

!========================================================================
! number of theta and phi pivot points to perform angular integration
! since Exc=f(a*Yllmax,m) we need more pivot points than theoretically
! needed to integrate Yllmax,m.
! the factor 2 is the minium, 3 is more accurate
!========================================================================
      PHPTS=PHPTS_FACT*(MAX(LLMAX,LLMAX_TAU)+1)
      THPTS=THPTS_FACT*FLOOR(REAL(MAX(LLMAX,LLMAX_TAU)/2+1,KIND=q))
      NPTS=PHPTS*THPTS
      DELTAPHI=REAL(2_q*PI/PHPTS,KIND=q)
! allocate arrays
      ALLOCATE(XYZPTS(NPTS,3),RADPTS(NPTS,2),WEIGHT(THPTS),ABSCIS(THPTS), &
     &     YLM(NPTS,LMMAX_alloc),YLMD(NPTS,LMMAX_alloc,3),YLMDD(NPTS,LMMAX_alloc,6), &
     &     YLM_NABLA_YLM(LMMAX,LMMAX,0:3),YLM_X_YLM(LMMAX,LMMAX,0:3), &
     &     RHOLM(R%NMAX,LMMAX,2),RHOLMD(R%NMAX,LMMAX,2))

      IF (LCALCPOT()) THEN
         ALLOCATE(dFXC(R%NMAX,LMMAX,0:3,2)); dFXC=0
         CALL SETYLM_NABLA_YLM(LLMAX,YLM_NABLA_YLM,YLM_X_YLM)
      ENDIF
      IF (LCALCLAPD()) THEN
         ALLOCATE(dFXCdLap(R%NMAX,LMMAX,2)); dFXCdLap=0
      ENDIF
      IF (LCALCMU()) THEN
         ALLOCATE(dFXCdT(R%NMAX,LMMAX_TAU,2)); dFXCdT=0
      ENDIF

      ! set phi positions, equally spaced
      RADPTS=0; WEIGHT=0; ABSCIS=0
      DO I=1,PHPTS
         DO J=1,THPTS
            RADPTS((J-1)*PHPTS+I,2)=(I-1)*DELTAPHI
         ENDDO
      ENDDO
      ! get theta positions (actually get cos(theta)) (Gauss integration)
      CALL GAUSSI(GAUSSI2,-1._q,1._q,0,THPTS,WEIGHT,ABSCIS,IFAIL)
      DO I=1,THPTS
         RADPTS((I-1)*PHPTS+1:I*PHPTS,1)=ABSCIS(I)
      ENDDO
      ! convert radial to cartesian coordinates
      DO I=1,NPTS
         XYZPTS(I,1)=COS(RADPTS(I,2))*SQRT(1_q-RADPTS(I,1)**2_q) ! x
         XYZPTS(I,2)=SIN(RADPTS(I,2))*SQRT(1_q-RADPTS(I,1)**2_q) ! y
         XYZPTS(I,3)=RADPTS(I,1)                                 ! z
      ENDDO

      ! get |r| Y_lm on a unit sphere and its derivatives
      YLM=0; YLMD=0; YLMDD=0
!     CALL SETYLM_GRAD2(LLMAX,NPTS,YLM,YLMD,XYZPTS(:,1),XYZPTS(:,2),XYZPTS(:,3))
      CALL SETYLM_GRAD3(MAX(LLMAX,LLMAX_TAU),NPTS,YLM,YLMD,YLMDD,XYZPTS(:,1),XYZPTS(:,2),XYZPTS(:,3))
!========================================================================
! main loop over all grid points
! prepare the charge density array RHOT
!========================================================================
      DEXC=0; GRDR=0

      ! loop over all points in the angular grid
      points: DO NP=1,NPTS
         ! weight of this points
         SIM_FAKT=DELTAPHI*WEIGHT((INT((NP-1)/PHPTS)+1))

         RHOT=0
         RHO_ANG=0
         TAUU=0; TAUD=0

         ! calculate the total charge RHOT = RHO/r^2 (up and down)
         ! and the gradient of the charge RHO_ANG
         DO K=1,R%NMAX
            DO LM=1,LMMAX_CALC
               ! total charge
               RHOT(K,1)=RHOT(K,1)+YLM(NP,LM)*RHO(K,LM,1) ! rho(r) Y_L(r)
               RHO_ANG(K,1,:)=RHO_ANG(K,1,:)+YLMD(NP,LM,:)*RHO(K,LM,1) ! rho(r) nabla Y_L(r)
               IF (ISPIN==1) THEN
               ! LM resolved charge density (up,down)
                  RHOLM(K,LM,1)=0.5_q*RHO(K,LM,1)/(R%R(K)*R%R(K))
                  RHOLM(K,LM,2)=0.5_q*RHO(K,LM,1)/(R%R(K)*R%R(K))
               ! magnetization
                  RHOT(K,2)=0
                  RHO_ANG(K,2,:)=0
               ELSE
               ! LM resolved charge density (up,down)
                  RHOLM(K,LM,1)=0.5_q*(RHO(K,LM,1)+RHO(K,LM,2))/(R%R(K)*R%R(K))
                  RHOLM(K,LM,2)=0.5_q*(RHO(K,LM,1)-RHO(K,LM,2))/(R%R(K)*R%R(K))
               ! magnetization
                  RHOT(K,2)=RHOT(K,2)+YLM(NP,LM)*RHO(K,LM,2)
                  RHO_ANG(K,2,:)=RHO_ANG(K,2,:)+YLMD(NP,LM,:)*RHO(K,LM,2)
               ENDIF
            ENDDO
            ! add core charge (spherical) and divide by 1/r^2
            RHOT(K,1)=(RHOT(K,1)+RHOC(K)*YLM(NP,1))/(R%R(K)*R%R(K))
!           RHOT(K,1)=(RHOT(K,1))/(R%R(K)*R%R(K))
            RHOT(K,2)= RHOT(K,2)/(R%R(K)*R%R(K))
            ! divide nabla Y_L through r^3 (1/r is missing in YLMD)
            RHO_ANG(K,:,:)=RHO_ANG(K,:,:)/(R%R(K)*R%R(K))/R%R(K)
            ! add core charge to RHOLM
            RHOLM(K,1,1)=RHOLM(K,1,1)+0.5_q*RHOC(K)/(R%R(K)*R%R(K))
            RHOLM(K,1,2)=RHOLM(K,1,2)+0.5_q*RHOC(K)/(R%R(K)*R%R(K))

            DO LM=1,LMMAX_TAU
               IF (ISPIN==1) THEN
               ! kinetic energy density
                  TAUU(K)=TAUU(K)+0.5_q*TAU(K,LM,1)*YLM(NP,LM)/(R%R(K)*R%R(K))
                  TAUD(K)=TAUU(K)
               ELSE
               ! kinetic energy density
                  TAUU(K)=TAUU(K)+TAU(K,LM,1)*YLM(NP,LM)/(R%R(K)*R%R(K))
                  TAUD(K)=TAUD(K)+TAU(K,LM,2)*YLM(NP,LM)/(R%R(K)*R%R(K))
               ENDIF
            ENDDO
            ! kinetic energy density of the core electrons
            IF (PRESENT(TAUC)) THEN
               TAUU(K)=TAUU(K)+0.5_q*TAUC(K)*YLM(NP,1)/(R%R(K)*R%R(K))
               TAUD(K)=TAUD(K)+0.5_q*TAUC(K)*YLM(NP,1)/(R%R(K)*R%R(K))
            ENDIF
            TAUU(K)=MAX(TAUU(K),TAUMIN)
            TAUD(K)=MAX(TAUD(K),TAUMIN)
         ENDDO

         ! d RHOLM / dr
         DO LM=1,LMMAX_CALC
            CALL GRAD(R,RHOLM(1:R%NMAX,LM,1),RHOLMD(1:R%NMAX,LM,1))
            CALL GRAD(R,RHOLM(1:R%NMAX,LM,2),RHOLMD(1:R%NMAX,LM,2))
         ENDDO

         DO K=1,R%NMAX
            TEMP1=RHOT(K,1)
            RHOT(K,1)=(RHOT(K,1)+RHOT(K,2))*0.5_q    ! spin up
            RHOT(K,2)=(TEMP1-RHOT(K,2))*0.5_q        ! spin down

         ENDDO

         ! d rhot / dr (up,down)
         CALL GRAD(R,RHOT,T1)
         CALL GRAD(R,RHOT(1:R%NMAX,2),T1(1:R%NMAX,2))
         ! d^2 rhot / dr^2 (up,down)
         CALL GRAD(R,T1,T2)
         CALL GRAD(R,T1(1:R%NMAX,2),T2(1:R%NMAX,2))

         DO K=1,R%NMAX
            ! calculate the laplacian of the density
            LAPLUP=0; LAPLDW=0
            DO LM=1,LMMAX_CALC
               LAPLUP=LAPLUP+ &
              &    YLMDD(NP,LM,1)*RHOLM(K,LM,1)/(R%R(K)*R%R(K)) &
              &   +(YLMD(NP,LM,1)*XYZPTS(NP,1)+YLMD(NP,LM,1)*XYZPTS(NP,1))/R%R(K)*RHOLMD(K,LM,1) &
              &   +YLMDD(NP,LM,4)*RHOLM(K,LM,1)/(R%R(K)*R%R(K)) &
              &   +(YLMD(NP,LM,2)*XYZPTS(NP,2)+YLMD(NP,LM,2)*XYZPTS(NP,2))/R%R(K)*RHOLMD(K,LM,1) &
              &   +YLMDD(NP,LM,6)*RHOLM(K,LM,1)/(R%R(K)*R%R(K)) &
              &   +(YLMD(NP,LM,3)*XYZPTS(NP,3)+YLMD(NP,LM,3)*XYZPTS(NP,3))/R%R(K)*RHOLMD(K,LM,1)
               LAPLDW=LAPLDW+ &
              &    YLMDD(NP,LM,1)*RHOLM(K,LM,2)/(R%R(K)*R%R(K)) &
              &   +(YLMD(NP,LM,1)*XYZPTS(NP,1)+YLMD(NP,LM,1)*XYZPTS(NP,1))/R%R(K)*RHOLMD(K,LM,2) &
              &   +YLMDD(NP,LM,4)*RHOLM(K,LM,2)/(R%R(K)*R%R(K)) &
              &   +(YLMD(NP,LM,2)*XYZPTS(NP,2)+YLMD(NP,LM,2)*XYZPTS(NP,2))/R%R(K)*RHOLMD(K,LM,2) &
              &   +YLMDD(NP,LM,6)*RHOLM(K,LM,2)/(R%R(K)*R%R(K)) &
              &   +(YLMD(NP,LM,3)*XYZPTS(NP,3)+YLMD(NP,LM,3)*XYZPTS(NP,3))/R%R(K)*RHOLMD(K,LM,2)
            ENDDO

            LAPLUP=LAPLUP- &
           &    XYZPTS(NP,1)*XYZPTS(NP,1)/(R%R(K))*T1(K,1)+XYZPTS(NP,1)*XYZPTS(NP,1)*T2(K,1) &
           &   -XYZPTS(NP,2)*XYZPTS(NP,2)/(R%R(K))*T1(K,1)+XYZPTS(NP,2)*XYZPTS(NP,2)*T2(K,1) &
           &   -XYZPTS(NP,3)*XYZPTS(NP,3)/(R%R(K))*T1(K,1)+XYZPTS(NP,3)*XYZPTS(NP,3)*T2(K,1) &
           &   +3*T1(K,1)/R%R(K)

            LAPLDW=LAPLDW- &
           &    XYZPTS(NP,1)*XYZPTS(NP,1)/(R%R(K))*T1(K,2)+XYZPTS(NP,1)*XYZPTS(NP,1)*T2(K,2) &
           &   -XYZPTS(NP,2)*XYZPTS(NP,2)/(R%R(K))*T1(K,2)+XYZPTS(NP,2)*XYZPTS(NP,2)*T2(K,2) &
           &   -XYZPTS(NP,3)*XYZPTS(NP,3)/(R%R(K))*T1(K,2)+XYZPTS(NP,3)*XYZPTS(NP,3)*T2(K,2) &
           &   +3*T1(K,2)/R%R(K)

            ! norm of gradient for spin up
            XU  =T1(K,1)*XYZPTS(NP,1)+(RHO_ANG(K,1,1)+RHO_ANG(K,2,1))*0.5_q
            YU  =T1(K,1)*XYZPTS(NP,2)+(RHO_ANG(K,1,2)+RHO_ANG(K,2,2))*0.5_q
            ZU  =T1(K,1)*XYZPTS(NP,3)+(RHO_ANG(K,1,3)+RHO_ANG(K,2,3))*0.5_q
            T1(K,1)=SQRT(XU*XU+YU*YU+ZU*ZU)
            ! norm of gradient for spin down
            XD  =T1(K,2)*XYZPTS(NP,1)+(RHO_ANG(K,1,1)-RHO_ANG(K,2,1))*0.5_q
            YD  =T1(K,2)*XYZPTS(NP,2)+(RHO_ANG(K,1,2)-RHO_ANG(K,2,2))*0.5_q
            ZD  =T1(K,2)*XYZPTS(NP,3)+(RHO_ANG(K,1,3)-RHO_ANG(K,2,3))*0.5_q

            T1(K,2)=SQRT(XD*XD+YD*YD+ZD*ZD)
!           TG=T1(K,1)+T1(K,2) incorrect definition
            TG=SQRT((XU+XD)**2+(YU+YD)**2+(ZU+ZD)**2)

!           not needed for MBJ
            IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
               T1(K,1)=MAX(T1(K,1),NABMIN)
               T1(K,2)=MAX(T1(K,2),NABMIN)
               TG=MAX(TG,2*NABMIN)
            ENDIF

            RHOT(K,1)=MAX(RHOT(K,1), CHGMIN)
            RHOT(K,2)=MAX(RHOT(K,2), CHGMIN)

            CALL METAGGASPIN(&
           &   RHOT(K,1)*AUTOA3,RHOT(K,2)*AUTOA3,T1(K,1)*AUTOA4,T1(K,2)*AUTOA4,TG*AUTOA4, &
           &   LAPLUP*AUTOA5,LAPLDW*AUTOA5,TAUU(K)*EVTOH,TAUD(K)*EVTOH, &
           &   EXT,DEXC1,DEXC2,DVXC1,DVXC2,DVC,MUUP,MUDW,DLXC1,DLXC2,CVMBJ)

            IF (LscMBJ()) GRDR=GRDR+(TG*R%R(K)**2*AUTOA*R%SI(K)*SIM_FAKT)/(RHOT(K,1)+RHOT(K,2))

            IF (ID_METAGGA==31) THEN
            ! TR: Spin-up
              ! factor 1/2 because we handle a single spin channel only
              GRHO_OVER_RHO_AUG(NI)=GRHO_OVER_RHO_AUG(NI)+0.5_q*AUGFACT &
                      *T1(K,1)*R%R(K)**2*AUTOA*R%SI(K)*SIM_FAKT/RHOT(K,1)
            ! TR: Spin-down
              ! factor 1/2 because we handle a single spin channel only
              GRHO_OVER_RHO_AUG(NI)=GRHO_OVER_RHO_AUG(NI)+0.5_q*AUGFACT &
                      *T1(K,2)*R%R(K)**2*AUTOA*R%SI(K)*SIM_FAKT/RHOT(K,2)
            ENDIF

            DEXC=DEXC+(EXT*RYTOEV)*(RHOT(K,1)+RHOT(K,2))*R%R(K)*R%R(K)*R%SI(K)*SIM_FAKT

            ! develop
            !             d    f_xc     grad rho
            !             ------------  --------  = vec dFXC(r)
            !             d |grad rho| |grad rho|
            ! into spherical harmonics
            ! afterwards vec dFXC can be reconstructed using
            ! dFXC_i(r) =  \sum_L dFXC_Li(r) Y_L(r)

            IF (LCALCPOT()) THEN
               DEXC1=DEXC1*RYTOEV
               DEXC2=DEXC2*RYTOEV
               DVXC1=DVXC1*RYTOEV*AUTOA
               DVXC2=DVXC2*RYTOEV*AUTOA
               DVC  =DVC  *RYTOEV*AUTOA

               DVXC1=DVXC1/ MAX(T1(K,1),NABMIN)
               DVXC2=DVXC2/ MAX(T1(K,2),NABMIN)
               DVC  =DVC  / MAX(TG,2*NABMIN)

               DO LM=1,LMMAX
                  dFXC(K,LM,0,1) = dFXC(K,LM,0,1)+DEXC1*SIM_FAKT*YLM(NP,LM)
                  dFXC(K,LM,0,2) = dFXC(K,LM,0,2)+DEXC2*SIM_FAKT*YLM(NP,LM)

                  dFXC(K,LM,1,1) = dFXC(K,LM,1,1)+(XU* DVXC1 + (XU+XD) * DVC)*SIM_FAKT*YLM(NP,LM)
                  dFXC(K,LM,2,1) = dFXC(K,LM,2,1)+(YU* DVXC1 + (YU+YD) * DVC)*SIM_FAKT*YLM(NP,LM)
                  dFXC(K,LM,3,1) = dFXC(K,LM,3,1)+(ZU* DVXC1 + (ZU+ZD) * DVC)*SIM_FAKT*YLM(NP,LM)

                  dFXC(K,LM,1,2) = dFXC(K,LM,1,2)+(XD* DVXC2 + (XU+XD) * DVC)*SIM_FAKT*YLM(NP,LM)
                  dFXC(K,LM,2,2) = dFXC(K,LM,2,2)+(YD* DVXC2 + (YU+YD) * DVC)*SIM_FAKT*YLM(NP,LM)
                  dFXC(K,LM,3,2) = dFXC(K,LM,3,2)+(ZD* DVXC2 + (ZU+ZD) * DVC)*SIM_FAKT*YLM(NP,LM)
               ENDDO
            ENDIF

            ! same thing, if laplacian-dependent functional is called,
            ! resolve d e_xc / d (lap n_sigma) into spherical harmonics
            IF (LCALCLAPD()) THEN
               DLXC1=DLXC1*RYTOEV*AUTOA2
               DLXC2=DLXC2*RYTOEV*AUTOA2
               DO LM=1,LMMAX
                  dFXCdLap(K,LM,1) = dFXCdLap(K,LM,1)+DLXC1*SIM_FAKT*YLM(NP,LM)
                  dFXCdLap(K,LM,2) = dFXCdLap(K,LM,2)+DLXC2*SIM_FAKT*YLM(NP,LM)
               ENDDO
            ENDIF

            IF (LCALCMU()) THEN
               MUUP=0.5_q*MUUP*RYTOEV*AUTOA2
               MUDW=0.5_q*MUDW*RYTOEV*AUTOA2
               DO LM=1,LMMAX_TAU
                  dFXCdT(K,LM,1) = dFXCdT(K,LM,1)+MUUP*SIM_FAKT*YLM(NP,LM)
                  dFXCdT(K,LM,2) = dFXCdT(K,LM,2)+MUDW*SIM_FAKT*YLM(NP,LM)
               ENDDO
            ENDIF
         ENDDO
      ENDDO points

DOACC CALL ACC_VTUTOR_CHECK()

!========================================================================
!
! GGA part related to d e_XC / grad n
!
! add -\sum_i Y_L  d (dFXC_L'i(x) Y_L'(x))/ d x_i to the potential V_L(r)
!
!                          x_i d dFXC_L'i(|x|)
! -\sum_L'i Y_L(x) Y_L'(x)  -  --------------- + dFXC_L'i(x) Y_L nabla_i Y_L'(x)
!                          |x|   d |x|
!
!========================================================================
      IF (LCALCPOT()) THEN
         DO ISP=1,ISPIN
            DO LM=1,LMMAX_CALC
               DO K=1,R%NMAX
                  POT(K,LM,ISP)=POT(K,LM,ISP)+dFXC(K,LM,0,ISP)
               ENDDO
            ENDDO
         ENDDO
         ! nabla comment:
         ! the matrix elements < Y_L| nabla | Y_L'> are non zero
         ! for L=L'+-1
         DO ISP=1,ISPIN
            DO I=1,3
               DO LMP=1,LMMAX
                  CALL GRAD(R,dFXC(1:R%NMAX,LMP,I,ISP),T1(1:R%NMAX,1))
                  DO LM=1,LMMAX_CALC
                     IF (ABS(YLM_NABLA_YLM(LM,LMP,I))>1E-4 .OR. ABS(YLM_X_YLM(LM,LMP,I))>1E-4) THEN
                        DO K=1,R%NMAX
                           POT(K,LM,ISP)=POT(K,LM,ISP)-( &
                                dFXC(K,LMP,I,ISP)*YLM_NABLA_YLM(LM,LMP,I)/ R%R(K)+ &
                                T1(K,1)*YLM_X_YLM(LM,LMP,I) &
                              )
                        ENDDO
                  ENDIF
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
         DEALLOCATE(dFXC)
      ENDIF

      ! v_xc_sigma = [d/dn - div d/d(grad n) + lap d/d/(lap n)] e_xc_sigma
      ! this adds the laplacian contribution
      ! lap R(r)Y_lm = R''(r)Y_lm + 2/r*R'(r) Y_lm - l(l+1)/r**2 R(r)Y_lm
      ! T1(:,1) = R'(r)
      ! T2(:,1) = R''(r), just to make the distinction clearer

      IF (LCALCLAPD()) THEN
         LMAX_TMP = LMAX_CALC
         IF (.NOT.LASPH) LMAX_TMP = 0
         DO ISP=1,ISPIN
           DO ell=0,LMAX_TMP
             DO M=1,2*ell+1
               lm = ell*ell + m
               CALL GRAD(R,dFXCdLap(1:R%NMAX,LM,ISP),T1(1:R%NMAX,1))
               CALL GRAD(R,T1(1:R%NMAX,1),T2(1:R%NMAX,1))
               lfac = ell*(ell+1)
               DO K=1,R%NMAX
                 POT(K,LM,ISP)=POT(K,LM,ISP) + T2(K,1) + 2*T1(K,1)/R%R(K) - lfac*dFXCdLap(K,LM,ISP)/R%R(K)**2
               ENDDO
             enddo
           ENDDO
         ENDDO
         DEALLOCATE(dFXcdLap)
      ENDIF

      DCMU=0
      IF (LCALCMU()) THEN
         DO ISP=1,ISPIN
            DO LM=1,LMMAX_TAU
               DO K=1,R%NMAX
                  MU(K,LM,ISP)=dFXCdT(K,LM,ISP)
                  DCMU=DCMU+MU(K,LM,ISP)*TAU(K,LM,ISP)*R%SI(K)/HSQDTM
               ENDDO
            ENDDO
         ENDDO
         DEALLOCATE(dFXcdT)
      ENDIF

      ! finally calculate the double counting corrections again
      DVXC=0
      IF (LCALCPOT()) THEN
         CALL RAD_POT_IN_RHO(R,ISPIN,LMAX_CALC,RHO,POT,DVXC)
         DVXC=DVXC-DVINI
      ENDIF

      IF (LCALCMU()) THEN
         DVXC=DVXC+DCMU
!        WRITE(*,'(A,F24.14)') 'dcmu =',DCMU
      ENDIF

      DEALLOCATE(YLM,YLMD,YLMDD,XYZPTS,RADPTS,YLM_NABLA_YLM,YLM_X_YLM,WEIGHT,ABSCIS,RHOLM,RHOLMD)

      RETURN
      END SUBROUTINE RAD_METAGGA_XC


!********************* SUBROUTINE RAD_PROJ_METAGGA *********************
!
!***********************************************************************
      SUBROUTINE RAD_PROJ_METAGGA(&
     &   P,W,LMAX_TAU,MU,A,DLLMM)
      USE prec
      USE asa
      USE pseudo
      USE radial
      USE constant
      USE paw
      USE string, ONLY: str
      USE tutor, ONLY: vtutor
      IMPLICIT NONE
      TYPE (potcar) P
      INTEGER LMAX_TAU
      REAL(q) A
      REAL(q) W(:,:)
      REAL(q) MU(:,:,:)
      OVERLAP DLLMM(:,:,:)
      ! local variables
      INTEGER ISP,I,K,Ch1,Ch2
      INTEGER LLMAX_TAU,LMMAX_TAU,LM,LMP,LL,LLP,M,MP,MPLOW,INDYLM,INDYLMP

      REAL(q) SUM
      REAL(q) W1(P%R%NMAX),W2(P%R%NMAX),DW1(P%R%NMAX),DW2(P%R%NMAX)
      REAL(q), ALLOCATABLE :: TAU(:,:)

      ! quick return if possible
      IF ((.NOT.LDO_METAGGA()).OR.(.NOT.LCALCMU())) RETURN

      ! non-collinear magnetism
!     IF (SIZE(DLLMM,3)==4) THEN
!        WRITE(*,*) 'RAD_PROJ_METAGGA: internal error; non-collinear case not supported (yet).'
!        STOP
!     ENDIF

      ! check consistency
      LMMAX_TAU=(LMAX_TAU+1)**2
      IF (SIZE(MU,2)<LMMAX_TAU) THEN
         CALL vtutor%error("RAD_PROJ_METAGGA: ERROR, size(MU,2)<LMMAX_TAU " // str(SIZE(MU,2)) // " &
            &" // str(LMMAX_TAU))
      ENDIF

      ! restriction for the angular development of \tau and \mu
      LLMAX_TAU=MIN(LMAXTAU,LMAX_TAU); LMMAX_TAU=(LLMAX_TAU+1)**2

      ALLOCATE(TAU(P%R%NMAX,LMMAX_TAU))

      ! loops over channels (l,epsilon)
      LM=1; DO Ch1=1,P%LMAX

      ! d(w1/r)/dr
      W1(:)=W(:,Ch1)/P%R%R(:); CALL GRAD(P%R,W1,DW1)

      LMP=LM; DO Ch2=Ch1,P%LMAX
      ! d(w2/r)/dr
      W2(:)=W(:,Ch2)/P%R%R(:); CALL GRAD(P%R,W2,DW2)

         LL=P%LPS(Ch1); LLP=P%LPS(Ch2)
         DO M=1,2*LL+1
         MPLOW=1; IF(Ch1==Ch2) MPLOW=M
         DO MP=MPLOW,2*LLP+1
            INDYLM= LL**2 +M
            INDYLMP=LLP**2+MP

            TAU=0

            DO I=1,LMMAX_TAU
               TAU(:,I)=TAU(:,I)+ &
              &   (DW1(:)*X_YLM_X_YLM(INDYLM,INDYLMP,I)*DW2(:)*P%R%R(:)*P%R%R(:) + &
              &    DW1(:)*X_YLM_YLMD(INDYLM,INDYLMP,I)*W2(:)*P%R%R(:) + &
              &    W1(:)*X_YLM_YLMD(INDYLMP,INDYLM,I)*DW2(:)*P%R%R(:) + &
              &    W1(:)*YLMD_YLMD(INDYLM,INDYLMP,I)*W2(:))
            ENDDO

            DO ISP=1,SIZE(DLLMM,3)
               SUM=0
               DO I=1,LMMAX_TAU
                  ! Integrate over r (Simpson integration)
                  DO K=1,P%R%NMAX
                     SUM=SUM+MU(K,I,ISP)*TAU(K,I)*P%R%SI(K)
                  ENDDO
               ENDDO
               DLLMM(LM+M-1,LMP+MP-1,ISP)=DLLMM(LM+M-1,LMP+MP-1,ISP)+A*SUM
               DLLMM(LMP+MP-1,LM+M-1,ISP)=DLLMM(LM+M-1,LMP+MP-1,ISP)
            ENDDO

         ENDDO
         ENDDO
      LMP=LMP+2*LLP+1
      ENDDO
      LM =LM +2*LL +1
      ENDDO

!     CALL DUMP_DLLMM( "NABLA-MU-NABLA",DLLMM(:,:,1),P)

      DEALLOCATE(TAU)

      RETURN
      END SUBROUTINE RAD_PROJ_METAGGA


!********************* SUBROUTINE RAD_AUXILIARY_FUNCTIONS_METAGGA ******
!
!***********************************************************************
      SUBROUTINE RAD_AUXILIARY_FUNCTIONS_METAGGA(LLMAX)
      USE prec
      USE asa
      USE radial
      USE constant
      USE pseudo
      IMPLICIT NONE
      INTEGER LLMAX
      ! local variables
      INTEGER I,J,Ch1,Ch2
      INTEGER IFAIL,PHPTS,THPTS,NPTS,NP
      INTEGER LMMAX,LLMAX_TAU,LMMAX_TAU
      INTEGER LM,LMP,LL,LLP,M,MP,INDYLM,INDYLMP

      REAL(q), ALLOCATABLE :: RADPTS(:,:), XYZPTS(:,:)
      REAL(q), ALLOCATABLE :: YLM(:,:),YLMD(:,:,:)
      REAL(q), ALLOCATABLE :: WEIGHT(:),ABSCIS(:)

      REAL(q) DELTAPHI,SIM_FAKT
      EXTERNAL GAUSSI2

      ! quick return if possible
      IF (.NOT.LDO_METAGGA()) RETURN

      IF (ALLOCATED(X_YLM_X_YLM).AND.ALLOCATED(YLMD_YLMD).AND.ALLOCATED(X_YLM_YLMD)) RETURN

      LMMAX=(LLMAX+1)**2
      LLMAX_TAU=MIN(2*LLMAX+2,LMAXTAU); LMMAX_TAU=(LLMAX_TAU+1)**2

      IF (ALLOCATED(X_YLM_X_YLM)) DEALLOCATE(X_YLM_X_YLM)
      ALLOCATE(X_YLM_X_YLM(LMMAX,LMMAX,LMMAX_TAU)); X_YLM_X_YLM=0

      IF (ALLOCATED(YLMD_YLMD)) DEALLOCATE(YLMD_YLMD)
      ALLOCATE(YLMD_YLMD(LMMAX,LMMAX,LMMAX_TAU)); YLMD_YLMD=0

      IF (ALLOCATED(X_YLM_YLMD)) DEALLOCATE(X_YLM_YLMD)
      ALLOCATE(X_YLM_YLMD(LMMAX,LMMAX,LMMAX_TAU)); X_YLM_YLMD=0


!========================================================================
! number of theta and phi pivot points to perform angular integration
! since Exc=f(a*Yllmax,m) we need more pivot points than theoretically
! needed to integrate Yllmax,m.
! the factor 2 is the minium, 3 is more accurate
!========================================================================
      PHPTS=PHPTS_FACT*(MAX(LLMAX,LLMAX_TAU)+1)
      THPTS=THPTS_FACT*FLOOR(REAL(MAX(LLMAX,LLMAX_TAU)/2+1,KIND=q))
      NPTS=PHPTS*THPTS
      DELTAPHI=REAL(2_q*PI/PHPTS,KIND=q)
! allocate arrays
      ALLOCATE(XYZPTS(NPTS,3),RADPTS(NPTS,2),WEIGHT(THPTS),ABSCIS(THPTS), &
     &     YLM(NPTS,MAX(LMMAX,LMMAX_TAU)),YLMD(NPTS,MAX(LMMAX,LMMAX_TAU),3))

      ! set phi positions, equally spaced
      RADPTS=0; WEIGHT=0; ABSCIS=0
      DO I=1,PHPTS
         DO J=1,THPTS
            RADPTS((J-1)*PHPTS+I,2)=(I-1)*DELTAPHI
         ENDDO
      ENDDO
     ! get theta positions (actually get cos(theta)) (Gauss integration)
      CALL GAUSSI(GAUSSI2,-1._q,1._q,0,THPTS,WEIGHT,ABSCIS,IFAIL)
      DO I=1,THPTS
         RADPTS((I-1)*PHPTS+1:I*PHPTS,1)=ABSCIS(I)
      ENDDO
      ! convert radial to cartesian coordinates
      DO I=1,NPTS
         XYZPTS(I,1)=COS(RADPTS(I,2))*SQRT(1_q-RADPTS(I,1)**2_q) ! x
         XYZPTS(I,2)=SIN(RADPTS(I,2))*SQRT(1_q-RADPTS(I,1)**2_q) ! y
         XYZPTS(I,3)=RADPTS(I,1)                                 ! z
      ENDDO

      ! get |r| Y_lm on a unit sphere and its derivatives
      YLM=0; YLMD=0
      CALL SETYLM_GRAD2(MAX(LLMAX,LLMAX_TAU),NPTS,YLM,YLMD,XYZPTS(:,1),XYZPTS(:,2),XYZPTS(:,3))

      ! loop over all points in the angular grid
      points: DO NP=1,NPTS

         ! weight of this points
         SIM_FAKT=DELTAPHI*WEIGHT((INT((NP-1)/PHPTS)+1))

         ! loops over channels (l,epsilon)
         DO LL =0,LLMAX
         DO LLP=0,LLMAX

            DO M=1,2*LL+1
            DO MP=1,2*LLP+1
               INDYLM= LL**2 +M
               INDYLMP=LLP**2+MP
               DO I=1,LMMAX_TAU
                  X_YLM_X_YLM(INDYLM,INDYLMP,I)=X_YLM_X_YLM(INDYLM,INDYLMP,I)+ SIM_FAKT*YLM(NP,I)* &
                 &   (XYZPTS(NP,1)*XYZPTS(NP,1)+XYZPTS(NP,2)*XYZPTS(NP,2)+XYZPTS(NP,3)*XYZPTS(NP,3))* &
                 &   YLM(NP,INDYLM)*YLM(NP,INDYLMP)
                  X_YLM_YLMD(INDYLM,INDYLMP,I)=X_YLM_YLMD(INDYLM,INDYLMP,I)+ SIM_FAKT*YLM(NP,I)* &
                 &   (XYZPTS(NP,1)*YLMD(NP,INDYLMP,1)+XYZPTS(NP,2)*YLMD(NP,INDYLMP,2)+XYZPTS(NP,3)*YLMD(NP,INDYLMP,3))* &
                 &   YLM(NP,INDYLM)
                  YLMD_YLMD(INDYLM,INDYLMP,I)=YLMD_YLMD(INDYLM,INDYLMP,I)+ SIM_FAKT*YLM(NP,I)* &
                 &   (YLMD(NP,INDYLM,1)*YLMD(NP,INDYLMP,1)+YLMD(NP,INDYLM,2)*YLMD(NP,INDYLMP,2)+YLMD(NP,INDYLM,3)*YLMD(NP,INDYLMP,3))
               ENDDO
            ENDDO
            ENDDO
         ENDDO
         ENDDO

      ENDDO points

      DEALLOCATE(XYZPTS,RADPTS,WEIGHT,ABSCIS,YLM,YLMD)

      RETURN
      END SUBROUTINE RAD_AUXILIARY_FUNCTIONS_METAGGA


!******************** FUNCTION IR_MATCH ********************************
!
!***********************************************************************
      FUNCTION IR_MATCH(PP,CHANNEL)
      USE prec
      USE pseudo
      IMPLICIT NONE
      TYPE(potcar), POINTER :: PP
      INTEGER CHANNEL
      INTEGER IR_MATCH
      ! local variables
      INTEGER K
      IR_MATCH=PP%R%NMAX
      DO K=PP%R%NMAX,1,-1
         IF (PP%WAE(K,CHANNEL)/=PP%WPS(K,CHANNEL)) EXIT
         IR_MATCH=K
      ENDDO
      END FUNCTION IR_MATCH


!******************** FUNCTION IR_PSMAX ********************************
!
!***********************************************************************
      FUNCTION IR_PSMAX(PP)
      USE prec
      USE pseudo
      IMPLICIT NONE
      TYPE(potcar), POINTER :: PP
      INTEGER IR_PSMAX
      ! local variables
      INTEGER K
      IR_PSMAX=PP%R%NMAX
      DO K=PP%R%NMAX,2,-1
         IF ((PP%R%R(K)<PP%PSDMAX).OR.(PP%R%R(K)<PP%PSRMAX)) EXIT
         IR_PSMAX=K
      ENDDO
      END FUNCTION IR_PSMAX


!***********************************************************************
!***********************************************************************
  END MODULE meta
!***********************************************************************
!***********************************************************************


!******************** SUBROUTINE FEXCGS_METAGGA_ ***********************
!
!  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
! Mind CWORK and DWORK point actually to the same storagelocation
! similar to an EQUIVALENCE (CWORK(1),DWORK(1))
! the same for  (CWGRAD,DWGRAD) and   (CHTOT,DHTOT)
! so we can interchange both arrays arbitrarily
!
!***********************************************************************

      SUBROUTINE FEXCGS_METAGGA_(LPOT,LMU,LLD, &
     &   ISPIN,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
     &   CWGRAD,CHTOT,CWORK,CKINEDEN,DWGRAD,DHTOT,DWORK,DKINEDEN, &
     &   DENCOR,TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,DMUWORK &
     &)
#ifdef _OPENACC
      USE mopenacc_struct_def
      USE tutoracc, ONLY : ACC_VTUTOR_CHECK
#endif
      USE prec
      USE lattice
      USE mpimy
      USE mgrid
      USE constant
      USE metalib
      USE setxcmeta
      USE meta

      IMPLICIT COMPLEX(q) (C)

      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR

      LOGICAL LPOT,LMU,LLD

      COMPLEX(q) CWGRAD(GRIDC%MPLWV,ISPIN),CHTOT(GRIDC%MPLWV,ISPIN), &
     &   CKINEDEN(GRIDC%MPLWV,ISPIN),CWORK(GRIDC%MPLWV,ISPIN)
      RGRID DWGRAD(DIMREAL(GRIDC%MPLWV),ISPIN),DHTOT(DIMREAL(GRIDC%MPLWV),ISPIN), &
     &   DKINEDEN(DIMREAL(GRIDC%MPLWV),ISPIN),DWORK(DIMREAL(GRIDC%MPLWV),ISPIN)

      RGRID DENCOR(GRIDC%RL%NP),TAUC(GRIDC%RL%NP)
      REAL(q) XCSIF(3,3)
      REAL(q) DWORKG(GRIDC%RL%NP,ISPIN),DWORK1(GRIDC%RL%NP,ISPIN), &
     &   DWORK2(GRIDC%RL%NP,ISPIN),DWORK3(GRIDC%RL%NP,ISPIN),DVC(GRIDC%RL%NP)

      RGRID  DMUWORK(DIMREAL(GRIDC%MPLWV),ISPIN)

      REAL(q) LAPLUP,LAPLDW,LAPLACIAN(GRIDC%RL%NP,ISPIN)
      REAL(q) MUUP,MUDW,EDCMU
      REAL(q) CVMBJ

      REAL(q), ALLOCATABLE :: DWORKL(:,:),DENSHESS(:,:,:)
      REAL(q) DLAPU,DLAPD

      REAL(q) :: CHGMIN=1E-10_q, NABMIN=1E-10_q, TAUMIN=1E-10_q

#ifdef debug2
      INTEGER, SAVE :: I_DBG=0
      REAL(Q) MU_DBG,TAU_DBG
#endif
!$ACC ROUTINE(LscMBJ,GET_CMBJ_PW) SEQ
!     TAUMIN=0 for MBJ is ok since there is no division by TAU
      IF ((ID_METAGGA == 30) .OR. (ID_METAGGA == 31)) TAUMIN=0._q

! set to one for error-dumps
#ifdef MPI
      NODE_ME=GRIDC%COMM%NODE_ME
      IONODE =GRIDC%COMM%IONODE
      IDUMP=0
#ifdef debug
      IF (NODE_ME==IONODE) IDUMP=1
#endif
#else
      IDUMP=0
#ifdef debug
      IDUMP=1
#endif
#endif

!$ACC ENTER DATA CREATE(LAPLACIAN) __IF_ASYNC__
!$ACC KERNELS PRESENT(LAPLACIAN) __IF_ASYNC__
      LAPLACIAN=0
!$ACC END KERNELS

      IF (LLD) THEN
         ALLOCATE(DWORKL(GRIDC%RL%NP,ISPIN),DENSHESS(GRIDC%RL%NP,6,ISPIN))
!$ACC ENTER DATA CREATE(DWORKL,DENSHESS) __IF_ASYNC__
!$ACC KERNELS PRESENT(DWORKL,DENSHESS) __IF_ASYNC__
         DWORKL=0
         DENSHESS=0
!$ACC END KERNELS
      ENDIF

      RINPL=1._q/GRIDC%NPLWV                    ! Scaling of Energy
      EVTOH=1._q/(2.*HSQDTM)*AUTOA5             ! KinEDens eV to Hartree

!=======================================================================
! First phase: Transform DENCOR (core charge) and
!  CHTOT (pseudo chargedensity) to real space
!=======================================================================
    spin: DO ISP=1,ISPIN
      ! set CWORK to total real charge in reciprocal space
!$ACC PARALLEL LOOP PRESENT(DWORK,DENCOR,DHTOT,LATT_CUR) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
         DWORK(I,ISP)=(DENCOR(I)/ISPIN+DHTOT(I,ISP))*RINPL/LATT_CUR%OMEGA
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!=======================================================================
! now calculate the gradient of the chargedensity
!=======================================================================
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWGRAD(I,ISP)=CWORK(I,ISP)
      ENDDO
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GX*CITPI
       ENDDO
! GRAD_x in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK1(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GY*CITPI
      ENDDO
! grad_y in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK2,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK2(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GZ*CITPI
      ENDDO
! grad_z in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK3,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK3(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! Compute the laplacian of the density

      IF (LLD) THEN

         ! and if laplacian-dependent functional is called, also compute density hessian
         ! indices for density hessian: 1 = xx, 2 = xy, 3 = xz, 4 = yy, 5 = yz, 6 = zz
         IDH = 0
         DO IDIR=1,3
           DO JDIR = IDIR,3
             IDH = IDH + 1
!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWGRAD,CWORK) PRIVATE(N1,N2,N3,NC,GI,GJ) __IF_ASYNC__
             DO I=1,GRIDC%RC%NP
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)

               GI = GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3)
               GJ = GRIDC%LPCTX(N1)*LATT_CUR%B(JDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(JDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(JDIR,3)
               CWORK(I,ISP) = CWGRAD(I,ISP) * GI*GJ*CITPI*CITPI
             ENDDO
             CALL SETUNB(CWORK(1,ISP),GRIDC)
             CALL FFT3D(CWORK(1,ISP),GRIDC,1)
             CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DENSHESS,DWORK) __IF_ASYNC__
             DO I=1,GRIDC%RL%NP
                DENSHESS(I,IDH,ISP) = REAL( DWORK(I,ISP) ,KIND=q)
             ENDDO
           ENDDO
         ENDDO
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DENSHESS) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
           LAPLACIAN(I,ISP) = DENSHESS(I,1,ISP) + DENSHESS(I,4,ISP) + DENSHESS(I,6,ISP)
         ENDDO

      ELSE

         DO IDIR=1,3
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR,CWGRAD) PRIVATE(N1,N2,N3,NC,GG) __IF_ASYNC__
            DO I=1,GRIDC%RC%NP  ! loop over all grid points NP in the reciprocal (RC) grid
               ! index of grid point along three reciprocal lattice vectors (N1, N2, N3)
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)
               ! convert to lattice vector component in direction x, y or z (corresponding to index J)
               GG=(GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3))
               CWORK(I,ISP)=CWGRAD(I,ISP)*GG*GG*CITPI*CITPI
               !write(*,*)'xcgrad:cwgrad ', CWORK4(I), CWGRAD(I), G1, G2, CITPI
            ENDDO
            CALL SETUNB(CWORK(1,ISP),GRIDC)
            CALL FFT3D(CWORK(1,ISP),GRIDC,1)
            CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DWORK) __IF_ASYNC__
            DO I=1,GRIDC%RL%NP
               LAPLACIAN(I,ISP)=LAPLACIAN(I,ISP)+REAL( DWORK(I,ISP) ,KIND=q)
            ENDDO
         ENDDO

      ENDIF

      ENDDO spin

!=======================================================================
!  grad rho    d    f_xc
! ---------- * ------------      (Phys.Rev.B 50,7 (1994) 4954)
! |grad rho|   d |grad rho|
!
!  MIND: the factor OMEGA is difficult to understand:
!   1/N sum_r energy_density * rho *OMEGA = Energy
!   1/N sum_r energy_density * \bar rho   = Energy (\bar rho=rho*LATT_CUR%OMEGA)
!=======================================================================
      EXC=0; EDCMU=0 ; CVMBJ=CMBJ
#ifdef debug2
      OPEN(100+I_DBG)
      TAU_DBG=0; MU_DBG=0
#endif
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORK1,DWORK2,DWORK3,TAUC,DKINEDEN,DMUWORK,DWORK,DWORKG,DVC,LAPLACIAN,DWORKL) &
!$ACC PRIVATE(RHO1,RHO2,ABSNABUP,ABSNABDW,ABSNAB,TAUU,TAUD,LAPLUP,LAPLDW,EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,DLAPU,DLAPD,MUUP,MUDW) &
!$ACC FIRSTPRIVATE(CVMBJ) REDUCTION(+:EXC,EDCMU) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
         IF (ISPIN==2) THEN
         ! Spin-polarized case
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= MAX(REAL((DHTOT(I,2)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            ABSNABUP=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
                          +DWORK3(I,1)*DWORK3(I,1))

            ABSNABDW=SQRT(DWORK1(I,2)*DWORK1(I,2)+DWORK2(I,2)*DWORK2(I,2) &
                          +DWORK3(I,2)*DWORK3(I,2))

            ABSNAB= (DWORK1(I,1)+DWORK1(I,2))*(DWORK1(I,1)+DWORK1(I,2))+ &
                    (DWORK2(I,1)+DWORK2(I,2))*(DWORK2(I,1)+DWORK2(I,2))+ &
                    (DWORK3(I,1)+DWORK3(I,2))*(DWORK3(I,1)+DWORK3(I,2))
            ABSNAB=SQRT(ABSNAB)

!           not needed for MBJ
            IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
               ABSNABUP=MAX(ABSNABUP,NABMIN)
               ABSNABDW=MAX(ABSNABDW,NABMIN)
               ABSNAB=MAX(ABSNAB,2*NABMIN)
            ENDIF
!#define  correlation_ABS_DRHOUP_ABS_DRHOD
#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
            ABSNAB=ABSNABUP+ABSNABDW
#endif
            ! kinetic energy density
            TAUU=MAX(REAL(DKINEDEN(I,1)+TAUC(I)*0.5_q,KIND=q), TAUMIN)
            TAUD=MAX(REAL(DKINEDEN(I,2)+TAUC(I)*0.5_q,KIND=q), TAUMIN)

            ! Laplacian of the density
            LAPLUP=REAL(LAPLACIAN(I,1),KIND=q)
            LAPLDW=REAL(LAPLACIAN(I,2),KIND=q)
         ELSE
         ! nonspin-polarized case
         ! up and down-spin variables get half of the total values
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I))*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= RHO1

            ABSNAB=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
                 +DWORK3(I,1)*DWORK3(I,1))

            ABSNABUP= 0.5_q*ABSNAB
            ABSNABDW= 0.5_q*ABSNAB

!           not needed for MBJ
            IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
               ABSNABUP=MAX(ABSNABUP,NABMIN)
               ABSNABDW=MAX(ABSNABDW,NABMIN)
               ABSNAB=MAX(ABSNAB,2*NABMIN)
            ENDIF

            ! kinetic energy density
            TAUU= MAX(0.5_q*REAL(DKINEDEN(I,1)+TAUC(I),KIND=q), TAUMIN)
            TAUD= TAUU

            ! Laplacian of the density
            LAPLUP=0.5_q*REAL(LAPLACIAN(I,1),KIND=q)
            LAPLDW=LAPLUP
         ENDIF

         ! The CMBJ parameter may depend on the spatial position,
         ! if so, it is set here to the right entry in CMBJ_AUX
         CALL GET_CMBJ_PW(I,CVMBJ)

         CALL METAGGASPIN(&
        &   RHO1*AUTOA3,RHO2*AUTOA3,ABSNABUP*AUTOA4,ABSNABDW*AUTOA4,ABSNAB*AUTOA4, &
        &   LAPLUP*AUTOA5,LAPLDW*AUTOA5,TAUU*EVTOH,TAUD*EVTOH, &
        &   EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,MUUP,MUDW,DLAPU,DLAPD,CVMBJ)

         RHO=RHO1+RHO2

         IF (LscMBJ()) CALL SUM_GRHO_OVER_RHO_PW(RHO*AUTOA3,ABSNAB*AUTOA4)
#ifdef debug2
         IF (ABS(MUUP)>1._q) THEN
            WRITE(100+I_DBG,'(A,I9,7F18.11)') 'in ',I,RHO1,RHO2,ABSNABUP,ABSNABDW,ABSNAB,TAUU,TAUD
            WRITE(100+I_DBG,'(A,I9,8F18.11)') 'out',I,EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,MUUP,MUDW
         ENDIF
#endif

         EXC=EXC+EXCL*RHO*RYTOEV*LATT_CUR%OMEGA
         DVXC1=DVXC1*RYTOEV*AUTOA
         DVXC2=DVXC2*RYTOEV*AUTOA
         DVC_ =DVC_ *RYTOEV*AUTOA
         IF (LLD) THEN
           DLAPU=DLAPU*RYTOEV*AUTOA2
           DLAPD=DLAPD*RYTOEV*AUTOA2
         ENDIF

         ! Double counting contribution stemming from dExc/d\mu
         EDCMU=EDCMU+0.5_q*(MUUP*TAUU+MUDW*TAUD-(MUUP+MUDW)*TAUC(I)*0.5_q)*LATT_CUR%OMEGA
#ifdef debug2
         TAU_DBG=TAU_+(TAUU+TAUD)*LATT_CUR%OMEGA
         MU_DBG=MU_DBG+MUUP
#endif
         MUUP=0.5_q*MUUP*RYTOEV*AUTOA2 ! HSQDTM = (plancks CONSTANT/(2*PI))**2/(2*ELECTRON MASS)
         MUDW=0.5_q*MUDW*RYTOEV*AUTOA2

#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
         DVXC1=DVXC1+DVC_
         DVXC2=DVXC2+DVC_
         DVC_=0
#endif

         ! Store d f_xc / d \tau_up,down in DMUWORK if required
         IF (LMU) THEN
            DMUWORK(I,1)=MUUP
            IF (ISPIN==2) DMUWORK(I,2)=MUDW
         ENDIF

         ! Store d f_x/ d (|\nabla \rho_up,down| ) / |\nabla \rho_up,down| in DWORK
         ! and  d f_xc/ d \rho_up,down  in DWORKG
         DWORK(I,1)  = DVXC1 / MAX(ABSNABUP, NABMIN)
         DWORKG(I,1) = DEXC1*RYTOEV
         IF (ISPIN==2) THEN
            DWORK(I,2)  = DVXC2 / MAX(ABSNABDW, NABMIN)
            DWORKG(I,2) = DEXC2*RYTOEV
         ENDIF
         ! storing laplacian
         IF (LLD) THEN
            DWORKL(I,1) = DLAPU
            IF (ISPIN==2) DWORKL(I,2) = DLAPD
         ENDIF
         ! Store d f_c/ d(|\nabla \rho|) / |\nabla \rho| in DVC
         DVC(I)=DVC_/MAX(ABSNAB, NABMIN)
      ENDDO
!$ACC EXIT DATA DELETE(LAPLACIAN) __IF_ASYNC__
DOACC CALL ACC_VTUTOR_CHECK()

#ifdef debug2
      CLOSE(100+I_DBG)
      I_DBG=I_DBG+1
#endif

#ifdef debug
      REWIND(77)
      REWIND(78)
      REWIND(79)
      I=1
      DO NY=1,GRIDC%NGY
         DO NX=1,GRIDC%NGX
            ABSNAB= (DWORK1(I,1)+DWORK1(I,2))*(DWORK1(I,1)+DWORK1(I,2))+ &
                 (DWORK2(I,1)+DWORK2(I,2))*(DWORK2(I,1)+DWORK2(I,2))+ &
                 (DWORK3(I,1)+DWORK3(I,2))*(DWORK3(I,1)+DWORK3(I,2))
            ABSNABUP=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
                   +DWORK3(I,1)*DWORK3(I,1))
            ABSNABDW=SQRT(DWORK1(I,2)*DWORK1(I,2)+DWORK2(I,2)*DWORK2(I,2) &
                   +DWORK3(I,2)*DWORK3(I,2))
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= MAX(REAL((DHTOT(I,2)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            WRITE(77,'(2I4,3F14.3)') NX,NY,DWORK(I,1)*ABSNABUP,RHO1
            WRITE(78,'(3F14.3)') DWORK(I,2)*ABSNABDW
            WRITE(79,'(3F14.3)') DVC(I)*ABSNAB

            I=I+1
         ENDDO
      ENDDO
#endif
#ifdef debug2
      OPEN(I_DBG+500-1)
      I=1
      DO N3=0,GRIDC%NGZ-1
         X3=MOD(N3*1._q/GRIDC%NGZ+10.5,1._q)-0.5
      DO N2=0,GRIDC%NGY-1
         X2=MOD(N2*1._q/GRIDC%NGY+10.5,1._q)-0.5
      DO N1=0,GRIDC%NGX-1
         X1=MOD(N1*1._q/GRIDC%NGX+10.5,1._q)-0.5
         X=X1*LATT_CUR%A(1,1)+X2*LATT_CUR%A(1,2)+X3*LATT_CUR%A(1,3)
         Y=X1*LATT_CUR%A(2,1)+X2*LATT_CUR%A(2,2)+X3*LATT_CUR%A(2,3)
         Z=X1*LATT_CUR%A(3,1)+X2*LATT_CUR%A(3,2)+X3*LATT_CUR%A(3,3)
         IF (ABS(REAL(DMUWORK(I,1),q)*2._q/RYTOEV/AUTOA2) > 1._q) THEN
            WRITE(I_DBG+500-1,'(3F14.7,F18.11)') X,Y,Z,REAL(DMUWORK(I,1),q)*2._q/RYTOEV/AUTOA2
         ENDIF
         I=I+1
      ENDDO
      ENDDO
      ENDDO
      CLOSE(I_DBG+500-1)
#endif

!**********************************************************************
! TR: update the values for local SC CMBJ
!**********************************************************************

      CALL UPDATE_CMBJ_AUX(GRIDC,LATT_CUR,DHTOT,DENCOR,DWORK1,DWORK2,DWORK3, ISPIN)

!=======================================================================
! gradient terms in stress tensor
!          d    f_xc     grad rho  x grad rho
! sum_r   ------------   --------------------- * LATT_CUR%OMEGA
!         d |grad rho|        |grad rho|
!=======================================================================
      SIF11=0
      SIF22=0
      SIF33=0
      SIF12=0
      SIF23=0
      SIF31=0
      IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
      IF (ISPIN==2) THEN
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC REDUCTION(+:SIF11,SIF22,SIF33,SIF12,SIF23,SIF31) __IF_ASYNC__
         DO ISP=1,ISPIN
         DO I=1,GRIDC%RL%NP
            SIF11=SIF11+DWORK1(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)
            SIF22=SIF22+DWORK2(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
            SIF33=SIF33+DWORK3(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
            SIF12=SIF12+DWORK1(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
            SIF23=SIF23+DWORK2(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
            SIF31=SIF31+DWORK3(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)

            SIF11=SIF11+DWORK1(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
            SIF22=SIF22+DWORK2(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
            SIF33=SIF33+DWORK3(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
            SIF12=SIF12+DWORK1(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
            SIF23=SIF23+DWORK2(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
            SIF31=SIF31+DWORK3(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
         ENDDO
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC REDUCTION(+:SIF11,SIF22,SIF33,SIF12,SIF23,SIF31) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            SIF11=SIF11+DWORK1(I,1)*DWORK1(I,1)*DWORK(I,1)*0.5_q
            SIF22=SIF22+DWORK2(I,1)*DWORK2(I,1)*DWORK(I,1)*0.5_q
            SIF33=SIF33+DWORK3(I,1)*DWORK3(I,1)*DWORK(I,1)*0.5_q
            SIF12=SIF12+DWORK1(I,1)*DWORK2(I,1)*DWORK(I,1)*0.5_q
            SIF23=SIF23+DWORK2(I,1)*DWORK3(I,1)*DWORK(I,1)*0.5_q
            SIF31=SIF31+DWORK3(I,1)*DWORK1(I,1)*DWORK(I,1)*0.5_q

            SIF11=SIF11+DWORK1(I,1)*(DWORK1(I,1))*DVC(I)
            SIF22=SIF22+DWORK2(I,1)*(DWORK2(I,1))*DVC(I)
            SIF33=SIF33+DWORK3(I,1)*(DWORK3(I,1))*DVC(I)
            SIF12=SIF12+DWORK1(I,1)*(DWORK2(I,1))*DVC(I)
            SIF23=SIF23+DWORK2(I,1)*(DWORK3(I,1))*DVC(I)
            SIF31=SIF31+DWORK3(I,1)*(DWORK1(I,1))*DVC(I)
         ENDDO
      ENDIF
      SIF11=SIF11*RINPL*LATT_CUR%OMEGA
      SIF22=SIF22*RINPL*LATT_CUR%OMEGA
      SIF33=SIF33*RINPL*LATT_CUR%OMEGA
      SIF12=SIF12*RINPL*LATT_CUR%OMEGA
      SIF23=SIF23*RINPL*LATT_CUR%OMEGA
      SIF31=SIF31*RINPL*LATT_CUR%OMEGA
      ENDIF   ! ID_METAGGA /= 30 and 31

!=======================================================================
! calculate
!              d    f_xc     grad rho
!        div  (------------  --------  )
!              d |grad rho| |grad rho|
!
! in reciprocal space
!=======================================================================

      IF (ISPIN==2) THEN
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC& PRIVATE(ANAB1U,ANAB2U,ANAB3U,ANAB1D,ANAB2D,ANAB3D) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            ANAB1U= DWORK1(I,1)
            ANAB2U= DWORK2(I,1)
            ANAB3U= DWORK3(I,1)
            ANAB1D= DWORK1(I,2)
            ANAB2D= DWORK2(I,2)
            ANAB3D= DWORK3(I,2)

            DWORK1(I,1) = ANAB1U* DWORK(I,1) + (ANAB1U+ANAB1D) * DVC(I)
            DWORK2(I,1) = ANAB2U* DWORK(I,1) + (ANAB2U+ANAB2D) * DVC(I)
            DWORK3(I,1) = ANAB3U* DWORK(I,1) + (ANAB3U+ANAB3D) * DVC(I)

            DWORK1(I,2) = ANAB1D* DWORK(I,2) + (ANAB1U+ANAB1D) * DVC(I)
            DWORK2(I,2) = ANAB2D* DWORK(I,2) + (ANAB2U+ANAB2D) * DVC(I)
            DWORK3(I,2) = ANAB3D* DWORK(I,2) + (ANAB3U+ANAB3D) * DVC(I)
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC& PRIVATE(ANAB1U,ANAB2U,ANAB3U,ANAB1D,ANAB2D,ANAB3D) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            ANAB1U= DWORK1(I,1)*0.5_q
            ANAB2U= DWORK2(I,1)*0.5_q
            ANAB3U= DWORK3(I,1)*0.5_q
            ANAB1D= ANAB1U
            ANAB2D= ANAB2U
            ANAB3D= ANAB3U

            DWORK1(I,1) = ANAB1U* DWORK(I,1) + (ANAB1U+ANAB1D) * DVC(I)
            DWORK2(I,1) = ANAB2U* DWORK(I,1) + (ANAB2U+ANAB2D) * DVC(I)
            DWORK3(I,1) = ANAB3U* DWORK(I,1) + (ANAB3U+ANAB3D) * DVC(I)
         ENDDO
      ENDIF

      spin2: DO ISP=1,ISPIN
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK1) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK1(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWGRAD(I,ISP)=CWORK(I,ISP)*GX*CITPI
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK2) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK2(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GY*CITPI
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK3) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK3(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GZ*CITPI
      ENDDO

      CALL SETUNB(CWGRAD(1,ISP),GRIDC)
      CALL FFT3D(CWGRAD(1,ISP),GRIDC,1)
      CALL OPSYNC(CWGRAD(1,ISP),DWGRAD(1,ISP),GRIDC%NPLWV)

      ENDDO spin2


!=======================================================================
! laplacian terms in stress tensor
!                     d  f_xc         d^2 n_sigma
! sum_(r,sigma)    ------------      ------------- * LATT_CUR%OMEGA
!                  d lap rho_sigma     d r_i d r_j
!=======================================================================

! if ispin == 1, then denshess(:,:,1) is the Hessian of the total density
! dworkl is still d f_xc / d lap rho_sigma, so the sum will still yield
! twice the sum over a single spin channel. No additional factor needed

! if ispin == 2, then denshess(:,:,sigma) is the Hessian for each spin channel sigma,
! no correcting factor needed

! this has to appear here rather than with the gradient contribution to
! the stress tensor because DWORK is required for the gradient contributions
! to the XC potential

      IF (LLD) THEN
        SIFLAP11=0
        SIFLAP22=0
        SIFLAP33=0
        SIFLAP12=0
        SIFLAP23=0
        SIFLAP31=0
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORKL,DENSHESS) &
!$ACC REDUCTION(+:SIFLAP11,SIFLAP22,SIFLAP33,SIFLAP12,SIFLAP23,SIFLAP31) __IF_ASYNC__
        SLST: DO ISP=1,ISPIN
          DO I=1,GRIDC%RL%NP
            SIFLAP11=SIFLAP11 + 2._q*DWORKL(I,ISP)*DENSHESS(I,1,ISP)
            SIFLAP22=SIFLAP22 + 2._q*DWORKL(I,ISP)*DENSHESS(I,4,ISP)
            SIFLAP33=SIFLAP33 + 2._q*DWORKL(I,ISP)*DENSHESS(I,6,ISP)
            SIFLAP12=SIFLAP12 + 2._q*DWORKL(I,ISP)*DENSHESS(I,2,ISP)
            SIFLAP23=SIFLAP23 + 2._q*DWORKL(I,ISP)*DENSHESS(I,5,ISP)
            SIFLAP31=SIFLAP31 + 2._q*DWORKL(I,ISP)*DENSHESS(I,3,ISP)
          ENDDO
        ENDDO SLST
        SIF11=SIF11 + SIFLAP11*RINPL*LATT_CUR%OMEGA
        SIF22=SIF22 + SIFLAP22*RINPL*LATT_CUR%OMEGA
        SIF33=SIF33 + SIFLAP33*RINPL*LATT_CUR%OMEGA
        SIF12=SIF12 + SIFLAP12*RINPL*LATT_CUR%OMEGA
        SIF23=SIF23 + SIFLAP23*RINPL*LATT_CUR%OMEGA
        SIF31=SIF31 + SIFLAP31*RINPL*LATT_CUR%OMEGA

!=======================================================================
! calculate
!               d    f_xc
!        lap ( ------------ )
!               d lap rho
!
! in reciprocal space
!=======================================================================

        SPINLAP: DO ISP=1,ISPIN
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORK(I,ISP) = DWORKL(I,ISP)
          ENDDO

          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
          CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
          CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWORK) PRIVATE(N1,N2,N3,NC,GX,GY,GZ,GG) __IF_ASYNC__
          DO I=1,GRIDC%RC%NP
             N1= MOD((I-1),GRIDC%RC%NROW) +1
             NC= (I-1)/GRIDC%RC%NROW+1
             N2= GRIDC%RC%I2(NC)
             N3= GRIDC%RC%I3(NC)

             GX = GRIDC%LPCTX(N1)*LATT_CUR%B(1,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(1,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
             GY = GRIDC%LPCTX(N1)*LATT_CUR%B(2,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(2,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
             GZ = GRIDC%LPCTX(N1)*LATT_CUR%B(3,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(3,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)
             GG = GX**2 + GY**2 + GZ**2

             CWORK(I,ISP) = GG*CITPI*CITPI*CWORK(I,ISP)
          ENDDO

          CALL SETUNB(CWORK(1,ISP),GRIDC)
          CALL FFT3D(CWORK(1,ISP),GRIDC,1)
          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORKL(I,ISP) = REAL(DWORK(I,ISP),KIND=q)
          ENDDO

        ENDDO SPINLAP
      ENDIF

!=======================================================================
! Now prepare the rest:
! (store rho in DWORK3 and quantity of above in DWORK1)
!=======================================================================
      XCENC=0._q
      CVZERO=0._q
      XCENCC=0._q

      IF (ISPIN==2) THEN
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORKG,DWGRAD,DWORK,DWORKL) &
!$ACC& REDUCTION(+:CVZERO,XCENCC,XCENC) PRIVATE(RHO1,RHO2,VXC1,VXC2,VXC) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
         ! Spin-polarized case
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)/ISPIN)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= MAX(REAL((DHTOT(I,2)+DENCOR(I)/ISPIN)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
            VXC2=DWORKG(I,2)- REAL( DWGRAD(I,2) ,KIND=q) *RINPL
            IF (LLD) THEN
               VXC1=VXC1 + DWORKL(I,1)*RINPL
               VXC2=VXC2 + DWORKL(I,2)*RINPL
            ENDIF
            DWORK(I,1)=VXC1
            DWORK(I,2)=VXC2
            VXC = 0.5_q*(VXC1+VXC2)
            CVZERO=CVZERO+VXC
            XCENCC=XCENCC-VXC1*RHO1*LATT_CUR%OMEGA-VXC2*RHO2*LATT_CUR%OMEGA
            XCENC=XCENC  -VXC1* REAL( DHTOT(I,1) ,KIND=q) -VXC2* REAL( DHTOT(I,2) ,KIND=q)
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORKG,DWGRAD,DWORK,DWORKL) &
!$ACC& REDUCTION(+:CVZERO,XCENCC,XCENC) PRIVATE(RHO,VXC1) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
         ! nonspin-polarized case
            RHO= MAX(REAL((DHTOT(I,1)+DENCOR(I))/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
            IF (LLD) THEN
               VXC1=VXC1 + DWORKL(I,1)*RINPL
            ENDIF
            DWORK(I,1)=VXC1
            CVZERO=CVZERO+VXC1
            XCENCC=XCENCC-VXC1*RHO*LATT_CUR%OMEGA
            XCENC=XCENC  -VXC1* REAL( DHTOT(I,1) ,KIND=q)
         ENDDO
      ENDIF
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)
!$ACC EXIT DATA DELETE(LAPLACIAN,DWORKL,DENSHESS) __IF_ASYNC__

      CVZERO=CVZERO*RINPL
      XCENC =(XCENC+EXC-EDCMU)*RINPL
      XCENCC=(XCENCC+EXC)*RINPL
      EXC   =EXC*RINPL
      EDCMU =EDCMU*RINPL

      SIF11=SIF11-XCENCC
      SIF22=SIF22-XCENCC
      SIF33=SIF33-XCENCC
      XCSIF(1,1)=SIF11
      XCSIF(2,2)=SIF22
      XCSIF(3,3)=SIF33
      XCSIF(1,2)=SIF12
      XCSIF(2,1)=SIF12
      XCSIF(2,3)=SIF23
      XCSIF(3,2)=SIF23
      XCSIF(3,1)=SIF31
      XCSIF(1,3)=SIF31

      CALLMPI( M_sum_3(GRIDC%COMM, EXC, XCENC, EDCMU))
      CALLMPI( M_sum_d(GRIDC%COMM, XCSIF, 9))
      CALLMPI( M_sum_z(GRIDC%COMM,CVZERO,1))

! Test dumps:
      IF (IDUMP/=0) THEN
         WRITE(*,'(A,F24.14)') '<rho*excgc> =',EXC
         WRITE(*,'(A,F24.14)') '<rho*vxcgc> =',EXC-XCENC
         WRITE(*,'(A,F24.14)') '    xcencgc =',XCENC
         WRITE(*,'(A,F24.14)') '    xcencc  =',XCENCC
         WRITE(*,'(A,F24.14)') '     edcmu  =',EDCMU
#ifdef debug2
         WRITE(*,'(A,F24.14)') '     tau    =',TAU_DBG*RINPL
         WRITE(*,'(A,F24.14)') '     mu     =',MU_DBG*RINPL
#endif
      ENDIF

      RETURN
      END SUBROUTINE FEXCGS_METAGGA_


!******************** SUBROUTINE FEXCGS_METAGGA_VDW_ *******************
!
!  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
! Mind CWORK and DWORK point actually to the same storagelocation
! similar to an EQUIVALENCE (CWORK(1),DWORK(1))
! the same for  (CWGRAD,DWGRAD) and   (CHTOT,DHTOT)
! so we can interchange both arrays arbitrarily
!
!***********************************************************************

      SUBROUTINE FEXCGS_METAGGA_VDW_(LPOT,LMU,LLD, &
     &   ISPIN,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
     &   CWGRAD,CHTOT,CWORK,CKINEDEN,DWGRAD,DHTOT,DWORK,DKINEDEN, &
     &   DENCOR,TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,DMUWORK, &
     &   DWORK4,DWORK5,DWORK6,DWORK7)
#ifdef _OPENACC
      USE mopenacc_struct_def
      USE tutoracc, ONLY : ACC_VTUTOR_CHECK
#endif
      USE prec
      USE lattice
      USE mpimy
      USE mgrid
      USE constant
      USE metalib
      USE setexm_struct_def, ONLY : IVDW_NL
      USE setxcmeta
      USE meta
      USE VDW_LL
      USE VDW_rVV10

      IMPLICIT COMPLEX(q) (C)

      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR

      LOGICAL LPOT,LMU,LLD

      COMPLEX(q) CWGRAD(GRIDC%MPLWV,ISPIN),CHTOT(GRIDC%MPLWV,ISPIN), &
     &   CKINEDEN(GRIDC%MPLWV,ISPIN),CWORK(GRIDC%MPLWV,ISPIN)
      RGRID DWGRAD(DIMREAL(GRIDC%MPLWV),ISPIN),DHTOT(DIMREAL(GRIDC%MPLWV),ISPIN), &
     &   DKINEDEN(DIMREAL(GRIDC%MPLWV),ISPIN),DWORK(DIMREAL(GRIDC%MPLWV),ISPIN)

      RGRID DENCOR(GRIDC%RL%NP),TAUC(GRIDC%RL%NP)
      REAL(q) XCSIF(3,3),STRESS(3,3)
      REAL(q) DWORKG(GRIDC%RL%NP,ISPIN),DWORK1(GRIDC%RL%NP,ISPIN), &
     &   DWORK2(GRIDC%RL%NP,ISPIN),DWORK3(GRIDC%RL%NP,ISPIN),DVC(GRIDC%RL%NP)

      RGRID  DMUWORK(DIMREAL(GRIDC%MPLWV),ISPIN)

      REAL(q) DWORK4(GRIDC%RL%NP),DWORK6(GRIDC%RL%NP),DWORK7(GRIDC%RL%NP)
      RGRID   DWORK5(GRIDC%RL%NP)

      REAL(q) LAPLUP,LAPLDW,LAPLACIAN(GRIDC%RL%NP,ISPIN)
      REAL(q) MUUP,MUDW,EDCMU
      REAL(q) CVMBJ

      REAL(q), ALLOCATABLE :: DWORKL(:,:),DENSHESS(:,:,:)
      REAL(q) DLAPU,DLAPD

      REAL(q) :: CHGMIN=1E-10_q, NABMIN=1E-10_q, TAUMIN=1E-10_q

#ifdef debug2
      INTEGER, SAVE :: I_DBG=0
      REAL(Q) MU_DBG,TAU_DBG
#endif
!$ACC ROUTINE(LscMBJ,GET_CMBJ_PW) SEQ
!     TAUMIN=0 for MBJ is ok since there is no division by TAU
      IF ((ID_METAGGA == 30) .OR. (ID_METAGGA == 31)) TAUMIN=0._q

! set to one for error-dumps
#ifdef MPI
      NODE_ME=GRIDC%COMM%NODE_ME
      IONODE =GRIDC%COMM%IONODE
      IDUMP=0
#ifdef debug
      IF (NODE_ME==IONODE) IDUMP=1
#endif
#else
      IDUMP=0
#ifdef debug
      IDUMP=1
#endif
#endif

!$ACC ENTER DATA CREATE(LAPLACIAN) __IF_ASYNC__
!$ACC KERNELS PRESENT(LAPLACIAN) __IF_ASYNC__
      LAPLACIAN=0
!$ACC END KERNELS

      IF (LLD) THEN
         ALLOCATE(DWORKL(GRIDC%RL%NP,ISPIN),DENSHESS(GRIDC%RL%NP,6,ISPIN))
!$ACC ENTER DATA CREATE(DWORKL,DENSHESS) __IF_ASYNC__
!$ACC KERNELS PRESENT(DWORKL,DENSHESS) __IF_ASYNC__
         DWORKL=0
         DENSHESS=0
!$ACC END KERNELS
      ENDIF

      RINPL=1._q/GRIDC%NPLWV                    ! Scaling of Energy
      EVTOH=1._q/(2.*HSQDTM)*AUTOA5             ! KinEDens eV to Hartree

!=======================================================================
! First phase: Transform DENCOR (core charge) and
!  CHTOT (pseudo chargedensity) to real space
!=======================================================================
    spin: DO ISP=1,ISPIN
      ! set CWORK to total real charge in reciprocal space
!$ACC PARALLEL LOOP PRESENT(DWORK,DENCOR,DHTOT,LATT_CUR) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
         DWORK(I,ISP)=(DENCOR(I)/ISPIN+DHTOT(I,ISP))*RINPL/LATT_CUR%OMEGA
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!=======================================================================
! now calculate the gradient of the chargedensity
!=======================================================================
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWGRAD(I,ISP)=CWORK(I,ISP)
      ENDDO
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GX*CITPI
       ENDDO
! GRAD_x in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK1(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GY*CITPI
      ENDDO
! grad_y in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK2,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK2(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GZ*CITPI
      ENDDO
! grad_z in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK3,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK3(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! Compute the laplacian of the density

      IF (LLD) THEN

         ! and if laplacian-dependent functional is called, also compute density hessian
         ! indices for density hessian: 1 = xx, 2 = xy, 3 = xz, 4 = yy, 5 = yz, 6 = zz
         IDH = 0
         DO IDIR=1,3
           DO JDIR = IDIR,3
             IDH = IDH + 1
!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWGRAD,CWORK) PRIVATE(N1,N2,N3,NC,GI,GJ) __IF_ASYNC__
             DO I=1,GRIDC%RC%NP
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)

               GI = GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3)
               GJ = GRIDC%LPCTX(N1)*LATT_CUR%B(JDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(JDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(JDIR,3)
               CWORK(I,ISP) = CWGRAD(I,ISP) * GI*GJ*CITPI*CITPI
             ENDDO
             CALL SETUNB(CWORK(1,ISP),GRIDC)
             CALL FFT3D(CWORK(1,ISP),GRIDC,1)
             CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DENSHESS,DWORK) __IF_ASYNC__
             DO I=1,GRIDC%RL%NP
                DENSHESS(I,IDH,ISP) = REAL( DWORK(I,ISP) ,KIND=q)
             ENDDO
           ENDDO
         ENDDO
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DENSHESS) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
           LAPLACIAN(I,ISP) = DENSHESS(I,1,ISP) + DENSHESS(I,4,ISP) + DENSHESS(I,6,ISP)
         ENDDO

      ELSE

         DO IDIR=1,3
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR,CWGRAD) PRIVATE(N1,N2,N3,NC,GG) __IF_ASYNC__
            DO I=1,GRIDC%RC%NP  ! loop over all grid points NP in the reciprocal (RC) grid
               ! index of grid point along three reciprocal lattice vectors (N1, N2, N3)
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)
               ! convert to lattice vector component in direction x, y or z (corresponding to index J)
               GG=(GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3))
               CWORK(I,ISP)=CWGRAD(I,ISP)*GG*GG*CITPI*CITPI
               !write(*,*)'xcgrad:cwgrad ', CWORK4(I), CWGRAD(I), G1, G2, CITPI
            ENDDO
            CALL SETUNB(CWORK(1,ISP),GRIDC)
            CALL FFT3D(CWORK(1,ISP),GRIDC,1)
            CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DWORK) __IF_ASYNC__
            DO I=1,GRIDC%RL%NP
               LAPLACIAN(I,ISP)=LAPLACIAN(I,ISP)+REAL( DWORK(I,ISP) ,KIND=q)
            ENDDO
         ENDDO

      ENDIF

      ENDDO spin


!=======================================================================
!  grad rho    d    f_xc
! ---------- * ------------      (Phys.Rev.B 50,7 (1994) 4954)
! |grad rho|   d |grad rho|
!
!  MIND: the factor OMEGA is difficult to understand:
!   1/N sum_r energy_density * rho *OMEGA = Energy
!   1/N sum_r energy_density * \bar rho   = Energy (\bar rho=rho*LATT_CUR%OMEGA)
!=======================================================================
      EXC=0; EDCMU=0; CVMBJ=CMBJ
#ifdef debug2
      OPEN(100+I_DBG)
      TAU_DBG=0; MU_DBG=0
#endif
!$ACC PARALLEL LOOP PRESENT(GRIDC,DHTOT,DENCOR,LATT_CUR,DWORK1,DWORK2,DWORK3,DWORK4,DWORK7,TAUC,DKINEDEN,DMUWORK,DWORK,DWORKG,DVC,LAPLACIAN,DWORKL) &
!$ACC PRIVATE(RHO1,RHO2,ABSNABUP,ABSNABDW,ABSNAB,TAUU,TAUD,LAPLUP,LAPLDW,EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,DLAPU,DLAPD,MUUP,MUDW) &
!$ACC FIRSTPRIVATE(CVMBJ) REDUCTION(+:EXC,EDCMU) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
         IF (ISPIN==2) THEN
         ! Spin-polarized case
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= MAX(REAL((DHTOT(I,2)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            ABSNABUP=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
                          +DWORK3(I,1)*DWORK3(I,1))

            ABSNABDW=SQRT(DWORK1(I,2)*DWORK1(I,2)+DWORK2(I,2)*DWORK2(I,2) &
                          +DWORK3(I,2)*DWORK3(I,2))

            ABSNAB= (DWORK1(I,1)+DWORK1(I,2))*(DWORK1(I,1)+DWORK1(I,2))+ &
                    (DWORK2(I,1)+DWORK2(I,2))*(DWORK2(I,1)+DWORK2(I,2))+ &
                    (DWORK3(I,1)+DWORK3(I,2))*(DWORK3(I,1)+DWORK3(I,2))
            ABSNAB=SQRT(ABSNAB)

!           not needed for MBJ
            IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
               ABSNABUP=MAX(ABSNABUP,NABMIN)
               ABSNABDW=MAX(ABSNABDW,NABMIN)
               ABSNAB=MAX(ABSNAB,2*NABMIN)
            ENDIF
!#define  correlation_ABS_DRHOUP_ABS_DRHOD
#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
            ABSNAB=ABSNABUP+ABSNABDW
#endif
            ! kinetic energy density
            TAUU=MAX(REAL(DKINEDEN(I,1)+TAUC(I)*0.5_q,KIND=q), TAUMIN)
            TAUD=MAX(REAL(DKINEDEN(I,2)+TAUC(I)*0.5_q,KIND=q), TAUMIN)

            ! Laplacian of the density
            LAPLUP=REAL(LAPLACIAN(I,1),KIND=q)
            LAPLDW=REAL(LAPLACIAN(I,2),KIND=q)

            DWORK4(I)=MAX(REAL((DENCOR(I)+DHTOT(I,1)+DHTOT(I,2))/LATT_CUR%OMEGA, kind=q),CHGMIN)
            DWORK7(I)=ABSNAB
         ELSE
         ! nonspin-polarized case
         ! up and down-spin variables get half of the total values
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I))*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= RHO1

            ABSNAB=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
                 +DWORK3(I,1)*DWORK3(I,1))

            ABSNABUP= 0.5_q*ABSNAB
            ABSNABDW= 0.5_q*ABSNAB

!           not needed for MBJ
            IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
               ABSNABUP=MAX(ABSNABUP,NABMIN)
               ABSNABDW=MAX(ABSNABDW,NABMIN)
               ABSNAB=MAX(ABSNAB,2*NABMIN)
            ENDIF

            ! kinetic energy density
            TAUU= MAX(0.5_q*REAL(DKINEDEN(I,1)+TAUC(I),KIND=q), TAUMIN)
            TAUD= TAUU

            ! Laplacian of the density
            LAPLUP=0.5_q*REAL(LAPLACIAN(I,1),KIND=q)
            LAPLDW=LAPLUP

            DWORK4(I)=MAX(REAL((DENCOR(I)+DHTOT(I,1))/LATT_CUR%OMEGA, KIND=q),CHGMIN)
            DWORK7(I)=ABSNAB
         ENDIF

         ! The CMBJ parameter may depend on the spatial position,
         ! if so, it is set here to the right entry in CMBJ_AUX
         CALL GET_CMBJ_PW(I,CVMBJ)

         CALL METAGGASPIN(&
        &   RHO1*AUTOA3,RHO2*AUTOA3,ABSNABUP*AUTOA4,ABSNABDW*AUTOA4,ABSNAB*AUTOA4, &
        &   LAPLUP*AUTOA5,LAPLDW*AUTOA5,TAUU*EVTOH,TAUD*EVTOH, &
        &   EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,MUUP,MUDW,DLAPU,DLAPD,CVMBJ)

         RHO=RHO1+RHO2

         IF (LscMBJ()) CALL SUM_GRHO_OVER_RHO_PW(RHO*AUTOA3,ABSNAB*AUTOA4)
#ifdef debug2
         IF (ABS(MUUP)>1._q) THEN
            WRITE(100+I_DBG,'(A,I9,7F18.11)') 'in ',I,RHO1,RHO2,ABSNABUP,ABSNABDW,ABSNAB,TAUU,TAUD
            WRITE(100+I_DBG,'(A,I9,8F18.11)') 'out',I,EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,MUUP,MUDW
         ENDIF
#endif

         EXC=EXC+EXCL*RHO*RYTOEV*LATT_CUR%OMEGA
         DVXC1=DVXC1*RYTOEV*AUTOA
         DVXC2=DVXC2*RYTOEV*AUTOA
         DVC_ =DVC_ *RYTOEV*AUTOA
         IF (LLD) THEN
           DLAPU=DLAPU*RYTOEV*AUTOA2
           DLAPD=DLAPD*RYTOEV*AUTOA2
         ENDIF

         ! Double counting contribution stemming from dExc/d\mu
         EDCMU=EDCMU+0.5_q*(MUUP*TAUU+MUDW*TAUD-(MUUP+MUDW)*TAUC(I)*0.5_q)*LATT_CUR%OMEGA
#ifdef debug2
         TAU_DBG=TAU_+(TAUU+TAUD)*LATT_CUR%OMEGA
         MU_DBG=MU_DBG+MUUP
#endif
         MUUP=0.5_q*MUUP*RYTOEV*AUTOA2 ! HSQDTM = (plancks CONSTANT/(2*PI))**2/(2*ELECTRON MASS)
         MUDW=0.5_q*MUDW*RYTOEV*AUTOA2

#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
         DVXC1=DVXC1+DVC_
         DVXC2=DVXC2+DVC_
         DVC_=0
#endif

         ! Store d f_xc / d \tau_up,down in DMUWORK if required
         IF (LMU) THEN
            DMUWORK(I,1)=MUUP
            IF (ISPIN==2) DMUWORK(I,2)=MUDW
         ENDIF

         ! Store d f_x/ d (|\nabla \rho_up,down| ) / |\nabla \rho_up,down| in DWORK
         ! and  d f_xc/ d \rho_up,down  in DWORKG
         DWORK(I,1)  = DVXC1 / MAX(ABSNABUP, NABMIN)
         DWORKG(I,1) = DEXC1*RYTOEV
         IF (ISPIN==2) THEN
            DWORK(I,2)  = DVXC2 / MAX(ABSNABDW, NABMIN)
            DWORKG(I,2) = DEXC2*RYTOEV
         ENDIF
         IF (LLD) THEN
            DWORKL(I,1) = DLAPU
            IF (ISPIN==2) DWORKL(I,2) = DLAPD
         ENDIF
         ! Store d f_c/ d(|\nabla \rho|) / |\nabla \rho| in DVC
         DVC(I)=DVC_/MAX(ABSNAB, NABMIN)
      ENDDO
!$ACC EXIT DATA DELETE(LAPLACIAN) __IF_ASYNC__
DOACC CALL ACC_VTUTOR_CHECK()

#ifdef debug2
      CLOSE(100+I_DBG)
      I_DBG=I_DBG+1
#endif

#ifdef debug
      REWIND(77)
      REWIND(78)
      REWIND(79)
      I=1
      DO NY=1,GRIDC%NGY
         DO NX=1,GRIDC%NGX
            ABSNAB= (DWORK1(I,1)+DWORK1(I,2))*(DWORK1(I,1)+DWORK1(I,2))+ &
                 (DWORK2(I,1)+DWORK2(I,2))*(DWORK2(I,1)+DWORK2(I,2))+ &
                 (DWORK3(I,1)+DWORK3(I,2))*(DWORK3(I,1)+DWORK3(I,2))
            ABSNABUP=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
                   +DWORK3(I,1)*DWORK3(I,1))
            ABSNABDW=SQRT(DWORK1(I,2)*DWORK1(I,2)+DWORK2(I,2)*DWORK2(I,2) &
                   +DWORK3(I,2)*DWORK3(I,2))
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= MAX(REAL((DHTOT(I,2)+DENCOR(I)*0.5_q)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            WRITE(77,'(2I4,3F14.3)') NX,NY,DWORK(I,1)*ABSNABUP,RHO1
            WRITE(78,'(3F14.3)') DWORK(I,2)*ABSNABDW
            WRITE(79,'(3F14.3)') DVC(I)*ABSNAB

            I=I+1
         ENDDO
      ENDDO
#endif
#ifdef debug2
      OPEN(I_DBG+500-1)
      I=1
      DO N3=0,GRIDC%NGZ-1
         X3=MOD(N3*1._q/GRIDC%NGZ+10.5,1._q)-0.5
      DO N2=0,GRIDC%NGY-1
         X2=MOD(N2*1._q/GRIDC%NGY+10.5,1._q)-0.5
      DO N1=0,GRIDC%NGX-1
         X1=MOD(N1*1._q/GRIDC%NGX+10.5,1._q)-0.5
         X=X1*LATT_CUR%A(1,1)+X2*LATT_CUR%A(1,2)+X3*LATT_CUR%A(1,3)
         Y=X1*LATT_CUR%A(2,1)+X2*LATT_CUR%A(2,2)+X3*LATT_CUR%A(2,3)
         Z=X1*LATT_CUR%A(3,1)+X2*LATT_CUR%A(3,2)+X3*LATT_CUR%A(3,3)
         IF (ABS(REAL(DMUWORK(I,1),q)*2._q/RYTOEV/AUTOA2) > 1._q) THEN
            WRITE(I_DBG+500-1,'(3F14.7,F18.11)') X,Y,Z,REAL(DMUWORK(I,1),q)*2._q/RYTOEV/AUTOA2
         ENDIF
         I=I+1
      ENDDO
      ENDDO
      ENDDO
      CLOSE(I_DBG+500-1)
#endif

      IF (ISPIN==1) THEN
!$ACC KERNELS PRESENT(DWORK) __IF_ASYNC__
         DWORK = DWORK/2._q
!$ACC END KERNELS
         IF (IVDW_NL==1) THEN
            CALL VDW_NONLOC(DWORK4, DWORK(:,1), DWORKG(:,1), DWORK7,EXC,GRIDC,LATT_CUR,STRESS,1)
         ELSEIF (IVDW_NL==2) THEN
            CALL VDW_NONLOC_RVV10(DWORK4, DWORK(:,1), DWORKG(:,1), DWORK7,EXC,GRIDC,LATT_CUR,STRESS,1)
         ENDIF
!$ACC KERNELS PRESENT(DWORK) __IF_ASYNC__
         DWORK = DWORK*2._q
!$ACC END KERNELS
      ELSEIF (ISPIN==2) THEN
!$ACC KERNELS PRESENT(DWORK5,DWORK6) __IF_ASYNC__
         DWORK5=0._q
         DWORK6=0._q
!$ACC END KERNELS
         IF (IVDW_NL==1) THEN
            CALL VDW_NONLOC( DWORK4, DWORK5, DWORK6, DWORK7,EXC,GRIDC,LATT_CUR,STRESS,2)
         ELSEIF (IVDW_NL==2) THEN
            CALL VDW_NONLOC_RVV10( DWORK4, DWORK5, DWORK6, DWORK7,EXC,GRIDC,LATT_CUR,STRESS,2)
         ENDIF
!$ACC PARALLEL PRESENT(DWORK,DWORK5,DWORK1,DWORK2,DWORK3,DWORKG,DWORK6) __IF_ASYNC__
!$ACC LOOP GANG VECTOR
         DO I=1,GRIDC%RL%NP
            DWORK(I,1)=DWORK(I,1)+DWORK5(I)/ MAX(SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
        &             +DWORK3(I,1)*DWORK3(I,1)),1.E-10_q)
            DWORK(I,2)=DWORK(I,2)+DWORK5(I)/ MAX(SQRT(DWORK1(I,2)*DWORK1(I,2)+DWORK2(I,2)*DWORK2(I,2) &
        &             +DWORK3(I,2)*DWORK3(I,2)),1.E-10_q)
         ENDDO

!$ACC LOOP GANG VECTOR
         DO I=1,GRIDC%RL%NP
            DWORKG(I,1)=DWORKG(I,1)+DWORK6(I)
            DWORKG(I,2)=DWORKG(I,2)+DWORK6(I)
         ENDDO
!$ACC END PARALLEL
      ENDIF

!**********************************************************************
! TR: update the values for local SC CMBJ
!**********************************************************************

      CALL UPDATE_CMBJ_AUX(GRIDC,LATT_CUR,DHTOT,DENCOR,DWORK1,DWORK2,DWORK3, ISPIN)

!=======================================================================
! gradient terms in STRESS tensor
!          d    f_xc     grad rho  x grad rho
! sum_r   ------------   --------------------- * LATT_CUR%OMEGA
!         d |grad rho|        |grad rho|
!=======================================================================
      SIF11=0
      SIF22=0
      SIF33=0
      SIF12=0
      SIF23=0
      SIF31=0
      IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
      IF (ISPIN==2) THEN
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC REDUCTION(+:SIF11,SIF22,SIF33,SIF12,SIF23,SIF31) __IF_ASYNC__
         DO ISP=1,ISPIN
         DO I=1,GRIDC%RL%NP
            SIF11=SIF11+DWORK1(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)
            SIF22=SIF22+DWORK2(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
            SIF33=SIF33+DWORK3(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
            SIF12=SIF12+DWORK1(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
            SIF23=SIF23+DWORK2(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
            SIF31=SIF31+DWORK3(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)

            SIF11=SIF11+DWORK1(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
            SIF22=SIF22+DWORK2(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
            SIF33=SIF33+DWORK3(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
            SIF12=SIF12+DWORK1(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
            SIF23=SIF23+DWORK2(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
            SIF31=SIF31+DWORK3(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
         ENDDO
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC REDUCTION(+:SIF11,SIF22,SIF33,SIF12,SIF23,SIF31) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            SIF11=SIF11+DWORK1(I,1)*DWORK1(I,1)*DWORK(I,1)*0.5_q
            SIF22=SIF22+DWORK2(I,1)*DWORK2(I,1)*DWORK(I,1)*0.5_q
            SIF33=SIF33+DWORK3(I,1)*DWORK3(I,1)*DWORK(I,1)*0.5_q
            SIF12=SIF12+DWORK1(I,1)*DWORK2(I,1)*DWORK(I,1)*0.5_q
            SIF23=SIF23+DWORK2(I,1)*DWORK3(I,1)*DWORK(I,1)*0.5_q
            SIF31=SIF31+DWORK3(I,1)*DWORK1(I,1)*DWORK(I,1)*0.5_q

            SIF11=SIF11+DWORK1(I,1)*(DWORK1(I,1))*DVC(I)
            SIF22=SIF22+DWORK2(I,1)*(DWORK2(I,1))*DVC(I)
            SIF33=SIF33+DWORK3(I,1)*(DWORK3(I,1))*DVC(I)
            SIF12=SIF12+DWORK1(I,1)*(DWORK2(I,1))*DVC(I)
            SIF23=SIF23+DWORK2(I,1)*(DWORK3(I,1))*DVC(I)
            SIF31=SIF31+DWORK3(I,1)*(DWORK1(I,1))*DVC(I)
         ENDDO
      ENDIF
      SIF11=SIF11*RINPL*LATT_CUR%OMEGA
      SIF22=SIF22*RINPL*LATT_CUR%OMEGA
      SIF33=SIF33*RINPL*LATT_CUR%OMEGA
      SIF12=SIF12*RINPL*LATT_CUR%OMEGA
      SIF23=SIF23*RINPL*LATT_CUR%OMEGA
      SIF31=SIF31*RINPL*LATT_CUR%OMEGA
      ENDIF   ! ID_METAGGA /= 30 and 31

!=======================================================================
! calculate
!              d    f_xc     grad rho
!        div  (------------  --------  )
!              d |grad rho| |grad rho|
!
! in reciprocal space
!=======================================================================

      IF (ISPIN==2) THEN
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC& PRIVATE(ANAB1U,ANAB2U,ANAB3U,ANAB1D,ANAB2D,ANAB3D) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            ANAB1U= DWORK1(I,1)
            ANAB2U= DWORK2(I,1)
            ANAB3U= DWORK3(I,1)
            ANAB1D= DWORK1(I,2)
            ANAB2D= DWORK2(I,2)
            ANAB3D= DWORK3(I,2)

            DWORK1(I,1) = ANAB1U* DWORK(I,1) + (ANAB1U+ANAB1D) * DVC(I)
            DWORK2(I,1) = ANAB2U* DWORK(I,1) + (ANAB2U+ANAB2D) * DVC(I)
            DWORK3(I,1) = ANAB3U* DWORK(I,1) + (ANAB3U+ANAB3D) * DVC(I)

            DWORK1(I,2) = ANAB1D* DWORK(I,2) + (ANAB1U+ANAB1D) * DVC(I)
            DWORK2(I,2) = ANAB2D* DWORK(I,2) + (ANAB2U+ANAB2D) * DVC(I)
            DWORK3(I,2) = ANAB3D* DWORK(I,2) + (ANAB3U+ANAB3D) * DVC(I)
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC& PRIVATE(ANAB1U,ANAB2U,ANAB3U,ANAB1D,ANAB2D,ANAB3D) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            ANAB1U= DWORK1(I,1)*0.5_q
            ANAB2U= DWORK2(I,1)*0.5_q
            ANAB3U= DWORK3(I,1)*0.5_q
            ANAB1D= ANAB1U
            ANAB2D= ANAB2U
            ANAB3D= ANAB3U

            DWORK1(I,1) = ANAB1U* DWORK(I,1) + (ANAB1U+ANAB1D) * DVC(I)
            DWORK2(I,1) = ANAB2U* DWORK(I,1) + (ANAB2U+ANAB2D) * DVC(I)
            DWORK3(I,1) = ANAB3U* DWORK(I,1) + (ANAB3U+ANAB3D) * DVC(I)
         ENDDO
      ENDIF

      spin2: DO ISP=1,ISPIN
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK1) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK1(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWGRAD(I,ISP)=CWORK(I,ISP)*GX*CITPI
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK2) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK2(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GY*CITPI
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK3) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK3(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GZ*CITPI
      ENDDO

      CALL SETUNB(CWGRAD(1,ISP),GRIDC)
      CALL FFT3D(CWGRAD(1,ISP),GRIDC,1)
      CALL OPSYNC(CWGRAD(1,ISP),DWGRAD(1,ISP),GRIDC%NPLWV)

      ENDDO spin2

!=======================================================================
! laplacian terms in stress tensor
!                     d  f_xc         d^2 n_sigma
! sum_(r,sigma)    ------------      ------------- * LATT_CUR%OMEGA
!                  d lap rho_sigma     d r_i d r_j
!=======================================================================

! if ispin == 1, then denshess(:,:,1) is the Hessian of the total density
! dworkl is still d f_xc / d lap rho_sigma, so the sum will still yield
! twice the sum over a single spin channel. No additional factor needed

! if ispin == 2, then denshess(:,:,sigma) is the Hessian for each spin channel sigma,
! no correcting factor needed

! this has to appear here rather than with the gradient contribution to
! the stress tensor because DWORK is required for the gradient contributions
! to the XC potential

      IF (LLD) THEN
        SIFLAP11=0
        SIFLAP22=0
        SIFLAP33=0
        SIFLAP12=0
        SIFLAP23=0
        SIFLAP31=0
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORKL,DENSHESS) &
!$ACC REDUCTION(+:SIFLAP11,SIFLAP22,SIFLAP33,SIFLAP12,SIFLAP23,SIFLAP31) __IF_ASYNC__
        SLST: DO ISP=1,ISPIN
          DO I=1,GRIDC%RL%NP
            SIFLAP11=SIFLAP11 + 2._q*DWORKL(I,ISP)*DENSHESS(I,1,ISP)
            SIFLAP22=SIFLAP22 + 2._q*DWORKL(I,ISP)*DENSHESS(I,4,ISP)
            SIFLAP33=SIFLAP33 + 2._q*DWORKL(I,ISP)*DENSHESS(I,6,ISP)
            SIFLAP12=SIFLAP12 + 2._q*DWORKL(I,ISP)*DENSHESS(I,2,ISP)
            SIFLAP23=SIFLAP23 + 2._q*DWORKL(I,ISP)*DENSHESS(I,5,ISP)
            SIFLAP31=SIFLAP31 + 2._q*DWORKL(I,ISP)*DENSHESS(I,3,ISP)
          ENDDO
        ENDDO SLST
        SIF11=SIF11 + SIFLAP11*RINPL*LATT_CUR%OMEGA
        SIF22=SIF22 + SIFLAP22*RINPL*LATT_CUR%OMEGA
        SIF33=SIF33 + SIFLAP33*RINPL*LATT_CUR%OMEGA
        SIF12=SIF12 + SIFLAP12*RINPL*LATT_CUR%OMEGA
        SIF23=SIF23 + SIFLAP23*RINPL*LATT_CUR%OMEGA
        SIF31=SIF31 + SIFLAP31*RINPL*LATT_CUR%OMEGA

!=======================================================================
! calculate
!               d    f_xc
!        lap ( ------------ )
!               d lap rho
!
! in reciprocal space
!=======================================================================

        SPINLAP: DO ISP=1,ISPIN
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORK(I,ISP) = DWORKL(I,ISP)
          ENDDO

          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
          CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
          CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWORK) PRIVATE(N1,N2,N3,NC,GX,GY,GZ,GG) __IF_ASYNC__
          DO I=1,GRIDC%RC%NP
             N1= MOD((I-1),GRIDC%RC%NROW) +1
             NC= (I-1)/GRIDC%RC%NROW+1
             N2= GRIDC%RC%I2(NC)
             N3= GRIDC%RC%I3(NC)

             GX = GRIDC%LPCTX(N1)*LATT_CUR%B(1,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(1,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
             GY = GRIDC%LPCTX(N1)*LATT_CUR%B(2,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(2,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
             GZ = GRIDC%LPCTX(N1)*LATT_CUR%B(3,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(3,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)
             GG = GX**2 + GY**2 + GZ**2

             CWORK(I,ISP) = GG*CITPI*CITPI*CWORK(I,ISP)
          ENDDO

          CALL SETUNB(CWORK(1,ISP),GRIDC)
          CALL FFT3D(CWORK(1,ISP),GRIDC,1)
          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORKL(I,ISP) = REAL(DWORK(I,ISP),KIND=q)
          ENDDO

        ENDDO SPINLAP
      ENDIF

!=======================================================================
! Now prepare the rest:
! (store rho in DWORK3 and quantity of above in DWORK1)
!=======================================================================
      XCENC=0._q
      CVZERO=0._q
      XCENCC=0._q

      IF (ISPIN==2) THEN
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORKG,DWGRAD,DWORK,DWORKL) &
!$ACC& REDUCTION(+:CVZERO,XCENCC,XCENC) PRIVATE(RHO1,RHO2,VXC1,VXC2,VXC) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
         ! Spin-polarized case
            RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)/ISPIN)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
            RHO2= MAX(REAL((DHTOT(I,2)+DENCOR(I)/ISPIN)/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
            VXC2=DWORKG(I,2)- REAL( DWGRAD(I,2) ,KIND=q) *RINPL
            IF (LLD) THEN
               VXC1=VXC1 + DWORKL(I,1)*RINPL
               VXC2=VXC2 + DWORKL(I,2)*RINPL
            ENDIF
            DWORK(I,1)=VXC1
            DWORK(I,2)=VXC2
            VXC = 0.5_q*(VXC1+VXC2)
            CVZERO=CVZERO+VXC
            XCENCC=XCENCC-VXC1*RHO1*LATT_CUR%OMEGA-VXC2*RHO2*LATT_CUR%OMEGA
            XCENC=XCENC  -VXC1* REAL( DHTOT(I,1) ,KIND=q) -VXC2* REAL( DHTOT(I,2) ,KIND=q)
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORKG,DWGRAD,DWORK,DWORKL) &
!$ACC& REDUCTION(+:CVZERO,XCENCC,XCENC) PRIVATE(RHO,VXC1) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
         ! nonspin-polarized case
            RHO= MAX(REAL((DHTOT(I,1)+DENCOR(I))/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

            VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
            IF (LLD) THEN
               VXC1=VXC1 + DWORKL(I,1)*RINPL
            ENDIF
            DWORK(I,1)=VXC1
            CVZERO=CVZERO+VXC1
            XCENCC=XCENCC-VXC1*RHO*LATT_CUR%OMEGA
            XCENC=XCENC  -VXC1* REAL( DHTOT(I,1) ,KIND=q)
         ENDDO
      ENDIF
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)
!$ACC EXIT DATA DELETE(LAPLACIAN,DWORKL,DENSHESS) __IF_ASYNC__

      CVZERO=CVZERO*RINPL
      XCENC =(XCENC+EXC-EDCMU)*RINPL
      XCENCC=(XCENCC+EXC)*RINPL
      EXC   =EXC*RINPL
      EDCMU =EDCMU*RINPL

      SIF11=SIF11-XCENCC
      SIF22=SIF22-XCENCC
      SIF33=SIF33-XCENCC
      XCSIF(1,1)=SIF11
      XCSIF(2,2)=SIF22
      XCSIF(3,3)=SIF33
      XCSIF(1,2)=SIF12
      XCSIF(2,1)=SIF12
      XCSIF(2,3)=SIF23
      XCSIF(3,2)=SIF23
      XCSIF(3,1)=SIF31
      XCSIF(1,3)=SIF31

      XCSIF = XCSIF - STRESS

      CALLMPI( M_sum_3(GRIDC%COMM, EXC, XCENC, EDCMU))
      CALLMPI( M_sum_d(GRIDC%COMM, XCSIF, 9))
      CALLMPI( M_sum_z(GRIDC%COMM,CVZERO,1))

! Test dumps:
      IF (IDUMP/=0) THEN
         WRITE(*,'(A,F24.14)') '<rho*excgc> =',EXC
         WRITE(*,'(A,F24.14)') '<rho*vxcgc> =',EXC-XCENC
         WRITE(*,'(A,F24.14)') '    xcencgc =',XCENC
         WRITE(*,'(A,F24.14)') '    xcencc  =',XCENCC
         WRITE(*,'(A,F24.14)') '     edcmu  =',EDCMU
#ifdef debug2
         WRITE(*,'(A,F24.14)') '     tau    =',TAU_DBG*RINPL
         WRITE(*,'(A,F24.14)') '     mu     =',MU_DBG*RINPL
#endif
      ENDIF

      RETURN
      END SUBROUTINE FEXCGS_METAGGA_VDW_


!***************** SUBROUTINE FEXCGS_METAGGA_NONCOL ********************
!
!  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
! Mind CWORK and DWORK point actually to the same storagelocation
! similar to an EQUIVALENCE (CWORK(1),DWORK(1))
! the same for  (CWGRAD,DWGRAD) and   (CHTOT,DHTOT)
! so we can interchange both arrays arbitrarily
!
!***********************************************************************

      SUBROUTINE FEXCGS_METAGGA_NONCOL(LPOT,LMU,LLD, &
     &   NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
     &   CWGRAD,CHTOT,CWORK,CKINEDEN,DWGRAD,DHTOT,DWORK,DKINEDEN, &
     &   DENCOR,TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC, &
     &   DMUWORK &
     &)
#ifdef _OPENACC
      USE mopenacc_struct_def
      USE tutoracc, ONLY : ACC_VTUTOR_CHECK
#endif
      USE prec
      USE lattice
      USE mpimy
      USE mgrid
      USE constant
      USE metalib
      USE setxcmeta
      USE meta

      IMPLICIT COMPLEX(q) (C)

      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR

      LOGICAL LPOT,LMU,LLD

      COMPLEX(q) CWGRAD(GRIDC%MPLWV,NCDIJ),CHTOT(GRIDC%MPLWV,NCDIJ), &
     &   CKINEDEN(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ)
      RGRID DWGRAD(DIMREAL(GRIDC%MPLWV),NCDIJ),DHTOT(DIMREAL(GRIDC%MPLWV),NCDIJ), &
     &   DKINEDEN(DIMREAL(GRIDC%MPLWV),NCDIJ),DWORK(DIMREAL(GRIDC%MPLWV),NCDIJ)

      RGRID DENCOR(GRIDC%RL%NP),TAUC(GRIDC%RL%NP)
      REAL(q) XCSIF(3,3)
      REAL(q) DWORKG(GRIDC%RL%NP,NCDIJ/2),DWORK1(GRIDC%RL%NP,NCDIJ), &
     &   DWORK2(GRIDC%RL%NP,NCDIJ),DWORK3(GRIDC%RL%NP,NCDIJ),DVC(GRIDC%RL%NP)
      REAL(q) MAG_NORM,MAG_NORM_I,NABMAG(3),TAU_NORM,TAU_DOT_MDIR,LAP_NORM,LAP_DOT_MDIR

      RGRID  DMUWORK(DIMREAL(GRIDC%MPLWV),NCDIJ)

      REAL(q) LAPLUP,LAPLDW,LAPLACIAN(GRIDC%RL%NP,NCDIJ)
      REAL(q) MUUP,MUDW,EDCMU
      REAL(q) CVMBJ

      REAL(q), ALLOCATABLE :: DWORKL(:,:),DENSHESS(:,:,:)
      REAL(q) DLAPU,DLAPD

      REAL(q) :: CHGMIN=1E-10_q, NABMIN=1E-10_q, TAUMIN=1E-10_q, LAPMIN=1E-10_q
!$ACC ROUTINE(LscMBJ,GET_CMBJ_PW) SEQ
!     TAUMIN=0 for MBJ is ok since there is no division by TAU
      IF ((ID_METAGGA == 30) .OR. (ID_METAGGA == 31)) TAUMIN=0._q

! set to one for error-dumps
#ifdef MPI
      NODE_ME=GRIDC%COMM%NODE_ME
      IONODE =GRIDC%COMM%IONODE
      IDUMP=0
#ifdef debug
      IF (NODE_ME==IONODE) IDUMP=1
#endif
#else
      IDUMP=0
#ifdef debug
      IDUMP=1
#endif
#endif

!$ACC ENTER DATA CREATE(LAPLACIAN) __IF_ASYNC__
!$ACC KERNELS PRESENT(LAPLACIAN) __IF_ASYNC__
      LAPLACIAN=0
!$ACC END KERNELS

      IF (LLD) THEN
         ALLOCATE(DWORKL(GRIDC%RL%NP,NCDIJ),DENSHESS(GRIDC%RL%NP,6,NCDIJ))
!$ACC ENTER DATA CREATE(DWORKL,DENSHESS) __IF_ASYNC__
!$ACC KERNELS PRESENT(DWORKL,DENSHESS) __IF_ASYNC__
         DWORKL=0
         DENSHESS=0
!$ACC END KERNELS
      ENDIF

      RINPL=1._q/GRIDC%NPLWV                    ! Scaling of Energy
      EVTOH=1._q/(2.*HSQDTM)*AUTOA5             ! KinEDens eV to Hartree

!=======================================================================
! First phase: Transform DENCOR (core charge) and
!  CHTOT (pseudo chargedensity) to real space
!=======================================================================
    spin: DO ISP=1,NCDIJ
      IF (ISP==1) THEN
      ! Add core charge density to pseudo charge density
!$ACC PARALLEL LOOP PRESENT(DWORK,DENCOR,DHTOT,LATT_CUR) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DWORK(I,ISP)=(DENCOR(I)+DHTOT(I,ISP))*RINPL/LATT_CUR%OMEGA
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DWORK,DHTOT,LATT_CUR) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DWORK(I,ISP)=DHTOT(I,ISP)*RINPL/LATT_CUR%OMEGA
         ENDDO
      ENDIF

      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!=======================================================================
! now calculate the gradient of the chargedensity
!=======================================================================
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWGRAD(I,ISP)=CWORK(I,ISP)
      ENDDO
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GX*CITPI
       ENDDO
! grad_x in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK1(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(CWORK,CWGRAD) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GY*CITPI
      ENDDO
! grad_y in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK2,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK2(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(CWORK,CWGRAD) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GZ*CITPI
      ENDDO
! grad_z in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK3,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK3(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! Compute the laplacian of the density

      IF (LLD) THEN

         ! and if laplacian-dependent functional is called, also compute density hessian
         ! indices for density hessian: 1 = xx, 2 = xy, 3 = xz, 4 = yy, 5 = yz, 6 = zz
         IDH = 0
         DO IDIR=1,3
           DO JDIR = IDIR,3
             IDH = IDH + 1
!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWGRAD,CWORK) PRIVATE(N1,N2,N3,NC,GI,GJ) __IF_ASYNC__
             DO I=1,GRIDC%RC%NP
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)

               GI = GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3)
               GJ = GRIDC%LPCTX(N1)*LATT_CUR%B(JDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(JDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(JDIR,3)
               CWORK(I,ISP) = CWGRAD(I,ISP) * GI*GJ*CITPI*CITPI
             ENDDO
             CALL SETUNB(CWORK(1,ISP),GRIDC)
             CALL FFT3D(CWORK(1,ISP),GRIDC,1)
             CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DENSHESS,DWORK) __IF_ASYNC__
             DO I=1,GRIDC%RL%NP
                DENSHESS(I,IDH,ISP) = REAL( DWORK(I,ISP) ,KIND=q)
             ENDDO
           ENDDO
         ENDDO
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DENSHESS) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
           LAPLACIAN(I,ISP) = DENSHESS(I,1,ISP) + DENSHESS(I,4,ISP) + DENSHESS(I,6,ISP)
         ENDDO

      ELSE

         DO IDIR=1,3
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR,CWGRAD) PRIVATE(N1,N2,N3,NC,GG) __IF_ASYNC__
            DO I=1,GRIDC%RC%NP  ! loop over all grid points NP in the reciprocal (RC) grid
               ! index of grid point along three reciprocal lattice vectors (N1, N2, N3)
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)
               ! convert to lattice vector component in direction x, y or z (corresponding to index J)
               GG=(GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3))
               !write(*,*)'xcgrad:cwgrad ', CWORK4(I), CWGRAD(I), G1, G2, CITPI
               CWORK(I,ISP)=CWGRAD(I,ISP)*GG*GG*CITPI*CITPI
            ENDDO
            CALL SETUNB(CWORK(1,ISP),GRIDC)
            CALL FFT3D(CWORK(1,ISP),GRIDC,1)
            CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DWORK) __IF_ASYNC__
            DO I=1,GRIDC%RL%NP
               LAPLACIAN(I,ISP)=LAPLACIAN(I,ISP)+REAL( DWORK(I,ISP) ,KIND=q)
            ENDDO
         ENDDO

      ENDIF

      ENDDO spin

!=======================================================================
!  grad rho    d    f_xc
! ---------- * ------------      (Phys.Rev.B 50,7 (1994) 4954)
! |grad rho|   d |grad rho|
!
!  MIND: the factor OMEGA is difficult to understand:
!   1/N sum_r energy_density * rho *OMEGA = Energy
!   1/N sum_r energy_density * \bar rho   = Energy (\bar rho=rho*LATT_CUR%OMEGA)
!=======================================================================
      EXC=0; EDCMU=0; CVMBJ=CMBJ
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORK1,DWORK2,DWORK3,DKINEDEN,DMUWORK,DWORK,DVC,LAPLACIAN,DWORKL) &
!$ACC PRIVATE(MAG_NORM,RHO1,RHO2,NABMAG,ABSNABUP,ABSNABDW,ABSNAB,TAU_NORM,TAU_DOT_MDIR,TAUU,TAUD, &
!$ACC LAP_NORM,LAP_DOT_MDIR,LAPLUP,LAPLDW,EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,DLAPU,DLAPD,MUUP,MUDW,RHO) &
!$ACC FIRSTPRIVATE(CVMBJ) REDUCTION(+:EXC,EDCMU) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
!
! | m |
!
         MAG_NORM=SQRT(ABS( &
        &    DHTOT(I,2)*DHTOT(I,2)+DHTOT(I,3)*DHTOT(I,3)+DHTOT(I,4)*DHTOT(I,4)))
        MAG_NORM_I=1._q/MAX(MAG_NORM,CHGMIN)
!
! RHO1: \rho_up   = ( \rho_tot + | m | )/2
! RHO2: \rho_down = ( \rho_tot - | m | )/2
!
         RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)+MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
         RHO2= MAX(REAL((DHTOT(I,1)+DENCOR(I)-MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
!
! \nabla | m |
!
         NABMAG(1)=(DWORK1(I,2)*DHTOT(I,2)+DWORK1(I,3)*DHTOT(I,3)+DWORK1(I,4)*DHTOT(I,4))*MAG_NORM_I
         NABMAG(2)=(DWORK2(I,2)*DHTOT(I,2)+DWORK2(I,3)*DHTOT(I,3)+DWORK2(I,4)*DHTOT(I,4))*MAG_NORM_I
         NABMAG(3)=(DWORK3(I,2)*DHTOT(I,2)+DWORK3(I,3)*DHTOT(I,3)+DWORK3(I,4)*DHTOT(I,4))*MAG_NORM_I
!
! | ( \nabla \rho + \nabla | m | )/2 |
!
         ABSNABUP=SQRT( &
        &            (DWORK1(I,1)+NABMAG(1))*(DWORK1(I,1)+NABMAG(1)) + &
        &             (DWORK2(I,1)+NABMAG(2))*(DWORK2(I,1)+NABMAG(2)) + &
        &              (DWORK3(I,1)+NABMAG(3))*(DWORK3(I,1)+NABMAG(3)) ) * 0.5_q
!
! | ( \nabla \rho - \nabla | m | )/2 |
!
         ABSNABDW=SQRT( &
        &            (DWORK1(I,1)-NABMAG(1))*(DWORK1(I,1)-NABMAG(1)) + &
        &             (DWORK2(I,1)-NABMAG(2))*(DWORK2(I,1)-NABMAG(2)) + &
        &              (DWORK3(I,1)-NABMAG(3))*(DWORK3(I,1)-NABMAG(3)) ) * 0.5_q
!
! | \nabla \rho |
!
         ABSNAB=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1)+DWORK3(I,1)*DWORK3(I,1))
!
! Refill DWORK[1..3](:,2) with ( \nabla \rho - \nabla | m | )/2
!
         DWORK1(I,2)=(DWORK1(I,1)-NABMAG(1))*0.5_q
         DWORK2(I,2)=(DWORK2(I,1)-NABMAG(2))*0.5_q
         DWORK3(I,2)=(DWORK3(I,1)-NABMAG(3))*0.5_q
!
! Refill DWORK[1..3](:,1) with ( \nabla \rho + \nabla | m | )/2
!
         DWORK1(I,1)=(DWORK1(I,1)+NABMAG(1))*0.5_q
         DWORK2(I,1)=(DWORK2(I,1)+NABMAG(2))*0.5_q
         DWORK3(I,1)=(DWORK3(I,1)+NABMAG(3))*0.5_q

!#define  correlation_ABS_DRHOUP_ABS_DRHOD
#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
         ABSNAB=ABSNABUP+ABSNABDW
#endif
         !
         ! | m |
         !
         TAU_NORM=MAX(SQRT(ABS( &
        &    DKINEDEN(I,2)*DKINEDEN(I,2)+DKINEDEN(I,3)*DKINEDEN(I,3)+DKINEDEN(I,4)*DKINEDEN(I,4))), TAUMIN)
         TAU_DOT_MDIR=(DHTOT(I,2)*DKINEDEN(I,2)+DHTOT(I,3)*DKINEDEN(I,3)+DHTOT(I,4)*DKINEDEN(I,4))*MAG_NORM_I
         !
         ! kinetic energy density
         ! TAUU: \tau_up   = ( \tau_tot + | m | )/2
         ! TAUD: \tau_down = ( \tau_tot - | m | )/2
         !
!         TAUU=MAX(REAL((DKINEDEN(I,1)+TAU_NORM)/2,KIND=q), TAUMIN)
!         TAUD=MAX(REAL((DKINEDEN(I,1)-TAU_NORM)/2,KIND=q), TAUMIN)
         TAUU=MAX(REAL((DKINEDEN(I,1)+TAU_DOT_MDIR)*0.5_q+TAUC(I)*0.5_q,KIND=q), TAUMIN)
         TAUD=MAX(REAL((DKINEDEN(I,1)-TAU_DOT_MDIR)*0.5_q+TAUC(I)*0.5_q,KIND=q), TAUMIN)

         !
         ! | m |
         !
         LAP_NORM=MAX(SQRT(ABS( &
        &    LAPLACIAN(I,2)*LAPLACIAN(I,2)+LAPLACIAN(I,3)*LAPLACIAN(I,3)+LAPLACIAN(I,4)*LAPLACIAN(I,4))), LAPMIN)
         LAP_DOT_MDIR=(DHTOT(I,2)*LAPLACIAN(I,2)+DHTOT(I,3)*LAPLACIAN(I,3)+DHTOT(I,4)*LAPLACIAN(I,4))*MAG_NORM_I
         !
         ! Laplacian of the density
!        LAPLUP=REAL((LAPLACIAN(I,1)+LAP_NORM)/2,KIND=q)
!        LAPLDW=REAL((LAPLACIAN(I,1)-LAP_NORM)/2,KIND=q)
         LAPLUP=REAL((LAPLACIAN(I,1)+LAP_DOT_MDIR)*0.5_q,KIND=q)
         LAPLDW=REAL((LAPLACIAN(I,1)-LAP_DOT_MDIR)*0.5_q,KIND=q)

         ! The CMBJ parameter may depend on the spatial position,
         ! if so, it is set here to the right entry in CMBJ_AUX
         CALL GET_CMBJ_PW(I,CVMBJ)

         CALL METAGGASPIN(&
        &   RHO1*AUTOA3,RHO2*AUTOA3,ABSNABUP*AUTOA4,ABSNABDW*AUTOA4,ABSNAB*AUTOA4, &
        &   LAPLUP*AUTOA5,LAPLDW*AUTOA5,TAUU*EVTOH,TAUD*EVTOH, &
        &   EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,MUUP,MUDW,DLAPU,DLAPD,CVMBJ)

         RHO=RHO1+RHO2

         IF (LscMBJ()) CALL SUM_GRHO_OVER_RHO_PW(RHO*AUTOA3,ABSNAB*AUTOA4)

         EXC=EXC+EXCL*RHO*RYTOEV*LATT_CUR%OMEGA
         DVXC1=DVXC1*RYTOEV*AUTOA
         DVXC2=DVXC2*RYTOEV*AUTOA
         DVC_ =DVC_ *RYTOEV*AUTOA
         IF (LLD) THEN
           DLAPU=DLAPU*RYTOEV*AUTOA2
           DLAPD=DLAPD*RYTOEV*AUTOA2
         ENDIF

         ! Double counting contribution stemming from dExc/d\mu
         EDCMU=EDCMU+0.5_q*(MUUP*TAUU+MUDW*TAUD-(MUUP+MUDW)*TAUC(I)*0.5_q)*LATT_CUR%OMEGA

         MUUP=0.5_q*MUUP*RYTOEV*AUTOA2 ! HSQDTM = (plancks CONSTANT/(2*PI))**2/(2*ELECTRON MASS)
         MUDW=0.5_q*MUDW*RYTOEV*AUTOA2

#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
         DVXC1=DVXC1+DVC_
         DVXC2=DVXC2+DVC_
         DVC_=0
#endif

!test
!         DVXC1=0
!         DVXC2=0
!         DVC_ =0
!test
         ! Store d f_xc / d \tau_up,down in DMUWORK if required
         IF (LMU) THEN
            DMUWORK(I,1)=MUUP
            DMUWORK(I,2)=MUDW
         ENDIF

!
!   store d f/ d (|d rho| ) / |d rho|  in DWORK
!
         DWORK(I,1)  = DVXC1 / MAX(ABSNABUP,NABMIN)
         DWORK(I,2)  = DVXC2 / MAX(ABSNABDW,NABMIN)
         DVC(I)      = DVC_  / MAX(ABSNAB,NABMIN)
!
!   store d f/ d rho  in DWORKG
!
         DWORKG(I,1) = DEXC1*RYTOEV
         DWORKG(I,2) = DEXC2*RYTOEV
!
!   storing laplacian
!
         IF (LLD) THEN
            DWORKL(I,1) = DLAPU
            DWORKL(I,2) = DLAPD
         ENDIF

      ENDDO
!$ACC EXIT DATA DELETE(LAPLACIAN) __IF_ASYNC__
DOACC CALL ACC_VTUTOR_CHECK()

!**********************************************************************
! TR: update the values for local SC CMBJ
!**********************************************************************

      CALL UPDATE_CMBJ_AUX(GRIDC,LATT_CUR,DHTOT,DENCOR,DWORK1,DWORK2,DWORK3,NCDIJ)

!=======================================================================
! gradient terms in stress tensor
!          d    f_xc     grad rho  x grad rho
! sum_r   ------------   --------------------- * LATT_CUR%OMEGA
!         d |grad rho|        |grad rho|
!=======================================================================
      SIF11=0
      SIF22=0
      SIF33=0
      SIF12=0
      SIF23=0
      SIF31=0
!     and hence there is also no possibility to obtain stresses or forces
      IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC REDUCTION(+:SIF11,SIF22,SIF33,SIF12,SIF23,SIF31) __IF_ASYNC__
      DO ISP=1,2
      DO I=1,GRIDC%RL%NP
         SIF11=SIF11+DWORK1(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)
         SIF22=SIF22+DWORK2(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
         SIF33=SIF33+DWORK3(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
         SIF12=SIF12+DWORK1(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
         SIF23=SIF23+DWORK2(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
         SIF31=SIF31+DWORK3(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)

         SIF11=SIF11+DWORK1(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
         SIF22=SIF22+DWORK2(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
         SIF33=SIF33+DWORK3(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
         SIF12=SIF12+DWORK1(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
         SIF23=SIF23+DWORK2(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
         SIF31=SIF31+DWORK3(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
      ENDDO
      ENDDO
      SIF11=SIF11*RINPL*LATT_CUR%OMEGA
      SIF22=SIF22*RINPL*LATT_CUR%OMEGA
      SIF33=SIF33*RINPL*LATT_CUR%OMEGA
      SIF12=SIF12*RINPL*LATT_CUR%OMEGA
      SIF23=SIF23*RINPL*LATT_CUR%OMEGA
      SIF31=SIF31*RINPL*LATT_CUR%OMEGA
      ENDIF   ! ID_METAGGA /= 30 and 31

!=======================================================================
! calculate
!              d    f_xc     grad rho
!        div  (------------  --------  )
!              d |grad rho| |grad rho|
!
! in reciprocal space
!=======================================================================

!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC& PRIVATE(ANAB1U,ANAB2U,ANAB3U,ANAB1D,ANAB2D,ANAB3D) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
         ANAB1U= DWORK1(I,1)
         ANAB2U= DWORK2(I,1)
         ANAB3U= DWORK3(I,1)
         ANAB1D= DWORK1(I,2)
         ANAB2D= DWORK2(I,2)
         ANAB3D= DWORK3(I,2)

         DWORK1(I,1) = ANAB1U* DWORK(I,1) + (ANAB1U+ANAB1D) * DVC(I)
         DWORK2(I,1) = ANAB2U* DWORK(I,1) + (ANAB2U+ANAB2D) * DVC(I)
         DWORK3(I,1) = ANAB3U* DWORK(I,1) + (ANAB3U+ANAB3D) * DVC(I)

         DWORK1(I,2) = ANAB1D* DWORK(I,2) + (ANAB1U+ANAB1D) * DVC(I)
         DWORK2(I,2) = ANAB2D* DWORK(I,2) + (ANAB2U+ANAB2D) * DVC(I)
         DWORK3(I,2) = ANAB3D* DWORK(I,2) + (ANAB3U+ANAB3D) * DVC(I)
      ENDDO

      spin2: DO ISP=1,2
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK1) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK1(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWGRAD(I,ISP)=CWORK(I,ISP)*GX*CITPI
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK2) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK2(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GY*CITPI
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK3) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK3(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GZ*CITPI
      ENDDO

      CALL SETUNB(CWGRAD(1,ISP),GRIDC)
      CALL FFT3D(CWGRAD(1,ISP),GRIDC,1)
      CALL OPSYNC(CWGRAD(1,ISP),DWGRAD(1,ISP),GRIDC%NPLWV)

      ENDDO spin2


!=======================================================================
! laplacian terms in stress tensor
!                     d  f_xc         d^2 n_sigma
! sum_(r,sigma)    ------------      ------------- * LATT_CUR%OMEGA
!                  d lap rho_sigma     d r_i d r_j
!=======================================================================

! if ispin == 1, then denshess(:,:,1) is the Hessian of the total density
! dworkl is still d f_xc / d lap rho_sigma, so the sum will still yield
! twice the sum over a single spin channel. No additional factor needed

! if ispin == 2, then denshess(:,:,sigma) is the Hessian for each spin channel sigma,
! no correcting factor needed

! this has to appear here rather than with the gradient contribution to
! the stress tensor because DWORK is required for the gradient contributions
! to the XC potential

      IF (LLD) THEN
        SIFLAP11=0
        SIFLAP22=0
        SIFLAP33=0
        SIFLAP12=0
        SIFLAP23=0
        SIFLAP31=0
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORKL,DENSHESS) &
!$ACC REDUCTION(+:SIFLAP11,SIFLAP22,SIFLAP33,SIFLAP12,SIFLAP23,SIFLAP31) __IF_ASYNC__
        SLST: DO ISP=1,2
          DO I=1,GRIDC%RL%NP
            SIFLAP11=SIFLAP11 + 2._q*DWORKL(I,ISP)*DENSHESS(I,1,ISP)
            SIFLAP22=SIFLAP22 + 2._q*DWORKL(I,ISP)*DENSHESS(I,4,ISP)
            SIFLAP33=SIFLAP33 + 2._q*DWORKL(I,ISP)*DENSHESS(I,6,ISP)
            SIFLAP12=SIFLAP12 + 2._q*DWORKL(I,ISP)*DENSHESS(I,2,ISP)
            SIFLAP23=SIFLAP23 + 2._q*DWORKL(I,ISP)*DENSHESS(I,5,ISP)
            SIFLAP31=SIFLAP31 + 2._q*DWORKL(I,ISP)*DENSHESS(I,3,ISP)
          ENDDO
        ENDDO SLST
        SIF11=SIF11 + SIFLAP11*RINPL*LATT_CUR%OMEGA
        SIF22=SIF22 + SIFLAP22*RINPL*LATT_CUR%OMEGA
        SIF33=SIF33 + SIFLAP33*RINPL*LATT_CUR%OMEGA
        SIF12=SIF12 + SIFLAP12*RINPL*LATT_CUR%OMEGA
        SIF23=SIF23 + SIFLAP23*RINPL*LATT_CUR%OMEGA
        SIF31=SIF31 + SIFLAP31*RINPL*LATT_CUR%OMEGA

!=======================================================================
! calculate
!               d    f_xc
!        lap ( ------------ )
!               d lap rho
!
! in reciprocal space
!=======================================================================

        SPINLAP: DO ISP=1,2
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORK(I,ISP) = DWORKL(I,ISP)
          ENDDO

          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
          CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
          CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWORK) PRIVATE(N1,N2,N3,NC,GX,GY,GZ,GG) __IF_ASYNC__
          DO I=1,GRIDC%RC%NP
             N1= MOD((I-1),GRIDC%RC%NROW) +1
             NC= (I-1)/GRIDC%RC%NROW+1
             N2= GRIDC%RC%I2(NC)
             N3= GRIDC%RC%I3(NC)

             GX = GRIDC%LPCTX(N1)*LATT_CUR%B(1,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(1,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
             GY = GRIDC%LPCTX(N1)*LATT_CUR%B(2,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(2,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
             GZ = GRIDC%LPCTX(N1)*LATT_CUR%B(3,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(3,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)
             GG = GX**2 + GY**2 + GZ**2

             CWORK(I,ISP) = GG*CITPI*CITPI*CWORK(I,ISP)
          ENDDO

          CALL SETUNB(CWORK(1,ISP),GRIDC)
          CALL FFT3D(CWORK(1,ISP),GRIDC,1)
          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORKL(I,ISP) = REAL(DWORK(I,ISP),KIND=q)
          ENDDO

        ENDDO SPINLAP
      ENDIF

!=======================================================================
! Now prepare the rest:
! (store rho in DWORK3 and quantity of above in DWORK1)
!=======================================================================
      XCENC=0._q
      CVZERO=0._q
      XCENCC=0._q

!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORKG,DWGRAD,DWORK,DWORKL) &
!$ACC& REDUCTION(+:CVZERO,XCENCC,XCENC) PRIVATE(MAG_NORM,RHO1,RHO2,VXC1,VXC2,VXC) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
!
! | m |
!
         MAG_NORM=SQRT(ABS(DHTOT(I,2)*DHTOT(I,2)+ DHTOT(I,3)*DHTOT(I,3) + DHTOT(I,4)*DHTOT(I,4)))
!
! RHO1: \rho_up   = ( \rho_tot + | m | )/2
! RHO2: \rho_down = ( \rho_tot - | m | )/2
!
         RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)+MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
         RHO2= MAX(REAL((DHTOT(I,1)+DENCOR(I)-MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

         VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
         VXC2=DWORKG(I,2)- REAL( DWGRAD(I,2) ,KIND=q) *RINPL
         IF (LLD) THEN
            VXC1=VXC1 + DWORKL(I,1)*RINPL
            VXC2=VXC2 + DWORKL(I,2)*RINPL
         ENDIF
         DWORK(I,1)=VXC1
         DWORK(I,2)=VXC2
         VXC = 0.5_q*(VXC1+VXC2)
         CVZERO=CVZERO+VXC
         XCENCC=XCENCC-VXC1*RHO1*LATT_CUR%OMEGA-VXC2*RHO2*LATT_CUR%OMEGA
         XCENC=XCENC  -VXC1* REAL( (DHTOT(I,1)+MAG_NORM)*0.5_q ,KIND=q) &
        &             -VXC2* REAL( (DHTOT(I,1)-MAG_NORM)*0.5_q ,KIND=q)
      ENDDO
!$ACC EXIT DATA DELETE(LAPLACIAN,DWORKL,DENSHESS) __IF_ASYNC__

      CVZERO=CVZERO*RINPL
      XCENC =(XCENC+EXC-EDCMU)*RINPL
      XCENCC=(XCENCC+EXC)*RINPL
      EXC   =EXC*RINPL
      EDCMU =EDCMU*RINPL

      SIF11=SIF11-XCENCC
      SIF22=SIF22-XCENCC
      SIF33=SIF33-XCENCC
      XCSIF(1,1)=SIF11
      XCSIF(2,2)=SIF22
      XCSIF(3,3)=SIF33
      XCSIF(1,2)=SIF12
      XCSIF(2,1)=SIF12
      XCSIF(2,3)=SIF23
      XCSIF(3,2)=SIF23
      XCSIF(3,1)=SIF31
      XCSIF(1,3)=SIF31

      CALLMPI( M_sum_3(GRIDC%COMM, EXC, XCENC, EDCMU))
      CALLMPI( M_sum_d(GRIDC%COMM, XCSIF, 9))
      CALLMPI( M_sum_z(GRIDC%COMM,CVZERO,1))

! Test dumps:
      IF (IDUMP/=0) THEN
         WRITE(*,'(A,F24.14)') '<rho*excgc> =',EXC
         WRITE(*,'(A,F24.14)') '<rho*vxcgc> =',EXC-XCENC
         WRITE(*,'(A,F24.14)') '    xcencgc =',XCENC
         WRITE(*,'(A,F24.14)') '    xcencc  =',XCENCC
         WRITE(*,'(A,F24.14)') '     edcmu  =',EDCMU
      ENDIF

      RETURN
      END SUBROUTINE FEXCGS_METAGGA_NONCOL


!***************** SUBROUTINE FEXCGS_METAGGA_NONCOL_VDW ****************
!
!  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
! Mind CWORK and DWORK point actually to the same storagelocation
! similar to an EQUIVALENCE (CWORK(1),DWORK(1))
! the same for  (CWGRAD,DWGRAD) and   (CHTOT,DHTOT)
! so we can interchange both arrays arbitrarily
!
!***********************************************************************

      SUBROUTINE FEXCGS_METAGGA_NONCOL_VDW(LPOT,LMU,LLD, &
     &   NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
     &   CWGRAD,CHTOT,CWORK,CKINEDEN,DWGRAD,DHTOT,DWORK,DKINEDEN, &
     &   DENCOR,TAUC,DWORKG,DWORK1,DWORK2,DWORK3,DVC,DMUWORK, &
     &   DWORK4,DWORK5,DWORK6,DWORK7)
#ifdef _OPENACC
      USE mopenacc_struct_def
      USE tutoracc, ONLY : ACC_VTUTOR_CHECK
#endif
      USE prec
      USE lattice
      USE mpimy
      USE mgrid
      USE constant
      USE metalib
      USE setexm_struct_def, ONLY : IVDW_NL
      USE setxcmeta
      USE VDW_LL
      USE VDW_rVV10
      USE meta

      IMPLICIT COMPLEX(q) (C)

      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE (grid_3d)     GRIDC
      TYPE (latt)        LATT_CUR

      LOGICAL LPOT,LMU,LLD

      COMPLEX(q) CWGRAD(GRIDC%MPLWV,NCDIJ),CHTOT(GRIDC%MPLWV,NCDIJ), &
     &   CKINEDEN(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ)
      RGRID DWGRAD(DIMREAL(GRIDC%MPLWV),NCDIJ),DHTOT(DIMREAL(GRIDC%MPLWV),NCDIJ), &
     &   DKINEDEN(DIMREAL(GRIDC%MPLWV),NCDIJ),DWORK(DIMREAL(GRIDC%MPLWV),NCDIJ)

      RGRID DENCOR(GRIDC%RL%NP),TAUC(GRIDC%RL%NP)
      REAL(q) XCSIF(3,3),STRESS(3,3)
      REAL(q) DWORKG(GRIDC%RL%NP,NCDIJ/2),DWORK1(GRIDC%RL%NP,NCDIJ), &
     &   DWORK2(GRIDC%RL%NP,NCDIJ),DWORK3(GRIDC%RL%NP,NCDIJ),DVC(GRIDC%RL%NP)
      REAL(q) MAG_NORM,MAG_NORM_I,NABMAG(3),TAU_NORM,TAU_DOT_MDIR,LAP_NORM,LAP_DOT_MDIR

      RGRID  DMUWORK(DIMREAL(GRIDC%MPLWV),NCDIJ)

      REAL(q) DWORK4(GRIDC%RL%NP),DWORK6(GRIDC%RL%NP),DWORK7(GRIDC%RL%NP)
      RGRID   DWORK5(GRIDC%RL%NP)

      REAL(q) LAPLUP,LAPLDW,LAPLACIAN(GRIDC%RL%NP,NCDIJ)
      REAL(q) MUUP,MUDW,EDCMU
      REAL(q) CVMBJ

      REAL(q), ALLOCATABLE :: DWORKL(:,:),DENSHESS(:,:,:)
      REAL(q) DLAPU,DLAPD

      REAL(q) :: CHGMIN=1E-10_q, NABMIN=1E-10_q, TAUMIN=1E-10_q, LAPMIN=1E-10_q
!$ACC ROUTINE(LscMBJ,GET_CMBJ_PW) SEQ
!     TAUMIN=0 for MBJ is ok since there is no division by TAU
      IF ((ID_METAGGA == 30) .OR. (ID_METAGGA == 31)) TAUMIN=0._q

! set to one for error-dumps
#ifdef MPI
      NODE_ME=GRIDC%COMM%NODE_ME
      IONODE =GRIDC%COMM%IONODE
      IDUMP=0
#ifdef debug
      IF (NODE_ME==IONODE) IDUMP=1
#endif
#else
      IDUMP=0
#ifdef debug
      IDUMP=1
#endif
#endif

!$ACC ENTER DATA CREATE(LAPLACIAN) __IF_ASYNC__
!$ACC KERNELS PRESENT(LAPLACIAN) __IF_ASYNC__
      LAPLACIAN=0
!$ACC END KERNELS

      IF (LLD) THEN
         ALLOCATE(DWORKL(GRIDC%RL%NP,NCDIJ),DENSHESS(GRIDC%RL%NP,6,NCDIJ))
!$ACC ENTER DATA CREATE(DWORKL,DENSHESS) __IF_ASYNC__
!$ACC KERNELS PRESENT(DWORKL,DENSHESS) __IF_ASYNC__
         DWORKL=0
         DENSHESS=0
!$ACC END KERNELS
      ENDIF

      RINPL=1._q/GRIDC%NPLWV                    ! Scaling of Energy
      EVTOH=1._q/(2.*HSQDTM)*AUTOA5             ! KinEDens eV to Hartree

!=======================================================================
! First phase: Transform DENCOR (core charge) and
!  CHTOT (pseudo chargedensity) to real space
!=======================================================================
    spin: DO ISP=1,NCDIJ
      IF (ISP==1) THEN
      ! Add core charge density to pseudo charge density
!$ACC PARALLEL LOOP PRESENT(DWORK,DENCOR,DHTOT,LATT_CUR) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DWORK(I,ISP)=(DENCOR(I)+DHTOT(I,ISP))*RINPL/LATT_CUR%OMEGA
         ENDDO
      ELSE
!$ACC PARALLEL LOOP PRESENT(DWORK,DHTOT,LATT_CUR) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DWORK(I,ISP)=DHTOT(I,ISP)*RINPL/LATT_CUR%OMEGA
         ENDDO
      ENDIF

      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!=======================================================================
! now calculate the gradient of the chargedensity
!=======================================================================
!$ACC PARALLEL LOOP PRESENT(CWGRAD,CWORK) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWGRAD(I,ISP)=CWORK(I,ISP)
      ENDDO
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GX*CITPI
       ENDDO
! grad_x in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK1(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(CWORK,CWGRAD) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GY*CITPI
      ENDDO
! grad_y in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK2,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK2(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(CWORK,CWGRAD) __IF_ASYNC__
      DO  I=1,GRIDC%RC%NP
        CWORK(I,ISP)=CWGRAD(I,ISP)
      ENDDO
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)
         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWORK(I,ISP)=CWORK(I,ISP)*GZ*CITPI
      ENDDO
! grad_z in real space:
      CALL SETUNB(CWORK(1,ISP),GRIDC)
      CALL FFT3D(CWORK(1,ISP),GRIDC,1)
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK3,DWORK) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK3(I,ISP)= REAL( DWORK(I,ISP) ,KIND=q)
      ENDDO

! Compute the laplacian of the density

      IF (LLD) THEN

         ! and if laplacian-dependent functional is called, also compute density hessian
         ! indices for density hessian: 1 = xx, 2 = xy, 3 = xz, 4 = yy, 5 = yz, 6 = zz
         IDH = 0
         DO IDIR=1,3
           DO JDIR = IDIR,3
             IDH = IDH + 1
!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWGRAD,CWORK) PRIVATE(N1,N2,N3,NC,GI,GJ) __IF_ASYNC__
             DO I=1,GRIDC%RC%NP
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)

               GI = GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3)
               GJ = GRIDC%LPCTX(N1)*LATT_CUR%B(JDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(JDIR,2)&
               &      +GRIDC%LPCTZ(N3)*LATT_CUR%B(JDIR,3)
               CWORK(I,ISP) = CWGRAD(I,ISP) * GI*GJ*CITPI*CITPI
             ENDDO
             CALL SETUNB(CWORK(1,ISP),GRIDC)
             CALL FFT3D(CWORK(1,ISP),GRIDC,1)
             CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DENSHESS,DWORK) __IF_ASYNC__
             DO I=1,GRIDC%RL%NP
                DENSHESS(I,IDH,ISP) = REAL( DWORK(I,ISP) ,KIND=q)
             ENDDO
           ENDDO
         ENDDO
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DENSHESS) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
           LAPLACIAN(I,ISP) = DENSHESS(I,1,ISP) + DENSHESS(I,4,ISP) + DENSHESS(I,6,ISP)
         ENDDO

      ELSE

         DO IDIR=1,3
!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,LATT_CUR,CWGRAD) PRIVATE(N1,N2,N3,NC,GG) __IF_ASYNC__
            DO I=1,GRIDC%RC%NP  ! loop over all grid points NP in the reciprocal (RC) grid
               ! index of grid point along three reciprocal lattice vectors (N1, N2, N3)
               N1= MOD((I-1),GRIDC%RC%NROW) +1
               NC= (I-1)/GRIDC%RC%NROW+1
               N2= GRIDC%RC%I2(NC)
               N3= GRIDC%RC%I3(NC)
               ! convert to lattice vector component in direction x, y or z (corresponding to index J)
               GG=(GRIDC%LPCTX(N1)*LATT_CUR%B(IDIR,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(IDIR,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(IDIR,3))
               !write(*,*)'xcgrad:cwgrad ', CWORK4(I), CWGRAD(I), G1, G2, CITPI
               CWORK(I,ISP)=CWGRAD(I,ISP)*GG*GG*CITPI*CITPI
            ENDDO
            CALL SETUNB(CWORK(1,ISP),GRIDC)
            CALL FFT3D(CWORK(1,ISP),GRIDC,1)
            CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(LAPLACIAN,DWORK) __IF_ASYNC__
            DO I=1,GRIDC%RL%NP
               LAPLACIAN(I,ISP)=LAPLACIAN(I,ISP)+REAL( DWORK(I,ISP) ,KIND=q)
            ENDDO
         ENDDO

      ENDIF

      ENDDO spin

!=======================================================================
!  grad rho    d    f_xc
! ---------- * ------------      (Phys.Rev.B 50,7 (1994) 4954)
! |grad rho|   d |grad rho|
!
!  MIND: the factor OMEGA is difficult to understand:
!   1/N sum_r energy_density * rho *OMEGA = Energy
!   1/N sum_r energy_density * \bar rho   = Energy (\bar rho=rho*LATT_CUR%OMEGA)
!=======================================================================
      EXC=0; EDCMU=0; CVMBJ=CMBJ
!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORK1,DWORK2,DWORK3,DWORK4,DWORK7,DKINEDEN,DMUWORK,DWORK,DVC,LAPLACIAN,DWORKL) &
!$ACC PRIVATE(MAG_NORM,MAG_NORM_I,RHO1,RHO2,NABMAG,ABSNABUP,ABSNABDW,ABSNAB,TAU_NORM,TAU_DOT_MDIR,TAUU,TAUD, &
!$ACC LAP_NORM,LAP_DOT_MDIR,LAPLUP,LAPLDW,EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,DLAPU,DLAPD,MUUP,MUDW,RHO) &
!$ACC FIRSTPRIVATE(CVMBJ) REDUCTION(+:EXC,EDCMU) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
!
! | m |
!
         MAG_NORM=SQRT(ABS( &
        &    DHTOT(I,2)*DHTOT(I,2)+DHTOT(I,3)*DHTOT(I,3)+DHTOT(I,4)*DHTOT(I,4)))
         MAG_NORM_I=1._q/MAX(MAG_NORM,CHGMIN)
!
! RHO1: \rho_up   = ( \rho_tot + | m | )/2
! RHO2: \rho_down = ( \rho_tot - | m | )/2
!
         RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)+MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
         RHO2= MAX(REAL((DHTOT(I,1)+DENCOR(I)-MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

! store total charge for non-local vdW-DF
         DWORK4(I)=MAX(REAL((DENCOR(I)+DHTOT(I,1))/LATT_CUR%OMEGA, kind=q),CHGMIN)
!
! \nabla | m |
!
         NABMAG(1)=(DWORK1(I,2)*DHTOT(I,2)+DWORK1(I,3)*DHTOT(I,3)+DWORK1(I,4)*DHTOT(I,4))*MAG_NORM_I
         NABMAG(2)=(DWORK2(I,2)*DHTOT(I,2)+DWORK2(I,3)*DHTOT(I,3)+DWORK2(I,4)*DHTOT(I,4))*MAG_NORM_I
         NABMAG(3)=(DWORK3(I,2)*DHTOT(I,2)+DWORK3(I,3)*DHTOT(I,3)+DWORK3(I,4)*DHTOT(I,4))*MAG_NORM_I
!
! | ( \nabla \rho + \nabla | m | )/2 |
!
         ABSNABUP=SQRT( &
        &            (DWORK1(I,1)+NABMAG(1))*(DWORK1(I,1)+NABMAG(1)) + &
        &             (DWORK2(I,1)+NABMAG(2))*(DWORK2(I,1)+NABMAG(2)) + &
        &              (DWORK3(I,1)+NABMAG(3))*(DWORK3(I,1)+NABMAG(3)) ) * 0.5_q
!
! | ( \nabla \rho - \nabla | m | )/2 |
!
         ABSNABDW=SQRT( &
        &            (DWORK1(I,1)-NABMAG(1))*(DWORK1(I,1)-NABMAG(1)) + &
        &             (DWORK2(I,1)-NABMAG(2))*(DWORK2(I,1)-NABMAG(2)) + &
        &              (DWORK3(I,1)-NABMAG(3))*(DWORK3(I,1)-NABMAG(3)) ) * 0.5_q
!
! | \nabla \rho |
!
         ABSNAB=SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1)+DWORK3(I,1)*DWORK3(I,1))
!
! Refill DWORK[1..3](:,2) with ( \nabla \rho - \nabla | m | )/2
!
         DWORK1(I,2)=(DWORK1(I,1)-NABMAG(1))*0.5_q
         DWORK2(I,2)=(DWORK2(I,1)-NABMAG(2))*0.5_q
         DWORK3(I,2)=(DWORK3(I,1)-NABMAG(3))*0.5_q
!
! Refill DWORK[1..3](:,1) with ( \nabla \rho + \nabla | m | )/2
!
         DWORK1(I,1)=(DWORK1(I,1)+NABMAG(1))*0.5_q
         DWORK2(I,1)=(DWORK2(I,1)+NABMAG(2))*0.5_q
         DWORK3(I,1)=(DWORK3(I,1)+NABMAG(3))*0.5_q

!#define  correlation_ABS_DRHOUP_ABS_DRHOD
#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
         ABSNAB=ABSNABUP+ABSNABDW
#endif
! store total gradient for non-local vdW-DF
         DWORK7(I)=ABSNAB
         !
         ! | m |
         !
         TAU_NORM=MAX(SQRT(ABS( &
        &    DKINEDEN(I,2)*DKINEDEN(I,2)+DKINEDEN(I,3)*DKINEDEN(I,3)+DKINEDEN(I,4)*DKINEDEN(I,4))), TAUMIN)
         TAU_DOT_MDIR=(DHTOT(I,2)*DKINEDEN(I,2)+DHTOT(I,3)*DKINEDEN(I,3)+DHTOT(I,4)*DKINEDEN(I,4))*MAG_NORM_I
         !
         ! kinetic energy density
         ! TAUU: \tau_up   = ( \tau_tot + | m | )/2
         ! TAUD: \tau_down = ( \tau_tot - | m | )/2
         !
!         TAUU=MAX(REAL((DKINEDEN(I,1)+TAU_NORM)*0.5_q,KIND=q), TAUMIN)
!         TAUD=MAX(REAL((DKINEDEN(I,1)-TAU_NORM)*0.5_q,KIND=q), TAUMIN)
         TAUU=MAX(REAL((DKINEDEN(I,1)+TAU_DOT_MDIR)*0.5_q+TAUC(I)*0.5_q,KIND=q), TAUMIN)
         TAUD=MAX(REAL((DKINEDEN(I,1)-TAU_DOT_MDIR)*0.5_q+TAUC(I)*0.5_q,KIND=q), TAUMIN)

         !
         ! | m |
         !
         LAP_NORM=MAX(SQRT(ABS( &
        &    LAPLACIAN(I,2)*LAPLACIAN(I,2)+LAPLACIAN(I,3)*LAPLACIAN(I,3)+LAPLACIAN(I,4)*LAPLACIAN(I,4))), LAPMIN)
         LAP_DOT_MDIR=(DHTOT(I,2)*LAPLACIAN(I,2)+DHTOT(I,3)*LAPLACIAN(I,3)+DHTOT(I,4)*LAPLACIAN(I,4))*MAG_NORM_I
         !
         ! Laplacian of the density
!        LAPLUP=REAL((LAPLACIAN(I,1)+LAP_NORM)/2,KIND=q)
!        LAPLDW=REAL((LAPLACIAN(I,1)-LAP_NORM)/2,KIND=q)
         LAPLUP=REAL((LAPLACIAN(I,1)+LAP_DOT_MDIR)*0.5_q,KIND=q)
         LAPLDW=REAL((LAPLACIAN(I,1)-LAP_DOT_MDIR)*0.5_q,KIND=q)

         ! The CMBJ parameter may depend on the spatial position,
         ! if so, it is set here to the right entry in CMBJ_AUX
         CALL GET_CMBJ_PW(I,CVMBJ)

         CALL METAGGASPIN(&
        &   RHO1*AUTOA3,RHO2*AUTOA3,ABSNABUP*AUTOA4,ABSNABDW*AUTOA4,ABSNAB*AUTOA4, &
        &   LAPLUP*AUTOA5,LAPLDW*AUTOA5,TAUU*EVTOH,TAUD*EVTOH, &
        &   EXCL,DEXC1,DEXC2,DVXC1,DVXC2,DVC_,MUUP,MUDW,DLAPU,DLAPD,CVMBJ)

         RHO=RHO1+RHO2

         IF (LscMBJ()) CALL SUM_GRHO_OVER_RHO_PW(RHO*AUTOA3,ABSNAB*AUTOA4)

         EXC=EXC+EXCL*RHO*RYTOEV*LATT_CUR%OMEGA
         DVXC1=DVXC1*RYTOEV*AUTOA
         DVXC2=DVXC2*RYTOEV*AUTOA
         DVC_ =DVC_ *RYTOEV*AUTOA
         IF (LLD) THEN
           DLAPU=DLAPU*RYTOEV*AUTOA2
           DLAPD=DLAPD*RYTOEV*AUTOA2
         ENDIF

         ! Double counting contribution stemming from dExc/d\mu
         EDCMU=EDCMU+0.5_q*(MUUP*TAUU+MUDW*TAUD-(MUUP+MUDW)*TAUC(I)*0.5_q)*LATT_CUR%OMEGA

         MUUP=0.5_q*MUUP*RYTOEV*AUTOA2 ! HSQDTM = (plancks CONSTANT/(2*PI))**2/(2*ELECTRON MASS)
         MUDW=0.5_q*MUDW*RYTOEV*AUTOA2

#ifdef correlation_ABS_DRHOUP_ABS_DRHOD
         DVXC1=DVXC1+DVC_
         DVXC2=DVXC2+DVC_
         DVC_=0
#endif

!test
!         DVXC1=0
!         DVXC2=0
!         DVC_ =0
!test
         ! Store d f_xc / d \tau_up,down in DMUWORK if required
         IF (LMU) THEN
            DMUWORK(I,1)=MUUP
            DMUWORK(I,2)=MUDW
         ENDIF

!
!   store d f/ d (|d rho| ) / |d rho|  in DWORK
!
         DWORK(I,1)  = DVXC1 / MAX(ABSNABUP,NABMIN)
         DWORK(I,2)  = DVXC2 / MAX(ABSNABDW,NABMIN)
         DVC(I)      = DVC_  / MAX(ABSNAB,NABMIN)
!
!   store d f/ d rho  in DWORKG
!
         DWORKG(I,1) = DEXC1*RYTOEV
         DWORKG(I,2) = DEXC2*RYTOEV
!
!   storing laplacian
!
         IF (LLD) THEN
            DWORKL(I,1) = DLAPU
            DWORKL(I,2) = DLAPD
         ENDIF

      ENDDO
!$ACC EXIT DATA DELETE(LAPLACIAN) __IF_ASYNC__
DOACC CALL ACC_VTUTOR_CHECK()

!=======================================================================
! non-local vdW-DF contributions
!=======================================================================
!$ACC KERNELS PRESENT(DWORK5,DWORK6) __IF_ASYNC__
       DWORK5=0._q
       DWORK6=0._q
!$ACC END KERNELS
       IF (IVDW_NL==1) THEN
          CALL VDW_NONLOC( DWORK4, DWORK5, DWORK6, DWORK7, EXC, GRIDC, LATT_CUR, STRESS, 2)
       ELSEIF (IVDW_NL==2) THEN
          CALL VDW_NONLOC_RVV10( DWORK4, DWORK5, DWORK6, DWORK7, EXC, GRIDC, LATT_CUR, STRESS, 2)
       ENDIF
!$ACC PARALLEL PRESENT(DWORK,DWORK5,DWORK1,DWORK2,DWORK3,DWORKG,DWORK6) __IF_ASYNC__
!$ACC LOOP GANG VECTOR
       DO I=1,GRIDC%RL%NP
          DWORK(I,1)=DWORK(I,1)+DWORK5(I)/ MAX(SQRT(DWORK1(I,1)*DWORK1(I,1)+DWORK2(I,1)*DWORK2(I,1) &
      &             +DWORK3(I,1)*DWORK3(I,1)),1.E-10_q)
          DWORK(I,2)=DWORK(I,2)+DWORK5(I)/ MAX(SQRT(DWORK1(I,2)*DWORK1(I,2)+DWORK2(I,2)*DWORK2(I,2) &
      &             +DWORK3(I,2)*DWORK3(I,2)),1.E-10_q)
       ENDDO

!$ACC LOOP GANG VECTOR
       DO I=1,GRIDC%RL%NP
          DWORKG(I,1)=DWORKG(I,1)+DWORK6(I)
          DWORKG(I,2)=DWORKG(I,2)+DWORK6(I)
       ENDDO
!$ACC END PARALLEL

!**********************************************************************
! TR: update the values for local SC CMBJ
!**********************************************************************

      CALL UPDATE_CMBJ_AUX(GRIDC,LATT_CUR,DHTOT,DENCOR,DWORK1,DWORK2,DWORK3,NCDIJ)

!=======================================================================
! gradient terms in stress tensor
!          d    f_xc     grad rho  x grad rho
! sum_r   ------------   --------------------- * LATT_CUR%OMEGA
!         d |grad rho|        |grad rho|
!=======================================================================
      SIF11=0
      SIF22=0
      SIF33=0
      SIF12=0
      SIF23=0
      SIF31=0
      IF ((ID_METAGGA /= 30) .AND. (ID_METAGGA /= 31)) THEN
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC REDUCTION(+:SIF11,SIF22,SIF33,SIF12,SIF23,SIF31) __IF_ASYNC__
      DO ISP=1,2
      DO I=1,GRIDC%RL%NP
         SIF11=SIF11+DWORK1(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)
         SIF22=SIF22+DWORK2(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
         SIF33=SIF33+DWORK3(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
         SIF12=SIF12+DWORK1(I,ISP)*DWORK2(I,ISP)*DWORK(I,ISP)
         SIF23=SIF23+DWORK2(I,ISP)*DWORK3(I,ISP)*DWORK(I,ISP)
         SIF31=SIF31+DWORK3(I,ISP)*DWORK1(I,ISP)*DWORK(I,ISP)

         SIF11=SIF11+DWORK1(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
         SIF22=SIF22+DWORK2(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
         SIF33=SIF33+DWORK3(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
         SIF12=SIF12+DWORK1(I,ISP)*(DWORK2(I,1)+DWORK2(I,2))*DVC(I)
         SIF23=SIF23+DWORK2(I,ISP)*(DWORK3(I,1)+DWORK3(I,2))*DVC(I)
         SIF31=SIF31+DWORK3(I,ISP)*(DWORK1(I,1)+DWORK1(I,2))*DVC(I)
      ENDDO
      ENDDO
      SIF11=SIF11*RINPL*LATT_CUR%OMEGA
      SIF22=SIF22*RINPL*LATT_CUR%OMEGA
      SIF33=SIF33*RINPL*LATT_CUR%OMEGA
      SIF12=SIF12*RINPL*LATT_CUR%OMEGA
      SIF23=SIF23*RINPL*LATT_CUR%OMEGA
      SIF31=SIF31*RINPL*LATT_CUR%OMEGA
      ENDIF   ! ID_METAGGA /= 30 and 31

!=======================================================================
! calculate
!              d    f_xc     grad rho
!        div  (------------  --------  )
!              d |grad rho| |grad rho|
!
! in reciprocal space
!=======================================================================

!$ACC PARALLEL LOOP PRESENT(DWORK1,DWORK2,DWORK3,DWORK,DVC) &
!$ACC& PRIVATE(ANAB1U,ANAB2U,ANAB3U,ANAB1D,ANAB2D,ANAB3D) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
         ANAB1U= DWORK1(I,1)
         ANAB2U= DWORK2(I,1)
         ANAB3U= DWORK3(I,1)
         ANAB1D= DWORK1(I,2)
         ANAB2D= DWORK2(I,2)
         ANAB3D= DWORK3(I,2)

         DWORK1(I,1) = ANAB1U* DWORK(I,1) + (ANAB1U+ANAB1D) * DVC(I)
         DWORK2(I,1) = ANAB2U* DWORK(I,1) + (ANAB2U+ANAB2D) * DVC(I)
         DWORK3(I,1) = ANAB3U* DWORK(I,1) + (ANAB3U+ANAB3D) * DVC(I)

         DWORK1(I,2) = ANAB1D* DWORK(I,2) + (ANAB1U+ANAB1D) * DVC(I)
         DWORK2(I,2) = ANAB2D* DWORK(I,2) + (ANAB2U+ANAB2D) * DVC(I)
         DWORK3(I,2) = ANAB3D* DWORK(I,2) + (ANAB3U+ANAB3D) * DVC(I)
      ENDDO

      spin2: DO ISP=1,2
! x-component:
!DIR$ IVDEP
!$DIR FORCE_VECTOR
!OCL NOVREC
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK1) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK1(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GX) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GX=(GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
         CWGRAD(I,ISP)=CWORK(I,ISP)*GX*CITPI
      ENDDO

! y-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK2) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK2(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GY) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GY=(GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GY*CITPI
      ENDDO

! z-component:
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORK3) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
        DWORK(I,ISP) = DWORK3(I,ISP)
      ENDDO
      CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
      CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
      CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,CWORK,CWGRAD,LATT_CUR) PRIVATE(N1,N2,N3,NC,GZ) __IF_ASYNC__
      DO I=1,GRIDC%RC%NP
         N1= MOD((I-1),GRIDC%RC%NROW) +1
         NC= (I-1)/GRIDC%RC%NROW+1
         N2= GRIDC%RC%I2(NC)
         N3= GRIDC%RC%I3(NC)

         GZ=(GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
         CWGRAD(I,ISP)=CWGRAD(I,ISP)+CWORK(I,ISP)*GZ*CITPI
      ENDDO

      CALL SETUNB(CWGRAD(1,ISP),GRIDC)
      CALL FFT3D(CWGRAD(1,ISP),GRIDC,1)
      CALL OPSYNC(CWGRAD(1,ISP),DWGRAD(1,ISP),GRIDC%NPLWV)

      ENDDO spin2


!=======================================================================
! laplacian terms in stress tensor
!                     d  f_xc         d^2 n_sigma
! sum_(r,sigma)    ------------      ------------- * LATT_CUR%OMEGA
!                  d lap rho_sigma     d r_i d r_j
!=======================================================================

! if ispin == 1, then denshess(:,:,1) is the Hessian of the total density
! dworkl is still d f_xc / d lap rho_sigma, so the sum will still yield
! twice the sum over a single spin channel. No additional factor needed

! if ispin == 2, then denshess(:,:,sigma) is the Hessian for each spin channel sigma,
! no correcting factor needed

! this has to appear here rather than with the gradient contribution to
! the stress tensor because DWORK is required for the gradient contributions
! to the XC potential

      IF (LLD) THEN
        SIFLAP11=0
        SIFLAP22=0
        SIFLAP33=0
        SIFLAP12=0
        SIFLAP23=0
        SIFLAP31=0
!$ACC PARALLEL LOOP COLLAPSE(2) PRESENT(DWORKL,DENSHESS) &
!$ACC REDUCTION(+:SIFLAP11,SIFLAP22,SIFLAP33,SIFLAP12,SIFLAP23,SIFLAP31) __IF_ASYNC__
        SLST: DO ISP=1,2
          DO I=1,GRIDC%RL%NP
            SIFLAP11=SIFLAP11 + 2._q*DWORKL(I,ISP)*DENSHESS(I,1,ISP)
            SIFLAP22=SIFLAP22 + 2._q*DWORKL(I,ISP)*DENSHESS(I,4,ISP)
            SIFLAP33=SIFLAP33 + 2._q*DWORKL(I,ISP)*DENSHESS(I,6,ISP)
            SIFLAP12=SIFLAP12 + 2._q*DWORKL(I,ISP)*DENSHESS(I,2,ISP)
            SIFLAP23=SIFLAP23 + 2._q*DWORKL(I,ISP)*DENSHESS(I,5,ISP)
            SIFLAP31=SIFLAP31 + 2._q*DWORKL(I,ISP)*DENSHESS(I,3,ISP)
          ENDDO
        ENDDO SLST
        SIF11=SIF11 + SIFLAP11*RINPL*LATT_CUR%OMEGA
        SIF22=SIF22 + SIFLAP22*RINPL*LATT_CUR%OMEGA
        SIF33=SIF33 + SIFLAP33*RINPL*LATT_CUR%OMEGA
        SIF12=SIF12 + SIFLAP12*RINPL*LATT_CUR%OMEGA
        SIF23=SIF23 + SIFLAP23*RINPL*LATT_CUR%OMEGA
        SIF31=SIF31 + SIFLAP31*RINPL*LATT_CUR%OMEGA

!=======================================================================
! calculate
!               d    f_xc
!        lap ( ------------ )
!               d lap rho
!
! in reciprocal space
!=======================================================================

        SPINLAP: DO ISP=1,2
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORK(I,ISP) = DWORKL(I,ISP)
          ENDDO

          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
          CALL FFT3D(CWORK(1,ISP),GRIDC,-1)
          CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, CWORK(1,ISP))

!$ACC PARALLEL LOOP PRESENT(GRIDC,LATT_CUR,CWORK) PRIVATE(N1,N2,N3,NC,GX,GY,GZ,GG) __IF_ASYNC__
          DO I=1,GRIDC%RC%NP
             N1= MOD((I-1),GRIDC%RC%NROW) +1
             NC= (I-1)/GRIDC%RC%NROW+1
             N2= GRIDC%RC%I2(NC)
             N3= GRIDC%RC%I3(NC)

             GX = GRIDC%LPCTX(N1)*LATT_CUR%B(1,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(1,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
             GY = GRIDC%LPCTX(N1)*LATT_CUR%B(2,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(2,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
             GZ = GRIDC%LPCTX(N1)*LATT_CUR%B(3,1) &
            &    + GRIDC%LPCTY(N2)*LATT_CUR%B(3,2) &
            &    + GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)
             GG = GX**2 + GY**2 + GZ**2

             CWORK(I,ISP) = GG*CITPI*CITPI*CWORK(I,ISP)
          ENDDO

          CALL SETUNB(CWORK(1,ISP),GRIDC)
          CALL FFT3D(CWORK(1,ISP),GRIDC,1)
          CALL OPSYNC(DWORK(1,ISP),CWORK(1,ISP),GRIDC%NPLWV)
!$ACC PARALLEL LOOP PRESENT(DWORK,DWORKL) __IF_ASYNC__
          DO I=1,GRIDC%RL%NP
            DWORKL(I,ISP) = REAL(DWORK(I,ISP),KIND=q)
          ENDDO

        ENDDO SPINLAP
      ENDIF

!=======================================================================
! Now prepare the rest:
! (store rho in DWORK3 and quantity of above in DWORK1)
!=======================================================================
      XCENC=0._q
      CVZERO=0._q
      XCENCC=0._q

!$ACC PARALLEL LOOP PRESENT(DHTOT,DENCOR,LATT_CUR,DWORKG,DWGRAD,DWORK,DWORKL) &
!$ACC& REDUCTION(+:CVZERO,XCENCC,XCENC) PRIVATE(MAG_NORM,RHO1,RHO2,VXC1,VXC2,VXC) __IF_ASYNC__
      DO I=1,GRIDC%RL%NP
!
! | m |
!
         MAG_NORM=SQRT(ABS(DHTOT(I,2)*DHTOT(I,2)+ DHTOT(I,3)*DHTOT(I,3) + DHTOT(I,4)*DHTOT(I,4)))
!
! RHO1: \rho_up   = ( \rho_tot + | m | )/2
! RHO2: \rho_down = ( \rho_tot - | m | )/2
!
         RHO1= MAX(REAL((DHTOT(I,1)+DENCOR(I)+MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)
         RHO2= MAX(REAL((DHTOT(I,1)+DENCOR(I)-MAG_NORM)*0.5_q/LATT_CUR%OMEGA ,KIND=q), CHGMIN)

         VXC1=DWORKG(I,1)- REAL( DWGRAD(I,1) ,KIND=q) *RINPL
         VXC2=DWORKG(I,2)- REAL( DWGRAD(I,2) ,KIND=q) *RINPL
         IF (LLD) THEN
            VXC1=VXC1 + DWORKL(I,1)*RINPL
            VXC2=VXC2 + DWORKL(I,2)*RINPL
         ENDIF
         DWORK(I,1)=VXC1
         DWORK(I,2)=VXC2
         VXC = 0.5_q*(VXC1+VXC2)
         CVZERO=CVZERO+VXC
         XCENCC=XCENCC-VXC1*RHO1*LATT_CUR%OMEGA-VXC2*RHO2*LATT_CUR%OMEGA
         XCENC=XCENC  -VXC1* REAL( (DHTOT(I,1)+MAG_NORM)*0.5_q ,KIND=q) &
        &             -VXC2* REAL( (DHTOT(I,1)-MAG_NORM)*0.5_q ,KIND=q)
      ENDDO
!$ACC EXIT DATA DELETE(LAPLACIAN,DWORKL,DENSHESS) __IF_ASYNC__

      CVZERO=CVZERO*RINPL
      XCENC =(XCENC+EXC-EDCMU)*RINPL
      XCENCC=(XCENCC+EXC)*RINPL
      EXC   =EXC*RINPL
      EDCMU =EDCMU*RINPL

      SIF11=SIF11-XCENCC
      SIF22=SIF22-XCENCC
      SIF33=SIF33-XCENCC
      XCSIF(1,1)=SIF11
      XCSIF(2,2)=SIF22
      XCSIF(3,3)=SIF33
      XCSIF(1,2)=SIF12
      XCSIF(2,1)=SIF12
      XCSIF(2,3)=SIF23
      XCSIF(3,2)=SIF23
      XCSIF(3,1)=SIF31
      XCSIF(1,3)=SIF31

      XCSIF = XCSIF - STRESS

      CALLMPI( M_sum_3(GRIDC%COMM, EXC, XCENC, EDCMU))
      CALLMPI( M_sum_d(GRIDC%COMM, XCSIF, 9))
      CALLMPI( M_sum_z(GRIDC%COMM,CVZERO,1))

! Test dumps:
      IF (IDUMP/=0) THEN
         WRITE(*,'(A,F24.14)') '<rho*excgc> =',EXC
         WRITE(*,'(A,F24.14)') '<rho*vxcgc> =',EXC-XCENC
         WRITE(*,'(A,F24.14)') '    xcencgc =',XCENC
         WRITE(*,'(A,F24.14)') '    xcencc  =',XCENCC
         WRITE(*,'(A,F24.14)') '     edcmu  =',EDCMU
      ENDIF

      RETURN
      END SUBROUTINE FEXCGS_METAGGA_NONCOL_VDW


      SUBROUTINE MUxTAU(GRIDC,NCDIJ,LATT_CUR,DMUTOT,DKINEDEN,TAUC,DE)
#ifdef _OPENACC
      USE mopenacc_struct_def
#endif
      USE prec
      USE constant
      USE lattice
      USE mgrid
      USE string, ONLY: str
      USE tutor, ONLY: vtutor

      IMPLICIT COMPLEX(q) (C)
      IMPLICIT REAL(q) (A-B,D-H,O-Z)

      TYPE(grid_3d) GRIDC
      TYPE(latt) LATT_CUR
      INTEGER NCDIJ
      RGRID DMUTOT(DIMREAL(GRIDC%MPLWV),NCDIJ)
      RGRID DKINEDEN(DIMREAL(GRIDC%MPLWV),NCDIJ),TAUC(GRIDC%RL%NP)
      REAL(q) DE
      ! local variables
      INTEGER I

      DE=0
      RINPL=1._q/GRIDC%NPLWV

      IF (NCDIJ==1) THEN
!$ACC PARALLEL LOOP REDUCTION(+:DE) PRESENT(DMUTOT,DKINEDEN,TAUC) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DE=DE+DMUTOT(I,1)*CHGCONJG(DKINEDEN(I,1)+TAUC(I))
         ENDDO
      ELSEIF (NCDIJ==2) THEN
!$ACC PARALLEL LOOP REDUCTION(+:DE) PRESENT(DMUTOT,DKINEDEN,TAUC) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DE=DE+DMUTOT(I,1)*CHGCONJG(DKINEDEN(I,1)+TAUC(I)/2._q)+ &
           &       DMUTOT(I,2)*CHGCONJG(DKINEDEN(I,2)+TAUC(I)/2._q)
         ENDDO
      ELSEIF (NCDIJ==4) THEN
!$ACC PARALLEL LOOP REDUCTION(+:DE) PRESENT(DMUTOT,DKINEDEN,TAUC) __IF_ASYNC__
         DO I=1,GRIDC%RL%NP
            DE=DE+DMUTOT(I,1)*CHGCONJG(DKINEDEN(I,1)+TAUC(I)/2._q)+ &
           &       DMUTOT(I,2)*CHGCONJG(DKINEDEN(I,2))+DMUTOT(I,3)*CHGCONJG(DKINEDEN(I,3))+ &
           &        DMUTOT(I,4)*CHGCONJG((DKINEDEN(I,4)+TAUC(I)/2._q))
         ENDDO
      ELSE
         CALL vtutor%bug("MUxTAU: internal error, NCDIJ= " // str(NCDIJ), __FILE__, __LINE__)
      ENDIF

      DE=DE*RINPL*LATT_CUR%OMEGA/(RYTOEV*AUTOA2)

      CALLMPI( M_sum_d(GRIDC%COMM,DE,1))

      RETURN
      END SUBROUTINE MUxTAU


!************************** M E T A G G A . F ******************************
! Implementation of the METAGGA according to
! Perdew, Kurth, Zupan and Blaha (PRL 82, 2544)
!
! All subroutines in this File were written by Robin Hirschl in Dec. 2000
! using templates supplied by Georg Kresse
! Thanks to Georg for his encouragement and support
!
!***************************************************************************


!************************ SUBROUTINE GGASPINCOR ************************
!
!  calculate the correlation energy density according to the
!  Perdew, Burke and Ernzerhof functional
!
!***********************************************************************

    SUBROUTINE GGASPINCOR(D1,D2,DDA, EC)
!$ACC ROUTINE SEQ

!     D1   density up
!     D2   density down
!     DDA  |gradient of the total density|

      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (THRD=1._q/3._q)
!$ACC ROUTINE(corpbe) SEQ

      D=D1+D2
      DTHRD=exp(log(D)*THRD)
      RS=(0.75_q/PI)**THRD/DTHRD

      ZETA=(D1-D2)/D
      ZETA=MIN(MAX(ZETA,-0.9999999999999_q),0.9999999999999_q)

      FK=(3._q*PI*PI)**THRD*DTHRD
      SK = SQRT(4.0_q*FK/PI)
      G = (exp((2*THRD)*log(1._q+ZETA)) &
                +exp((2*THRD)*log(1._q-ZETA)))/2._q
      T = DDA/(D*2._q*SK*G)

      CALL corpbe(RS,ZETA,ECLDA,ECD1LDA,ECD2LDA,G,SK, &
           T,EC,ECD1,ECD2,ECQ,.TRUE.)

      EC  =(EC  +ECLDA)

      RETURN
    END SUBROUTINE GGASPINCOR

!************************ SUBROUTINE GGACOR *****************************
!
!  calculate the correlation energy density according to the
!  Perdew, Burke and Ernzerhof functional
!
!***********************************************************************

    SUBROUTINE GGACOR(D, DD, EC)
      USE prec
      USE constant
      IMPLICIT REAL(q) (A-H,O-Z)
      PARAMETER (THRD=1._q/3._q)

      IF (D<0) THEN
         EC   = 0._q
         RETURN
      ENDIF

      DTHRD=exp(log(D)*THRD)
      RS=(0.75_q/PI)**THRD/DTHRD
      FK=(3._q*PI*PI)**THRD*DTHRD
      SK = SQRT(4.0_q*FK/PI)

      IF(D>1.E-10_q)THEN
         T=DD/(D*SK*2._q)
      ELSE
         T=0.0_q
      ENDIF

      CALL CORunspPBE(RS,ECLDA,ECDLDA,SK, &
           T,EC,ECD,ECDD,.TRUE.)

      EC = (EC+ECLDA)

      RETURN
    END SUBROUTINE GGACOR


!=======================================================================
!
! SUBROUTINE TAU_PW
!
! This subroutine calculates the kinetic energy of the PW part of the
! wavefunctions (0.5*|grad psi|**2) on GRIDC
!
! INPUT: GRIDC,  LATT_CUR, SYMM, NIOND, W, WDES
! OUTPUT: TAU(GRIDC%MPLWC, WDES%NCDIJ)
!
! Robin Hirschl 20001221
!=======================================================================

    SUBROUTINE TAU_PW(GRID,GRID_SOFT,GRIDC,SOFT_TO_C,LATT_CUR,SYMM,NIOND,W,WDES,TAU)
#ifdef _OPENACC
      USE mopenacc
#endif
      USE prec
      USE lattice
      USE mgrid
      USE msymmetry
      USE base
      USE wave
      USE mpimy
      USE constant

      IMPLICIT NONE

      TYPE (grid_3d)     GRIDC,GRID,GRID_SOFT
      TYPE (latt)        LATT_CUR
      TYPE (transit)     SOFT_TO_C
      TYPE (symmetry)    SYMM
      TYPE (wavespin)    W
      TYPE (wavedes)     WDES
! result
      RGRID ::  TAU(DIMREAL(GRIDC%MPLWV),WDES%NCDIJ)  ! kinetic energy density
! work arrays
      RGRID,  ALLOCATABLE :: CKIN(:)
      COMPLEX(q), POINTER :: CFA(:),CFB(:),CFAR(:),CFBR(:)

      INTEGER :: ISPINOR,ISPINOR_
      INTEGER :: MPLWV,ISP,N,NK,NPL,IDIR,I,NIOND
      REAL(q) :: WEIGHT,G1,G2,G3
      COMPLEX(q) :: GC

#ifdef _OPENACC
!$ACC WAIT IF(ACC_EXEC_ON)
      PUSH_ACC_EXEC_ON(.TRUE.)

      ACC_ASYNC_Q = ACC_ASYNC_ASYNC

      CALL ACC_COPYIN_TYPED_VAR(WDES)
      CALL ACC_COPYIN_TYPED_VAR(W)
      CALL ACC_COPYIN_TYPED_VAR(GRID)
      CALL ACC_COPYIN_TYPED_VAR(GRID_SOFT)
      CALL ACC_COPYIN_TYPED_VAR(GRIDC)
      CALL ACC_COPYIN_TYPED_VAR(SOFT_TO_C)

!$ACC ENTER DATA COPYIN(LATT_CUR) __IF_ASYNC__
!$ACC ENTER DATA CREATE(TAU) __IF_ASYNC__
#endif

      MPLWV=MAX(GRID%MPLWV,GRID_SOFT%MPLWV)

      ALLOCATE(CFA(WDES%NRPLWV),CFAR(MPLWV),CKIN(DIMREAL(MPLWV)))

      IF (WDES%LNONCOLLINEAR) THEN
! the non-collinear case needs work arrays for two separate spinor components
         ALLOCATE(CFB(WDES%NRPLWV),CFBR(MPLWV))
      ELSE
! in the collinear case there is no second spinor component
         CFB=>CFA ; CFBR=>CFAR
      ENDIF

!$ACC ENTER DATA CREATE(CFA,CFB,CFAR,CFBR,CKIN) __IF_ASYNC__

!$ACC KERNELS PRESENT(TAU) __IF_ASYNC__
      TAU=0
!$ACC END KERNELS

!$ACC UPDATE SELF(W%FERWE) __IF_ASYNC__
!$ACC WAIT(ACC_ASYNC_Q) IF(ACC_EXEC_ON)
spin: DO ISP=1,WDES%ISPIN

      DO ISPINOR =0,WDES%NRSPINORS-1
      DO ISPINOR_=0,WDES%NRSPINORS-1

!$ACC KERNELS PRESENT(CFAR,CFBR,CKIN) __IF_ASYNC__
      CKIN=0 ; CFAR=0 ; IF (WDES%LNONCOLLINEAR) CFBR=0
!$ACC END KERNELS

      kpoints: DO NK=1,WDES%NKPTS
#ifdef MPI
         IF (MOD(NK-1,WDES%COMM_KINTER%NCPU).NE.WDES%COMM_KINTER%NODE_ME-1) CYCLE kpoints
#endif
         NPL=WDES%NGVECTOR(NK)

         bands: DO N=1,WDES%NBANDS

            WEIGHT=WDES%RSPIN*WDES%WTKPT(NK)*W%FERWE(N,NK,ISP)/LATT_CUR%OMEGA/GRID_SOFT%NPLWV

            dirs: DO IDIR=1,3
!$ACC KERNELS PRESENT(CFA,CFB) __IF_ASYNC__
               CFA=0 ; IF (WDES%LNONCOLLINEAR) CFB=0
!$ACC END KERNELS
! loop over plane wave coefficients
!$ACC PARALLEL LOOP GANG VECTOR PRESENT(WDES,LATT_CUR,W,CFA) PRIVATE(G1,G2,G3,GC) __IF_ASYNC__
               DO I=1,NPL
! get k-vector of respective k-point and coefficient
                  G1=WDES%IGX(I,NK)+WDES%VKPT(1,NK)
                  G2=WDES%IGY(I,NK)+WDES%VKPT(2,NK)
                  G3=WDES%IGZ(I,NK)+WDES%VKPT(3,NK)
                  GC=(G1*LATT_CUR%B(IDIR,1)+G2*LATT_CUR%B(IDIR,2)+G3*LATT_CUR%B(IDIR,3))
                  CFA(I)=GC*W%CPTWFP(I+ISPINOR *NPL,N,NK,ISP)*CITPI
               ENDDO
! fourier trafo of gradient of wave-function
               CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CFAR(1),CFA(1),GRID)

! and for LNONCOLLINEAR=T repeat this procedure for the second spinor component
               IF (WDES%LNONCOLLINEAR) THEN
! loop over plane wave coefficients
!$ACC PARALLEL LOOP GANG VECTOR PRESENT(WDES,LATT_CUR,W,CFB) PRIVATE(G1,G2,G3,GC) __IF_ASYNC__
               DO I=1,NPL
! get k-vector of respective k-point and coefficient
                  G1=WDES%IGX(I,NK)+WDES%VKPT(1,NK)
                  G2=WDES%IGY(I,NK)+WDES%VKPT(2,NK)
                  G3=WDES%IGZ(I,NK)+WDES%VKPT(3,NK)
                  GC=(G1*LATT_CUR%B(IDIR,1)+G2*LATT_CUR%B(IDIR,2)+G3*LATT_CUR%B(IDIR,3))
                  CFB(I)=GC*W%CPTWFP(I+ISPINOR_*NPL,N,NK,ISP)*CITPI
               ENDDO
! fourier trafo of gradient of wave-function
               CALL FFTWAV(NPL,WDES%NINDPW(1,NK),CFBR(1),CFB(1),GRID)
               ENDIF
! update kinetic energy density (in CW2) and grad rho^2 (in CW4)
!$ACC PARALLEL LOOP PRESENT(CKIN,CFBR,CFAR,GRID) __IF_ASYNC__
               DO I=1,GRID%RL%NP
#ifdef realmode
                  CKIN(I)=CKIN(I)+HSQDTM*REAL(CONJG(CFBR(I))*CFAR(I),KIND=q)*WEIGHT
#else
                  CKIN(I)=CKIN(I)+HSQDTM*(CONJG(CFBR(I))*CFAR(I))*WEIGHT
#endif
               ENDDO

            ENDDO dirs

         ENDDO bands
      ENDDO kpoints

! merge results from nodes
#ifdef realmode
      CALLMPI( M_sum_d(WDES%COMM_INTER,  CKIN(1), GRID%RL%NP))
      CALLMPI( M_sum_d(WDES%COMM_KINTER, CKIN(1), GRID%RL%NP))
#else
      CALLMPI( M_sum_z(WDES%COMM_INTER,  CKIN(1), GRID%RL%NP))
      CALLMPI( M_sum_z(WDES%COMM_KINTER, CKIN(1), GRID%RL%NP))
#endif

! ACC: this kernel caused the code to crash when executed asynchronously.
!      Fix: the operation is absorbed into the WEIGHT.
! rescaling
!!!$ACC KERNELS PRESENT(CKIN,GRID_SOFT) __IF_ASYNC__
!!      CKIN=CKIN/GRID_SOFT%NPLWV
!!!$ACC END KERNELS

! to rec space
      CALL FFT3D(CKIN(1),GRID_SOFT,-1)

! transition to finer grid
      CALL CPB_GRID(GRIDC,GRID_SOFT,SOFT_TO_C,CKIN(1),TAU(1,ISP+ISPINOR_+2*ISPINOR))
!     CALL SETUNB_COMPAT(TAU(1,ISP+ISPINOR_+2*ISPINOR),GRIDC)

      ENDDO ! ispinor_
      ENDDO ! ispinor
      ENDDO spin

! deallocate work arrays
!$ACC EXIT DATA DELETE(CFA,CFB,CFAR,CFBR,CKIN) __IF_ASYNC__
      DEALLOCATE(CFA,CFAR,CKIN) ; IF (WDES%LNONCOLLINEAR) DEALLOCATE(CFB,CFBR)
      NULLIFY(CFA,CFB,CFAR,CFBR)

      IF (WDES%LNONCOLLINEAR) THEN
         ! needs (total,mag) instead of up,dw
         CALL RC_FLIP(TAU,GRIDC,WDES%NCDIJ,.FALSE.)
         IF (SYMM%ISYM>0) THEN
            CALL RHOSYM(TAU(1,1),GRIDC,SYMM%PTRANS,NIOND,SYMM%MAGROT,1)
            IF (.NOT.WDES%LSPIRAL) THEN
               CALL SYMFIELD(TAU(1,2),GRIDC,SYMM%PTRANS,NIOND,SYMM%MAGROT,WDES%SAXIS,LATT_CUR)
            ENDIF
         ENDIF
      ELSE
         IF (SYMM%ISYM>0) THEN
            ! symmetrization of result TAU(:,ISP)
            ! needs (total,mag) instead of up,dw
            CALL RC_FLIP(TAU, GRIDC,WDES%NCDIJ,.FALSE.)
            DO ISP=1,WDES%ISPIN
               CALL RHOSYM(TAU(1,ISP),GRIDC,SYMM%PTRANS,NIOND,SYMM%MAGROT,ISP)
            ENDDO
            ! in the collinear case we go back to up,dw
            CALL RC_FLIP(TAU,GRIDC,WDES%NCDIJ,.TRUE.)
         ENDIF
      ENDIF

! back to real space
      DO ISP=1,WDES%NCDIJ
         CALL TRUNC_HIGH_FREQU(LATT_CUR, GRIDC, TAU(1,ISP))
         CALL FFT3D(TAU(1,ISP),GRIDC,1)
      ENDDO
!$ACC KERNELS PRESENT(TAU) __IF_ASYNC__
      TAU=REAL(TAU,KIND=q)
!$ACC END KERNELS

#ifdef _OPENACC
      CALL ACC_DELETE_TYPED_VAR(W)
      CALL ACC_DELETE_TYPED_VAR(WDES)
      CALL ACC_DELETE_TYPED_VAR(GRID)
      CALL ACC_DELETE_TYPED_VAR(GRID_SOFT)
      CALL ACC_DELETE_TYPED_VAR(GRIDC)
      CALL ACC_DELETE_TYPED_VAR(SOFT_TO_C)

!$ACC EXIT DATA DELETE(LATT_CUR) __IF_ASYNC__
!$ACC EXIT DATA COPYOUT(TAU) __IF_ASYNC__

!$ACC WAIT IF(ACC_EXEC_ON)
      ACC_ASYNC_Q = ACC_ASYNC_SYNC

      POP_ACC_EXEC_ON
#endif

      RETURN
    END SUBROUTINE TAU_PW


!************************ SUBROUTINE METAGGA ***************************
!
! calculates local contribution to metagga Exc according to
! Perdew et. al. PRL 82, 12 (1999)
!
! RH 20001119
!
! everything in Hartree units
!
! ATTANTION: Every values are passed "as they are", i.e. including
! possibly unphysical numerical errors (e.g. negative charge densities)
! values need to be checked accordingly
!***********************************************************************

SUBROUTINE METAGGA(RU,RD,DRU,DRD,DRT,TAUU,TAUD,TAUWU,TAUWD,EX,EC,I)

! RU,RD      density up,down
! DRU, DRD   abs. val. gradient of density up/down
! DRT        abs. val. gradient of total density
! TAUU,TAUD  kinetic energy density up/down
! TAUWU,TAUWD Weizsaecker kinetic energy density up/down
! EXC        return value

  USE prec
  USE constant
  IMPLICIT REAL(q) (A-H,O-Z)

  INTEGER I
! the following parameters are given by Perdew et.al.
  PARAMETER (RKAPPA=0.804_q)
  PARAMETER (D=0.113_q)
  PARAMETER (C=0.53_q)
! other parameters
  PARAMETER (THRD=1._q/3._q)
  PARAMETER (TTHRD=2._q*THRD)
  PARAMETER (FTHRD=1._q+TTHRD)
  PARAMETER (ETHRD=1._q+FTHRD)
  PARAMETER (PISQ=PI*PI)


  EX=0._q;EC=0._q
! exchange energy
! spin up
     P=(2._q*DRU)**2._q/(4._q*(3._q*PISQ)**TTHRD*(2._q*RU)**ETHRD)
     QQS=6._q*TAUU/(2._q*(3._q*PISQ)**TTHRD*(2._q*RU)**FTHRD)-9._q/20._q-P/12._q
     X=10._q/81._q*P+146._q/2025._q*QQS*QQS-73._q/405._q*QQS*P
     X=X+(D+1._q/RKAPPA*(10._q/81._q)**2._q)*P*P
     FX=1._q+RKAPPA-RKAPPA/(1._q+(X/RKAPPA))
     EX=EX-RU*(3._q/(4._q*PI))*(3._q*PISQ*2._q*RU)**THRD*FX
! spin down
     P=(2._q*DRD)**2._q/(4._q*(3._q*PISQ)**TTHRD*(2._q*RD)**ETHRD)
     QQS=6._q*TAUD/(2._q*(3._q*PISQ)**TTHRD*(2._q*RD)**FTHRD)-9._q/20._q-P/12._q
     X=10._q/81._q*P+146._q/2025._q*QQS*QQS-73._q/405._q*QQS*P
     X=X+(D+1._q/RKAPPA*(10._q/81._q)**2._q)*P*P
     FX=1._q+RKAPPA-RKAPPA/(1._q+(X/RKAPPA))
     EX=EX-RD*(3._q/(4._q*PI))*(3._q*PISQ*2._q*RD)**THRD*FX

! correlation energy
     CALL GGASPINCOR(RU,RD,DRT,ECT)
     TAUK=(TAUWU+TAUWD)/(TAUU+TAUD)
     ECM1=(RU+RD)*ECT*(1._q+C*TAUK**2._q)

!     CALL GGACOR(RU,DRU,ECU)
     CALL GGASPINCOR(RU,0.0_q,DRU,ECU)
     TAUK=TAUWU/TAUU
     ECM2=TAUK**2._q*RU*ECU

!     CALL GGACOR(RD,DRD,ECD)
     CALL GGASPINCOR(RD,0.0_q,DRD,ECD)
     TAUK=TAUWD/TAUD
     ECM3=TAUK**2._q*RD*ECD
     EC=ECM1-(1._q+C)*(ECM2+ECM3)

  RETURN
END SUBROUTINE METAGGA
